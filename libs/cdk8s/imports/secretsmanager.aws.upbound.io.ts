// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Secret is the Schema for the Secrets API. Provides a resource to manage AWS Secrets Manager secret metadata
 *
 * @schema Secret
 */
export class Secret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Secret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretsmanager.aws.upbound.io/v1beta1',
    kind: 'Secret',
  }

  /**
   * Renders a Kubernetes manifest for "Secret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretProps): any {
    return {
      ...Secret.GVK,
      ...toJson_SecretProps(props),
    };
  }

  /**
   * Defines a "Secret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretProps) {
    super(scope, id, {
      ...Secret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Secret.GVK,
      ...toJson_SecretProps(resolved),
    };
  }
}

/**
 * Secret is the Schema for the Secrets API. Provides a resource to manage AWS Secrets Manager secret metadata
 *
 * @schema Secret
 */
export interface SecretProps {
  /**
   * @schema Secret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretSpec defines the desired state of Secret
   *
   * @schema Secret#spec
   */
  readonly spec: SecretSpec;

}

/**
 * Converts an object of type 'SecretProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretProps(obj: SecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretSpec defines the desired state of Secret
 *
 * @schema SecretSpec
 */
export interface SecretSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretSpecDeletionPolicy;

  /**
   * @schema SecretSpec#forProvider
   */
  readonly forProvider: SecretSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretSpec#managementPolicy
   */
  readonly managementPolicy?: SecretSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SecretSpec#providerRef
   */
  readonly providerRef?: SecretSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpec(obj: SecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SecretSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SecretSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SecretSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretSpecDeletionPolicy
 */
export enum SecretSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretSpecForProvider
 */
export interface SecretSpecForProvider {
  /**
   * Description of the secret.
   *
   * @schema SecretSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Accepts boolean value to specify whether to overwrite a secret with the same name in the destination Region.
   *
   * @schema SecretSpecForProvider#forceOverwriteReplicaSecret
   */
  readonly forceOverwriteReplicaSecret?: boolean;

  /**
   * ARN or Id of the AWS KMS key to be used to encrypt the secret values in the versions stored in this secret. If you need to reference a CMK in a different account, you can use only the key ARN. If you don't specify this value, then Secrets Manager defaults to using the AWS account's default KMS key (the one named aws/secretsmanager). If the default KMS key with that name doesn't yet exist, then AWS Secrets Manager creates it for you automatically the first time.
   *
   * @schema SecretSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema SecretSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: SecretSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema SecretSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: SecretSpecForProviderKmsKeyIdSelector;

  /**
   * Friendly name of the new secret. The secret name can consist of uppercase letters, lowercase letters, digits, and any of the following characters: /_+=.@- Conflicts with name_prefix.
   *
   * @schema SecretSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Number of days that AWS Secrets Manager waits before it can delete the secret. This value can be 0 to force deletion without recovery or range from 7 to 30 days. The default value is 30.
   *
   * @schema SecretSpecForProvider#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

  /**
   * Region for replicating the secret. Region is the region you'd like your resource to be created in.
   *
   * @schema SecretSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block to support secret replication. See details below.
   *
   * @schema SecretSpecForProvider#replica
   */
  readonly replica?: SecretSpecForProviderReplica[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SecretSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SecretSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProvider(obj: SecretSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'forceOverwriteReplicaSecret': obj.forceOverwriteReplicaSecret,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_SecretSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_SecretSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'name': obj.name,
    'recoveryWindowInDays': obj.recoveryWindowInDays,
    'region': obj.region,
    'replica': obj.replica?.map(y => toJson_SecretSpecForProviderReplica(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretSpecManagementPolicy
 */
export enum SecretSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretSpecProviderConfigRef
 */
export interface SecretSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecProviderConfigRef#policy
   */
  readonly policy?: SecretSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderConfigRef(obj: SecretSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SecretSpecProviderRef
 */
export interface SecretSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecProviderRef#policy
   */
  readonly policy?: SecretSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderRef(obj: SecretSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretSpecPublishConnectionDetailsTo
 */
export interface SecretSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsTo(obj: SecretSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretSpecWriteConnectionSecretToRef
 */
export interface SecretSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecWriteConnectionSecretToRef(obj: SecretSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema SecretSpecForProviderKmsKeyIdRef
 */
export interface SecretSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: SecretSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdRef(obj: SecretSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelector
 */
export interface SecretSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: SecretSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdSelector(obj: SecretSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretSpecForProviderReplica
 */
export interface SecretSpecForProviderReplica {
  /**
   * ARN, Key ID, or Alias of the AWS KMS key within the region secret is replicated to. If one is not specified, then Secrets Manager defaults to using the AWS account's default KMS key (aws/secretsmanager) in the region or creates one for use if non-existent.
   *
   * @schema SecretSpecForProviderReplica#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Region for replicating the secret.
   *
   * @schema SecretSpecForProviderReplica#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'SecretSpecForProviderReplica' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderReplica(obj: SecretSpecForProviderReplica | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretSpecProviderConfigRefPolicy
 */
export interface SecretSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderConfigRefPolicy(obj: SecretSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretSpecProviderRefPolicy
 */
export interface SecretSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SecretSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SecretSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecProviderRefPolicy(obj: SecretSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToConfigRef(obj: SecretSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretSpecPublishConnectionDetailsToMetadata
 */
export interface SecretSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToMetadata(obj: SecretSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretSpecForProviderKmsKeyIdRefPolicy
 */
export interface SecretSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: SecretSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: SecretSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdRefPolicy(obj: SecretSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface SecretSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: SecretSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: SecretSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecForProviderKmsKeyIdSelectorPolicy(obj: SecretSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecProviderConfigRefPolicyResolution
 */
export enum SecretSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecProviderConfigRefPolicyResolve
 */
export enum SecretSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecProviderRefPolicyResolution
 */
export enum SecretSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecProviderRefPolicyResolve
 */
export enum SecretSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum SecretSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum SecretSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum SecretSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum SecretSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SecretPolicy is the Schema for the SecretPolicys API. Provides a resource to manage AWS Secrets Manager secret policy
 *
 * @schema SecretPolicy
 */
export class SecretPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretsmanager.aws.upbound.io/v1beta1',
    kind: 'SecretPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "SecretPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretPolicyProps): any {
    return {
      ...SecretPolicy.GVK,
      ...toJson_SecretPolicyProps(props),
    };
  }

  /**
   * Defines a "SecretPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretPolicyProps) {
    super(scope, id, {
      ...SecretPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretPolicy.GVK,
      ...toJson_SecretPolicyProps(resolved),
    };
  }
}

/**
 * SecretPolicy is the Schema for the SecretPolicys API. Provides a resource to manage AWS Secrets Manager secret policy
 *
 * @schema SecretPolicy
 */
export interface SecretPolicyProps {
  /**
   * @schema SecretPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretPolicySpec defines the desired state of SecretPolicy
   *
   * @schema SecretPolicy#spec
   */
  readonly spec: SecretPolicySpec;

}

/**
 * Converts an object of type 'SecretPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicyProps(obj: SecretPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretPolicySpec defines the desired state of SecretPolicy
 *
 * @schema SecretPolicySpec
 */
export interface SecretPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretPolicySpecDeletionPolicy;

  /**
   * @schema SecretPolicySpec#forProvider
   */
  readonly forProvider: SecretPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretPolicySpec#managementPolicy
   */
  readonly managementPolicy?: SecretPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SecretPolicySpec#providerRef
   */
  readonly providerRef?: SecretPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpec(obj: SecretPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SecretPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SecretPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SecretPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretPolicySpecDeletionPolicy
 */
export enum SecretPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretPolicySpecForProvider
 */
export interface SecretPolicySpecForProvider {
  /**
   * Makes an optional API call to Zelkova to validate the Resource Policy to prevent broad access to your secret.
   *
   * @schema SecretPolicySpecForProvider#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * Valid JSON document representing a resource policy. Unlike aws_secretsmanager_secret, where policy can be set to "{}" to delete the policy, "{}" is not a valid policy since policy is required.
   *
   * @schema SecretPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SecretPolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Secret ARN.
   *
   * @schema SecretPolicySpecForProvider#secretArn
   */
  readonly secretArn?: string;

  /**
   * Reference to a Secret in secretsmanager to populate secretArn.
   *
   * @schema SecretPolicySpecForProvider#secretArnRef
   */
  readonly secretArnRef?: SecretPolicySpecForProviderSecretArnRef;

  /**
   * Selector for a Secret in secretsmanager to populate secretArn.
   *
   * @schema SecretPolicySpecForProvider#secretArnSelector
   */
  readonly secretArnSelector?: SecretPolicySpecForProviderSecretArnSelector;

}

/**
 * Converts an object of type 'SecretPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecForProvider(obj: SecretPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockPublicPolicy': obj.blockPublicPolicy,
    'policy': obj.policy,
    'region': obj.region,
    'secretArn': obj.secretArn,
    'secretArnRef': toJson_SecretPolicySpecForProviderSecretArnRef(obj.secretArnRef),
    'secretArnSelector': toJson_SecretPolicySpecForProviderSecretArnSelector(obj.secretArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretPolicySpecManagementPolicy
 */
export enum SecretPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretPolicySpecProviderConfigRef
 */
export interface SecretPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretPolicySpecProviderConfigRef#policy
   */
  readonly policy?: SecretPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecProviderConfigRef(obj: SecretPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SecretPolicySpecProviderRef
 */
export interface SecretPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretPolicySpecProviderRef#policy
   */
  readonly policy?: SecretPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SecretPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecProviderRef(obj: SecretPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretPolicySpecPublishConnectionDetailsTo
 */
export interface SecretPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecPublishConnectionDetailsTo(obj: SecretPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretPolicySpecWriteConnectionSecretToRef
 */
export interface SecretPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecWriteConnectionSecretToRef(obj: SecretPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretsmanager to populate secretArn.
 *
 * @schema SecretPolicySpecForProviderSecretArnRef
 */
export interface SecretPolicySpecForProviderSecretArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretPolicySpecForProviderSecretArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretPolicySpecForProviderSecretArnRef#policy
   */
  readonly policy?: SecretPolicySpecForProviderSecretArnRefPolicy;

}

/**
 * Converts an object of type 'SecretPolicySpecForProviderSecretArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecForProviderSecretArnRef(obj: SecretPolicySpecForProviderSecretArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretPolicySpecForProviderSecretArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretsmanager to populate secretArn.
 *
 * @schema SecretPolicySpecForProviderSecretArnSelector
 */
export interface SecretPolicySpecForProviderSecretArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretPolicySpecForProviderSecretArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretPolicySpecForProviderSecretArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretPolicySpecForProviderSecretArnSelector#policy
   */
  readonly policy?: SecretPolicySpecForProviderSecretArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecretPolicySpecForProviderSecretArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecForProviderSecretArnSelector(obj: SecretPolicySpecForProviderSecretArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretPolicySpecForProviderSecretArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretPolicySpecProviderConfigRefPolicy
 */
export interface SecretPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecProviderConfigRefPolicy(obj: SecretPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretPolicySpecProviderRefPolicy
 */
export interface SecretPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: SecretPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: SecretPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecProviderRefPolicy(obj: SecretPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface SecretPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecPublishConnectionDetailsToConfigRef(obj: SecretPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretPolicySpecPublishConnectionDetailsToMetadata
 */
export interface SecretPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecPublishConnectionDetailsToMetadata(obj: SecretPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretPolicySpecForProviderSecretArnRefPolicy
 */
export interface SecretPolicySpecForProviderSecretArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretPolicySpecForProviderSecretArnRefPolicy#resolution
   */
  readonly resolution?: SecretPolicySpecForProviderSecretArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretPolicySpecForProviderSecretArnRefPolicy#resolve
   */
  readonly resolve?: SecretPolicySpecForProviderSecretArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretPolicySpecForProviderSecretArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecForProviderSecretArnRefPolicy(obj: SecretPolicySpecForProviderSecretArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretPolicySpecForProviderSecretArnSelectorPolicy
 */
export interface SecretPolicySpecForProviderSecretArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretPolicySpecForProviderSecretArnSelectorPolicy#resolution
   */
  readonly resolution?: SecretPolicySpecForProviderSecretArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretPolicySpecForProviderSecretArnSelectorPolicy#resolve
   */
  readonly resolve?: SecretPolicySpecForProviderSecretArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretPolicySpecForProviderSecretArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecForProviderSecretArnSelectorPolicy(obj: SecretPolicySpecForProviderSecretArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretPolicySpecProviderConfigRefPolicyResolution
 */
export enum SecretPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretPolicySpecProviderConfigRefPolicyResolve
 */
export enum SecretPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretPolicySpecProviderRefPolicyResolution
 */
export enum SecretPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretPolicySpecProviderRefPolicyResolve
 */
export enum SecretPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretPolicySpecForProviderSecretArnRefPolicyResolution
 */
export enum SecretPolicySpecForProviderSecretArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretPolicySpecForProviderSecretArnRefPolicyResolve
 */
export enum SecretPolicySpecForProviderSecretArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretPolicySpecForProviderSecretArnSelectorPolicyResolution
 */
export enum SecretPolicySpecForProviderSecretArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretPolicySpecForProviderSecretArnSelectorPolicyResolve
 */
export enum SecretPolicySpecForProviderSecretArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SecretRotation is the Schema for the SecretRotations API. Provides a resource to manage AWS Secrets Manager secret rotation
 *
 * @schema SecretRotation
 */
export class SecretRotation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretRotation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretsmanager.aws.upbound.io/v1beta1',
    kind: 'SecretRotation',
  }

  /**
   * Renders a Kubernetes manifest for "SecretRotation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretRotationProps): any {
    return {
      ...SecretRotation.GVK,
      ...toJson_SecretRotationProps(props),
    };
  }

  /**
   * Defines a "SecretRotation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretRotationProps) {
    super(scope, id, {
      ...SecretRotation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretRotation.GVK,
      ...toJson_SecretRotationProps(resolved),
    };
  }
}

/**
 * SecretRotation is the Schema for the SecretRotations API. Provides a resource to manage AWS Secrets Manager secret rotation
 *
 * @schema SecretRotation
 */
export interface SecretRotationProps {
  /**
   * @schema SecretRotation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretRotationSpec defines the desired state of SecretRotation
   *
   * @schema SecretRotation#spec
   */
  readonly spec: SecretRotationSpec;

}

/**
 * Converts an object of type 'SecretRotationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationProps(obj: SecretRotationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretRotationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretRotationSpec defines the desired state of SecretRotation
 *
 * @schema SecretRotationSpec
 */
export interface SecretRotationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretRotationSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretRotationSpecDeletionPolicy;

  /**
   * @schema SecretRotationSpec#forProvider
   */
  readonly forProvider: SecretRotationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretRotationSpec#managementPolicy
   */
  readonly managementPolicy?: SecretRotationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretRotationSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretRotationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SecretRotationSpec#providerRef
   */
  readonly providerRef?: SecretRotationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretRotationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretRotationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretRotationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretRotationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretRotationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpec(obj: SecretRotationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretRotationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SecretRotationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SecretRotationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SecretRotationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretRotationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretRotationSpecDeletionPolicy
 */
export enum SecretRotationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretRotationSpecForProvider
 */
export interface SecretRotationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SecretRotationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the ARN of the Lambda function that can rotate the secret.
   *
   * @schema SecretRotationSpecForProvider#rotationLambdaArn
   */
  readonly rotationLambdaArn?: string;

  /**
   * Reference to a Function in lambda to populate rotationLambdaArn.
   *
   * @schema SecretRotationSpecForProvider#rotationLambdaArnRef
   */
  readonly rotationLambdaArnRef?: SecretRotationSpecForProviderRotationLambdaArnRef;

  /**
   * Selector for a Function in lambda to populate rotationLambdaArn.
   *
   * @schema SecretRotationSpecForProvider#rotationLambdaArnSelector
   */
  readonly rotationLambdaArnSelector?: SecretRotationSpecForProviderRotationLambdaArnSelector;

  /**
   * A structure that defines the rotation configuration for this secret. Defined below.
   *
   * @schema SecretRotationSpecForProvider#rotationRules
   */
  readonly rotationRules?: SecretRotationSpecForProviderRotationRules[];

  /**
   * Specifies the secret to which you want to add a new version. You can specify either the Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already exist.
   *
   * @schema SecretRotationSpecForProvider#secretId
   */
  readonly secretId?: string;

  /**
   * Reference to a Secret in secretsmanager to populate secretId.
   *
   * @schema SecretRotationSpecForProvider#secretIdRef
   */
  readonly secretIdRef?: SecretRotationSpecForProviderSecretIdRef;

  /**
   * Selector for a Secret in secretsmanager to populate secretId.
   *
   * @schema SecretRotationSpecForProvider#secretIdSelector
   */
  readonly secretIdSelector?: SecretRotationSpecForProviderSecretIdSelector;

}

/**
 * Converts an object of type 'SecretRotationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProvider(obj: SecretRotationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'rotationLambdaArn': obj.rotationLambdaArn,
    'rotationLambdaArnRef': toJson_SecretRotationSpecForProviderRotationLambdaArnRef(obj.rotationLambdaArnRef),
    'rotationLambdaArnSelector': toJson_SecretRotationSpecForProviderRotationLambdaArnSelector(obj.rotationLambdaArnSelector),
    'rotationRules': obj.rotationRules?.map(y => toJson_SecretRotationSpecForProviderRotationRules(y)),
    'secretId': obj.secretId,
    'secretIdRef': toJson_SecretRotationSpecForProviderSecretIdRef(obj.secretIdRef),
    'secretIdSelector': toJson_SecretRotationSpecForProviderSecretIdSelector(obj.secretIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretRotationSpecManagementPolicy
 */
export enum SecretRotationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretRotationSpecProviderConfigRef
 */
export interface SecretRotationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretRotationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretRotationSpecProviderConfigRef#policy
   */
  readonly policy?: SecretRotationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretRotationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecProviderConfigRef(obj: SecretRotationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretRotationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SecretRotationSpecProviderRef
 */
export interface SecretRotationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretRotationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretRotationSpecProviderRef#policy
   */
  readonly policy?: SecretRotationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SecretRotationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecProviderRef(obj: SecretRotationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretRotationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretRotationSpecPublishConnectionDetailsTo
 */
export interface SecretRotationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretRotationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretRotationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretRotationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecPublishConnectionDetailsTo(obj: SecretRotationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretRotationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretRotationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretRotationSpecWriteConnectionSecretToRef
 */
export interface SecretRotationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretRotationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretRotationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretRotationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecWriteConnectionSecretToRef(obj: SecretRotationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate rotationLambdaArn.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnRef
 */
export interface SecretRotationSpecForProviderRotationLambdaArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnRef#policy
   */
  readonly policy?: SecretRotationSpecForProviderRotationLambdaArnRefPolicy;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderRotationLambdaArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderRotationLambdaArnRef(obj: SecretRotationSpecForProviderRotationLambdaArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretRotationSpecForProviderRotationLambdaArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate rotationLambdaArn.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnSelector
 */
export interface SecretRotationSpecForProviderRotationLambdaArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnSelector#policy
   */
  readonly policy?: SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderRotationLambdaArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderRotationLambdaArnSelector(obj: SecretRotationSpecForProviderRotationLambdaArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SecretRotationSpecForProviderRotationRules
 */
export interface SecretRotationSpecForProviderRotationRules {
  /**
   * Specifies the number of days between automatic scheduled rotations of the secret. Either automatically_after_days or schedule_expression must be specified.
   *
   * @schema SecretRotationSpecForProviderRotationRules#automaticallyAfterDays
   */
  readonly automaticallyAfterDays?: number;

  /**
   * - The length of the rotation window in hours. For example, 3h for a three hour window.
   *
   * @schema SecretRotationSpecForProviderRotationRules#duration
   */
  readonly duration?: string;

  /**
   * A cron() or rate() expression that defines the schedule for rotating your secret. Either automatically_after_days or schedule_expression must be specified.
   *
   * @schema SecretRotationSpecForProviderRotationRules#scheduleExpression
   */
  readonly scheduleExpression?: string;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderRotationRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderRotationRules(obj: SecretRotationSpecForProviderRotationRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automaticallyAfterDays': obj.automaticallyAfterDays,
    'duration': obj.duration,
    'scheduleExpression': obj.scheduleExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretsmanager to populate secretId.
 *
 * @schema SecretRotationSpecForProviderSecretIdRef
 */
export interface SecretRotationSpecForProviderSecretIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretRotationSpecForProviderSecretIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretRotationSpecForProviderSecretIdRef#policy
   */
  readonly policy?: SecretRotationSpecForProviderSecretIdRefPolicy;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderSecretIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderSecretIdRef(obj: SecretRotationSpecForProviderSecretIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretRotationSpecForProviderSecretIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretsmanager to populate secretId.
 *
 * @schema SecretRotationSpecForProviderSecretIdSelector
 */
export interface SecretRotationSpecForProviderSecretIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretRotationSpecForProviderSecretIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretRotationSpecForProviderSecretIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretRotationSpecForProviderSecretIdSelector#policy
   */
  readonly policy?: SecretRotationSpecForProviderSecretIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderSecretIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderSecretIdSelector(obj: SecretRotationSpecForProviderSecretIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretRotationSpecForProviderSecretIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretRotationSpecProviderConfigRefPolicy
 */
export interface SecretRotationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretRotationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretRotationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretRotationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretRotationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretRotationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecProviderConfigRefPolicy(obj: SecretRotationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretRotationSpecProviderRefPolicy
 */
export interface SecretRotationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretRotationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SecretRotationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretRotationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SecretRotationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretRotationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecProviderRefPolicy(obj: SecretRotationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretRotationSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretRotationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretRotationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecPublishConnectionDetailsToConfigRef(obj: SecretRotationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretRotationSpecPublishConnectionDetailsToMetadata
 */
export interface SecretRotationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretRotationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecPublishConnectionDetailsToMetadata(obj: SecretRotationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnRefPolicy
 */
export interface SecretRotationSpecForProviderRotationLambdaArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnRefPolicy#resolution
   */
  readonly resolution?: SecretRotationSpecForProviderRotationLambdaArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnRefPolicy#resolve
   */
  readonly resolve?: SecretRotationSpecForProviderRotationLambdaArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderRotationLambdaArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderRotationLambdaArnRefPolicy(obj: SecretRotationSpecForProviderRotationLambdaArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy
 */
export interface SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy#resolution
   */
  readonly resolution?: SecretRotationSpecForProviderRotationLambdaArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy#resolve
   */
  readonly resolve?: SecretRotationSpecForProviderRotationLambdaArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy(obj: SecretRotationSpecForProviderRotationLambdaArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretRotationSpecForProviderSecretIdRefPolicy
 */
export interface SecretRotationSpecForProviderSecretIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretRotationSpecForProviderSecretIdRefPolicy#resolution
   */
  readonly resolution?: SecretRotationSpecForProviderSecretIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretRotationSpecForProviderSecretIdRefPolicy#resolve
   */
  readonly resolve?: SecretRotationSpecForProviderSecretIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderSecretIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderSecretIdRefPolicy(obj: SecretRotationSpecForProviderSecretIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretRotationSpecForProviderSecretIdSelectorPolicy
 */
export interface SecretRotationSpecForProviderSecretIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretRotationSpecForProviderSecretIdSelectorPolicy#resolution
   */
  readonly resolution?: SecretRotationSpecForProviderSecretIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretRotationSpecForProviderSecretIdSelectorPolicy#resolve
   */
  readonly resolve?: SecretRotationSpecForProviderSecretIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretRotationSpecForProviderSecretIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecForProviderSecretIdSelectorPolicy(obj: SecretRotationSpecForProviderSecretIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretRotationSpecProviderConfigRefPolicyResolution
 */
export enum SecretRotationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretRotationSpecProviderConfigRefPolicyResolve
 */
export enum SecretRotationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretRotationSpecProviderRefPolicyResolution
 */
export enum SecretRotationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretRotationSpecProviderRefPolicyResolve
 */
export enum SecretRotationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretRotationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretRotationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretRotationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnRefPolicyResolution
 */
export enum SecretRotationSpecForProviderRotationLambdaArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnRefPolicyResolve
 */
export enum SecretRotationSpecForProviderRotationLambdaArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnSelectorPolicyResolution
 */
export enum SecretRotationSpecForProviderRotationLambdaArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretRotationSpecForProviderRotationLambdaArnSelectorPolicyResolve
 */
export enum SecretRotationSpecForProviderRotationLambdaArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretRotationSpecForProviderSecretIdRefPolicyResolution
 */
export enum SecretRotationSpecForProviderSecretIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretRotationSpecForProviderSecretIdRefPolicyResolve
 */
export enum SecretRotationSpecForProviderSecretIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretRotationSpecForProviderSecretIdSelectorPolicyResolution
 */
export enum SecretRotationSpecForProviderSecretIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretRotationSpecForProviderSecretIdSelectorPolicyResolve
 */
export enum SecretRotationSpecForProviderSecretIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretRotationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretRotationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretRotationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretRotationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SecretVersion is the Schema for the SecretVersions API. Provides a resource to manage AWS Secrets Manager secret version including its secret value
 *
 * @schema SecretVersion
 */
export class SecretVersion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SecretVersion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'secretsmanager.aws.upbound.io/v1beta1',
    kind: 'SecretVersion',
  }

  /**
   * Renders a Kubernetes manifest for "SecretVersion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SecretVersionProps): any {
    return {
      ...SecretVersion.GVK,
      ...toJson_SecretVersionProps(props),
    };
  }

  /**
   * Defines a "SecretVersion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SecretVersionProps) {
    super(scope, id, {
      ...SecretVersion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SecretVersion.GVK,
      ...toJson_SecretVersionProps(resolved),
    };
  }
}

/**
 * SecretVersion is the Schema for the SecretVersions API. Provides a resource to manage AWS Secrets Manager secret version including its secret value
 *
 * @schema SecretVersion
 */
export interface SecretVersionProps {
  /**
   * @schema SecretVersion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretVersionSpec defines the desired state of SecretVersion
   *
   * @schema SecretVersion#spec
   */
  readonly spec: SecretVersionSpec;

}

/**
 * Converts an object of type 'SecretVersionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionProps(obj: SecretVersionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SecretVersionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretVersionSpec defines the desired state of SecretVersion
 *
 * @schema SecretVersionSpec
 */
export interface SecretVersionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretVersionSpec#deletionPolicy
   */
  readonly deletionPolicy?: SecretVersionSpecDeletionPolicy;

  /**
   * @schema SecretVersionSpec#forProvider
   */
  readonly forProvider: SecretVersionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SecretVersionSpec#managementPolicy
   */
  readonly managementPolicy?: SecretVersionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SecretVersionSpec#providerConfigRef
   */
  readonly providerConfigRef?: SecretVersionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SecretVersionSpec#providerRef
   */
  readonly providerRef?: SecretVersionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SecretVersionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SecretVersionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SecretVersionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SecretVersionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SecretVersionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpec(obj: SecretVersionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SecretVersionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SecretVersionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SecretVersionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SecretVersionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SecretVersionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretVersionSpecDeletionPolicy
 */
export enum SecretVersionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SecretVersionSpecForProvider
 */
export interface SecretVersionSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SecretVersionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies binary data that you want to encrypt and store in this version of the secret. This is required if secret_string is not set. Needs to be encoded to base64.
   *
   * @schema SecretVersionSpecForProvider#secretBinarySecretRef
   */
  readonly secretBinarySecretRef?: SecretVersionSpecForProviderSecretBinarySecretRef;

  /**
   * Specifies the secret to which you want to add a new version. You can specify either the Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already exist.
   *
   * @schema SecretVersionSpecForProvider#secretId
   */
  readonly secretId?: string;

  /**
   * Reference to a Secret in secretsmanager to populate secretId.
   *
   * @schema SecretVersionSpecForProvider#secretIdRef
   */
  readonly secretIdRef?: SecretVersionSpecForProviderSecretIdRef;

  /**
   * Selector for a Secret in secretsmanager to populate secretId.
   *
   * @schema SecretVersionSpecForProvider#secretIdSelector
   */
  readonly secretIdSelector?: SecretVersionSpecForProviderSecretIdSelector;

  /**
   * Specifies text data that you want to encrypt and store in this version of the secret. This is required if secret_binary is not set.
   *
   * @schema SecretVersionSpecForProvider#secretStringSecretRef
   */
  readonly secretStringSecretRef?: SecretVersionSpecForProviderSecretStringSecretRef;

  /**
   * Specifies a list of staging labels that are attached to this version of the secret. A staging label must be unique to a single version of the secret. If you specify a staging label that's already associated with a different version of the same secret then that staging label is automatically removed from the other version and attached to this version. If you do not specify a value, then AWS Secrets Manager automatically moves the staging label AWSCURRENT to this new version on creation.
   *
   * @schema SecretVersionSpecForProvider#versionStages
   */
  readonly versionStages?: string[];

}

/**
 * Converts an object of type 'SecretVersionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProvider(obj: SecretVersionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'secretBinarySecretRef': toJson_SecretVersionSpecForProviderSecretBinarySecretRef(obj.secretBinarySecretRef),
    'secretId': obj.secretId,
    'secretIdRef': toJson_SecretVersionSpecForProviderSecretIdRef(obj.secretIdRef),
    'secretIdSelector': toJson_SecretVersionSpecForProviderSecretIdSelector(obj.secretIdSelector),
    'secretStringSecretRef': toJson_SecretVersionSpecForProviderSecretStringSecretRef(obj.secretStringSecretRef),
    'versionStages': obj.versionStages?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SecretVersionSpecManagementPolicy
 */
export enum SecretVersionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SecretVersionSpecProviderConfigRef
 */
export interface SecretVersionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretVersionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretVersionSpecProviderConfigRef#policy
   */
  readonly policy?: SecretVersionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecProviderConfigRef(obj: SecretVersionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretVersionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SecretVersionSpecProviderRef
 */
export interface SecretVersionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretVersionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretVersionSpecProviderRef#policy
   */
  readonly policy?: SecretVersionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecProviderRef(obj: SecretVersionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretVersionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsTo
 */
export interface SecretVersionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SecretVersionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SecretVersionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsTo(obj: SecretVersionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SecretVersionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SecretVersionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SecretVersionSpecWriteConnectionSecretToRef
 */
export interface SecretVersionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SecretVersionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretVersionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretVersionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecWriteConnectionSecretToRef(obj: SecretVersionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies binary data that you want to encrypt and store in this version of the secret. This is required if secret_string is not set. Needs to be encoded to base64.
 *
 * @schema SecretVersionSpecForProviderSecretBinarySecretRef
 */
export interface SecretVersionSpecForProviderSecretBinarySecretRef {
  /**
   * The key to select.
   *
   * @schema SecretVersionSpecForProviderSecretBinarySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema SecretVersionSpecForProviderSecretBinarySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretVersionSpecForProviderSecretBinarySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretBinarySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretBinarySecretRef(obj: SecretVersionSpecForProviderSecretBinarySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Secret in secretsmanager to populate secretId.
 *
 * @schema SecretVersionSpecForProviderSecretIdRef
 */
export interface SecretVersionSpecForProviderSecretIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretVersionSpecForProviderSecretIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretVersionSpecForProviderSecretIdRef#policy
   */
  readonly policy?: SecretVersionSpecForProviderSecretIdRefPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretIdRef(obj: SecretVersionSpecForProviderSecretIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretVersionSpecForProviderSecretIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Secret in secretsmanager to populate secretId.
 *
 * @schema SecretVersionSpecForProviderSecretIdSelector
 */
export interface SecretVersionSpecForProviderSecretIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SecretVersionSpecForProviderSecretIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SecretVersionSpecForProviderSecretIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SecretVersionSpecForProviderSecretIdSelector#policy
   */
  readonly policy?: SecretVersionSpecForProviderSecretIdSelectorPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretIdSelector(obj: SecretVersionSpecForProviderSecretIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SecretVersionSpecForProviderSecretIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies text data that you want to encrypt and store in this version of the secret. This is required if secret_binary is not set.
 *
 * @schema SecretVersionSpecForProviderSecretStringSecretRef
 */
export interface SecretVersionSpecForProviderSecretStringSecretRef {
  /**
   * The key to select.
   *
   * @schema SecretVersionSpecForProviderSecretStringSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema SecretVersionSpecForProviderSecretStringSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SecretVersionSpecForProviderSecretStringSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretStringSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretStringSecretRef(obj: SecretVersionSpecForProviderSecretStringSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretVersionSpecProviderConfigRefPolicy
 */
export interface SecretVersionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecProviderConfigRefPolicy(obj: SecretVersionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretVersionSpecProviderRefPolicy
 */
export interface SecretVersionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecProviderRefPolicy(obj: SecretVersionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRef
 */
export interface SecretVersionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsToConfigRef(obj: SecretVersionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToMetadata
 */
export interface SecretVersionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsToMetadata(obj: SecretVersionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SecretVersionSpecForProviderSecretIdRefPolicy
 */
export interface SecretVersionSpecForProviderSecretIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecForProviderSecretIdRefPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecForProviderSecretIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecForProviderSecretIdRefPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecForProviderSecretIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretIdRefPolicy(obj: SecretVersionSpecForProviderSecretIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SecretVersionSpecForProviderSecretIdSelectorPolicy
 */
export interface SecretVersionSpecForProviderSecretIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecForProviderSecretIdSelectorPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecForProviderSecretIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecForProviderSecretIdSelectorPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecForProviderSecretIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecForProviderSecretIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecForProviderSecretIdSelectorPolicy(obj: SecretVersionSpecForProviderSecretIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecProviderConfigRefPolicyResolution
 */
export enum SecretVersionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecProviderConfigRefPolicyResolve
 */
export enum SecretVersionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecProviderRefPolicyResolution
 */
export enum SecretVersionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecProviderRefPolicyResolve
 */
export enum SecretVersionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy(obj: SecretVersionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecForProviderSecretIdRefPolicyResolution
 */
export enum SecretVersionSpecForProviderSecretIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecForProviderSecretIdRefPolicyResolve
 */
export enum SecretVersionSpecForProviderSecretIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecForProviderSecretIdSelectorPolicyResolution
 */
export enum SecretVersionSpecForProviderSecretIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecForProviderSecretIdSelectorPolicyResolve
 */
export enum SecretVersionSpecForProviderSecretIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SecretVersionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

