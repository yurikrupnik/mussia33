// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DefaultSupportedIdPConfig is the Schema for the DefaultSupportedIdPConfigs API. Configurations options for authenticating with a the standard set of Identity Toolkit-trusted IDPs.
 *
 * @schema DefaultSupportedIdPConfig
 */
export class DefaultSupportedIdPConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DefaultSupportedIdPConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'DefaultSupportedIdPConfig',
  }

  /**
   * Renders a Kubernetes manifest for "DefaultSupportedIdPConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DefaultSupportedIdPConfigProps): any {
    return {
      ...DefaultSupportedIdPConfig.GVK,
      ...toJson_DefaultSupportedIdPConfigProps(props),
    };
  }

  /**
   * Defines a "DefaultSupportedIdPConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DefaultSupportedIdPConfigProps) {
    super(scope, id, {
      ...DefaultSupportedIdPConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DefaultSupportedIdPConfig.GVK,
      ...toJson_DefaultSupportedIdPConfigProps(resolved),
    };
  }
}

/**
 * DefaultSupportedIdPConfig is the Schema for the DefaultSupportedIdPConfigs API. Configurations options for authenticating with a the standard set of Identity Toolkit-trusted IDPs.
 *
 * @schema DefaultSupportedIdPConfig
 */
export interface DefaultSupportedIdPConfigProps {
  /**
   * @schema DefaultSupportedIdPConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DefaultSupportedIdPConfigSpec defines the desired state of DefaultSupportedIdPConfig
   *
   * @schema DefaultSupportedIdPConfig#spec
   */
  readonly spec: DefaultSupportedIdPConfigSpec;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigProps(obj: DefaultSupportedIdPConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DefaultSupportedIdPConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultSupportedIdPConfigSpec defines the desired state of DefaultSupportedIdPConfig
 *
 * @schema DefaultSupportedIdPConfigSpec
 */
export interface DefaultSupportedIdPConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DefaultSupportedIdPConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: DefaultSupportedIdPConfigSpecDeletionPolicy;

  /**
   * @schema DefaultSupportedIdPConfigSpec#forProvider
   */
  readonly forProvider: DefaultSupportedIdPConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DefaultSupportedIdPConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: DefaultSupportedIdPConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DefaultSupportedIdPConfigSpec#providerRef
   */
  readonly providerRef?: DefaultSupportedIdPConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DefaultSupportedIdPConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DefaultSupportedIdPConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpec(obj: DefaultSupportedIdPConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DefaultSupportedIdPConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DefaultSupportedIdPConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DefaultSupportedIdPConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DefaultSupportedIdPConfigSpecDeletionPolicy
 */
export enum DefaultSupportedIdPConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DefaultSupportedIdPConfigSpecForProvider
 */
export interface DefaultSupportedIdPConfigSpecForProvider {
  /**
   * OAuth client ID
   *
   * @schema DefaultSupportedIdPConfigSpecForProvider#clientIdSecretRef
   */
  readonly clientIdSecretRef: DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef;

  /**
   * OAuth client secret
   *
   * @schema DefaultSupportedIdPConfigSpecForProvider#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef;

  /**
   * If this IDP allows the user to sign in
   *
   * @schema DefaultSupportedIdPConfigSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * ID of the IDP. Possible values include:
   *
   * @schema DefaultSupportedIdPConfigSpecForProvider#idpId
   */
  readonly idpId: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DefaultSupportedIdPConfigSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecForProvider(obj: DefaultSupportedIdPConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIdSecretRef': toJson_DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef(obj.clientIdSecretRef),
    'clientSecretSecretRef': toJson_DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef(obj.clientSecretSecretRef),
    'enabled': obj.enabled,
    'idpId': obj.idpId,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DefaultSupportedIdPConfigSpecProviderConfigRef
 */
export interface DefaultSupportedIdPConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderConfigRef#policy
   */
  readonly policy?: DefaultSupportedIdPConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecProviderConfigRef(obj: DefaultSupportedIdPConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultSupportedIdPConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DefaultSupportedIdPConfigSpecProviderRef
 */
export interface DefaultSupportedIdPConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderRef#policy
   */
  readonly policy?: DefaultSupportedIdPConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecProviderRef(obj: DefaultSupportedIdPConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultSupportedIdPConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo
 */
export interface DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo(obj: DefaultSupportedIdPConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef
 */
export interface DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef(obj: DefaultSupportedIdPConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth client ID
 *
 * @schema DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef
 */
export interface DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef {
  /**
   * The key to select.
   *
   * @schema DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef(obj: DefaultSupportedIdPConfigSpecForProviderClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth client secret
 *
 * @schema DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef
 */
export interface DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef(obj: DefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultSupportedIdPConfigSpecProviderConfigRefPolicy
 */
export interface DefaultSupportedIdPConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecProviderConfigRefPolicy(obj: DefaultSupportedIdPConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultSupportedIdPConfigSpecProviderRefPolicy
 */
export interface DefaultSupportedIdPConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DefaultSupportedIdPConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultSupportedIdPConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DefaultSupportedIdPConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecProviderRefPolicy(obj: DefaultSupportedIdPConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef(obj: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata
 */
export interface DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata(obj: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolution
 */
export enum DefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolve
 */
export enum DefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultSupportedIdPConfigSpecProviderRefPolicyResolution
 */
export enum DefaultSupportedIdPConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultSupportedIdPConfigSpecProviderRefPolicyResolve
 */
export enum DefaultSupportedIdPConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InboundSAMLConfig is the Schema for the InboundSAMLConfigs API. Inbound SAML configuration for a Identity Toolkit project.
 *
 * @schema InboundSAMLConfig
 */
export class InboundSamlConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InboundSAMLConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'InboundSAMLConfig',
  }

  /**
   * Renders a Kubernetes manifest for "InboundSAMLConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InboundSamlConfigProps): any {
    return {
      ...InboundSamlConfig.GVK,
      ...toJson_InboundSamlConfigProps(props),
    };
  }

  /**
   * Defines a "InboundSAMLConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InboundSamlConfigProps) {
    super(scope, id, {
      ...InboundSamlConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InboundSamlConfig.GVK,
      ...toJson_InboundSamlConfigProps(resolved),
    };
  }
}

/**
 * InboundSAMLConfig is the Schema for the InboundSAMLConfigs API. Inbound SAML configuration for a Identity Toolkit project.
 *
 * @schema InboundSAMLConfig
 */
export interface InboundSamlConfigProps {
  /**
   * @schema InboundSAMLConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InboundSAMLConfigSpec defines the desired state of InboundSAMLConfig
   *
   * @schema InboundSAMLConfig#spec
   */
  readonly spec: InboundSamlConfigSpec;

}

/**
 * Converts an object of type 'InboundSamlConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigProps(obj: InboundSamlConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InboundSamlConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InboundSAMLConfigSpec defines the desired state of InboundSAMLConfig
 *
 * @schema InboundSamlConfigSpec
 */
export interface InboundSamlConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InboundSamlConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: InboundSamlConfigSpecDeletionPolicy;

  /**
   * @schema InboundSamlConfigSpec#forProvider
   */
  readonly forProvider: InboundSamlConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InboundSamlConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: InboundSamlConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InboundSamlConfigSpec#providerRef
   */
  readonly providerRef?: InboundSamlConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InboundSamlConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InboundSamlConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InboundSamlConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InboundSamlConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InboundSamlConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpec(obj: InboundSamlConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InboundSamlConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InboundSamlConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InboundSamlConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InboundSamlConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InboundSamlConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InboundSamlConfigSpecDeletionPolicy
 */
export enum InboundSamlConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InboundSamlConfigSpecForProvider
 */
export interface InboundSamlConfigSpecForProvider {
  /**
   * Human friendly display name.
   *
   * @schema InboundSamlConfigSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * If this config allows users to sign in with the provider.
   *
   * @schema InboundSamlConfigSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * SAML IdP configuration when the project acts as the relying party Structure is documented below.
   *
   * @schema InboundSamlConfigSpecForProvider#idpConfig
   */
  readonly idpConfig: InboundSamlConfigSpecForProviderIdpConfig[];

  /**
   * The name of the InboundSamlConfig resource. Must start with 'saml.' and can only have alphanumeric characters, hyphens, underscores or periods. The part after 'saml.' must also start with a lowercase letter, end with an alphanumeric character, and have at least 2 characters.
   *
   * @schema InboundSamlConfigSpecForProvider#name
   */
  readonly name: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InboundSamlConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * SAML SP (Service Provider) configuration when the project acts as the relying party to receive and accept an authentication assertion issued by a SAML identity provider. Structure is documented below.
   *
   * @schema InboundSamlConfigSpecForProvider#spConfig
   */
  readonly spConfig: InboundSamlConfigSpecForProviderSpConfig[];

}

/**
 * Converts an object of type 'InboundSamlConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecForProvider(obj: InboundSamlConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'enabled': obj.enabled,
    'idpConfig': obj.idpConfig?.map(y => toJson_InboundSamlConfigSpecForProviderIdpConfig(y)),
    'name': obj.name,
    'project': obj.project,
    'spConfig': obj.spConfig?.map(y => toJson_InboundSamlConfigSpecForProviderSpConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InboundSamlConfigSpecProviderConfigRef
 */
export interface InboundSamlConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InboundSamlConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InboundSamlConfigSpecProviderConfigRef#policy
   */
  readonly policy?: InboundSamlConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecProviderConfigRef(obj: InboundSamlConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InboundSamlConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InboundSamlConfigSpecProviderRef
 */
export interface InboundSamlConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InboundSamlConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InboundSamlConfigSpecProviderRef#policy
   */
  readonly policy?: InboundSamlConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecProviderRef(obj: InboundSamlConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InboundSamlConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InboundSamlConfigSpecPublishConnectionDetailsTo
 */
export interface InboundSamlConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InboundSamlConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InboundSamlConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecPublishConnectionDetailsTo(obj: InboundSamlConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InboundSamlConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InboundSamlConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InboundSamlConfigSpecWriteConnectionSecretToRef
 */
export interface InboundSamlConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InboundSamlConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InboundSamlConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecWriteConnectionSecretToRef(obj: InboundSamlConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InboundSamlConfigSpecForProviderIdpConfig
 */
export interface InboundSamlConfigSpecForProviderIdpConfig {
  /**
   * The IdP's certificate data to verify the signature in the SAMLResponse issued by the IDP. Structure is documented below.
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfig#idpCertificates
   */
  readonly idpCertificates: InboundSamlConfigSpecForProviderIdpConfigIdpCertificates[];

  /**
   * Unique identifier for all SAML entities
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfig#idpEntityId
   */
  readonly idpEntityId: string;

  /**
   * Indicates if outbounding SAMLRequest should be signed.
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfig#signRequest
   */
  readonly signRequest?: boolean;

  /**
   * URL to send Authentication request to.
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfig#ssoUrl
   */
  readonly ssoUrl: string;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecForProviderIdpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecForProviderIdpConfig(obj: InboundSamlConfigSpecForProviderIdpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idpCertificates': obj.idpCertificates?.map(y => toJson_InboundSamlConfigSpecForProviderIdpConfigIdpCertificates(y)),
    'idpEntityId': obj.idpEntityId,
    'signRequest': obj.signRequest,
    'ssoUrl': obj.ssoUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InboundSamlConfigSpecForProviderSpConfig
 */
export interface InboundSamlConfigSpecForProviderSpConfig {
  /**
   * Callback URI where responses from IDP are handled. Must start with https://.
   *
   * @schema InboundSamlConfigSpecForProviderSpConfig#callbackUri
   */
  readonly callbackUri?: string;

  /**
   * Unique identifier for all SAML entities.
   *
   * @schema InboundSamlConfigSpecForProviderSpConfig#spEntityId
   */
  readonly spEntityId?: string;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecForProviderSpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecForProviderSpConfig(obj: InboundSamlConfigSpecForProviderSpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'callbackUri': obj.callbackUri,
    'spEntityId': obj.spEntityId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InboundSamlConfigSpecProviderConfigRefPolicy
 */
export interface InboundSamlConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InboundSamlConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InboundSamlConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InboundSamlConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InboundSamlConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecProviderConfigRefPolicy(obj: InboundSamlConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InboundSamlConfigSpecProviderRefPolicy
 */
export interface InboundSamlConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InboundSamlConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InboundSamlConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InboundSamlConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InboundSamlConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecProviderRefPolicy(obj: InboundSamlConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface InboundSamlConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecPublishConnectionDetailsToConfigRef(obj: InboundSamlConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InboundSamlConfigSpecPublishConnectionDetailsToMetadata
 */
export interface InboundSamlConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecPublishConnectionDetailsToMetadata(obj: InboundSamlConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InboundSamlConfigSpecForProviderIdpConfigIdpCertificates
 */
export interface InboundSamlConfigSpecForProviderIdpConfigIdpCertificates {
  /**
   * The x509 certificate
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfigIdpCertificates#x509CertificateSecretRef
   */
  readonly x509CertificateSecretRef?: InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecForProviderIdpConfigIdpCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecForProviderIdpConfigIdpCertificates(obj: InboundSamlConfigSpecForProviderIdpConfigIdpCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'x509CertificateSecretRef': toJson_InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef(obj.x509CertificateSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InboundSamlConfigSpecProviderConfigRefPolicyResolution
 */
export enum InboundSamlConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InboundSamlConfigSpecProviderConfigRefPolicyResolve
 */
export enum InboundSamlConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InboundSamlConfigSpecProviderRefPolicyResolution
 */
export enum InboundSamlConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InboundSamlConfigSpecProviderRefPolicyResolve
 */
export enum InboundSamlConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The x509 certificate
 *
 * @schema InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef
 */
export interface InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef {
  /**
   * The key to select.
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef(obj: InboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * OAuthIdPConfig is the Schema for the OAuthIdPConfigs API. OIDC IdP configuration for a Identity Toolkit project.
 *
 * @schema OAuthIdPConfig
 */
export class OAuthIdPConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "OAuthIdPConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'OAuthIdPConfig',
  }

  /**
   * Renders a Kubernetes manifest for "OAuthIdPConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: OAuthIdPConfigProps): any {
    return {
      ...OAuthIdPConfig.GVK,
      ...toJson_OAuthIdPConfigProps(props),
    };
  }

  /**
   * Defines a "OAuthIdPConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: OAuthIdPConfigProps) {
    super(scope, id, {
      ...OAuthIdPConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...OAuthIdPConfig.GVK,
      ...toJson_OAuthIdPConfigProps(resolved),
    };
  }
}

/**
 * OAuthIdPConfig is the Schema for the OAuthIdPConfigs API. OIDC IdP configuration for a Identity Toolkit project.
 *
 * @schema OAuthIdPConfig
 */
export interface OAuthIdPConfigProps {
  /**
   * @schema OAuthIdPConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * OAuthIdPConfigSpec defines the desired state of OAuthIdPConfig
   *
   * @schema OAuthIdPConfig#spec
   */
  readonly spec: OAuthIdPConfigSpec;

}

/**
 * Converts an object of type 'OAuthIdPConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigProps(obj: OAuthIdPConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_OAuthIdPConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuthIdPConfigSpec defines the desired state of OAuthIdPConfig
 *
 * @schema OAuthIdPConfigSpec
 */
export interface OAuthIdPConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema OAuthIdPConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: OAuthIdPConfigSpecDeletionPolicy;

  /**
   * @schema OAuthIdPConfigSpec#forProvider
   */
  readonly forProvider: OAuthIdPConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema OAuthIdPConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: OAuthIdPConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema OAuthIdPConfigSpec#providerRef
   */
  readonly providerRef?: OAuthIdPConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema OAuthIdPConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: OAuthIdPConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema OAuthIdPConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: OAuthIdPConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpec(obj: OAuthIdPConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_OAuthIdPConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_OAuthIdPConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_OAuthIdPConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_OAuthIdPConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_OAuthIdPConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema OAuthIdPConfigSpecDeletionPolicy
 */
export enum OAuthIdPConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema OAuthIdPConfigSpecForProvider
 */
export interface OAuthIdPConfigSpecForProvider {
  /**
   * The client id of an OAuth client.
   *
   * @schema OAuthIdPConfigSpecForProvider#clientIdSecretRef
   */
  readonly clientIdSecretRef: OAuthIdPConfigSpecForProviderClientIdSecretRef;

  /**
   * The client secret of the OAuth client, to enable OIDC code flow.
   *
   * @schema OAuthIdPConfigSpecForProvider#clientSecretSecretRef
   */
  readonly clientSecretSecretRef?: OAuthIdPConfigSpecForProviderClientSecretSecretRef;

  /**
   * Human friendly display name.
   *
   * @schema OAuthIdPConfigSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * If this config allows users to sign in with the provider.
   *
   * @schema OAuthIdPConfigSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * For OIDC Idps, the issuer identifier.
   *
   * @schema OAuthIdPConfigSpecForProvider#issuer
   */
  readonly issuer: string;

  /**
   * The name of the OauthIdpConfig. Must start with oidc..
   *
   * @schema OAuthIdPConfigSpecForProvider#name
   */
  readonly name: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema OAuthIdPConfigSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecForProvider(obj: OAuthIdPConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIdSecretRef': toJson_OAuthIdPConfigSpecForProviderClientIdSecretRef(obj.clientIdSecretRef),
    'clientSecretSecretRef': toJson_OAuthIdPConfigSpecForProviderClientSecretSecretRef(obj.clientSecretSecretRef),
    'displayName': obj.displayName,
    'enabled': obj.enabled,
    'issuer': obj.issuer,
    'name': obj.name,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema OAuthIdPConfigSpecProviderConfigRef
 */
export interface OAuthIdPConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OAuthIdPConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OAuthIdPConfigSpecProviderConfigRef#policy
   */
  readonly policy?: OAuthIdPConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecProviderConfigRef(obj: OAuthIdPConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OAuthIdPConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema OAuthIdPConfigSpecProviderRef
 */
export interface OAuthIdPConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema OAuthIdPConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OAuthIdPConfigSpecProviderRef#policy
   */
  readonly policy?: OAuthIdPConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecProviderRef(obj: OAuthIdPConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OAuthIdPConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema OAuthIdPConfigSpecPublishConnectionDetailsTo
 */
export interface OAuthIdPConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: OAuthIdPConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecPublishConnectionDetailsTo(obj: OAuthIdPConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_OAuthIdPConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema OAuthIdPConfigSpecWriteConnectionSecretToRef
 */
export interface OAuthIdPConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema OAuthIdPConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OAuthIdPConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecWriteConnectionSecretToRef(obj: OAuthIdPConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The client id of an OAuth client.
 *
 * @schema OAuthIdPConfigSpecForProviderClientIdSecretRef
 */
export interface OAuthIdPConfigSpecForProviderClientIdSecretRef {
  /**
   * The key to select.
   *
   * @schema OAuthIdPConfigSpecForProviderClientIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema OAuthIdPConfigSpecForProviderClientIdSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OAuthIdPConfigSpecForProviderClientIdSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecForProviderClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecForProviderClientIdSecretRef(obj: OAuthIdPConfigSpecForProviderClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The client secret of the OAuth client, to enable OIDC code flow.
 *
 * @schema OAuthIdPConfigSpecForProviderClientSecretSecretRef
 */
export interface OAuthIdPConfigSpecForProviderClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema OAuthIdPConfigSpecForProviderClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema OAuthIdPConfigSpecForProviderClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema OAuthIdPConfigSpecForProviderClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecForProviderClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecForProviderClientSecretSecretRef(obj: OAuthIdPConfigSpecForProviderClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OAuthIdPConfigSpecProviderConfigRefPolicy
 */
export interface OAuthIdPConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OAuthIdPConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: OAuthIdPConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OAuthIdPConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: OAuthIdPConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecProviderConfigRefPolicy(obj: OAuthIdPConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema OAuthIdPConfigSpecProviderRefPolicy
 */
export interface OAuthIdPConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OAuthIdPConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: OAuthIdPConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OAuthIdPConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: OAuthIdPConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecProviderRefPolicy(obj: OAuthIdPConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef(obj: OAuthIdPConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema OAuthIdPConfigSpecPublishConnectionDetailsToMetadata
 */
export interface OAuthIdPConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecPublishConnectionDetailsToMetadata(obj: OAuthIdPConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OAuthIdPConfigSpecProviderConfigRefPolicyResolution
 */
export enum OAuthIdPConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OAuthIdPConfigSpecProviderConfigRefPolicyResolve
 */
export enum OAuthIdPConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OAuthIdPConfigSpecProviderRefPolicyResolution
 */
export enum OAuthIdPConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OAuthIdPConfigSpecProviderRefPolicyResolve
 */
export enum OAuthIdPConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum OAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProjectDefaultConfig is the Schema for the ProjectDefaultConfigs API. There is no persistent data associated with this resource.
 *
 * @schema ProjectDefaultConfig
 */
export class ProjectDefaultConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectDefaultConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'ProjectDefaultConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectDefaultConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectDefaultConfigProps): any {
    return {
      ...ProjectDefaultConfig.GVK,
      ...toJson_ProjectDefaultConfigProps(props),
    };
  }

  /**
   * Defines a "ProjectDefaultConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectDefaultConfigProps) {
    super(scope, id, {
      ...ProjectDefaultConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectDefaultConfig.GVK,
      ...toJson_ProjectDefaultConfigProps(resolved),
    };
  }
}

/**
 * ProjectDefaultConfig is the Schema for the ProjectDefaultConfigs API. There is no persistent data associated with this resource.
 *
 * @schema ProjectDefaultConfig
 */
export interface ProjectDefaultConfigProps {
  /**
   * @schema ProjectDefaultConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProjectDefaultConfigSpec defines the desired state of ProjectDefaultConfig
   *
   * @schema ProjectDefaultConfig#spec
   */
  readonly spec: ProjectDefaultConfigSpec;

}

/**
 * Converts an object of type 'ProjectDefaultConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigProps(obj: ProjectDefaultConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectDefaultConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProjectDefaultConfigSpec defines the desired state of ProjectDefaultConfig
 *
 * @schema ProjectDefaultConfigSpec
 */
export interface ProjectDefaultConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ProjectDefaultConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProjectDefaultConfigSpecDeletionPolicy;

  /**
   * @schema ProjectDefaultConfigSpec#forProvider
   */
  readonly forProvider: ProjectDefaultConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProjectDefaultConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProjectDefaultConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProjectDefaultConfigSpec#providerRef
   */
  readonly providerRef?: ProjectDefaultConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProjectDefaultConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProjectDefaultConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProjectDefaultConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProjectDefaultConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpec(obj: ProjectDefaultConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProjectDefaultConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ProjectDefaultConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProjectDefaultConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProjectDefaultConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProjectDefaultConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ProjectDefaultConfigSpecDeletionPolicy
 */
export enum ProjectDefaultConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProjectDefaultConfigSpecForProvider
 */
export interface ProjectDefaultConfigSpecForProvider {
  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ProjectDefaultConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Configuration related to local sign in methods. Structure is documented below.
   *
   * @schema ProjectDefaultConfigSpecForProvider#signIn
   */
  readonly signIn?: ProjectDefaultConfigSpecForProviderSignIn[];

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecForProvider(obj: ProjectDefaultConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'project': obj.project,
    'signIn': obj.signIn?.map(y => toJson_ProjectDefaultConfigSpecForProviderSignIn(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProjectDefaultConfigSpecProviderConfigRef
 */
export interface ProjectDefaultConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectDefaultConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectDefaultConfigSpecProviderConfigRef#policy
   */
  readonly policy?: ProjectDefaultConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecProviderConfigRef(obj: ProjectDefaultConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectDefaultConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProjectDefaultConfigSpecProviderRef
 */
export interface ProjectDefaultConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectDefaultConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectDefaultConfigSpecProviderRef#policy
   */
  readonly policy?: ProjectDefaultConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecProviderRef(obj: ProjectDefaultConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectDefaultConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProjectDefaultConfigSpecPublishConnectionDetailsTo
 */
export interface ProjectDefaultConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecPublishConnectionDetailsTo(obj: ProjectDefaultConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProjectDefaultConfigSpecWriteConnectionSecretToRef
 */
export interface ProjectDefaultConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProjectDefaultConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProjectDefaultConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecWriteConnectionSecretToRef(obj: ProjectDefaultConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectDefaultConfigSpecForProviderSignIn
 */
export interface ProjectDefaultConfigSpecForProviderSignIn {
  /**
   * Whether to allow more than one account to have the same email.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignIn#allowDuplicateEmails
   */
  readonly allowDuplicateEmails?: boolean;

  /**
   * Configuration options related to authenticating an anonymous user. Structure is documented below.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignIn#anonymous
   */
  readonly anonymous?: ProjectDefaultConfigSpecForProviderSignInAnonymous[];

  /**
   * Configuration options related to authenticating a user by their email address. Structure is documented below.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignIn#email
   */
  readonly email?: ProjectDefaultConfigSpecForProviderSignInEmail[];

  /**
   * Configuration options related to authenticated a user by their phone number. Structure is documented below.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignIn#phoneNumber
   */
  readonly phoneNumber?: ProjectDefaultConfigSpecForProviderSignInPhoneNumber[];

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecForProviderSignIn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecForProviderSignIn(obj: ProjectDefaultConfigSpecForProviderSignIn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowDuplicateEmails': obj.allowDuplicateEmails,
    'anonymous': obj.anonymous?.map(y => toJson_ProjectDefaultConfigSpecForProviderSignInAnonymous(y)),
    'email': obj.email?.map(y => toJson_ProjectDefaultConfigSpecForProviderSignInEmail(y)),
    'phoneNumber': obj.phoneNumber?.map(y => toJson_ProjectDefaultConfigSpecForProviderSignInPhoneNumber(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectDefaultConfigSpecProviderConfigRefPolicy
 */
export interface ProjectDefaultConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectDefaultConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectDefaultConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectDefaultConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectDefaultConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecProviderConfigRefPolicy(obj: ProjectDefaultConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProjectDefaultConfigSpecProviderRefPolicy
 */
export interface ProjectDefaultConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectDefaultConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProjectDefaultConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectDefaultConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProjectDefaultConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecProviderRefPolicy(obj: ProjectDefaultConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef(obj: ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata
 */
export interface ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata(obj: ProjectDefaultConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectDefaultConfigSpecForProviderSignInAnonymous
 */
export interface ProjectDefaultConfigSpecForProviderSignInAnonymous {
  /**
   * Whether phone number auth is enabled for the project or not.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignInAnonymous#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecForProviderSignInAnonymous' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecForProviderSignInAnonymous(obj: ProjectDefaultConfigSpecForProviderSignInAnonymous | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectDefaultConfigSpecForProviderSignInEmail
 */
export interface ProjectDefaultConfigSpecForProviderSignInEmail {
  /**
   * Whether phone number auth is enabled for the project or not.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignInEmail#enabled
   */
  readonly enabled?: boolean;

  /**
   * Whether a password is required for email auth or not. If true, both an email and password must be provided to sign in. If false, a user may sign in via either email/password or email link.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignInEmail#passwordRequired
   */
  readonly passwordRequired?: boolean;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecForProviderSignInEmail' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecForProviderSignInEmail(obj: ProjectDefaultConfigSpecForProviderSignInEmail | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'passwordRequired': obj.passwordRequired,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProjectDefaultConfigSpecForProviderSignInPhoneNumber
 */
export interface ProjectDefaultConfigSpecForProviderSignInPhoneNumber {
  /**
   * Whether phone number auth is enabled for the project or not.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignInPhoneNumber#enabled
   */
  readonly enabled?: boolean;

  /**
   * A map of <test phone number, fake code> that can be used for phone auth testing.
   *
   * @schema ProjectDefaultConfigSpecForProviderSignInPhoneNumber#testPhoneNumbers
   */
  readonly testPhoneNumbers?: { [key: string]: string };

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecForProviderSignInPhoneNumber' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecForProviderSignInPhoneNumber(obj: ProjectDefaultConfigSpecForProviderSignInPhoneNumber | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'testPhoneNumbers': ((obj.testPhoneNumbers) === undefined) ? undefined : (Object.entries(obj.testPhoneNumbers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectDefaultConfigSpecProviderConfigRefPolicyResolution
 */
export enum ProjectDefaultConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectDefaultConfigSpecProviderConfigRefPolicyResolve
 */
export enum ProjectDefaultConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectDefaultConfigSpecProviderRefPolicyResolution
 */
export enum ProjectDefaultConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectDefaultConfigSpecProviderRefPolicyResolve
 */
export enum ProjectDefaultConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProjectDefaultConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Tenant is the Schema for the Tenants API. Tenant configuration in a multi-tenant project.
 *
 * @schema Tenant
 */
export class Tenant extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tenant"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'Tenant',
  }

  /**
   * Renders a Kubernetes manifest for "Tenant".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TenantProps): any {
    return {
      ...Tenant.GVK,
      ...toJson_TenantProps(props),
    };
  }

  /**
   * Defines a "Tenant" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TenantProps) {
    super(scope, id, {
      ...Tenant.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tenant.GVK,
      ...toJson_TenantProps(resolved),
    };
  }
}

/**
 * Tenant is the Schema for the Tenants API. Tenant configuration in a multi-tenant project.
 *
 * @schema Tenant
 */
export interface TenantProps {
  /**
   * @schema Tenant#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TenantSpec defines the desired state of Tenant
   *
   * @schema Tenant#spec
   */
  readonly spec: TenantSpec;

}

/**
 * Converts an object of type 'TenantProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantProps(obj: TenantProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TenantSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TenantSpec defines the desired state of Tenant
 *
 * @schema TenantSpec
 */
export interface TenantSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TenantSpec#deletionPolicy
   */
  readonly deletionPolicy?: TenantSpecDeletionPolicy;

  /**
   * @schema TenantSpec#forProvider
   */
  readonly forProvider: TenantSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TenantSpec#providerConfigRef
   */
  readonly providerConfigRef?: TenantSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TenantSpec#providerRef
   */
  readonly providerRef?: TenantSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TenantSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TenantSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TenantSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TenantSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TenantSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpec(obj: TenantSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TenantSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TenantSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TenantSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TenantSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TenantSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TenantSpecDeletionPolicy
 */
export enum TenantSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TenantSpecForProvider
 */
export interface TenantSpecForProvider {
  /**
   * Whether to allow email/password user authentication.
   *
   * @schema TenantSpecForProvider#allowPasswordSignup
   */
  readonly allowPasswordSignup?: boolean;

  /**
   * Whether authentication is disabled for the tenant. If true, the users under the disabled tenant are not allowed to sign-in. Admins of the disabled tenant are not able to manage its users.
   *
   * @schema TenantSpecForProvider#disableAuth
   */
  readonly disableAuth?: boolean;

  /**
   * Human friendly display name of the tenant.
   *
   * @schema TenantSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * Whether to enable email link user authentication.
   *
   * @schema TenantSpecForProvider#enableEmailLinkSignin
   */
  readonly enableEmailLinkSignin?: boolean;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TenantSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'TenantSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecForProvider(obj: TenantSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPasswordSignup': obj.allowPasswordSignup,
    'disableAuth': obj.disableAuth,
    'displayName': obj.displayName,
    'enableEmailLinkSignin': obj.enableEmailLinkSignin,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TenantSpecProviderConfigRef
 */
export interface TenantSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantSpecProviderConfigRef#policy
   */
  readonly policy?: TenantSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecProviderConfigRef(obj: TenantSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TenantSpecProviderRef
 */
export interface TenantSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantSpecProviderRef#policy
   */
  readonly policy?: TenantSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TenantSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecProviderRef(obj: TenantSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TenantSpecPublishConnectionDetailsTo
 */
export interface TenantSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TenantSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TenantSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TenantSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TenantSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TenantSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TenantSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecPublishConnectionDetailsTo(obj: TenantSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TenantSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TenantSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TenantSpecWriteConnectionSecretToRef
 */
export interface TenantSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TenantSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecWriteConnectionSecretToRef(obj: TenantSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantSpecProviderConfigRefPolicy
 */
export interface TenantSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TenantSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TenantSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecProviderConfigRefPolicy(obj: TenantSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantSpecProviderRefPolicy
 */
export interface TenantSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TenantSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TenantSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecProviderRefPolicy(obj: TenantSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TenantSpecPublishConnectionDetailsToConfigRef
 */
export interface TenantSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TenantSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecPublishConnectionDetailsToConfigRef(obj: TenantSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TenantSpecPublishConnectionDetailsToMetadata
 */
export interface TenantSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TenantSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TenantSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecPublishConnectionDetailsToMetadata(obj: TenantSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantSpecProviderConfigRefPolicyResolution
 */
export enum TenantSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantSpecProviderConfigRefPolicyResolve
 */
export enum TenantSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantSpecProviderRefPolicyResolution
 */
export enum TenantSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantSpecProviderRefPolicyResolve
 */
export enum TenantSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TenantSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TenantSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TenantSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TenantSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantSpecPublishConnectionDetailsToConfigRefPolicy(obj: TenantSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TenantSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TenantSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TenantDefaultSupportedIdPConfig is the Schema for the TenantDefaultSupportedIdPConfigs API. Configurations options for the tenant for authenticating with a the standard set of Identity Toolkit-trusted IDPs.
 *
 * @schema TenantDefaultSupportedIdPConfig
 */
export class TenantDefaultSupportedIdPConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TenantDefaultSupportedIdPConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'TenantDefaultSupportedIdPConfig',
  }

  /**
   * Renders a Kubernetes manifest for "TenantDefaultSupportedIdPConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TenantDefaultSupportedIdPConfigProps): any {
    return {
      ...TenantDefaultSupportedIdPConfig.GVK,
      ...toJson_TenantDefaultSupportedIdPConfigProps(props),
    };
  }

  /**
   * Defines a "TenantDefaultSupportedIdPConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TenantDefaultSupportedIdPConfigProps) {
    super(scope, id, {
      ...TenantDefaultSupportedIdPConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TenantDefaultSupportedIdPConfig.GVK,
      ...toJson_TenantDefaultSupportedIdPConfigProps(resolved),
    };
  }
}

/**
 * TenantDefaultSupportedIdPConfig is the Schema for the TenantDefaultSupportedIdPConfigs API. Configurations options for the tenant for authenticating with a the standard set of Identity Toolkit-trusted IDPs.
 *
 * @schema TenantDefaultSupportedIdPConfig
 */
export interface TenantDefaultSupportedIdPConfigProps {
  /**
   * @schema TenantDefaultSupportedIdPConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TenantDefaultSupportedIdPConfigSpec defines the desired state of TenantDefaultSupportedIdPConfig
   *
   * @schema TenantDefaultSupportedIdPConfig#spec
   */
  readonly spec: TenantDefaultSupportedIdPConfigSpec;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigProps(obj: TenantDefaultSupportedIdPConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TenantDefaultSupportedIdPConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TenantDefaultSupportedIdPConfigSpec defines the desired state of TenantDefaultSupportedIdPConfig
 *
 * @schema TenantDefaultSupportedIdPConfigSpec
 */
export interface TenantDefaultSupportedIdPConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TenantDefaultSupportedIdPConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: TenantDefaultSupportedIdPConfigSpecDeletionPolicy;

  /**
   * @schema TenantDefaultSupportedIdPConfigSpec#forProvider
   */
  readonly forProvider: TenantDefaultSupportedIdPConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TenantDefaultSupportedIdPConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: TenantDefaultSupportedIdPConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TenantDefaultSupportedIdPConfigSpec#providerRef
   */
  readonly providerRef?: TenantDefaultSupportedIdPConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TenantDefaultSupportedIdPConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TenantDefaultSupportedIdPConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpec(obj: TenantDefaultSupportedIdPConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TenantDefaultSupportedIdPConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TenantDefaultSupportedIdPConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TenantDefaultSupportedIdPConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecDeletionPolicy
 */
export enum TenantDefaultSupportedIdPConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TenantDefaultSupportedIdPConfigSpecForProvider
 */
export interface TenantDefaultSupportedIdPConfigSpecForProvider {
  /**
   * OAuth client ID
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#clientIdSecretRef
   */
  readonly clientIdSecretRef: TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef;

  /**
   * OAuth client secret
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef;

  /**
   * If this IDP allows the user to sign in
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * ID of the IDP. Possible values include:
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#idpId
   */
  readonly idpId: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The name of the tenant where this DefaultSupportedIdpConfig resource exists
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#tenant
   */
  readonly tenant?: string;

  /**
   * Reference to a Tenant in identityplatform to populate tenant.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#tenantRef
   */
  readonly tenantRef?: TenantDefaultSupportedIdPConfigSpecForProviderTenantRef;

  /**
   * Selector for a Tenant in identityplatform to populate tenant.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProvider#tenantSelector
   */
  readonly tenantSelector?: TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecForProvider(obj: TenantDefaultSupportedIdPConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIdSecretRef': toJson_TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef(obj.clientIdSecretRef),
    'clientSecretSecretRef': toJson_TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef(obj.clientSecretSecretRef),
    'enabled': obj.enabled,
    'idpId': obj.idpId,
    'project': obj.project,
    'tenant': obj.tenant,
    'tenantRef': toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantRef(obj.tenantRef),
    'tenantSelector': toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector(obj.tenantSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRef
 */
export interface TenantDefaultSupportedIdPConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRef#policy
   */
  readonly policy?: TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecProviderConfigRef(obj: TenantDefaultSupportedIdPConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderRef
 */
export interface TenantDefaultSupportedIdPConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderRef#policy
   */
  readonly policy?: TenantDefaultSupportedIdPConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecProviderRef(obj: TenantDefaultSupportedIdPConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantDefaultSupportedIdPConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo
 */
export interface TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo(obj: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef
 */
export interface TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef(obj: TenantDefaultSupportedIdPConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth client ID
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef
 */
export interface TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef {
  /**
   * The key to select.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef(obj: TenantDefaultSupportedIdPConfigSpecForProviderClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth client secret
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef
 */
export interface TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef(obj: TenantDefaultSupportedIdPConfigSpecForProviderClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Tenant in identityplatform to populate tenant.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRef
 */
export interface TenantDefaultSupportedIdPConfigSpecForProviderTenantRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRef#policy
   */
  readonly policy?: TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecForProviderTenantRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantRef(obj: TenantDefaultSupportedIdPConfigSpecForProviderTenantRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Tenant in identityplatform to populate tenant.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector
 */
export interface TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector#policy
   */
  readonly policy?: TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector(obj: TenantDefaultSupportedIdPConfigSpecForProviderTenantSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy
 */
export interface TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy(obj: TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderRefPolicy
 */
export interface TenantDefaultSupportedIdPConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TenantDefaultSupportedIdPConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TenantDefaultSupportedIdPConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecProviderRefPolicy(obj: TenantDefaultSupportedIdPConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef(obj: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata
 */
export interface TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata(obj: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy
 */
export interface TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy#resolution
   */
  readonly resolution?: TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy#resolve
   */
  readonly resolve?: TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy(obj: TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy
 */
export interface TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy#resolution
   */
  readonly resolution?: TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy#resolve
   */
  readonly resolve?: TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy(obj: TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolution
 */
export enum TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolve
 */
export enum TenantDefaultSupportedIdPConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderRefPolicyResolution
 */
export enum TenantDefaultSupportedIdPConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecProviderRefPolicyResolve
 */
export enum TenantDefaultSupportedIdPConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicyResolution
 */
export enum TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicyResolve
 */
export enum TenantDefaultSupportedIdPConfigSpecForProviderTenantRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicyResolution
 */
export enum TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicyResolve
 */
export enum TenantDefaultSupportedIdPConfigSpecForProviderTenantSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TenantDefaultSupportedIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TenantInboundSAMLConfig is the Schema for the TenantInboundSAMLConfigs API. Inbound SAML configuration for a Identity Toolkit tenant.
 *
 * @schema TenantInboundSAMLConfig
 */
export class TenantInboundSamlConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TenantInboundSAMLConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'TenantInboundSAMLConfig',
  }

  /**
   * Renders a Kubernetes manifest for "TenantInboundSAMLConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TenantInboundSamlConfigProps): any {
    return {
      ...TenantInboundSamlConfig.GVK,
      ...toJson_TenantInboundSamlConfigProps(props),
    };
  }

  /**
   * Defines a "TenantInboundSAMLConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TenantInboundSamlConfigProps) {
    super(scope, id, {
      ...TenantInboundSamlConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TenantInboundSamlConfig.GVK,
      ...toJson_TenantInboundSamlConfigProps(resolved),
    };
  }
}

/**
 * TenantInboundSAMLConfig is the Schema for the TenantInboundSAMLConfigs API. Inbound SAML configuration for a Identity Toolkit tenant.
 *
 * @schema TenantInboundSAMLConfig
 */
export interface TenantInboundSamlConfigProps {
  /**
   * @schema TenantInboundSAMLConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TenantInboundSAMLConfigSpec defines the desired state of TenantInboundSAMLConfig
   *
   * @schema TenantInboundSAMLConfig#spec
   */
  readonly spec: TenantInboundSamlConfigSpec;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigProps(obj: TenantInboundSamlConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TenantInboundSamlConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TenantInboundSAMLConfigSpec defines the desired state of TenantInboundSAMLConfig
 *
 * @schema TenantInboundSamlConfigSpec
 */
export interface TenantInboundSamlConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TenantInboundSamlConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: TenantInboundSamlConfigSpecDeletionPolicy;

  /**
   * @schema TenantInboundSamlConfigSpec#forProvider
   */
  readonly forProvider: TenantInboundSamlConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TenantInboundSamlConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: TenantInboundSamlConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TenantInboundSamlConfigSpec#providerRef
   */
  readonly providerRef?: TenantInboundSamlConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TenantInboundSamlConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TenantInboundSamlConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TenantInboundSamlConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TenantInboundSamlConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpec(obj: TenantInboundSamlConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TenantInboundSamlConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TenantInboundSamlConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TenantInboundSamlConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TenantInboundSamlConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TenantInboundSamlConfigSpecDeletionPolicy
 */
export enum TenantInboundSamlConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TenantInboundSamlConfigSpecForProvider
 */
export interface TenantInboundSamlConfigSpecForProvider {
  /**
   * Human friendly display name.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * If this config allows users to sign in with the provider.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * SAML IdP configuration when the project acts as the relying party Structure is documented below.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#idpConfig
   */
  readonly idpConfig: TenantInboundSamlConfigSpecForProviderIdpConfig[];

  /**
   * The name of the InboundSamlConfig resource. Must start with 'saml.' and can only have alphanumeric characters, hyphens, underscores or periods. The part after 'saml.' must also start with a lowercase letter, end with an alphanumeric character, and have at least 2 characters.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#name
   */
  readonly name: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * SAML SP (Service Provider) configuration when the project acts as the relying party to receive and accept an authentication assertion issued by a SAML identity provider. Structure is documented below.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#spConfig
   */
  readonly spConfig: TenantInboundSamlConfigSpecForProviderSpConfig[];

  /**
   * The name of the tenant where this inbound SAML config resource exists
   *
   * @schema TenantInboundSamlConfigSpecForProvider#tenant
   */
  readonly tenant?: string;

  /**
   * Reference to a Tenant in identityplatform to populate tenant.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#tenantRef
   */
  readonly tenantRef?: TenantInboundSamlConfigSpecForProviderTenantRef;

  /**
   * Selector for a Tenant in identityplatform to populate tenant.
   *
   * @schema TenantInboundSamlConfigSpecForProvider#tenantSelector
   */
  readonly tenantSelector?: TenantInboundSamlConfigSpecForProviderTenantSelector;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProvider(obj: TenantInboundSamlConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'enabled': obj.enabled,
    'idpConfig': obj.idpConfig?.map(y => toJson_TenantInboundSamlConfigSpecForProviderIdpConfig(y)),
    'name': obj.name,
    'project': obj.project,
    'spConfig': obj.spConfig?.map(y => toJson_TenantInboundSamlConfigSpecForProviderSpConfig(y)),
    'tenant': obj.tenant,
    'tenantRef': toJson_TenantInboundSamlConfigSpecForProviderTenantRef(obj.tenantRef),
    'tenantSelector': toJson_TenantInboundSamlConfigSpecForProviderTenantSelector(obj.tenantSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TenantInboundSamlConfigSpecProviderConfigRef
 */
export interface TenantInboundSamlConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantInboundSamlConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantInboundSamlConfigSpecProviderConfigRef#policy
   */
  readonly policy?: TenantInboundSamlConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecProviderConfigRef(obj: TenantInboundSamlConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantInboundSamlConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TenantInboundSamlConfigSpecProviderRef
 */
export interface TenantInboundSamlConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantInboundSamlConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantInboundSamlConfigSpecProviderRef#policy
   */
  readonly policy?: TenantInboundSamlConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecProviderRef(obj: TenantInboundSamlConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantInboundSamlConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsTo
 */
export interface TenantInboundSamlConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsTo(obj: TenantInboundSamlConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TenantInboundSamlConfigSpecWriteConnectionSecretToRef
 */
export interface TenantInboundSamlConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TenantInboundSamlConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantInboundSamlConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecWriteConnectionSecretToRef(obj: TenantInboundSamlConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TenantInboundSamlConfigSpecForProviderIdpConfig
 */
export interface TenantInboundSamlConfigSpecForProviderIdpConfig {
  /**
   * The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP. Structure is documented below.
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfig#idpCertificates
   */
  readonly idpCertificates: TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates[];

  /**
   * Unique identifier for all SAML entities
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfig#idpEntityId
   */
  readonly idpEntityId: string;

  /**
   * Indicates if outbounding SAMLRequest should be signed.
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfig#signRequest
   */
  readonly signRequest?: boolean;

  /**
   * URL to send Authentication request to.
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfig#ssoUrl
   */
  readonly ssoUrl: string;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderIdpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderIdpConfig(obj: TenantInboundSamlConfigSpecForProviderIdpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'idpCertificates': obj.idpCertificates?.map(y => toJson_TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates(y)),
    'idpEntityId': obj.idpEntityId,
    'signRequest': obj.signRequest,
    'ssoUrl': obj.ssoUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TenantInboundSamlConfigSpecForProviderSpConfig
 */
export interface TenantInboundSamlConfigSpecForProviderSpConfig {
  /**
   * Callback URI where responses from IDP are handled. Must start with https://.
   *
   * @schema TenantInboundSamlConfigSpecForProviderSpConfig#callbackUri
   */
  readonly callbackUri: string;

  /**
   * Unique identifier for all SAML entities.
   *
   * @schema TenantInboundSamlConfigSpecForProviderSpConfig#spEntityId
   */
  readonly spEntityId: string;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderSpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderSpConfig(obj: TenantInboundSamlConfigSpecForProviderSpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'callbackUri': obj.callbackUri,
    'spEntityId': obj.spEntityId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Tenant in identityplatform to populate tenant.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantRef
 */
export interface TenantInboundSamlConfigSpecForProviderTenantRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantRef#policy
   */
  readonly policy?: TenantInboundSamlConfigSpecForProviderTenantRefPolicy;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderTenantRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderTenantRef(obj: TenantInboundSamlConfigSpecForProviderTenantRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantInboundSamlConfigSpecForProviderTenantRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Tenant in identityplatform to populate tenant.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantSelector
 */
export interface TenantInboundSamlConfigSpecForProviderTenantSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantSelector#policy
   */
  readonly policy?: TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderTenantSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderTenantSelector(obj: TenantInboundSamlConfigSpecForProviderTenantSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantInboundSamlConfigSpecProviderConfigRefPolicy
 */
export interface TenantInboundSamlConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantInboundSamlConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TenantInboundSamlConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantInboundSamlConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TenantInboundSamlConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecProviderConfigRefPolicy(obj: TenantInboundSamlConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantInboundSamlConfigSpecProviderRefPolicy
 */
export interface TenantInboundSamlConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantInboundSamlConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TenantInboundSamlConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantInboundSamlConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TenantInboundSamlConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecProviderRefPolicy(obj: TenantInboundSamlConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef(obj: TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata
 */
export interface TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata(obj: TenantInboundSamlConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates
 */
export interface TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates {
  /**
   * The x509 certificate
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates#x509CertificateSecretRef
   */
  readonly x509CertificateSecretRef?: TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates(obj: TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'x509CertificateSecretRef': toJson_TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef(obj.x509CertificateSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantRefPolicy
 */
export interface TenantInboundSamlConfigSpecForProviderTenantRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantRefPolicy#resolution
   */
  readonly resolution?: TenantInboundSamlConfigSpecForProviderTenantRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantRefPolicy#resolve
   */
  readonly resolve?: TenantInboundSamlConfigSpecForProviderTenantRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderTenantRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderTenantRefPolicy(obj: TenantInboundSamlConfigSpecForProviderTenantRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy
 */
export interface TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy#resolution
   */
  readonly resolution?: TenantInboundSamlConfigSpecForProviderTenantSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy#resolve
   */
  readonly resolve?: TenantInboundSamlConfigSpecForProviderTenantSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy(obj: TenantInboundSamlConfigSpecForProviderTenantSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantInboundSamlConfigSpecProviderConfigRefPolicyResolution
 */
export enum TenantInboundSamlConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantInboundSamlConfigSpecProviderConfigRefPolicyResolve
 */
export enum TenantInboundSamlConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantInboundSamlConfigSpecProviderRefPolicyResolution
 */
export enum TenantInboundSamlConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantInboundSamlConfigSpecProviderRefPolicyResolve
 */
export enum TenantInboundSamlConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The x509 certificate
 *
 * @schema TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef
 */
export interface TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef {
  /**
   * The key to select.
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef(obj: TenantInboundSamlConfigSpecForProviderIdpConfigIdpCertificatesX509CertificateSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantRefPolicyResolution
 */
export enum TenantInboundSamlConfigSpecForProviderTenantRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantRefPolicyResolve
 */
export enum TenantInboundSamlConfigSpecForProviderTenantRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantSelectorPolicyResolution
 */
export enum TenantInboundSamlConfigSpecForProviderTenantSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantInboundSamlConfigSpecForProviderTenantSelectorPolicyResolve
 */
export enum TenantInboundSamlConfigSpecForProviderTenantSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TenantInboundSamlConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TenantOAuthIdPConfig is the Schema for the TenantOAuthIdPConfigs API. OIDC IdP configuration for a Identity Toolkit project within a tenant.
 *
 * @schema TenantOAuthIdPConfig
 */
export class TenantOAuthIdPConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TenantOAuthIdPConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identityplatform.gcp.upbound.io/v1beta1',
    kind: 'TenantOAuthIdPConfig',
  }

  /**
   * Renders a Kubernetes manifest for "TenantOAuthIdPConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TenantOAuthIdPConfigProps): any {
    return {
      ...TenantOAuthIdPConfig.GVK,
      ...toJson_TenantOAuthIdPConfigProps(props),
    };
  }

  /**
   * Defines a "TenantOAuthIdPConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TenantOAuthIdPConfigProps) {
    super(scope, id, {
      ...TenantOAuthIdPConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TenantOAuthIdPConfig.GVK,
      ...toJson_TenantOAuthIdPConfigProps(resolved),
    };
  }
}

/**
 * TenantOAuthIdPConfig is the Schema for the TenantOAuthIdPConfigs API. OIDC IdP configuration for a Identity Toolkit project within a tenant.
 *
 * @schema TenantOAuthIdPConfig
 */
export interface TenantOAuthIdPConfigProps {
  /**
   * @schema TenantOAuthIdPConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TenantOAuthIdPConfigSpec defines the desired state of TenantOAuthIdPConfig
   *
   * @schema TenantOAuthIdPConfig#spec
   */
  readonly spec: TenantOAuthIdPConfigSpec;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigProps(obj: TenantOAuthIdPConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TenantOAuthIdPConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TenantOAuthIdPConfigSpec defines the desired state of TenantOAuthIdPConfig
 *
 * @schema TenantOAuthIdPConfigSpec
 */
export interface TenantOAuthIdPConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema TenantOAuthIdPConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: TenantOAuthIdPConfigSpecDeletionPolicy;

  /**
   * @schema TenantOAuthIdPConfigSpec#forProvider
   */
  readonly forProvider: TenantOAuthIdPConfigSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TenantOAuthIdPConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: TenantOAuthIdPConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TenantOAuthIdPConfigSpec#providerRef
   */
  readonly providerRef?: TenantOAuthIdPConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TenantOAuthIdPConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TenantOAuthIdPConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TenantOAuthIdPConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TenantOAuthIdPConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpec(obj: TenantOAuthIdPConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TenantOAuthIdPConfigSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_TenantOAuthIdPConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TenantOAuthIdPConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TenantOAuthIdPConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema TenantOAuthIdPConfigSpecDeletionPolicy
 */
export enum TenantOAuthIdPConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TenantOAuthIdPConfigSpecForProvider
 */
export interface TenantOAuthIdPConfigSpecForProvider {
  /**
   * The client id of an OAuth client.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#clientIdSecretRef
   */
  readonly clientIdSecretRef: TenantOAuthIdPConfigSpecForProviderClientIdSecretRef;

  /**
   * The client secret of the OAuth client, to enable OIDC code flow.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#clientSecretSecretRef
   */
  readonly clientSecretSecretRef?: TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef;

  /**
   * Human friendly display name.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * If this config allows users to sign in with the provider.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * For OIDC Idps, the issuer identifier.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#issuer
   */
  readonly issuer: string;

  /**
   * The name of the OauthIdpConfig. Must start with oidc..
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#name
   */
  readonly name: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The name of the tenant where this OIDC IDP configuration resource exists
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#tenant
   */
  readonly tenant?: string;

  /**
   * Reference to a Tenant in identityplatform to populate tenant.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#tenantRef
   */
  readonly tenantRef?: TenantOAuthIdPConfigSpecForProviderTenantRef;

  /**
   * Selector for a Tenant in identityplatform to populate tenant.
   *
   * @schema TenantOAuthIdPConfigSpecForProvider#tenantSelector
   */
  readonly tenantSelector?: TenantOAuthIdPConfigSpecForProviderTenantSelector;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecForProvider(obj: TenantOAuthIdPConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientIdSecretRef': toJson_TenantOAuthIdPConfigSpecForProviderClientIdSecretRef(obj.clientIdSecretRef),
    'clientSecretSecretRef': toJson_TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef(obj.clientSecretSecretRef),
    'displayName': obj.displayName,
    'enabled': obj.enabled,
    'issuer': obj.issuer,
    'name': obj.name,
    'project': obj.project,
    'tenant': obj.tenant,
    'tenantRef': toJson_TenantOAuthIdPConfigSpecForProviderTenantRef(obj.tenantRef),
    'tenantSelector': toJson_TenantOAuthIdPConfigSpecForProviderTenantSelector(obj.tenantSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TenantOAuthIdPConfigSpecProviderConfigRef
 */
export interface TenantOAuthIdPConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantOAuthIdPConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantOAuthIdPConfigSpecProviderConfigRef#policy
   */
  readonly policy?: TenantOAuthIdPConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecProviderConfigRef(obj: TenantOAuthIdPConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantOAuthIdPConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TenantOAuthIdPConfigSpecProviderRef
 */
export interface TenantOAuthIdPConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantOAuthIdPConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantOAuthIdPConfigSpecProviderRef#policy
   */
  readonly policy?: TenantOAuthIdPConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecProviderRef(obj: TenantOAuthIdPConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantOAuthIdPConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsTo
 */
export interface TenantOAuthIdPConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsTo(obj: TenantOAuthIdPConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TenantOAuthIdPConfigSpecWriteConnectionSecretToRef
 */
export interface TenantOAuthIdPConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TenantOAuthIdPConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantOAuthIdPConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecWriteConnectionSecretToRef(obj: TenantOAuthIdPConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The client id of an OAuth client.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderClientIdSecretRef
 */
export interface TenantOAuthIdPConfigSpecForProviderClientIdSecretRef {
  /**
   * The key to select.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderClientIdSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderClientIdSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderClientIdSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecForProviderClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecForProviderClientIdSecretRef(obj: TenantOAuthIdPConfigSpecForProviderClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The client secret of the OAuth client, to enable OIDC code flow.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef
 */
export interface TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef(obj: TenantOAuthIdPConfigSpecForProviderClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Tenant in identityplatform to populate tenant.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantRef
 */
export interface TenantOAuthIdPConfigSpecForProviderTenantRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantRef#policy
   */
  readonly policy?: TenantOAuthIdPConfigSpecForProviderTenantRefPolicy;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecForProviderTenantRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecForProviderTenantRef(obj: TenantOAuthIdPConfigSpecForProviderTenantRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantOAuthIdPConfigSpecForProviderTenantRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Tenant in identityplatform to populate tenant.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantSelector
 */
export interface TenantOAuthIdPConfigSpecForProviderTenantSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantSelector#policy
   */
  readonly policy?: TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecForProviderTenantSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecForProviderTenantSelector(obj: TenantOAuthIdPConfigSpecForProviderTenantSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantOAuthIdPConfigSpecProviderConfigRefPolicy
 */
export interface TenantOAuthIdPConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantOAuthIdPConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TenantOAuthIdPConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantOAuthIdPConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TenantOAuthIdPConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecProviderConfigRefPolicy(obj: TenantOAuthIdPConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantOAuthIdPConfigSpecProviderRefPolicy
 */
export interface TenantOAuthIdPConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantOAuthIdPConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TenantOAuthIdPConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantOAuthIdPConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TenantOAuthIdPConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecProviderRefPolicy(obj: TenantOAuthIdPConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef(obj: TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata
 */
export interface TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata(obj: TenantOAuthIdPConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantRefPolicy
 */
export interface TenantOAuthIdPConfigSpecForProviderTenantRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantRefPolicy#resolution
   */
  readonly resolution?: TenantOAuthIdPConfigSpecForProviderTenantRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantRefPolicy#resolve
   */
  readonly resolve?: TenantOAuthIdPConfigSpecForProviderTenantRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecForProviderTenantRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecForProviderTenantRefPolicy(obj: TenantOAuthIdPConfigSpecForProviderTenantRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy
 */
export interface TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy#resolution
   */
  readonly resolution?: TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy#resolve
   */
  readonly resolve?: TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy(obj: TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantOAuthIdPConfigSpecProviderConfigRefPolicyResolution
 */
export enum TenantOAuthIdPConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantOAuthIdPConfigSpecProviderConfigRefPolicyResolve
 */
export enum TenantOAuthIdPConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantOAuthIdPConfigSpecProviderRefPolicyResolution
 */
export enum TenantOAuthIdPConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantOAuthIdPConfigSpecProviderRefPolicyResolve
 */
export enum TenantOAuthIdPConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantRefPolicyResolution
 */
export enum TenantOAuthIdPConfigSpecForProviderTenantRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantRefPolicyResolve
 */
export enum TenantOAuthIdPConfigSpecForProviderTenantRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicyResolution
 */
export enum TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicyResolve
 */
export enum TenantOAuthIdPConfigSpecForProviderTenantSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TenantOAuthIdPConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

