// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * LB is the Schema for the LBs API. Provides a Load Balancer resource.
 *
 * @schema LB
 */
export class Lb extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LB"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.upbound.io/v1beta1',
    kind: 'LB',
  }

  /**
   * Renders a Kubernetes manifest for "LB".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LbProps): any {
    return {
      ...Lb.GVK,
      ...toJson_LbProps(props),
    };
  }

  /**
   * Defines a "LB" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LbProps) {
    super(scope, id, {
      ...Lb.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Lb.GVK,
      ...toJson_LbProps(resolved),
    };
  }
}

/**
 * LB is the Schema for the LBs API. Provides a Load Balancer resource.
 *
 * @schema LB
 */
export interface LbProps {
  /**
   * @schema LB#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LBSpec defines the desired state of LB
   *
   * @schema LB#spec
   */
  readonly spec: LbSpec;

}

/**
 * Converts an object of type 'LbProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbProps(obj: LbProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LbSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LBSpec defines the desired state of LB
 *
 * @schema LbSpec
 */
export interface LbSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbSpec#deletionPolicy
   */
  readonly deletionPolicy?: LbSpecDeletionPolicy;

  /**
   * @schema LbSpec#forProvider
   */
  readonly forProvider: LbSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbSpec#managementPolicy
   */
  readonly managementPolicy?: LbSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LbSpec#providerConfigRef
   */
  readonly providerConfigRef?: LbSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LbSpec#providerRef
   */
  readonly providerRef?: LbSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LbSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LbSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LbSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LbSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LbSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpec(obj: LbSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LbSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LbSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LbSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LbSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LbSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbSpecDeletionPolicy
 */
export enum LbSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LbSpecForProvider
 */
export interface LbSpecForProvider {
  /**
   * An Access Logs block. Access Logs documented below.
   *
   * @schema LbSpecForProvider#accessLogs
   */
  readonly accessLogs?: LbSpecForProviderAccessLogs[];

  /**
   * The ID of the customer owned ipv4 pool to use for this load balancer.
   *
   * @schema LbSpecForProvider#customerOwnedIpv4Pool
   */
  readonly customerOwnedIpv4Pool?: string;

  /**
   * Determines how the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are monitor, defensive (default), strictest.
   *
   * @schema LbSpecForProvider#desyncMitigationMode
   */
  readonly desyncMitigationMode?: string;

  /**
   * Indicates whether HTTP headers with header fields that are not valid are removed by the load balancer (true) or routed to targets (false). The default is false. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens. Only valid for Load Balancers of type application.
   *
   * @schema LbSpecForProvider#dropInvalidHeaderFields
   */
  readonly dropInvalidHeaderFields?: boolean;

  /**
   * If true, cross-zone load balancing of the load balancer will be enabled. For network and gateway type load balancers, this feature is disabled by default (false). For application load balancer this feature is always enabled (true) and cannot be disabled. Defaults to false.
   *
   * @default false.
   * @schema LbSpecForProvider#enableCrossZoneLoadBalancing
   */
  readonly enableCrossZoneLoadBalancing?: boolean;

  /**
   * If true, deletion of the load balancer will be disabled via the AWS API. Defaults to false.
   *
   * @default false.
   * @schema LbSpecForProvider#enableDeletionProtection
   */
  readonly enableDeletionProtection?: boolean;

  /**
   * Indicates whether HTTP/2 is enabled in application load balancers. Defaults to true.
   *
   * @default true.
   * @schema LbSpecForProvider#enableHttp2
   */
  readonly enableHttp2?: boolean;

  /**
   * Indicates whether the two headers (x-amzn-tls-version and x-amzn-tls-cipher-suite), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. Only valid for Load Balancers of type application. Defaults to false
   *
   * @default false
   * @schema LbSpecForProvider#enableTlsVersionAndCipherSuiteHeaders
   */
  readonly enableTlsVersionAndCipherSuiteHeaders?: boolean;

  /**
   * Indicates whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Defaults to false.
   *
   * @default false.
   * @schema LbSpecForProvider#enableWafFailOpen
   */
  readonly enableWafFailOpen?: boolean;

  /**
   * Indicates whether the X-Forwarded-For header should preserve the source port that the client used to connect to the load balancer in application load balancers. Defaults to false.
   *
   * @default false.
   * @schema LbSpecForProvider#enableXffClientPort
   */
  readonly enableXffClientPort?: boolean;

  /**
   * The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type application. Default: 60.
   *
   * @schema LbSpecForProvider#idleTimeout
   */
  readonly idleTimeout?: number;

  /**
   * If true, the LB will be internal. Defaults to false.
   *
   * @default false.
   * @schema LbSpecForProvider#internal
   */
  readonly internal?: boolean;

  /**
   * The type of IP addresses used by the subnets for your load balancer. The possible values are ipv4 and dualstack.
   *
   * @schema LbSpecForProvider#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * The type of load balancer to create. Possible values are application, gateway, or network. The default value is application.
   *
   * @schema LbSpecForProvider#loadBalancerType
   */
  readonly loadBalancerType?: string;

  /**
   * The name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
   *
   * @schema LbSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Indicates whether the Application Load Balancer should preserve the Host header in the HTTP request and send it to the target without any change. Defaults to false.
   *
   * @default false.
   * @schema LbSpecForProvider#preserveHostHeader
   */
  readonly preserveHostHeader?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LbSpecForProvider#region
   */
  readonly region: string;

  /**
   * References to SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema LbSpecForProvider#securityGroupRefs
   */
  readonly securityGroupRefs?: LbSpecForProviderSecurityGroupRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema LbSpecForProvider#securityGroupSelector
   */
  readonly securityGroupSelector?: LbSpecForProviderSecurityGroupSelector;

  /**
   * A list of security group IDs to assign to the LB. Only valid for Load Balancers of type application.
   *
   * @schema LbSpecForProvider#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * A subnet mapping block as documented below.
   *
   * @schema LbSpecForProvider#subnetMapping
   */
  readonly subnetMapping?: LbSpecForProviderSubnetMapping[];

  /**
   * References to Subnet in ec2 to populate subnets.
   *
   * @schema LbSpecForProvider#subnetRefs
   */
  readonly subnetRefs?: LbSpecForProviderSubnetRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnets.
   *
   * @schema LbSpecForProvider#subnetSelector
   */
  readonly subnetSelector?: LbSpecForProviderSubnetSelector;

  /**
   * A list of subnet IDs to attach to the LB. Subnets cannot be updated for Load Balancers of type network. Changing this value for load balancers of type network will force a recreation of the resource.
   *
   * @schema LbSpecForProvider#subnets
   */
  readonly subnets?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema LbSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Determines how the load balancer modifies the X-Forwarded-For header in the HTTP request before sending the request to the target. The possible values are append, preserve, and remove. Only valid for Load Balancers of type application. The default is append.
   *
   * @schema LbSpecForProvider#xffHeaderProcessingMode
   */
  readonly xffHeaderProcessingMode?: string;

}

/**
 * Converts an object of type 'LbSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProvider(obj: LbSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessLogs': obj.accessLogs?.map(y => toJson_LbSpecForProviderAccessLogs(y)),
    'customerOwnedIpv4Pool': obj.customerOwnedIpv4Pool,
    'desyncMitigationMode': obj.desyncMitigationMode,
    'dropInvalidHeaderFields': obj.dropInvalidHeaderFields,
    'enableCrossZoneLoadBalancing': obj.enableCrossZoneLoadBalancing,
    'enableDeletionProtection': obj.enableDeletionProtection,
    'enableHttp2': obj.enableHttp2,
    'enableTlsVersionAndCipherSuiteHeaders': obj.enableTlsVersionAndCipherSuiteHeaders,
    'enableWafFailOpen': obj.enableWafFailOpen,
    'enableXffClientPort': obj.enableXffClientPort,
    'idleTimeout': obj.idleTimeout,
    'internal': obj.internal,
    'ipAddressType': obj.ipAddressType,
    'loadBalancerType': obj.loadBalancerType,
    'name': obj.name,
    'preserveHostHeader': obj.preserveHostHeader,
    'region': obj.region,
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_LbSpecForProviderSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_LbSpecForProviderSecurityGroupSelector(obj.securityGroupSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnetMapping': obj.subnetMapping?.map(y => toJson_LbSpecForProviderSubnetMapping(y)),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_LbSpecForProviderSubnetRefs(y)),
    'subnetSelector': toJson_LbSpecForProviderSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'xffHeaderProcessingMode': obj.xffHeaderProcessingMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbSpecManagementPolicy
 */
export enum LbSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LbSpecProviderConfigRef
 */
export interface LbSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbSpecProviderConfigRef#policy
   */
  readonly policy?: LbSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LbSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecProviderConfigRef(obj: LbSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LbSpecProviderRef
 */
export interface LbSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbSpecProviderRef#policy
   */
  readonly policy?: LbSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LbSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecProviderRef(obj: LbSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LbSpecPublishConnectionDetailsTo
 */
export interface LbSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LbSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LbSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LbSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LbSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LbSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LbSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecPublishConnectionDetailsTo(obj: LbSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LbSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LbSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LbSpecWriteConnectionSecretToRef
 */
export interface LbSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LbSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecWriteConnectionSecretToRef(obj: LbSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbSpecForProviderAccessLogs
 */
export interface LbSpecForProviderAccessLogs {
  /**
   * The S3 bucket name to store the logs in.
   *
   * @schema LbSpecForProviderAccessLogs#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema LbSpecForProviderAccessLogs#bucketRef
   */
  readonly bucketRef?: LbSpecForProviderAccessLogsBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema LbSpecForProviderAccessLogs#bucketSelector
   */
  readonly bucketSelector?: LbSpecForProviderAccessLogsBucketSelector;

  /**
   * Boolean to enable / disable access_logs. Defaults to false, even when bucket is specified.
   *
   * @default false, even when bucket is specified.
   * @schema LbSpecForProviderAccessLogs#enabled
   */
  readonly enabled?: boolean;

  /**
   * The S3 bucket prefix. Logs are stored in the root if not configured.
   *
   * @schema LbSpecForProviderAccessLogs#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'LbSpecForProviderAccessLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderAccessLogs(obj: LbSpecForProviderAccessLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_LbSpecForProviderAccessLogsBucketRef(obj.bucketRef),
    'bucketSelector': toJson_LbSpecForProviderAccessLogsBucketSelector(obj.bucketSelector),
    'enabled': obj.enabled,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema LbSpecForProviderSecurityGroupRefs
 */
export interface LbSpecForProviderSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema LbSpecForProviderSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbSpecForProviderSecurityGroupRefs#policy
   */
  readonly policy?: LbSpecForProviderSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSecurityGroupRefs(obj: LbSpecForProviderSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbSpecForProviderSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
 *
 * @schema LbSpecForProviderSecurityGroupSelector
 */
export interface LbSpecForProviderSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbSpecForProviderSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbSpecForProviderSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbSpecForProviderSecurityGroupSelector#policy
   */
  readonly policy?: LbSpecForProviderSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSecurityGroupSelector(obj: LbSpecForProviderSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbSpecForProviderSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbSpecForProviderSubnetMapping
 */
export interface LbSpecForProviderSubnetMapping {
  /**
   * The allocation ID of the Elastic IP address for an internet-facing load balancer.
   *
   * @schema LbSpecForProviderSubnetMapping#allocationId
   */
  readonly allocationId?: string;

  /**
   * The IPv6 address. You associate IPv6 CIDR blocks with your VPC and choose the subnets where you launch both internet-facing and internal Application Load Balancers or Network Load Balancers.
   *
   * @schema LbSpecForProviderSubnetMapping#ipv6Address
   */
  readonly ipv6Address?: string;

  /**
   * The private IPv4 address for an internal load balancer.
   *
   * @schema LbSpecForProviderSubnetMapping#privateIpv4Address
   */
  readonly privateIpv4Address?: string;

  /**
   * ID of the subnet of which to attach to the load balancer. You can specify only one subnet per Availability Zone.
   *
   * @schema LbSpecForProviderSubnetMapping#subnetId
   */
  readonly subnetId?: string;

  /**
   * Reference to a Subnet in ec2 to populate subnetId.
   *
   * @schema LbSpecForProviderSubnetMapping#subnetIdRef
   */
  readonly subnetIdRef?: LbSpecForProviderSubnetMappingSubnetIdRef;

  /**
   * Selector for a Subnet in ec2 to populate subnetId.
   *
   * @schema LbSpecForProviderSubnetMapping#subnetIdSelector
   */
  readonly subnetIdSelector?: LbSpecForProviderSubnetMappingSubnetIdSelector;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetMapping' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetMapping(obj: LbSpecForProviderSubnetMapping | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocationId': obj.allocationId,
    'ipv6Address': obj.ipv6Address,
    'privateIpv4Address': obj.privateIpv4Address,
    'subnetId': obj.subnetId,
    'subnetIdRef': toJson_LbSpecForProviderSubnetMappingSubnetIdRef(obj.subnetIdRef),
    'subnetIdSelector': toJson_LbSpecForProviderSubnetMappingSubnetIdSelector(obj.subnetIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema LbSpecForProviderSubnetRefs
 */
export interface LbSpecForProviderSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema LbSpecForProviderSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbSpecForProviderSubnetRefs#policy
   */
  readonly policy?: LbSpecForProviderSubnetRefsPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetRefs(obj: LbSpecForProviderSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbSpecForProviderSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnets.
 *
 * @schema LbSpecForProviderSubnetSelector
 */
export interface LbSpecForProviderSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbSpecForProviderSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbSpecForProviderSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbSpecForProviderSubnetSelector#policy
   */
  readonly policy?: LbSpecForProviderSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetSelector(obj: LbSpecForProviderSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbSpecForProviderSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbSpecProviderConfigRefPolicy
 */
export interface LbSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LbSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LbSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecProviderConfigRefPolicy(obj: LbSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbSpecProviderRefPolicy
 */
export interface LbSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LbSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LbSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecProviderRefPolicy(obj: LbSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LbSpecPublishConnectionDetailsToConfigRef
 */
export interface LbSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LbSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LbSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecPublishConnectionDetailsToConfigRef(obj: LbSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LbSpecPublishConnectionDetailsToMetadata
 */
export interface LbSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LbSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LbSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecPublishConnectionDetailsToMetadata(obj: LbSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema LbSpecForProviderAccessLogsBucketRef
 */
export interface LbSpecForProviderAccessLogsBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbSpecForProviderAccessLogsBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbSpecForProviderAccessLogsBucketRef#policy
   */
  readonly policy?: LbSpecForProviderAccessLogsBucketRefPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderAccessLogsBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderAccessLogsBucketRef(obj: LbSpecForProviderAccessLogsBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbSpecForProviderAccessLogsBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema LbSpecForProviderAccessLogsBucketSelector
 */
export interface LbSpecForProviderAccessLogsBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbSpecForProviderAccessLogsBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbSpecForProviderAccessLogsBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbSpecForProviderAccessLogsBucketSelector#policy
   */
  readonly policy?: LbSpecForProviderAccessLogsBucketSelectorPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderAccessLogsBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderAccessLogsBucketSelector(obj: LbSpecForProviderAccessLogsBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbSpecForProviderAccessLogsBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbSpecForProviderSecurityGroupRefsPolicy
 */
export interface LbSpecForProviderSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSecurityGroupRefsPolicy(obj: LbSpecForProviderSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbSpecForProviderSecurityGroupSelectorPolicy
 */
export interface LbSpecForProviderSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSecurityGroupSelectorPolicy(obj: LbSpecForProviderSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Subnet in ec2 to populate subnetId.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdRef
 */
export interface LbSpecForProviderSubnetMappingSubnetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdRef#policy
   */
  readonly policy?: LbSpecForProviderSubnetMappingSubnetIdRefPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetMappingSubnetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetMappingSubnetIdRef(obj: LbSpecForProviderSubnetMappingSubnetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbSpecForProviderSubnetMappingSubnetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Subnet in ec2 to populate subnetId.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdSelector
 */
export interface LbSpecForProviderSubnetMappingSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdSelector#policy
   */
  readonly policy?: LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetMappingSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetMappingSubnetIdSelector(obj: LbSpecForProviderSubnetMappingSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbSpecForProviderSubnetRefsPolicy
 */
export interface LbSpecForProviderSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderSubnetRefsPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderSubnetRefsPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetRefsPolicy(obj: LbSpecForProviderSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbSpecForProviderSubnetSelectorPolicy
 */
export interface LbSpecForProviderSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderSubnetSelectorPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderSubnetSelectorPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetSelectorPolicy(obj: LbSpecForProviderSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecProviderConfigRefPolicyResolution
 */
export enum LbSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecProviderConfigRefPolicyResolve
 */
export enum LbSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecProviderRefPolicyResolution
 */
export enum LbSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecProviderRefPolicyResolve
 */
export enum LbSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LbSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LbSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LbSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecPublishConnectionDetailsToConfigRefPolicy(obj: LbSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbSpecForProviderAccessLogsBucketRefPolicy
 */
export interface LbSpecForProviderAccessLogsBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderAccessLogsBucketRefPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderAccessLogsBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderAccessLogsBucketRefPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderAccessLogsBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderAccessLogsBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderAccessLogsBucketRefPolicy(obj: LbSpecForProviderAccessLogsBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbSpecForProviderAccessLogsBucketSelectorPolicy
 */
export interface LbSpecForProviderAccessLogsBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderAccessLogsBucketSelectorPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderAccessLogsBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderAccessLogsBucketSelectorPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderAccessLogsBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderAccessLogsBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderAccessLogsBucketSelectorPolicy(obj: LbSpecForProviderAccessLogsBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderSecurityGroupRefsPolicyResolution
 */
export enum LbSpecForProviderSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderSecurityGroupRefsPolicyResolve
 */
export enum LbSpecForProviderSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderSecurityGroupSelectorPolicyResolution
 */
export enum LbSpecForProviderSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderSecurityGroupSelectorPolicyResolve
 */
export enum LbSpecForProviderSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdRefPolicy
 */
export interface LbSpecForProviderSubnetMappingSubnetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdRefPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderSubnetMappingSubnetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdRefPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderSubnetMappingSubnetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetMappingSubnetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetMappingSubnetIdRefPolicy(obj: LbSpecForProviderSubnetMappingSubnetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy
 */
export interface LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: LbSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: LbSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy(obj: LbSpecForProviderSubnetMappingSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderSubnetRefsPolicyResolution
 */
export enum LbSpecForProviderSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderSubnetRefsPolicyResolve
 */
export enum LbSpecForProviderSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderSubnetSelectorPolicyResolution
 */
export enum LbSpecForProviderSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderSubnetSelectorPolicyResolve
 */
export enum LbSpecForProviderSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LbSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LbSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderAccessLogsBucketRefPolicyResolution
 */
export enum LbSpecForProviderAccessLogsBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderAccessLogsBucketRefPolicyResolve
 */
export enum LbSpecForProviderAccessLogsBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderAccessLogsBucketSelectorPolicyResolution
 */
export enum LbSpecForProviderAccessLogsBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderAccessLogsBucketSelectorPolicyResolve
 */
export enum LbSpecForProviderAccessLogsBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdRefPolicyResolution
 */
export enum LbSpecForProviderSubnetMappingSubnetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdRefPolicyResolve
 */
export enum LbSpecForProviderSubnetMappingSubnetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution
 */
export enum LbSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve
 */
export enum LbSpecForProviderSubnetMappingSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LBListener is the Schema for the LBListeners API. Provides a Load Balancer Listener resource.
 *
 * @schema LBListener
 */
export class LbListener extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LBListener"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.upbound.io/v1beta1',
    kind: 'LBListener',
  }

  /**
   * Renders a Kubernetes manifest for "LBListener".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LbListenerProps): any {
    return {
      ...LbListener.GVK,
      ...toJson_LbListenerProps(props),
    };
  }

  /**
   * Defines a "LBListener" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LbListenerProps) {
    super(scope, id, {
      ...LbListener.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LbListener.GVK,
      ...toJson_LbListenerProps(resolved),
    };
  }
}

/**
 * LBListener is the Schema for the LBListeners API. Provides a Load Balancer Listener resource.
 *
 * @schema LBListener
 */
export interface LbListenerProps {
  /**
   * @schema LBListener#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LBListenerSpec defines the desired state of LBListener
   *
   * @schema LBListener#spec
   */
  readonly spec: LbListenerSpec;

}

/**
 * Converts an object of type 'LbListenerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerProps(obj: LbListenerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LbListenerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LBListenerSpec defines the desired state of LBListener
 *
 * @schema LbListenerSpec
 */
export interface LbListenerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbListenerSpec#deletionPolicy
   */
  readonly deletionPolicy?: LbListenerSpecDeletionPolicy;

  /**
   * @schema LbListenerSpec#forProvider
   */
  readonly forProvider: LbListenerSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbListenerSpec#managementPolicy
   */
  readonly managementPolicy?: LbListenerSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LbListenerSpec#providerConfigRef
   */
  readonly providerConfigRef?: LbListenerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LbListenerSpec#providerRef
   */
  readonly providerRef?: LbListenerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LbListenerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LbListenerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LbListenerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LbListenerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LbListenerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpec(obj: LbListenerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LbListenerSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LbListenerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LbListenerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LbListenerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LbListenerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbListenerSpecDeletionPolicy
 */
export enum LbListenerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LbListenerSpecForProvider
 */
export interface LbListenerSpecForProvider {
  /**
   * Name of the Application-Layer Protocol Negotiation (ALPN) policy. Can be set if protocol is TLS. Valid values are HTTP1Only, HTTP2Only, HTTP2Optional, HTTP2Preferred, and None.
   *
   * @schema LbListenerSpecForProvider#alpnPolicy
   */
  readonly alpnPolicy?: string;

  /**
   * ARN of the default SSL server certificate. Exactly one certificate is required if the protocol is HTTPS. For adding additional SSL certificates, see the aws_lb_listener_certificate resource.
   *
   * @schema LbListenerSpecForProvider#certificateArn
   */
  readonly certificateArn?: string;

  /**
   * Configuration block for default actions. Detailed below.
   *
   * @schema LbListenerSpecForProvider#defaultAction
   */
  readonly defaultAction?: LbListenerSpecForProviderDefaultAction[];

  /**
   * ARN of the load balancer.
   *
   * @schema LbListenerSpecForProvider#loadBalancerArn
   */
  readonly loadBalancerArn?: string;

  /**
   * Reference to a LB to populate loadBalancerArn.
   *
   * @schema LbListenerSpecForProvider#loadBalancerArnRef
   */
  readonly loadBalancerArnRef?: LbListenerSpecForProviderLoadBalancerArnRef;

  /**
   * Selector for a LB to populate loadBalancerArn.
   *
   * @schema LbListenerSpecForProvider#loadBalancerArnSelector
   */
  readonly loadBalancerArnSelector?: LbListenerSpecForProviderLoadBalancerArnSelector;

  /**
   * Port on which the load balancer is listening. Not valid for Gateway Load Balancers.
   *
   * @schema LbListenerSpecForProvider#port
   */
  readonly port?: number;

  /**
   * Protocol for connections from clients to the load balancer. For Application Load Balancers, valid values are HTTP and HTTPS, with a default of HTTP. For Network Load Balancers, valid values are TCP, TLS, UDP, and TCP_UDP. Not valid to use UDP or TCP_UDP if dual-stack mode is enabled. Not valid for Gateway Load Balancers.
   *
   * @schema LbListenerSpecForProvider#protocol
   */
  readonly protocol?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LbListenerSpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the SSL Policy for the listener. Required if protocol is HTTPS or TLS.
   *
   * @schema LbListenerSpecForProvider#sslPolicy
   */
  readonly sslPolicy?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LbListenerSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LbListenerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProvider(obj: LbListenerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alpnPolicy': obj.alpnPolicy,
    'certificateArn': obj.certificateArn,
    'defaultAction': obj.defaultAction?.map(y => toJson_LbListenerSpecForProviderDefaultAction(y)),
    'loadBalancerArn': obj.loadBalancerArn,
    'loadBalancerArnRef': toJson_LbListenerSpecForProviderLoadBalancerArnRef(obj.loadBalancerArnRef),
    'loadBalancerArnSelector': toJson_LbListenerSpecForProviderLoadBalancerArnSelector(obj.loadBalancerArnSelector),
    'port': obj.port,
    'protocol': obj.protocol,
    'region': obj.region,
    'sslPolicy': obj.sslPolicy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbListenerSpecManagementPolicy
 */
export enum LbListenerSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LbListenerSpecProviderConfigRef
 */
export interface LbListenerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerSpecProviderConfigRef#policy
   */
  readonly policy?: LbListenerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecProviderConfigRef(obj: LbListenerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LbListenerSpecProviderRef
 */
export interface LbListenerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerSpecProviderRef#policy
   */
  readonly policy?: LbListenerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecProviderRef(obj: LbListenerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LbListenerSpecPublishConnectionDetailsTo
 */
export interface LbListenerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LbListenerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LbListenerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LbListenerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LbListenerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LbListenerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LbListenerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecPublishConnectionDetailsTo(obj: LbListenerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LbListenerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LbListenerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LbListenerSpecWriteConnectionSecretToRef
 */
export interface LbListenerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LbListenerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbListenerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbListenerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecWriteConnectionSecretToRef(obj: LbListenerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultAction
 */
export interface LbListenerSpecForProviderDefaultAction {
  /**
   * Configuration block for using Amazon Cognito to authenticate users. Specify only when type is authenticate-cognito. Detailed below.
   *
   * @schema LbListenerSpecForProviderDefaultAction#authenticateCognito
   */
  readonly authenticateCognito?: LbListenerSpecForProviderDefaultActionAuthenticateCognito[];

  /**
   * Configuration block for an identity provider that is compliant with OpenID Connect (OIDC). Specify only when type is authenticate-oidc. Detailed below.
   *
   * @schema LbListenerSpecForProviderDefaultAction#authenticateOidc
   */
  readonly authenticateOidc?: LbListenerSpecForProviderDefaultActionAuthenticateOidc[];

  /**
   * Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
   *
   * @schema LbListenerSpecForProviderDefaultAction#fixedResponse
   */
  readonly fixedResponse?: LbListenerSpecForProviderDefaultActionFixedResponse[];

  /**
   * Configuration block for creating an action that distributes requests among one or more target groups. Specify only if type is forward. If you specify both forward block and target_group_arn attribute, you can specify only one target group using forward and it must be the same target group specified in target_group_arn. Detailed below.
   *
   * @schema LbListenerSpecForProviderDefaultAction#forward
   */
  readonly forward?: LbListenerSpecForProviderDefaultActionForward[];

  /**
   * Order for the action. This value is required for rules with multiple actions. The action with the lowest value for order is performed first. Valid values are between 1 and 50000.
   *
   * @schema LbListenerSpecForProviderDefaultAction#order
   */
  readonly order?: number;

  /**
   * Configuration block for creating a redirect action. Required if type is redirect. Detailed below.
   *
   * @schema LbListenerSpecForProviderDefaultAction#redirect
   */
  readonly redirect?: LbListenerSpecForProviderDefaultActionRedirect[];

  /**
   * ARN of the Target Group to which to route traffic. Specify only if type is forward and you want to route to a single target group. To route to one or more target groups, use a forward block instead.
   *
   * @schema LbListenerSpecForProviderDefaultAction#targetGroupArn
   */
  readonly targetGroupArn?: string;

  /**
   * Reference to a LBTargetGroup to populate targetGroupArn.
   *
   * @schema LbListenerSpecForProviderDefaultAction#targetGroupArnRef
   */
  readonly targetGroupArnRef?: LbListenerSpecForProviderDefaultActionTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup to populate targetGroupArn.
   *
   * @schema LbListenerSpecForProviderDefaultAction#targetGroupArnSelector
   */
  readonly targetGroupArnSelector?: LbListenerSpecForProviderDefaultActionTargetGroupArnSelector;

  /**
   * Type of routing action. Valid values are forward, redirect, fixed-response, authenticate-cognito and authenticate-oidc.
   *
   * @schema LbListenerSpecForProviderDefaultAction#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultAction(obj: LbListenerSpecForProviderDefaultAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticateCognito': obj.authenticateCognito?.map(y => toJson_LbListenerSpecForProviderDefaultActionAuthenticateCognito(y)),
    'authenticateOidc': obj.authenticateOidc?.map(y => toJson_LbListenerSpecForProviderDefaultActionAuthenticateOidc(y)),
    'fixedResponse': obj.fixedResponse?.map(y => toJson_LbListenerSpecForProviderDefaultActionFixedResponse(y)),
    'forward': obj.forward?.map(y => toJson_LbListenerSpecForProviderDefaultActionForward(y)),
    'order': obj.order,
    'redirect': obj.redirect?.map(y => toJson_LbListenerSpecForProviderDefaultActionRedirect(y)),
    'targetGroupArn': obj.targetGroupArn,
    'targetGroupArnRef': toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupArnSelector': toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnSelector(obj.targetGroupArnSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LB to populate loadBalancerArn.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnRef
 */
export interface LbListenerSpecForProviderLoadBalancerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnRef#policy
   */
  readonly policy?: LbListenerSpecForProviderLoadBalancerArnRefPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderLoadBalancerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderLoadBalancerArnRef(obj: LbListenerSpecForProviderLoadBalancerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerSpecForProviderLoadBalancerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LB to populate loadBalancerArn.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnSelector
 */
export interface LbListenerSpecForProviderLoadBalancerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnSelector#policy
   */
  readonly policy?: LbListenerSpecForProviderLoadBalancerArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderLoadBalancerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderLoadBalancerArnSelector(obj: LbListenerSpecForProviderLoadBalancerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerSpecForProviderLoadBalancerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerSpecProviderConfigRefPolicy
 */
export interface LbListenerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LbListenerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LbListenerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecProviderConfigRefPolicy(obj: LbListenerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerSpecProviderRefPolicy
 */
export interface LbListenerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LbListenerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LbListenerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecProviderRefPolicy(obj: LbListenerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LbListenerSpecPublishConnectionDetailsToConfigRef
 */
export interface LbListenerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LbListenerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecPublishConnectionDetailsToConfigRef(obj: LbListenerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LbListenerSpecPublishConnectionDetailsToMetadata
 */
export interface LbListenerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbListenerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbListenerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LbListenerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LbListenerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecPublishConnectionDetailsToMetadata(obj: LbListenerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito
 */
export interface LbListenerSpecForProviderDefaultActionAuthenticateCognito {
  /**
   * Query parameters to include in the redirect request to the authorization endpoint. Max: 10. Detailed below.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#authenticationRequestExtraParams
   */
  readonly authenticationRequestExtraParams?: { [key: string]: string };

  /**
   * Behavior if the user is not authenticated. Valid values are deny, allow and authenticate.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#onUnauthenticatedRequest
   */
  readonly onUnauthenticatedRequest?: string;

  /**
   * Set of user claims to be requested from the IdP.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#scope
   */
  readonly scope?: string;

  /**
   * Name of the cookie used to maintain session information.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#sessionCookieName
   */
  readonly sessionCookieName?: string;

  /**
   * Maximum duration of the authentication session, in seconds.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#sessionTimeout
   */
  readonly sessionTimeout?: number;

  /**
   * ARN of the Cognito user pool.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#userPoolArn
   */
  readonly userPoolArn: string;

  /**
   * ID of the Cognito user pool client.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#userPoolClientId
   */
  readonly userPoolClientId: string;

  /**
   * Domain prefix or fully-qualified domain name of the Cognito user pool.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateCognito#userPoolDomain
   */
  readonly userPoolDomain: string;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionAuthenticateCognito' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionAuthenticateCognito(obj: LbListenerSpecForProviderDefaultActionAuthenticateCognito | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationRequestExtraParams': ((obj.authenticationRequestExtraParams) === undefined) ? undefined : (Object.entries(obj.authenticationRequestExtraParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'onUnauthenticatedRequest': obj.onUnauthenticatedRequest,
    'scope': obj.scope,
    'sessionCookieName': obj.sessionCookieName,
    'sessionTimeout': obj.sessionTimeout,
    'userPoolArn': obj.userPoolArn,
    'userPoolClientId': obj.userPoolClientId,
    'userPoolDomain': obj.userPoolDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc
 */
export interface LbListenerSpecForProviderDefaultActionAuthenticateOidc {
  /**
   * Query parameters to include in the redirect request to the authorization endpoint. Max: 10.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#authenticationRequestExtraParams
   */
  readonly authenticationRequestExtraParams?: { [key: string]: string };

  /**
   * Authorization endpoint of the IdP.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#authorizationEndpoint
   */
  readonly authorizationEndpoint: string;

  /**
   * OAuth 2.0 client identifier.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#clientId
   */
  readonly clientId: string;

  /**
   * OAuth 2.0 client secret.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef;

  /**
   * OIDC issuer identifier of the IdP.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#issuer
   */
  readonly issuer: string;

  /**
   * Behavior if the user is not authenticated. Valid values: deny, allow and authenticate
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#onUnauthenticatedRequest
   */
  readonly onUnauthenticatedRequest?: string;

  /**
   * Set of user claims to be requested from the IdP.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#scope
   */
  readonly scope?: string;

  /**
   * Name of the cookie used to maintain session information.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#sessionCookieName
   */
  readonly sessionCookieName?: string;

  /**
   * Maximum duration of the authentication session, in seconds.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#sessionTimeout
   */
  readonly sessionTimeout?: number;

  /**
   * Token endpoint of the IdP.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#tokenEndpoint
   */
  readonly tokenEndpoint: string;

  /**
   * User info endpoint of the IdP.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidc#userInfoEndpoint
   */
  readonly userInfoEndpoint: string;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionAuthenticateOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionAuthenticateOidc(obj: LbListenerSpecForProviderDefaultActionAuthenticateOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationRequestExtraParams': ((obj.authenticationRequestExtraParams) === undefined) ? undefined : (Object.entries(obj.authenticationRequestExtraParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'authorizationEndpoint': obj.authorizationEndpoint,
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef(obj.clientSecretSecretRef),
    'issuer': obj.issuer,
    'onUnauthenticatedRequest': obj.onUnauthenticatedRequest,
    'scope': obj.scope,
    'sessionCookieName': obj.sessionCookieName,
    'sessionTimeout': obj.sessionTimeout,
    'tokenEndpoint': obj.tokenEndpoint,
    'userInfoEndpoint': obj.userInfoEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultActionFixedResponse
 */
export interface LbListenerSpecForProviderDefaultActionFixedResponse {
  /**
   * Content type. Valid values are text/plain, text/css, text/html, application/javascript and application/json.
   *
   * @schema LbListenerSpecForProviderDefaultActionFixedResponse#contentType
   */
  readonly contentType: string;

  /**
   * Message body.
   *
   * @schema LbListenerSpecForProviderDefaultActionFixedResponse#messageBody
   */
  readonly messageBody?: string;

  /**
   * HTTP response code. Valid values are 2XX, 4XX, or 5XX.
   *
   * @schema LbListenerSpecForProviderDefaultActionFixedResponse#statusCode
   */
  readonly statusCode?: string;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionFixedResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionFixedResponse(obj: LbListenerSpecForProviderDefaultActionFixedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'messageBody': obj.messageBody,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultActionForward
 */
export interface LbListenerSpecForProviderDefaultActionForward {
  /**
   * Configuration block for target group stickiness for the rule. Detailed below.
   *
   * @schema LbListenerSpecForProviderDefaultActionForward#stickiness
   */
  readonly stickiness?: LbListenerSpecForProviderDefaultActionForwardStickiness[];

  /**
   * Set of 1-5 target group blocks. Detailed below.
   *
   * @schema LbListenerSpecForProviderDefaultActionForward#targetGroup
   */
  readonly targetGroup: LbListenerSpecForProviderDefaultActionForwardTargetGroup[];

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionForward' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionForward(obj: LbListenerSpecForProviderDefaultActionForward | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stickiness': obj.stickiness?.map(y => toJson_LbListenerSpecForProviderDefaultActionForwardStickiness(y)),
    'targetGroup': obj.targetGroup?.map(y => toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroup(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultActionRedirect
 */
export interface LbListenerSpecForProviderDefaultActionRedirect {
  /**
   * Hostname. This component is not percent-encoded. The hostname can contain #{host}. Defaults to #{host}.
   *
   * @default host}.
   * @schema LbListenerSpecForProviderDefaultActionRedirect#host
   */
  readonly host?: string;

  /**
   * Absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to /#{path}.
   *
   * @default path}.
   * @schema LbListenerSpecForProviderDefaultActionRedirect#path
   */
  readonly path?: string;

  /**
   * Port. Specify a value from 1 to 65535 or #{port}. Defaults to #{port}.
   *
   * @default port}.
   * @schema LbListenerSpecForProviderDefaultActionRedirect#port
   */
  readonly port?: string;

  /**
   * Protocol. Valid values are HTTP, HTTPS, or #{protocol}. Defaults to #{protocol}.
   *
   * @default protocol}.
   * @schema LbListenerSpecForProviderDefaultActionRedirect#protocol
   */
  readonly protocol?: string;

  /**
   * Query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to #{query}.
   *
   * @default query}.
   * @schema LbListenerSpecForProviderDefaultActionRedirect#query
   */
  readonly query?: string;

  /**
   * HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
   *
   * @schema LbListenerSpecForProviderDefaultActionRedirect#statusCode
   */
  readonly statusCode: string;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionRedirect(obj: LbListenerSpecForProviderDefaultActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'query': obj.query,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup to populate targetGroupArn.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRef
 */
export interface LbListenerSpecForProviderDefaultActionTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRef#policy
   */
  readonly policy?: LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnRef(obj: LbListenerSpecForProviderDefaultActionTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup to populate targetGroupArn.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelector
 */
export interface LbListenerSpecForProviderDefaultActionTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelector#policy
   */
  readonly policy?: LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnSelector(obj: LbListenerSpecForProviderDefaultActionTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnRefPolicy
 */
export interface LbListenerSpecForProviderLoadBalancerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnRefPolicy#resolution
   */
  readonly resolution?: LbListenerSpecForProviderLoadBalancerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnRefPolicy#resolve
   */
  readonly resolve?: LbListenerSpecForProviderLoadBalancerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderLoadBalancerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderLoadBalancerArnRefPolicy(obj: LbListenerSpecForProviderLoadBalancerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnSelectorPolicy
 */
export interface LbListenerSpecForProviderLoadBalancerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerSpecForProviderLoadBalancerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecForProviderLoadBalancerArnSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerSpecForProviderLoadBalancerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderLoadBalancerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderLoadBalancerArnSelectorPolicy(obj: LbListenerSpecForProviderLoadBalancerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecProviderConfigRefPolicyResolution
 */
export enum LbListenerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecProviderConfigRefPolicyResolve
 */
export enum LbListenerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecProviderRefPolicyResolution
 */
export enum LbListenerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecProviderRefPolicyResolve
 */
export enum LbListenerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbListenerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LbListenerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LbListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LbListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecPublishConnectionDetailsToConfigRefPolicy(obj: LbListenerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OAuth 2.0 client secret.
 *
 * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef
 */
export interface LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef(obj: LbListenerSpecForProviderDefaultActionAuthenticateOidcClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultActionForwardStickiness
 */
export interface LbListenerSpecForProviderDefaultActionForwardStickiness {
  /**
   * Time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardStickiness#duration
   */
  readonly duration: number;

  /**
   * Whether target group stickiness is enabled. Default is false.
   *
   * @default false.
   * @schema LbListenerSpecForProviderDefaultActionForwardStickiness#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionForwardStickiness' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionForwardStickiness(obj: LbListenerSpecForProviderDefaultActionForwardStickiness | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroup
 */
export interface LbListenerSpecForProviderDefaultActionForwardTargetGroup {
  /**
   * ARN of the target group.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroup#arn
   */
  readonly arn?: string;

  /**
   * Reference to a LBTargetGroup to populate arn.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroup#arnRef
   */
  readonly arnRef?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup to populate arn.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroup#arnSelector
   */
  readonly arnSelector?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector;

  /**
   * Weight. The range is 0 to 999.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroup#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionForwardTargetGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroup(obj: LbListenerSpecForProviderDefaultActionForwardTargetGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'arnRef': toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef(obj.arnRef),
    'arnSelector': toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector(obj.arnSelector),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy
 */
export interface LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy(obj: LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy
 */
export interface LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy(obj: LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnRefPolicyResolution
 */
export enum LbListenerSpecForProviderLoadBalancerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnRefPolicyResolve
 */
export enum LbListenerSpecForProviderLoadBalancerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnSelectorPolicyResolution
 */
export enum LbListenerSpecForProviderLoadBalancerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecForProviderLoadBalancerArnSelectorPolicyResolve
 */
export enum LbListenerSpecForProviderLoadBalancerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LbListenerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LbListenerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a LBTargetGroup to populate arn.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef
 */
export interface LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef#policy
   */
  readonly policy?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef(obj: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup to populate arn.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector
 */
export interface LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector#policy
   */
  readonly policy?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector(obj: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicyResolution
 */
export enum LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicyResolve
 */
export enum LbListenerSpecForProviderDefaultActionTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicyResolution
 */
export enum LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicyResolve
 */
export enum LbListenerSpecForProviderDefaultActionTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy
 */
export interface LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy(obj: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy
 */
export interface LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy(obj: LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicyResolution
 */
export enum LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicyResolve
 */
export enum LbListenerSpecForProviderDefaultActionForwardTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicyResolution
 */
export enum LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicyResolve
 */
export enum LbListenerSpecForProviderDefaultActionForwardTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LBListenerRule is the Schema for the LBListenerRules API. Provides a Load Balancer Listener Rule resource.
 *
 * @schema LBListenerRule
 */
export class LbListenerRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LBListenerRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.upbound.io/v1beta1',
    kind: 'LBListenerRule',
  }

  /**
   * Renders a Kubernetes manifest for "LBListenerRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LbListenerRuleProps): any {
    return {
      ...LbListenerRule.GVK,
      ...toJson_LbListenerRuleProps(props),
    };
  }

  /**
   * Defines a "LBListenerRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LbListenerRuleProps) {
    super(scope, id, {
      ...LbListenerRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LbListenerRule.GVK,
      ...toJson_LbListenerRuleProps(resolved),
    };
  }
}

/**
 * LBListenerRule is the Schema for the LBListenerRules API. Provides a Load Balancer Listener Rule resource.
 *
 * @schema LBListenerRule
 */
export interface LbListenerRuleProps {
  /**
   * @schema LBListenerRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LBListenerRuleSpec defines the desired state of LBListenerRule
   *
   * @schema LBListenerRule#spec
   */
  readonly spec: LbListenerRuleSpec;

}

/**
 * Converts an object of type 'LbListenerRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleProps(obj: LbListenerRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LbListenerRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LBListenerRuleSpec defines the desired state of LBListenerRule
 *
 * @schema LbListenerRuleSpec
 */
export interface LbListenerRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbListenerRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: LbListenerRuleSpecDeletionPolicy;

  /**
   * @schema LbListenerRuleSpec#forProvider
   */
  readonly forProvider: LbListenerRuleSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbListenerRuleSpec#managementPolicy
   */
  readonly managementPolicy?: LbListenerRuleSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LbListenerRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: LbListenerRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LbListenerRuleSpec#providerRef
   */
  readonly providerRef?: LbListenerRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LbListenerRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LbListenerRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LbListenerRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LbListenerRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LbListenerRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpec(obj: LbListenerRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LbListenerRuleSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LbListenerRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LbListenerRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LbListenerRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LbListenerRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbListenerRuleSpecDeletionPolicy
 */
export enum LbListenerRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LbListenerRuleSpecForProvider
 */
export interface LbListenerRuleSpecForProvider {
  /**
   * An Action block. Action blocks are documented below.
   *
   * @schema LbListenerRuleSpecForProvider#action
   */
  readonly action?: LbListenerRuleSpecForProviderAction[];

  /**
   * A Condition block. Multiple condition blocks of different types can be set and all must be satisfied for the rule to match. Condition blocks are documented below.
   *
   * @schema LbListenerRuleSpecForProvider#condition
   */
  readonly condition?: LbListenerRuleSpecForProviderCondition[];

  /**
   * The ARN of the listener to which to attach the rule.
   *
   * @schema LbListenerRuleSpecForProvider#listenerArn
   */
  readonly listenerArn?: string;

  /**
   * Reference to a LBListener in elbv2 to populate listenerArn.
   *
   * @schema LbListenerRuleSpecForProvider#listenerArnRef
   */
  readonly listenerArnRef?: LbListenerRuleSpecForProviderListenerArnRef;

  /**
   * Selector for a LBListener in elbv2 to populate listenerArn.
   *
   * @schema LbListenerRuleSpecForProvider#listenerArnSelector
   */
  readonly listenerArnSelector?: LbListenerRuleSpecForProviderListenerArnSelector;

  /**
   * The priority for the rule between 1 and 50000. Leaving it unset will automatically set the rule with next available priority after currently existing highest rule. A listener can't have multiple rules with the same priority.
   *
   * @schema LbListenerRuleSpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LbListenerRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LbListenerRuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProvider(obj: LbListenerRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_LbListenerRuleSpecForProviderAction(y)),
    'condition': obj.condition?.map(y => toJson_LbListenerRuleSpecForProviderCondition(y)),
    'listenerArn': obj.listenerArn,
    'listenerArnRef': toJson_LbListenerRuleSpecForProviderListenerArnRef(obj.listenerArnRef),
    'listenerArnSelector': toJson_LbListenerRuleSpecForProviderListenerArnSelector(obj.listenerArnSelector),
    'priority': obj.priority,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbListenerRuleSpecManagementPolicy
 */
export enum LbListenerRuleSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LbListenerRuleSpecProviderConfigRef
 */
export interface LbListenerRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecProviderConfigRef#policy
   */
  readonly policy?: LbListenerRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecProviderConfigRef(obj: LbListenerRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LbListenerRuleSpecProviderRef
 */
export interface LbListenerRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecProviderRef#policy
   */
  readonly policy?: LbListenerRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecProviderRef(obj: LbListenerRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LbListenerRuleSpecPublishConnectionDetailsTo
 */
export interface LbListenerRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LbListenerRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LbListenerRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecPublishConnectionDetailsTo(obj: LbListenerRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LbListenerRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LbListenerRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LbListenerRuleSpecWriteConnectionSecretToRef
 */
export interface LbListenerRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LbListenerRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbListenerRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecWriteConnectionSecretToRef(obj: LbListenerRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderAction
 */
export interface LbListenerRuleSpecForProviderAction {
  /**
   * Information for creating an authenticate action using Cognito. Required if type is authenticate-cognito.
   *
   * @schema LbListenerRuleSpecForProviderAction#authenticateCognito
   */
  readonly authenticateCognito?: LbListenerRuleSpecForProviderActionAuthenticateCognito[];

  /**
   * Information for creating an authenticate action using OIDC. Required if type is authenticate-oidc.
   *
   * @schema LbListenerRuleSpecForProviderAction#authenticateOidc
   */
  readonly authenticateOidc?: LbListenerRuleSpecForProviderActionAuthenticateOidc[];

  /**
   * Information for creating an action that returns a custom HTTP response. Required if type is fixed-response.
   *
   * @schema LbListenerRuleSpecForProviderAction#fixedResponse
   */
  readonly fixedResponse?: LbListenerRuleSpecForProviderActionFixedResponse[];

  /**
   * Information for creating an action that distributes requests among one or more target groups. Specify only if type is forward. If you specify both forward block and target_group_arn attribute, you can specify only one target group using forward and it must be the same target group specified in target_group_arn.
   *
   * @schema LbListenerRuleSpecForProviderAction#forward
   */
  readonly forward?: LbListenerRuleSpecForProviderActionForward[];

  /**
   * @schema LbListenerRuleSpecForProviderAction#order
   */
  readonly order?: number;

  /**
   * Information for creating a redirect action. Required if type is redirect.
   *
   * @schema LbListenerRuleSpecForProviderAction#redirect
   */
  readonly redirect?: LbListenerRuleSpecForProviderActionRedirect[];

  /**
   * The ARN of the Target Group to which to route traffic. Specify only if type is forward and you want to route to a single target group. To route to one or more target groups, use a forward block instead.
   *
   * @schema LbListenerRuleSpecForProviderAction#targetGroupArn
   */
  readonly targetGroupArn?: string;

  /**
   * Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
   *
   * @schema LbListenerRuleSpecForProviderAction#targetGroupArnRef
   */
  readonly targetGroupArnRef?: LbListenerRuleSpecForProviderActionTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
   *
   * @schema LbListenerRuleSpecForProviderAction#targetGroupArnSelector
   */
  readonly targetGroupArnSelector?: LbListenerRuleSpecForProviderActionTargetGroupArnSelector;

  /**
   * The type of routing action. Valid values are forward, redirect, fixed-response, authenticate-cognito and authenticate-oidc.
   *
   * @schema LbListenerRuleSpecForProviderAction#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderAction(obj: LbListenerRuleSpecForProviderAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticateCognito': obj.authenticateCognito?.map(y => toJson_LbListenerRuleSpecForProviderActionAuthenticateCognito(y)),
    'authenticateOidc': obj.authenticateOidc?.map(y => toJson_LbListenerRuleSpecForProviderActionAuthenticateOidc(y)),
    'fixedResponse': obj.fixedResponse?.map(y => toJson_LbListenerRuleSpecForProviderActionFixedResponse(y)),
    'forward': obj.forward?.map(y => toJson_LbListenerRuleSpecForProviderActionForward(y)),
    'order': obj.order,
    'redirect': obj.redirect?.map(y => toJson_LbListenerRuleSpecForProviderActionRedirect(y)),
    'targetGroupArn': obj.targetGroupArn,
    'targetGroupArnRef': toJson_LbListenerRuleSpecForProviderActionTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupArnSelector': toJson_LbListenerRuleSpecForProviderActionTargetGroupArnSelector(obj.targetGroupArnSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderCondition
 */
export interface LbListenerRuleSpecForProviderCondition {
  /**
   * Contains a single values item which is a list of host header patterns to match. The maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied.
   *
   * @schema LbListenerRuleSpecForProviderCondition#hostHeader
   */
  readonly hostHeader?: LbListenerRuleSpecForProviderConditionHostHeader[];

  /**
   * HTTP headers to match. HTTP Header block fields documented below.
   *
   * @schema LbListenerRuleSpecForProviderCondition#httpHeader
   */
  readonly httpHeader?: LbListenerRuleSpecForProviderConditionHttpHeader[];

  /**
   * Contains a single values item which is a list of HTTP request methods or verbs to match. Maximum size is 40 characters. Only allowed characters are A-Z, hyphen (-) and underscore (_). Comparison is case sensitive. Wildcards are not supported. Only one needs to match for the condition to be satisfied. AWS recommends that GET and HEAD requests are routed in the same way because the response to a HEAD request may be cached.
   *
   * @schema LbListenerRuleSpecForProviderCondition#httpRequestMethod
   */
  readonly httpRequestMethod?: LbListenerRuleSpecForProviderConditionHttpRequestMethod[];

  /**
   * Contains a single values item which is a list of path patterns to match against the request URL. Maximum size of each pattern is 128 characters. Comparison is case sensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). Only one pattern needs to match for the condition to be satisfied. Path pattern is compared only to the path of the URL, not to its query string. To compare against the query string, use a query_string condition.
   *
   * @schema LbListenerRuleSpecForProviderCondition#pathPattern
   */
  readonly pathPattern?: LbListenerRuleSpecForProviderConditionPathPattern[];

  /**
   * Query strings to match. Query String block fields documented below.
   *
   * @schema LbListenerRuleSpecForProviderCondition#queryString
   */
  readonly queryString?: LbListenerRuleSpecForProviderConditionQueryString[];

  /**
   * Contains a single values item which is a list of source IP CIDR notations to match. You can use both IPv4 and IPv6 addresses. Wildcards are not supported. Condition is satisfied if the source IP address of the request matches one of the CIDR blocks. Condition is not satisfied by the addresses in the X-Forwarded-For header, use http_header condition instead.
   *
   * @schema LbListenerRuleSpecForProviderCondition#sourceIp
   */
  readonly sourceIp?: LbListenerRuleSpecForProviderConditionSourceIp[];

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderCondition(obj: LbListenerRuleSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostHeader': obj.hostHeader?.map(y => toJson_LbListenerRuleSpecForProviderConditionHostHeader(y)),
    'httpHeader': obj.httpHeader?.map(y => toJson_LbListenerRuleSpecForProviderConditionHttpHeader(y)),
    'httpRequestMethod': obj.httpRequestMethod?.map(y => toJson_LbListenerRuleSpecForProviderConditionHttpRequestMethod(y)),
    'pathPattern': obj.pathPattern?.map(y => toJson_LbListenerRuleSpecForProviderConditionPathPattern(y)),
    'queryString': obj.queryString?.map(y => toJson_LbListenerRuleSpecForProviderConditionQueryString(y)),
    'sourceIp': obj.sourceIp?.map(y => toJson_LbListenerRuleSpecForProviderConditionSourceIp(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBListener in elbv2 to populate listenerArn.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnRef
 */
export interface LbListenerRuleSpecForProviderListenerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnRef#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderListenerArnRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderListenerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderListenerArnRef(obj: LbListenerRuleSpecForProviderListenerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecForProviderListenerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBListener in elbv2 to populate listenerArn.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnSelector
 */
export interface LbListenerRuleSpecForProviderListenerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnSelector#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderListenerArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderListenerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderListenerArnSelector(obj: LbListenerRuleSpecForProviderListenerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerRuleSpecForProviderListenerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecProviderConfigRefPolicy
 */
export interface LbListenerRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecProviderConfigRefPolicy(obj: LbListenerRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecProviderRefPolicy
 */
export interface LbListenerRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecProviderRefPolicy(obj: LbListenerRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface LbListenerRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecPublishConnectionDetailsToConfigRef(obj: LbListenerRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LbListenerRuleSpecPublishConnectionDetailsToMetadata
 */
export interface LbListenerRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecPublishConnectionDetailsToMetadata(obj: LbListenerRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognito {
  /**
   * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#authenticationRequestExtraParams
   */
  readonly authenticationRequestExtraParams?: { [key: string]: string };

  /**
   * The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#onUnauthenticatedRequest
   */
  readonly onUnauthenticatedRequest?: string;

  /**
   * The set of user claims to be requested from the IdP.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#scope
   */
  readonly scope?: string;

  /**
   * The name of the cookie used to maintain session information.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#sessionCookieName
   */
  readonly sessionCookieName?: string;

  /**
   * The maximum duration of the authentication session, in seconds.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#sessionTimeout
   */
  readonly sessionTimeout?: number;

  /**
   * The ARN of the Cognito user pool.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolArn
   */
  readonly userPoolArn?: string;

  /**
   * Reference to a UserPool in cognitoidp to populate userPoolArn.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolArnRef
   */
  readonly userPoolArnRef?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef;

  /**
   * Selector for a UserPool in cognitoidp to populate userPoolArn.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolArnSelector
   */
  readonly userPoolArnSelector?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector;

  /**
   * The ID of the Cognito user pool client.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolClientId
   */
  readonly userPoolClientId?: string;

  /**
   * Reference to a UserPoolClient in cognitoidp to populate userPoolClientId.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolClientIdRef
   */
  readonly userPoolClientIdRef?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef;

  /**
   * Selector for a UserPoolClient in cognitoidp to populate userPoolClientId.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolClientIdSelector
   */
  readonly userPoolClientIdSelector?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector;

  /**
   * The domain prefix or fully-qualified domain name of the Cognito user pool.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolDomain
   */
  readonly userPoolDomain?: string;

  /**
   * Reference to a UserPoolDomain in cognitoidp to populate userPoolDomain.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolDomainRef
   */
  readonly userPoolDomainRef?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef;

  /**
   * Selector for a UserPoolDomain in cognitoidp to populate userPoolDomain.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognito#userPoolDomainSelector
   */
  readonly userPoolDomainSelector?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognito' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognito(obj: LbListenerRuleSpecForProviderActionAuthenticateCognito | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationRequestExtraParams': ((obj.authenticationRequestExtraParams) === undefined) ? undefined : (Object.entries(obj.authenticationRequestExtraParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'onUnauthenticatedRequest': obj.onUnauthenticatedRequest,
    'scope': obj.scope,
    'sessionCookieName': obj.sessionCookieName,
    'sessionTimeout': obj.sessionTimeout,
    'userPoolArn': obj.userPoolArn,
    'userPoolArnRef': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef(obj.userPoolArnRef),
    'userPoolArnSelector': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector(obj.userPoolArnSelector),
    'userPoolClientId': obj.userPoolClientId,
    'userPoolClientIdRef': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef(obj.userPoolClientIdRef),
    'userPoolClientIdSelector': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector(obj.userPoolClientIdSelector),
    'userPoolDomain': obj.userPoolDomain,
    'userPoolDomainRef': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef(obj.userPoolDomainRef),
    'userPoolDomainSelector': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector(obj.userPoolDomainSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateOidc {
  /**
   * The query parameters to include in the redirect request to the authorization endpoint. Max: 10.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#authenticationRequestExtraParams
   */
  readonly authenticationRequestExtraParams?: { [key: string]: string };

  /**
   * The authorization endpoint of the IdP.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#authorizationEndpoint
   */
  readonly authorizationEndpoint: string;

  /**
   * The OAuth 2.0 client identifier.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#clientId
   */
  readonly clientId: string;

  /**
   * The OAuth 2.0 client secret.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef;

  /**
   * The OIDC issuer identifier of the IdP.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#issuer
   */
  readonly issuer: string;

  /**
   * The behavior if the user is not authenticated. Valid values: deny, allow and authenticate
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#onUnauthenticatedRequest
   */
  readonly onUnauthenticatedRequest?: string;

  /**
   * The set of user claims to be requested from the IdP.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#scope
   */
  readonly scope?: string;

  /**
   * The name of the cookie used to maintain session information.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#sessionCookieName
   */
  readonly sessionCookieName?: string;

  /**
   * The maximum duration of the authentication session, in seconds.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#sessionTimeout
   */
  readonly sessionTimeout?: number;

  /**
   * The token endpoint of the IdP.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#tokenEndpoint
   */
  readonly tokenEndpoint: string;

  /**
   * The user info endpoint of the IdP.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidc#userInfoEndpoint
   */
  readonly userInfoEndpoint: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateOidc(obj: LbListenerRuleSpecForProviderActionAuthenticateOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationRequestExtraParams': ((obj.authenticationRequestExtraParams) === undefined) ? undefined : (Object.entries(obj.authenticationRequestExtraParams).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'authorizationEndpoint': obj.authorizationEndpoint,
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef(obj.clientSecretSecretRef),
    'issuer': obj.issuer,
    'onUnauthenticatedRequest': obj.onUnauthenticatedRequest,
    'scope': obj.scope,
    'sessionCookieName': obj.sessionCookieName,
    'sessionTimeout': obj.sessionTimeout,
    'tokenEndpoint': obj.tokenEndpoint,
    'userInfoEndpoint': obj.userInfoEndpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderActionFixedResponse
 */
export interface LbListenerRuleSpecForProviderActionFixedResponse {
  /**
   * The content type. Valid values are text/plain, text/css, text/html, application/javascript and application/json.
   *
   * @schema LbListenerRuleSpecForProviderActionFixedResponse#contentType
   */
  readonly contentType: string;

  /**
   * The message body.
   *
   * @schema LbListenerRuleSpecForProviderActionFixedResponse#messageBody
   */
  readonly messageBody?: string;

  /**
   * The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
   *
   * @schema LbListenerRuleSpecForProviderActionFixedResponse#statusCode
   */
  readonly statusCode?: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionFixedResponse' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionFixedResponse(obj: LbListenerRuleSpecForProviderActionFixedResponse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'contentType': obj.contentType,
    'messageBody': obj.messageBody,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderActionForward
 */
export interface LbListenerRuleSpecForProviderActionForward {
  /**
   * The target group stickiness for the rule.
   *
   * @schema LbListenerRuleSpecForProviderActionForward#stickiness
   */
  readonly stickiness?: LbListenerRuleSpecForProviderActionForwardStickiness[];

  /**
   * One or more target groups block.
   *
   * @schema LbListenerRuleSpecForProviderActionForward#targetGroup
   */
  readonly targetGroup: LbListenerRuleSpecForProviderActionForwardTargetGroup[];

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionForward' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionForward(obj: LbListenerRuleSpecForProviderActionForward | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stickiness': obj.stickiness?.map(y => toJson_LbListenerRuleSpecForProviderActionForwardStickiness(y)),
    'targetGroup': obj.targetGroup?.map(y => toJson_LbListenerRuleSpecForProviderActionForwardTargetGroup(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderActionRedirect
 */
export interface LbListenerRuleSpecForProviderActionRedirect {
  /**
   * The hostname. This component is not percent-encoded. The hostname can contain #{host}. Defaults to #{host}.
   *
   * @default host}.
   * @schema LbListenerRuleSpecForProviderActionRedirect#host
   */
  readonly host?: string;

  /**
   * The absolute path, starting with the leading "/". This component is not percent-encoded. The path can contain #{host}, #{path}, and #{port}. Defaults to /#{path}.
   *
   * @default path}.
   * @schema LbListenerRuleSpecForProviderActionRedirect#path
   */
  readonly path?: string;

  /**
   * The port. Specify a value from 1 to 65535 or #{port}. Defaults to #{port}.
   *
   * @default port}.
   * @schema LbListenerRuleSpecForProviderActionRedirect#port
   */
  readonly port?: string;

  /**
   * The protocol. Valid values are HTTP, HTTPS, or #{protocol}. Defaults to #{protocol}.
   *
   * @default protocol}.
   * @schema LbListenerRuleSpecForProviderActionRedirect#protocol
   */
  readonly protocol?: string;

  /**
   * The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include the leading "?". Defaults to #{query}.
   *
   * @default query}.
   * @schema LbListenerRuleSpecForProviderActionRedirect#query
   */
  readonly query?: string;

  /**
   * The HTTP redirect code. The redirect is either permanent (HTTP_301) or temporary (HTTP_302).
   *
   * @schema LbListenerRuleSpecForProviderActionRedirect#statusCode
   */
  readonly statusCode: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionRedirect(obj: LbListenerRuleSpecForProviderActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'query': obj.query,
    'statusCode': obj.statusCode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRef
 */
export interface LbListenerRuleSpecForProviderActionTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRef#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionTargetGroupArnRef(obj: LbListenerRuleSpecForProviderActionTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelector
 */
export interface LbListenerRuleSpecForProviderActionTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelector#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionTargetGroupArnSelector(obj: LbListenerRuleSpecForProviderActionTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderConditionHostHeader
 */
export interface LbListenerRuleSpecForProviderConditionHostHeader {
  /**
   * Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
   *
   * @schema LbListenerRuleSpecForProviderConditionHostHeader#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderConditionHostHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderConditionHostHeader(obj: LbListenerRuleSpecForProviderConditionHostHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderConditionHttpHeader
 */
export interface LbListenerRuleSpecForProviderConditionHttpHeader {
  /**
   * Name of HTTP header to search. The maximum size is 40 characters. Comparison is case insensitive. Only RFC7240 characters are supported. Wildcards are not supported. You cannot use HTTP header condition to specify the host header, use a host-header condition instead.
   *
   * @schema LbListenerRuleSpecForProviderConditionHttpHeader#httpHeaderName
   */
  readonly httpHeaderName: string;

  /**
   * List of header value patterns to match. Maximum size of each pattern is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). If the same header appears multiple times in the request they will be searched in order until a match is found. Only one pattern needs to match for the condition to be satisfied. To require that all of the strings are a match, create one condition block per string.
   *
   * @schema LbListenerRuleSpecForProviderConditionHttpHeader#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderConditionHttpHeader' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderConditionHttpHeader(obj: LbListenerRuleSpecForProviderConditionHttpHeader | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpHeaderName': obj.httpHeaderName,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderConditionHttpRequestMethod
 */
export interface LbListenerRuleSpecForProviderConditionHttpRequestMethod {
  /**
   * Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
   *
   * @schema LbListenerRuleSpecForProviderConditionHttpRequestMethod#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderConditionHttpRequestMethod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderConditionHttpRequestMethod(obj: LbListenerRuleSpecForProviderConditionHttpRequestMethod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderConditionPathPattern
 */
export interface LbListenerRuleSpecForProviderConditionPathPattern {
  /**
   * Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
   *
   * @schema LbListenerRuleSpecForProviderConditionPathPattern#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderConditionPathPattern' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderConditionPathPattern(obj: LbListenerRuleSpecForProviderConditionPathPattern | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderConditionQueryString
 */
export interface LbListenerRuleSpecForProviderConditionQueryString {
  /**
   * Query string key pattern to match.
   *
   * @schema LbListenerRuleSpecForProviderConditionQueryString#key
   */
  readonly key?: string;

  /**
   * Query string value pattern to match.
   *
   * @schema LbListenerRuleSpecForProviderConditionQueryString#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderConditionQueryString' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderConditionQueryString(obj: LbListenerRuleSpecForProviderConditionQueryString | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderConditionSourceIp
 */
export interface LbListenerRuleSpecForProviderConditionSourceIp {
  /**
   * Query string pairs or values to match. Query String Value blocks documented below. Multiple values blocks can be specified, see example above. Maximum size of each string is 128 characters. Comparison is case insensitive. Wildcard characters supported: * (matches 0 or more characters) and ? (matches exactly 1 character). To search for a literal '*' or '?' character in a query string, escape the character with a backslash (\). Only one pair needs to match for the condition to be satisfied.
   *
   * @schema LbListenerRuleSpecForProviderConditionSourceIp#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderConditionSourceIp' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderConditionSourceIp(obj: LbListenerRuleSpecForProviderConditionSourceIp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnRefPolicy
 */
export interface LbListenerRuleSpecForProviderListenerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderListenerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderListenerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderListenerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderListenerArnRefPolicy(obj: LbListenerRuleSpecForProviderListenerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnSelectorPolicy
 */
export interface LbListenerRuleSpecForProviderListenerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderListenerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderListenerArnSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderListenerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderListenerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderListenerArnSelectorPolicy(obj: LbListenerRuleSpecForProviderListenerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecProviderConfigRefPolicyResolution
 */
export enum LbListenerRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecProviderConfigRefPolicyResolve
 */
export enum LbListenerRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecProviderRefPolicyResolution
 */
export enum LbListenerRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecProviderRefPolicyResolve
 */
export enum LbListenerRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool in cognitoidp to populate userPoolArn.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool in cognitoidp to populate userPoolArn.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolClient in cognitoidp to populate userPoolClientId.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolClient in cognitoidp to populate userPoolClientId.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolDomain in cognitoidp to populate userPoolDomain.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolDomain in cognitoidp to populate userPoolDomain.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The OAuth 2.0 client secret.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef {
  /**
   * The key to select.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef(obj: LbListenerRuleSpecForProviderActionAuthenticateOidcClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderActionForwardStickiness
 */
export interface LbListenerRuleSpecForProviderActionForwardStickiness {
  /**
   * The time period, in seconds, during which requests from a client should be routed to the same target group. The range is 1-604800 seconds (7 days).
   *
   * @schema LbListenerRuleSpecForProviderActionForwardStickiness#duration
   */
  readonly duration: number;

  /**
   * Indicates whether target group stickiness is enabled.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardStickiness#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionForwardStickiness' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionForwardStickiness(obj: LbListenerRuleSpecForProviderActionForwardStickiness | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroup
 */
export interface LbListenerRuleSpecForProviderActionForwardTargetGroup {
  /**
   * The Amazon Resource Name (ARN) of the target group.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroup#arn
   */
  readonly arn?: string;

  /**
   * Reference to a LBTargetGroup in elbv2 to populate arn.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroup#arnRef
   */
  readonly arnRef?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup in elbv2 to populate arn.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroup#arnSelector
   */
  readonly arnSelector?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector;

  /**
   * The weight. The range is 0 to 999.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroup#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionForwardTargetGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionForwardTargetGroup(obj: LbListenerRuleSpecForProviderActionForwardTargetGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'arnRef': toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef(obj.arnRef),
    'arnSelector': toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector(obj.arnSelector),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy
 */
export interface LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy(obj: LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy
 */
export interface LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy(obj: LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnRefPolicyResolution
 */
export enum LbListenerRuleSpecForProviderListenerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnRefPolicyResolve
 */
export enum LbListenerRuleSpecForProviderListenerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnSelectorPolicyResolution
 */
export enum LbListenerRuleSpecForProviderListenerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderListenerArnSelectorPolicyResolve
 */
export enum LbListenerRuleSpecForProviderListenerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LbListenerRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy
 */
export interface LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy(obj: LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup in elbv2 to populate arn.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef
 */
export interface LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef(obj: LbListenerRuleSpecForProviderActionForwardTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup in elbv2 to populate arn.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector
 */
export interface LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector#policy
   */
  readonly policy?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector(obj: LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolClientIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionAuthenticateCognitoUserPoolDomainSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy
 */
export interface LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy(obj: LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy
 */
export interface LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy(obj: LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionForwardTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicyResolution
 */
export enum LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicyResolve
 */
export enum LbListenerRuleSpecForProviderActionForwardTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LBTargetGroup is the Schema for the LBTargetGroups API. Provides a Target Group resource for use with Load Balancers.
 *
 * @schema LBTargetGroup
 */
export class LbTargetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LBTargetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.upbound.io/v1beta1',
    kind: 'LBTargetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "LBTargetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LbTargetGroupProps): any {
    return {
      ...LbTargetGroup.GVK,
      ...toJson_LbTargetGroupProps(props),
    };
  }

  /**
   * Defines a "LBTargetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LbTargetGroupProps) {
    super(scope, id, {
      ...LbTargetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LbTargetGroup.GVK,
      ...toJson_LbTargetGroupProps(resolved),
    };
  }
}

/**
 * LBTargetGroup is the Schema for the LBTargetGroups API. Provides a Target Group resource for use with Load Balancers.
 *
 * @schema LBTargetGroup
 */
export interface LbTargetGroupProps {
  /**
   * @schema LBTargetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LBTargetGroupSpec defines the desired state of LBTargetGroup
   *
   * @schema LBTargetGroup#spec
   */
  readonly spec: LbTargetGroupSpec;

}

/**
 * Converts an object of type 'LbTargetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupProps(obj: LbTargetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LbTargetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LBTargetGroupSpec defines the desired state of LBTargetGroup
 *
 * @schema LbTargetGroupSpec
 */
export interface LbTargetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbTargetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: LbTargetGroupSpecDeletionPolicy;

  /**
   * @schema LbTargetGroupSpec#forProvider
   */
  readonly forProvider: LbTargetGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbTargetGroupSpec#managementPolicy
   */
  readonly managementPolicy?: LbTargetGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LbTargetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: LbTargetGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LbTargetGroupSpec#providerRef
   */
  readonly providerRef?: LbTargetGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LbTargetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LbTargetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LbTargetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LbTargetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LbTargetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpec(obj: LbTargetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LbTargetGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LbTargetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LbTargetGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LbTargetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LbTargetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbTargetGroupSpecDeletionPolicy
 */
export enum LbTargetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LbTargetGroupSpecForProvider
 */
export interface LbTargetGroupSpecForProvider {
  /**
   * Whether to terminate connections at the end of the deregistration timeout on Network Load Balancers. See doc for more information. Default is false.
   *
   * @default false.
   * @schema LbTargetGroupSpecForProvider#connectionTermination
   */
  readonly connectionTermination?: boolean;

  /**
   * Amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds. The default value is 300 seconds.
   *
   * @schema LbTargetGroupSpecForProvider#deregistrationDelay
   */
  readonly deregistrationDelay?: string;

  /**
   * Health Check configuration block. Detailed below.
   *
   * @schema LbTargetGroupSpecForProvider#healthCheck
   */
  readonly healthCheck?: LbTargetGroupSpecForProviderHealthCheck[];

  /**
   * The type of IP addresses used by the target group, only supported when target type is set to ip. Possible values are ipv4 or ipv6.
   *
   * @schema LbTargetGroupSpecForProvider#ipAddressType
   */
  readonly ipAddressType?: string;

  /**
   * Whether the request and response headers exchanged between the load balancer and the Lambda function include arrays of values or strings. Only applies when target_type is lambda. Default is false.
   *
   * @default false.
   * @schema LbTargetGroupSpecForProvider#lambdaMultiValueHeadersEnabled
   */
  readonly lambdaMultiValueHeadersEnabled?: boolean;

  /**
   * Determines how the load balancer selects targets when routing requests. Only applicable for Application Load Balancer Target Groups. The value is round_robin or least_outstanding_requests. The default is round_robin.
   *
   * @schema LbTargetGroupSpecForProvider#loadBalancingAlgorithmType
   */
  readonly loadBalancingAlgorithmType?: string;

  /**
   * Indicates whether cross zone load balancing is enabled. The value is "true", "false" or "use_load_balancer_configuration". The default is "use_load_balancer_configuration".
   *
   * @schema LbTargetGroupSpecForProvider#loadBalancingCrossZoneEnabled
   */
  readonly loadBalancingCrossZoneEnabled?: string;

  /**
   * Name of the target group. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.
   *
   * @schema LbTargetGroupSpecForProvider#name
   */
  readonly name?: string;

  /**
   * (May be required, Forces new resource) Port on which targets receive traffic, unless overridden when registering a specific target. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
   *
   * @schema LbTargetGroupSpecForProvider#port
   */
  readonly port?: number;

  /**
   * Whether client IP preservation is enabled. See doc for more information.
   *
   * @schema LbTargetGroupSpecForProvider#preserveClientIp
   */
  readonly preserveClientIp?: string;

  /**
   * (May be required, Forces new resource) Protocol to use for routing traffic to the targets. Should be one of GENEVE, HTTP, HTTPS, TCP, TCP_UDP, TLS, or UDP. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
   *
   * @schema LbTargetGroupSpecForProvider#protocol
   */
  readonly protocol?: string;

  /**
   * Only applicable when protocol is HTTP or HTTPS. The protocol version. Specify GRPC to send requests to targets using gRPC. Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends requests to targets using HTTP/1.1
   *
   * @schema LbTargetGroupSpecForProvider#protocolVersion
   */
  readonly protocolVersion?: string;

  /**
   * Whether to enable support for proxy protocol v2 on Network Load Balancers. See doc for more information. Default is false.
   *
   * @default false.
   * @schema LbTargetGroupSpecForProvider#proxyProtocolV2
   */
  readonly proxyProtocolV2?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LbTargetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amount time for targets to warm up before the load balancer sends them a full share of requests. The range is 30-900 seconds or 0 to disable. The default value is 0 seconds.
   *
   * @schema LbTargetGroupSpecForProvider#slowStart
   */
  readonly slowStart?: number;

  /**
   * Stickiness configuration block. Detailed below.
   *
   * @schema LbTargetGroupSpecForProvider#stickiness
   */
  readonly stickiness?: LbTargetGroupSpecForProviderStickiness[];

  /**
   * Key-value map of resource tags.
   *
   * @schema LbTargetGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Target failover block. Only applicable for Gateway Load Balancer target groups. See target_failover for more information.
   *
   * @schema LbTargetGroupSpecForProvider#targetFailover
   */
  readonly targetFailover?: LbTargetGroupSpecForProviderTargetFailover[];

  /**
   * (May be required, Forces new resource) Type of target that you must specify when registering targets with this target group. See doc for supported values. The default is instance.
   *
   * @schema LbTargetGroupSpecForProvider#targetType
   */
  readonly targetType?: string;

  /**
   * Identifier of the VPC in which to create the target group. Required when target_type is instance, ip or alb. Does not apply when target_type is lambda.
   *
   * @schema LbTargetGroupSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema LbTargetGroupSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: LbTargetGroupSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema LbTargetGroupSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: LbTargetGroupSpecForProviderVpcIdSelector;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProvider(obj: LbTargetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectionTermination': obj.connectionTermination,
    'deregistrationDelay': obj.deregistrationDelay,
    'healthCheck': obj.healthCheck?.map(y => toJson_LbTargetGroupSpecForProviderHealthCheck(y)),
    'ipAddressType': obj.ipAddressType,
    'lambdaMultiValueHeadersEnabled': obj.lambdaMultiValueHeadersEnabled,
    'loadBalancingAlgorithmType': obj.loadBalancingAlgorithmType,
    'loadBalancingCrossZoneEnabled': obj.loadBalancingCrossZoneEnabled,
    'name': obj.name,
    'port': obj.port,
    'preserveClientIp': obj.preserveClientIp,
    'protocol': obj.protocol,
    'protocolVersion': obj.protocolVersion,
    'proxyProtocolV2': obj.proxyProtocolV2,
    'region': obj.region,
    'slowStart': obj.slowStart,
    'stickiness': obj.stickiness?.map(y => toJson_LbTargetGroupSpecForProviderStickiness(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetFailover': obj.targetFailover?.map(y => toJson_LbTargetGroupSpecForProviderTargetFailover(y)),
    'targetType': obj.targetType,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_LbTargetGroupSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_LbTargetGroupSpecForProviderVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbTargetGroupSpecManagementPolicy
 */
export enum LbTargetGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LbTargetGroupSpecProviderConfigRef
 */
export interface LbTargetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: LbTargetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecProviderConfigRef(obj: LbTargetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LbTargetGroupSpecProviderRef
 */
export interface LbTargetGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupSpecProviderRef#policy
   */
  readonly policy?: LbTargetGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecProviderRef(obj: LbTargetGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LbTargetGroupSpecPublishConnectionDetailsTo
 */
export interface LbTargetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LbTargetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LbTargetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LbTargetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecPublishConnectionDetailsTo(obj: LbTargetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LbTargetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LbTargetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LbTargetGroupSpecWriteConnectionSecretToRef
 */
export interface LbTargetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LbTargetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbTargetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbTargetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecWriteConnectionSecretToRef(obj: LbTargetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbTargetGroupSpecForProviderHealthCheck
 */
export interface LbTargetGroupSpecForProviderHealthCheck {
  /**
   * Whether health checks are enabled. Defaults to true.
   *
   * @default true.
   * @schema LbTargetGroupSpecForProviderHealthCheck#enabled
   */
  readonly enabled?: boolean;

  /**
   * Number of consecutive health check successes required before considering a target healthy. The range is 2-10. Defaults to 3.
   *
   * @default 3.
   * @schema LbTargetGroupSpecForProviderHealthCheck#healthyThreshold
   */
  readonly healthyThreshold?: number;

  /**
   * Approximate amount of time, in seconds, between health checks of an individual target. The range is 5-300. For lambda target groups, it needs to be greater than the timeout of the underlying lambda. Defaults to 30.
   *
   * @default 30.
   * @schema LbTargetGroupSpecForProviderHealthCheck#interval
   */
  readonly interval?: number;

  /**
   * 299" or "0-99"). Required for HTTP/HTTPS/GRPC ALB. Only applies to Application Load Balancers (i.e., HTTP/HTTPS/GRPC) not Network Load Balancers (i.e., TCP).
   *
   * @schema LbTargetGroupSpecForProviderHealthCheck#matcher
   */
  readonly matcher?: string;

  /**
   * (May be required) Destination for the health check request. Required for HTTP/HTTPS ALB and HTTP NLB. Only applies to HTTP/HTTPS.
   *
   * @schema LbTargetGroupSpecForProviderHealthCheck#path
   */
  readonly path?: string;

  /**
   * The port the load balancer uses when performing health checks on targets. Default is traffic-port.
   *
   * @default traffic-port.
   * @schema LbTargetGroupSpecForProviderHealthCheck#port
   */
  readonly port?: string;

  /**
   * Protocol the load balancer uses when performing health checks on targets. Must be either TCP, HTTP, or HTTPS. The TCP protocol is not supported for health checks if the protocol of the target group is HTTP or HTTPS. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema LbTargetGroupSpecForProviderHealthCheck#protocol
   */
  readonly protocol?: string;

  /**
   * Amount of time, in seconds, during which no response from a target means a failed health check. The range is 2120 seconds. For target groups with a protocol of HTTP, the default is 6 seconds. For target groups with a protocol of TCP, TLS or HTTPS, the default is 10 seconds. For target groups with a protocol of GENEVE, the default is 5 seconds. If the target type is lambda, the default is 30 seconds.
   *
   * @schema LbTargetGroupSpecForProviderHealthCheck#timeout
   */
  readonly timeout?: number;

  /**
   * Number of consecutive health check failures required before considering a target unhealthy. The range is 2-10. Defaults to 3.
   *
   * @default 3.
   * @schema LbTargetGroupSpecForProviderHealthCheck#unhealthyThreshold
   */
  readonly unhealthyThreshold?: number;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProviderHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProviderHealthCheck(obj: LbTargetGroupSpecForProviderHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'healthyThreshold': obj.healthyThreshold,
    'interval': obj.interval,
    'matcher': obj.matcher,
    'path': obj.path,
    'port': obj.port,
    'protocol': obj.protocol,
    'timeout': obj.timeout,
    'unhealthyThreshold': obj.unhealthyThreshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbTargetGroupSpecForProviderStickiness
 */
export interface LbTargetGroupSpecForProviderStickiness {
  /**
   * Only used when the type is lb_cookie. The time period, in seconds, during which requests from a client should be routed to the same target. After this time period expires, the load balancer-generated cookie is considered stale. The range is 1 second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).
   *
   * @schema LbTargetGroupSpecForProviderStickiness#cookieDuration
   */
  readonly cookieDuration?: number;

  /**
   * Name of the application based cookie. AWSALB, AWSALBAPP, and AWSALBTG prefixes are reserved and cannot be used. Only needed when type is app_cookie.
   *
   * @schema LbTargetGroupSpecForProviderStickiness#cookieName
   */
  readonly cookieName?: string;

  /**
   * Whether health checks are enabled. Defaults to true.
   *
   * @default true.
   * @schema LbTargetGroupSpecForProviderStickiness#enabled
   */
  readonly enabled?: boolean;

  /**
   * The type of sticky sessions. The only current possible values are lb_cookie, app_cookie for ALBs, source_ip for NLBs, and source_ip_dest_ip, source_ip_dest_ip_proto for GWLBs.
   *
   * @schema LbTargetGroupSpecForProviderStickiness#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProviderStickiness' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProviderStickiness(obj: LbTargetGroupSpecForProviderStickiness | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookieDuration': obj.cookieDuration,
    'cookieName': obj.cookieName,
    'enabled': obj.enabled,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LbTargetGroupSpecForProviderTargetFailover
 */
export interface LbTargetGroupSpecForProviderTargetFailover {
  /**
   * Indicates how the GWLB handles existing flows when a target is deregistered. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_unhealthy. Default: no_rebalance.
   *
   * @schema LbTargetGroupSpecForProviderTargetFailover#onDeregistration
   */
  readonly onDeregistration: string;

  /**
   * Indicates how the GWLB handles existing flows when a target is unhealthy. Possible values are rebalance and no_rebalance. Must match the attribute value set for on_deregistration. Default: no_rebalance.
   *
   * @schema LbTargetGroupSpecForProviderTargetFailover#onUnhealthy
   */
  readonly onUnhealthy: string;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProviderTargetFailover' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProviderTargetFailover(obj: LbTargetGroupSpecForProviderTargetFailover | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'onDeregistration': obj.onDeregistration,
    'onUnhealthy': obj.onUnhealthy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdRef
 */
export interface LbTargetGroupSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdRef#policy
   */
  readonly policy?: LbTargetGroupSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProviderVpcIdRef(obj: LbTargetGroupSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdSelector
 */
export interface LbTargetGroupSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: LbTargetGroupSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProviderVpcIdSelector(obj: LbTargetGroupSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbTargetGroupSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupSpecProviderConfigRefPolicy
 */
export interface LbTargetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecProviderConfigRefPolicy(obj: LbTargetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupSpecProviderRefPolicy
 */
export interface LbTargetGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecProviderRefPolicy(obj: LbTargetGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface LbTargetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecPublishConnectionDetailsToConfigRef(obj: LbTargetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LbTargetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface LbTargetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LbTargetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecPublishConnectionDetailsToMetadata(obj: LbTargetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdRefPolicy
 */
export interface LbTargetGroupSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProviderVpcIdRefPolicy(obj: LbTargetGroupSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdSelectorPolicy
 */
export interface LbTargetGroupSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: LbTargetGroupSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: LbTargetGroupSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecForProviderVpcIdSelectorPolicy(obj: LbTargetGroupSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupSpecProviderConfigRefPolicyResolution
 */
export enum LbTargetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupSpecProviderConfigRefPolicyResolve
 */
export enum LbTargetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupSpecProviderRefPolicyResolution
 */
export enum LbTargetGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupSpecProviderRefPolicyResolve
 */
export enum LbTargetGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdRefPolicyResolution
 */
export enum LbTargetGroupSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdRefPolicyResolve
 */
export enum LbTargetGroupSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum LbTargetGroupSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum LbTargetGroupSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LbTargetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LBTargetGroupAttachment is the Schema for the LBTargetGroupAttachments API. Provides the ability to register instances and containers with a LB target group
 *
 * @schema LBTargetGroupAttachment
 */
export class LbTargetGroupAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LBTargetGroupAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'elbv2.aws.upbound.io/v1beta1',
    kind: 'LBTargetGroupAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "LBTargetGroupAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LbTargetGroupAttachmentProps): any {
    return {
      ...LbTargetGroupAttachment.GVK,
      ...toJson_LbTargetGroupAttachmentProps(props),
    };
  }

  /**
   * Defines a "LBTargetGroupAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LbTargetGroupAttachmentProps) {
    super(scope, id, {
      ...LbTargetGroupAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LbTargetGroupAttachment.GVK,
      ...toJson_LbTargetGroupAttachmentProps(resolved),
    };
  }
}

/**
 * LBTargetGroupAttachment is the Schema for the LBTargetGroupAttachments API. Provides the ability to register instances and containers with a LB target group
 *
 * @schema LBTargetGroupAttachment
 */
export interface LbTargetGroupAttachmentProps {
  /**
   * @schema LBTargetGroupAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LBTargetGroupAttachmentSpec defines the desired state of LBTargetGroupAttachment
   *
   * @schema LBTargetGroupAttachment#spec
   */
  readonly spec: LbTargetGroupAttachmentSpec;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentProps(obj: LbTargetGroupAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LbTargetGroupAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LBTargetGroupAttachmentSpec defines the desired state of LBTargetGroupAttachment
 *
 * @schema LbTargetGroupAttachmentSpec
 */
export interface LbTargetGroupAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbTargetGroupAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: LbTargetGroupAttachmentSpecDeletionPolicy;

  /**
   * @schema LbTargetGroupAttachmentSpec#forProvider
   */
  readonly forProvider: LbTargetGroupAttachmentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LbTargetGroupAttachmentSpec#managementPolicy
   */
  readonly managementPolicy?: LbTargetGroupAttachmentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LbTargetGroupAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: LbTargetGroupAttachmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema LbTargetGroupAttachmentSpec#providerRef
   */
  readonly providerRef?: LbTargetGroupAttachmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LbTargetGroupAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LbTargetGroupAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LbTargetGroupAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LbTargetGroupAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpec(obj: LbTargetGroupAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LbTargetGroupAttachmentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_LbTargetGroupAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_LbTargetGroupAttachmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LbTargetGroupAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbTargetGroupAttachmentSpecDeletionPolicy
 */
export enum LbTargetGroupAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LbTargetGroupAttachmentSpecForProvider
 */
export interface LbTargetGroupAttachmentSpecForProvider {
  /**
   * The Availability Zone where the IP address of the target is to be registered. If the private ip address is outside of the VPC scope, this value must be set to 'all'.
   *
   * @schema LbTargetGroupAttachmentSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The port on which targets receive traffic.
   *
   * @schema LbTargetGroupAttachmentSpecForProvider#port
   */
  readonly port?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LbTargetGroupAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the target group with which to register targets
   *
   * @schema LbTargetGroupAttachmentSpecForProvider#targetGroupArn
   */
  readonly targetGroupArn?: string;

  /**
   * Reference to a LBTargetGroup to populate targetGroupArn.
   *
   * @schema LbTargetGroupAttachmentSpecForProvider#targetGroupArnRef
   */
  readonly targetGroupArnRef?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup to populate targetGroupArn.
   *
   * @schema LbTargetGroupAttachmentSpecForProvider#targetGroupArnSelector
   */
  readonly targetGroupArnSelector?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector;

  /**
   * The ID of the target. This is the Instance ID for an instance, or the container ID for an ECS container. If the target type is ip, specify an IP address. If the target type is lambda, specify the arn of lambda. If the target type is alb, specify the arn of alb.
   *
   * @schema LbTargetGroupAttachmentSpecForProvider#targetId
   */
  readonly targetId?: string;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecForProvider(obj: LbTargetGroupAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityZone': obj.availabilityZone,
    'port': obj.port,
    'region': obj.region,
    'targetGroupArn': obj.targetGroupArn,
    'targetGroupArnRef': toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupArnSelector': toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector(obj.targetGroupArnSelector),
    'targetId': obj.targetId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LbTargetGroupAttachmentSpecManagementPolicy
 */
export enum LbTargetGroupAttachmentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LbTargetGroupAttachmentSpecProviderConfigRef
 */
export interface LbTargetGroupAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: LbTargetGroupAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecProviderConfigRef(obj: LbTargetGroupAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema LbTargetGroupAttachmentSpecProviderRef
 */
export interface LbTargetGroupAttachmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupAttachmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupAttachmentSpecProviderRef#policy
   */
  readonly policy?: LbTargetGroupAttachmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecProviderRef(obj: LbTargetGroupAttachmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupAttachmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsTo
 */
export interface LbTargetGroupAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsTo(obj: LbTargetGroupAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LbTargetGroupAttachmentSpecWriteConnectionSecretToRef
 */
export interface LbTargetGroupAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LbTargetGroupAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LbTargetGroupAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecWriteConnectionSecretToRef(obj: LbTargetGroupAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup to populate targetGroupArn.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef
 */
export interface LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef#policy
   */
  readonly policy?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef(obj: LbTargetGroupAttachmentSpecForProviderTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup to populate targetGroupArn.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector
 */
export interface LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector#policy
   */
  readonly policy?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector(obj: LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupAttachmentSpecProviderConfigRefPolicy
 */
export interface LbTargetGroupAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecProviderConfigRefPolicy(obj: LbTargetGroupAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupAttachmentSpecProviderRefPolicy
 */
export interface LbTargetGroupAttachmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupAttachmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupAttachmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupAttachmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupAttachmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecProviderRefPolicy(obj: LbTargetGroupAttachmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef(obj: LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata(obj: LbTargetGroupAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy
 */
export interface LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy(obj: LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy
 */
export interface LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy(obj: LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum LbTargetGroupAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum LbTargetGroupAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupAttachmentSpecProviderRefPolicyResolution
 */
export enum LbTargetGroupAttachmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupAttachmentSpecProviderRefPolicyResolve
 */
export enum LbTargetGroupAttachmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicyResolution
 */
export enum LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicyResolve
 */
export enum LbTargetGroupAttachmentSpecForProviderTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicyResolution
 */
export enum LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicyResolve
 */
export enum LbTargetGroupAttachmentSpecForProviderTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LbTargetGroupAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

