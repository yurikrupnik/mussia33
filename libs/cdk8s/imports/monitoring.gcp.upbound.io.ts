// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AlertPolicy is the Schema for the AlertPolicys API. A description of the conditions under which some aspect of your system is considered to be "unhealthy" and the ways to notify people or services about this state.
 *
 * @schema AlertPolicy
 */
export class AlertPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AlertPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'AlertPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "AlertPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AlertPolicyProps): any {
    return {
      ...AlertPolicy.GVK,
      ...toJson_AlertPolicyProps(props),
    };
  }

  /**
   * Defines a "AlertPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AlertPolicyProps) {
    super(scope, id, {
      ...AlertPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AlertPolicy.GVK,
      ...toJson_AlertPolicyProps(resolved),
    };
  }
}

/**
 * AlertPolicy is the Schema for the AlertPolicys API. A description of the conditions under which some aspect of your system is considered to be "unhealthy" and the ways to notify people or services about this state.
 *
 * @schema AlertPolicy
 */
export interface AlertPolicyProps {
  /**
   * @schema AlertPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AlertPolicySpec defines the desired state of AlertPolicy
   *
   * @schema AlertPolicy#spec
   */
  readonly spec: AlertPolicySpec;

}

/**
 * Converts an object of type 'AlertPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicyProps(obj: AlertPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AlertPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AlertPolicySpec defines the desired state of AlertPolicy
 *
 * @schema AlertPolicySpec
 */
export interface AlertPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AlertPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: AlertPolicySpecDeletionPolicy;

  /**
   * @schema AlertPolicySpec#forProvider
   */
  readonly forProvider: AlertPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AlertPolicySpec#managementPolicy
   */
  readonly managementPolicy?: AlertPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AlertPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: AlertPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AlertPolicySpec#providerRef
   */
  readonly providerRef?: AlertPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AlertPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AlertPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AlertPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AlertPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AlertPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpec(obj: AlertPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AlertPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AlertPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AlertPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AlertPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AlertPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AlertPolicySpecDeletionPolicy
 */
export enum AlertPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AlertPolicySpecForProvider
 */
export interface AlertPolicySpecForProvider {
  /**
   * Control over how this alert policy's notification channels are notified. Structure is documented below.
   *
   * @schema AlertPolicySpecForProvider#alertStrategy
   */
  readonly alertStrategy?: AlertPolicySpecForProviderAlertStrategy[];

  /**
   * How to combine the results of multiple conditions to determine if an incident should be opened. Possible values are: AND, OR, AND_WITH_MATCHING_RESOURCE.
   *
   * @schema AlertPolicySpecForProvider#combiner
   */
  readonly combiner?: string;

  /**
   * A list of conditions for the policy. The conditions are combined by AND or OR according to the combiner field. If the combined conditions evaluate to true, then an incident is created. A policy can have from one to six conditions. Structure is documented below.
   *
   * @schema AlertPolicySpecForProvider#conditions
   */
  readonly conditions?: AlertPolicySpecForProviderConditions[];

  /**
   * A short name or phrase used to identify the policy in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple policies in the same project. The name is limited to 512 Unicode characters.
   *
   * @schema AlertPolicySpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Documentation that is included with notifications and incidents related to this policy. Best practice is for the documentation to include information to help responders understand, mitigate, escalate, and correct the underlying problems detected by the alerting policy. Notification channels that have limited capacity might not show this documentation. Structure is documented below.
   *
   * @schema AlertPolicySpecForProvider#documentation
   */
  readonly documentation?: AlertPolicySpecForProviderDocumentation[];

  /**
   * Whether or not the policy is enabled. The default is true.
   *
   * @schema AlertPolicySpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Identifies the notification channels to which notifications should be sent when incidents are opened or closed or when new violations occur on an already opened incident. Each element of this array corresponds to the name field in each of the NotificationChannel objects that are returned from the notificationChannels.list method. The syntax of the entries in this field is projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
   *
   * @schema AlertPolicySpecForProvider#notificationChannels
   */
  readonly notificationChannels?: string[];

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AlertPolicySpecForProvider#project
   */
  readonly project?: string;

  /**
   * This field is intended to be used for organizing and identifying the AlertPolicy objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
   *
   * @schema AlertPolicySpecForProvider#userLabels
   */
  readonly userLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'AlertPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProvider(obj: AlertPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alertStrategy': obj.alertStrategy?.map(y => toJson_AlertPolicySpecForProviderAlertStrategy(y)),
    'combiner': obj.combiner,
    'conditions': obj.conditions?.map(y => toJson_AlertPolicySpecForProviderConditions(y)),
    'displayName': obj.displayName,
    'documentation': obj.documentation?.map(y => toJson_AlertPolicySpecForProviderDocumentation(y)),
    'enabled': obj.enabled,
    'notificationChannels': obj.notificationChannels?.map(y => y),
    'project': obj.project,
    'userLabels': ((obj.userLabels) === undefined) ? undefined : (Object.entries(obj.userLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AlertPolicySpecManagementPolicy
 */
export enum AlertPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AlertPolicySpecProviderConfigRef
 */
export interface AlertPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertPolicySpecProviderConfigRef#policy
   */
  readonly policy?: AlertPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecProviderConfigRef(obj: AlertPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AlertPolicySpecProviderRef
 */
export interface AlertPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertPolicySpecProviderRef#policy
   */
  readonly policy?: AlertPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AlertPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecProviderRef(obj: AlertPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AlertPolicySpecPublishConnectionDetailsTo
 */
export interface AlertPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AlertPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AlertPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AlertPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecPublishConnectionDetailsTo(obj: AlertPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AlertPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AlertPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AlertPolicySpecWriteConnectionSecretToRef
 */
export interface AlertPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AlertPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AlertPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AlertPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecWriteConnectionSecretToRef(obj: AlertPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderAlertStrategy
 */
export interface AlertPolicySpecForProviderAlertStrategy {
  /**
   * If an alert policy that was active has no data for this long, any open incidents will close.
   *
   * @schema AlertPolicySpecForProviderAlertStrategy#autoClose
   */
  readonly autoClose?: string;

  /**
   * Control over how the notification channels in notification_channels are notified when this alert fires, on a per-channel basis. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderAlertStrategy#notificationChannelStrategy
   */
  readonly notificationChannelStrategy?: AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy[];

  /**
   * Required for alert policies with a LogMatch condition. This limit is not implemented for alert policies that are not log-based. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderAlertStrategy#notificationRateLimit
   */
  readonly notificationRateLimit?: AlertPolicySpecForProviderAlertStrategyNotificationRateLimit[];

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderAlertStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderAlertStrategy(obj: AlertPolicySpecForProviderAlertStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoClose': obj.autoClose,
    'notificationChannelStrategy': obj.notificationChannelStrategy?.map(y => toJson_AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy(y)),
    'notificationRateLimit': obj.notificationRateLimit?.map(y => toJson_AlertPolicySpecForProviderAlertStrategyNotificationRateLimit(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditions
 */
export interface AlertPolicySpecForProviderConditions {
  /**
   * A condition that checks that a time series continues to receive new data points. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditions#conditionAbsent
   */
  readonly conditionAbsent?: AlertPolicySpecForProviderConditionsConditionAbsent[];

  /**
   * A condition that checks for log messages matching given constraints. If set, no other conditions can be present. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditions#conditionMatchedLog
   */
  readonly conditionMatchedLog?: AlertPolicySpecForProviderConditionsConditionMatchedLog[];

  /**
   * A Monitoring Query Language query that outputs a boolean stream Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditions#conditionMonitoringQueryLanguage
   */
  readonly conditionMonitoringQueryLanguage?: AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage[];

  /**
   * A condition that compares a time series against a threshold. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditions#conditionThreshold
   */
  readonly conditionThreshold?: AlertPolicySpecForProviderConditionsConditionThreshold[];

  /**
   * A short name or phrase used to identify the condition in dashboards, notifications, and incidents. To avoid confusion, don't use the same display name for multiple conditions in the same policy.
   *
   * @schema AlertPolicySpecForProviderConditions#displayName
   */
  readonly displayName: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditions(obj: AlertPolicySpecForProviderConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditionAbsent': obj.conditionAbsent?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionAbsent(y)),
    'conditionMatchedLog': obj.conditionMatchedLog?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionMatchedLog(y)),
    'conditionMonitoringQueryLanguage': obj.conditionMonitoringQueryLanguage?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage(y)),
    'conditionThreshold': obj.conditionThreshold?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionThreshold(y)),
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderDocumentation
 */
export interface AlertPolicySpecForProviderDocumentation {
  /**
   * The text of the documentation, interpreted according to mimeType. The content may not exceed 8,192 Unicode characters and may not exceed more than 10,240 bytes when encoded in UTF-8 format, whichever is smaller.
   *
   * @schema AlertPolicySpecForProviderDocumentation#content
   */
  readonly content?: string;

  /**
   * The format of the content field. Presently, only the value "text/markdown" is supported.
   *
   * @schema AlertPolicySpecForProviderDocumentation#mimeType
   */
  readonly mimeType?: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderDocumentation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderDocumentation(obj: AlertPolicySpecForProviderDocumentation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'mimeType': obj.mimeType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertPolicySpecProviderConfigRefPolicy
 */
export interface AlertPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AlertPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AlertPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecProviderConfigRefPolicy(obj: AlertPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AlertPolicySpecProviderRefPolicy
 */
export interface AlertPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: AlertPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: AlertPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecProviderRefPolicy(obj: AlertPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AlertPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface AlertPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AlertPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecPublishConnectionDetailsToConfigRef(obj: AlertPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AlertPolicySpecPublishConnectionDetailsToMetadata
 */
export interface AlertPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AlertPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecPublishConnectionDetailsToMetadata(obj: AlertPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy
 */
export interface AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy {
  /**
   * The notification channels that these settings apply to. Each of these correspond to the name field in one of the NotificationChannel objects referenced in the notification_channels field of this AlertPolicy. The format is projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   *
   * @schema AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy#notificationChannelNames
   */
  readonly notificationChannelNames?: string[];

  /**
   * The frequency at which to send reminder notifications for open incidents.
   *
   * @schema AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy#renotifyInterval
   */
  readonly renotifyInterval?: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy(obj: AlertPolicySpecForProviderAlertStrategyNotificationChannelStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notificationChannelNames': obj.notificationChannelNames?.map(y => y),
    'renotifyInterval': obj.renotifyInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderAlertStrategyNotificationRateLimit
 */
export interface AlertPolicySpecForProviderAlertStrategyNotificationRateLimit {
  /**
   * Not more than one notification per period.
   *
   * @schema AlertPolicySpecForProviderAlertStrategyNotificationRateLimit#period
   */
  readonly period?: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderAlertStrategyNotificationRateLimit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderAlertStrategyNotificationRateLimit(obj: AlertPolicySpecForProviderAlertStrategyNotificationRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'period': obj.period,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionAbsent
 */
export interface AlertPolicySpecForProviderConditionsConditionAbsent {
  /**
   * Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the MetricService.ListTimeSeries request. It is advisable to use the ListTimeSeries method when debugging this field. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsent#aggregations
   */
  readonly aggregations?: AlertPolicySpecForProviderConditionsConditionAbsentAggregations[];

  /**
   * The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsent#duration
   */
  readonly duration: string;

  /**
   * A filter that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the MetricService.ListTimeSeries request (that call is useful to verify the time series that will be retrieved / processed) and must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsent#filter
   */
  readonly filter?: string;

  /**
   * The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsent#trigger
   */
  readonly trigger?: AlertPolicySpecForProviderConditionsConditionAbsentTrigger[];

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionAbsent' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionAbsent(obj: AlertPolicySpecForProviderConditionsConditionAbsent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregations': obj.aggregations?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionAbsentAggregations(y)),
    'duration': obj.duration,
    'filter': obj.filter,
    'trigger': obj.trigger?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionAbsentTrigger(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionMatchedLog
 */
export interface AlertPolicySpecForProviderConditionsConditionMatchedLog {
  /**
   * A filter that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the MetricService.ListTimeSeries request (that call is useful to verify the time series that will be retrieved / processed) and must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMatchedLog#filter
   */
  readonly filter: string;

  /**
   * A map from a label key to an extractor expression, which is used to extract the value for this label key. Each entry in this map is a specification for how data should be extracted from log entries that match filter. Each combination of extracted values is treated as a separate rule for the purposes of triggering notifications. Label keys and corresponding values can be used in notifications generated by this condition.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMatchedLog#labelExtractors
   */
  readonly labelExtractors?: { [key: string]: string };

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionMatchedLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionMatchedLog(obj: AlertPolicySpecForProviderConditionsConditionMatchedLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filter': obj.filter,
    'labelExtractors': ((obj.labelExtractors) === undefined) ? undefined : (Object.entries(obj.labelExtractors).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage
 */
export interface AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage {
  /**
   * The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage#duration
   */
  readonly duration: string;

  /**
   * A condition control that determines how metric-threshold conditions are evaluated when data stops arriving. Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage#evaluationMissingData
   */
  readonly evaluationMissingData?: string;

  /**
   * Monitoring Query Language query that outputs a boolean stream.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage#query
   */
  readonly query: string;

  /**
   * The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage#trigger
   */
  readonly trigger?: AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger[];

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage(obj: AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'duration': obj.duration,
    'evaluationMissingData': obj.evaluationMissingData,
    'query': obj.query,
    'trigger': obj.trigger?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionThreshold
 */
export interface AlertPolicySpecForProviderConditionsConditionThreshold {
  /**
   * Specifies the alignment of data points in individual time series as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources). Multiple aggregations are applied in the order specified.This field is similar to the one in the MetricService.ListTimeSeries request. It is advisable to use the ListTimeSeries method when debugging this field. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#aggregations
   */
  readonly aggregations?: AlertPolicySpecForProviderConditionsConditionThresholdAggregations[];

  /**
   * The comparison to apply between the time series (indicated by filter and aggregation) and the threshold (indicated by threshold_value). The comparison is applied on each time series, with the time series on the left-hand side and the threshold on the right-hand side. Only COMPARISON_LT and COMPARISON_GT are supported currently. Possible values are: COMPARISON_GT, COMPARISON_GE, COMPARISON_LT, COMPARISON_LE, COMPARISON_EQ, COMPARISON_NE.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#comparison
   */
  readonly comparison: string;

  /**
   * Specifies the alignment of data points in individual time series selected by denominatorFilter as well as how to combine the retrieved time series together (such as when aggregating multiple streams on each resource to a single stream for each resource or when aggregating streams across all members of a group of resources).When computing ratios, the aggregations and denominator_aggregations fields must use the same alignment period and produce time series that have the same periodicity and labels.This field is similar to the one in the MetricService.ListTimeSeries request. It is advisable to use the ListTimeSeries method when debugging this field. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#denominatorAggregations
   */
  readonly denominatorAggregations?: AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations[];

  /**
   * A filter that identifies a time series that should be used as the denominator of a ratio that will be compared with the threshold. If a denominator_filter is specified, the time series specified by the filter field will be used as the numerator.The filter is similar to the one that is specified in the MetricService.ListTimeSeries request (that call is useful to verify the time series that will be retrieved / processed) and must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#denominatorFilter
   */
  readonly denominatorFilter?: string;

  /**
   * The amount of time that a time series must violate the threshold to be considered failing. Currently, only values that are a multiple of a minute--e.g., 0, 60, 120, or 300 seconds--are supported. If an invalid value is given, an error will be returned. When choosing a duration, it is useful to keep in mind the frequency of the underlying time series data (which may also be affected by any alignments specified in the aggregations field); a good duration is long enough so that a single outlier does not generate spurious alerts, but short enough that unhealthy states are detected and alerted on quickly.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#duration
   */
  readonly duration: string;

  /**
   * A condition control that determines how metric-threshold conditions are evaluated when data stops arriving. Possible values are: EVALUATION_MISSING_DATA_INACTIVE, EVALUATION_MISSING_DATA_ACTIVE, EVALUATION_MISSING_DATA_NO_OP.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#evaluationMissingData
   */
  readonly evaluationMissingData?: string;

  /**
   * A filter that identifies which time series should be compared with the threshold.The filter is similar to the one that is specified in the MetricService.ListTimeSeries request (that call is useful to verify the time series that will be retrieved / processed) and must specify the metric type and optionally may contain restrictions on resource type, resource labels, and metric labels. This field may not exceed 2048 Unicode characters in length.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#filter
   */
  readonly filter?: string;

  /**
   * When this field is present, the MetricThreshold condition forecasts whether the time series is predicted to violate the threshold within the forecastHorizon. When this field is not set, the MetricThreshold tests the current value of the timeseries against the threshold. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#forecastOptions
   */
  readonly forecastOptions?: AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions[];

  /**
   * A value against which to compare the time series.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#thresholdValue
   */
  readonly thresholdValue?: number;

  /**
   * The number/percent of time series for which the comparison must hold in order for the condition to trigger. If unspecified, then the condition will trigger if the comparison is true for any of the time series that have been identified by filter and aggregations, or by the ratio, if denominator_filter and denominator_aggregations are specified. Structure is documented below.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThreshold#trigger
   */
  readonly trigger?: AlertPolicySpecForProviderConditionsConditionThresholdTrigger[];

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionThreshold(obj: AlertPolicySpecForProviderConditionsConditionThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'aggregations': obj.aggregations?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionThresholdAggregations(y)),
    'comparison': obj.comparison,
    'denominatorAggregations': obj.denominatorAggregations?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations(y)),
    'denominatorFilter': obj.denominatorFilter,
    'duration': obj.duration,
    'evaluationMissingData': obj.evaluationMissingData,
    'filter': obj.filter,
    'forecastOptions': obj.forecastOptions?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions(y)),
    'thresholdValue': obj.thresholdValue,
    'trigger': obj.trigger?.map(y => toJson_AlertPolicySpecForProviderConditionsConditionThresholdTrigger(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertPolicySpecProviderConfigRefPolicyResolution
 */
export enum AlertPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertPolicySpecProviderConfigRefPolicyResolve
 */
export enum AlertPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertPolicySpecProviderRefPolicyResolution
 */
export enum AlertPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertPolicySpecProviderRefPolicyResolve
 */
export enum AlertPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AlertPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AlertPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: AlertPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionAbsentAggregations
 */
export interface AlertPolicySpecForProviderConditionsConditionAbsentAggregations {
  /**
   * The alignment period for per-time series alignment. If present, alignmentPeriod must be at least 60 seconds. After per-time series alignment, each time series will contain data points only on the period boundaries. If perSeriesAligner is not specified or equals ALIGN_NONE, then this field is ignored. If perSeriesAligner is specified and does not equal ALIGN_NONE, then this field must be defined; otherwise an error is returned.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsentAggregations#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The approach to be used to combine time series. Not all reducer functions may be applied to all time series, depending on the metric type and the value type of the original time series. Reduction may change the metric type of value type of the time series.Time series data must be aligned in order to perform cross- time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned. Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsentAggregations#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when crossSeriesReducer is specified. The groupByFields determine how the time series are partitioned into subsets prior to applying the aggregation function. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The crossSeriesReducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in groupByFields are aggregated away. If groupByFields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If crossSeriesReducer is not defined, this field is ignored.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsentAggregations#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * The approach to be used to align individual time series. Not all alignment functions may be applied to all time series, depending on the metric type and value type of the original time series. Alignment may change the metric type or the value type of the time series.Time series data must be aligned in order to perform cross- time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned. Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsentAggregations#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionAbsentAggregations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionAbsentAggregations(obj: AlertPolicySpecForProviderConditionsConditionAbsentAggregations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionAbsentTrigger
 */
export interface AlertPolicySpecForProviderConditionsConditionAbsentTrigger {
  /**
   * The absolute number of time series that must fail the predicate for the condition to be triggered.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsentTrigger#count
   */
  readonly count?: number;

  /**
   * The percentage of time series that must fail the predicate for the condition to be triggered.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionAbsentTrigger#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionAbsentTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionAbsentTrigger(obj: AlertPolicySpecForProviderConditionsConditionAbsentTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger
 */
export interface AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger {
  /**
   * The absolute number of time series that must fail the predicate for the condition to be triggered.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger#count
   */
  readonly count?: number;

  /**
   * The percentage of time series that must fail the predicate for the condition to be triggered.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger(obj: AlertPolicySpecForProviderConditionsConditionMonitoringQueryLanguageTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionThresholdAggregations
 */
export interface AlertPolicySpecForProviderConditionsConditionThresholdAggregations {
  /**
   * The alignment period for per-time series alignment. If present, alignmentPeriod must be at least 60 seconds. After per-time series alignment, each time series will contain data points only on the period boundaries. If perSeriesAligner is not specified or equals ALIGN_NONE, then this field is ignored. If perSeriesAligner is specified and does not equal ALIGN_NONE, then this field must be defined; otherwise an error is returned.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdAggregations#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The approach to be used to combine time series. Not all reducer functions may be applied to all time series, depending on the metric type and the value type of the original time series. Reduction may change the metric type of value type of the time series.Time series data must be aligned in order to perform cross- time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned. Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdAggregations#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when crossSeriesReducer is specified. The groupByFields determine how the time series are partitioned into subsets prior to applying the aggregation function. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The crossSeriesReducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in groupByFields are aggregated away. If groupByFields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If crossSeriesReducer is not defined, this field is ignored.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdAggregations#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * The approach to be used to align individual time series. Not all alignment functions may be applied to all time series, depending on the metric type and value type of the original time series. Alignment may change the metric type or the value type of the time series.Time series data must be aligned in order to perform cross- time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned. Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdAggregations#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionThresholdAggregations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionThresholdAggregations(obj: AlertPolicySpecForProviderConditionsConditionThresholdAggregations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations
 */
export interface AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations {
  /**
   * The alignment period for per-time series alignment. If present, alignmentPeriod must be at least 60 seconds. After per-time series alignment, each time series will contain data points only on the period boundaries. If perSeriesAligner is not specified or equals ALIGN_NONE, then this field is ignored. If perSeriesAligner is specified and does not equal ALIGN_NONE, then this field must be defined; otherwise an error is returned.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations#alignmentPeriod
   */
  readonly alignmentPeriod?: string;

  /**
   * The approach to be used to combine time series. Not all reducer functions may be applied to all time series, depending on the metric type and the value type of the original time series. Reduction may change the metric type of value type of the time series.Time series data must be aligned in order to perform cross- time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned. Possible values are: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations#crossSeriesReducer
   */
  readonly crossSeriesReducer?: string;

  /**
   * The set of fields to preserve when crossSeriesReducer is specified. The groupByFields determine how the time series are partitioned into subsets prior to applying the aggregation function. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The crossSeriesReducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in groupByFields are aggregated away. If groupByFields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If crossSeriesReducer is not defined, this field is ignored.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations#groupByFields
   */
  readonly groupByFields?: string[];

  /**
   * The approach to be used to align individual time series. Not all alignment functions may be applied to all time series, depending on the metric type and value type of the original time series. Alignment may change the metric type or the value type of the time series.Time series data must be aligned in order to perform cross- time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned. Possible values are: ALIGN_NONE, ALIGN_DELTA, ALIGN_RATE, ALIGN_INTERPOLATE, ALIGN_NEXT_OLDER, ALIGN_MIN, ALIGN_MAX, ALIGN_MEAN, ALIGN_COUNT, ALIGN_SUM, ALIGN_STDDEV, ALIGN_COUNT_TRUE, ALIGN_COUNT_FALSE, ALIGN_FRACTION_TRUE, ALIGN_PERCENTILE_99, ALIGN_PERCENTILE_95, ALIGN_PERCENTILE_50, ALIGN_PERCENTILE_05, ALIGN_PERCENT_CHANGE.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations#perSeriesAligner
   */
  readonly perSeriesAligner?: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations(obj: AlertPolicySpecForProviderConditionsConditionThresholdDenominatorAggregations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alignmentPeriod': obj.alignmentPeriod,
    'crossSeriesReducer': obj.crossSeriesReducer,
    'groupByFields': obj.groupByFields?.map(y => y),
    'perSeriesAligner': obj.perSeriesAligner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions
 */
export interface AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions {
  /**
   * The length of time into the future to forecast whether a timeseries will violate the threshold. If the predicted value is found to violate the threshold, and the violation is observed in all forecasts made for the Configured duration, then the timeseries is considered to be failing.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions#forecastHorizon
   */
  readonly forecastHorizon: string;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions(obj: AlertPolicySpecForProviderConditionsConditionThresholdForecastOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forecastHorizon': obj.forecastHorizon,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AlertPolicySpecForProviderConditionsConditionThresholdTrigger
 */
export interface AlertPolicySpecForProviderConditionsConditionThresholdTrigger {
  /**
   * The absolute number of time series that must fail the predicate for the condition to be triggered.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdTrigger#count
   */
  readonly count?: number;

  /**
   * The percentage of time series that must fail the predicate for the condition to be triggered.
   *
   * @schema AlertPolicySpecForProviderConditionsConditionThresholdTrigger#percent
   */
  readonly percent?: number;

}

/**
 * Converts an object of type 'AlertPolicySpecForProviderConditionsConditionThresholdTrigger' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AlertPolicySpecForProviderConditionsConditionThresholdTrigger(obj: AlertPolicySpecForProviderConditionsConditionThresholdTrigger | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'percent': obj.percent,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AlertPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AlertPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AlertPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AlertPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CustomService is the Schema for the CustomServices API. A Service is a discrete, autonomous, and network-accessible unit, designed to solve an individual concern (Wikipedia).
 *
 * @schema CustomService
 */
export class CustomService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'CustomService',
  }

  /**
   * Renders a Kubernetes manifest for "CustomService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomServiceProps): any {
    return {
      ...CustomService.GVK,
      ...toJson_CustomServiceProps(props),
    };
  }

  /**
   * Defines a "CustomService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomServiceProps) {
    super(scope, id, {
      ...CustomService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomService.GVK,
      ...toJson_CustomServiceProps(resolved),
    };
  }
}

/**
 * CustomService is the Schema for the CustomServices API. A Service is a discrete, autonomous, and network-accessible unit, designed to solve an individual concern (Wikipedia).
 *
 * @schema CustomService
 */
export interface CustomServiceProps {
  /**
   * @schema CustomService#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomServiceSpec defines the desired state of CustomService
   *
   * @schema CustomService#spec
   */
  readonly spec: CustomServiceSpec;

}

/**
 * Converts an object of type 'CustomServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceProps(obj: CustomServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomServiceSpec defines the desired state of CustomService
 *
 * @schema CustomServiceSpec
 */
export interface CustomServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: CustomServiceSpecDeletionPolicy;

  /**
   * @schema CustomServiceSpec#forProvider
   */
  readonly forProvider: CustomServiceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomServiceSpec#managementPolicy
   */
  readonly managementPolicy?: CustomServiceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CustomServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: CustomServiceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CustomServiceSpec#providerRef
   */
  readonly providerRef?: CustomServiceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CustomServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CustomServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpec(obj: CustomServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomServiceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CustomServiceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CustomServiceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CustomServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomServiceSpecDeletionPolicy
 */
export enum CustomServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomServiceSpecForProvider
 */
export interface CustomServiceSpecForProvider {
  /**
   * Name used for UI elements listing this Service.
   *
   * @schema CustomServiceSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema CustomServiceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * An optional service ID to use. If not given, the server will generate a service ID.
   *
   * @schema CustomServiceSpecForProvider#serviceId
   */
  readonly serviceId?: string;

  /**
   * Configuration for how to query telemetry on a Service. Structure is documented below.
   *
   * @schema CustomServiceSpecForProvider#telemetry
   */
  readonly telemetry?: CustomServiceSpecForProviderTelemetry[];

  /**
   * Labels which have been used to annotate the service. Label keys must start with a letter. Label keys and values may contain lowercase letters, numbers, underscores, and dashes. Label keys and values have a maximum length of 63 characters, and must be less than 128 bytes in size. Up to 64 label entries may be stored. For labels which do not have a semantic value, the empty string may be supplied for the label value.
   *
   * @schema CustomServiceSpecForProvider#userLabels
   */
  readonly userLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CustomServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecForProvider(obj: CustomServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'project': obj.project,
    'serviceId': obj.serviceId,
    'telemetry': obj.telemetry?.map(y => toJson_CustomServiceSpecForProviderTelemetry(y)),
    'userLabels': ((obj.userLabels) === undefined) ? undefined : (Object.entries(obj.userLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomServiceSpecManagementPolicy
 */
export enum CustomServiceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CustomServiceSpecProviderConfigRef
 */
export interface CustomServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomServiceSpecProviderConfigRef#policy
   */
  readonly policy?: CustomServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecProviderConfigRef(obj: CustomServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CustomServiceSpecProviderRef
 */
export interface CustomServiceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomServiceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomServiceSpecProviderRef#policy
   */
  readonly policy?: CustomServiceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CustomServiceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecProviderRef(obj: CustomServiceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomServiceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CustomServiceSpecPublishConnectionDetailsTo
 */
export interface CustomServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecPublishConnectionDetailsTo(obj: CustomServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CustomServiceSpecWriteConnectionSecretToRef
 */
export interface CustomServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecWriteConnectionSecretToRef(obj: CustomServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomServiceSpecForProviderTelemetry
 */
export interface CustomServiceSpecForProviderTelemetry {
  /**
   * The full name of the resource that defines this service. Formatted as described in https://cloud.google.com/apis/design/resource_names.
   *
   * @schema CustomServiceSpecForProviderTelemetry#resourceName
   */
  readonly resourceName?: string;

}

/**
 * Converts an object of type 'CustomServiceSpecForProviderTelemetry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecForProviderTelemetry(obj: CustomServiceSpecForProviderTelemetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceName': obj.resourceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomServiceSpecProviderConfigRefPolicy
 */
export interface CustomServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecProviderConfigRefPolicy(obj: CustomServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomServiceSpecProviderRefPolicy
 */
export interface CustomServiceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomServiceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CustomServiceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomServiceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CustomServiceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomServiceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecProviderRefPolicy(obj: CustomServiceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CustomServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface CustomServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecPublishConnectionDetailsToConfigRef(obj: CustomServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomServiceSpecPublishConnectionDetailsToMetadata
 */
export interface CustomServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecPublishConnectionDetailsToMetadata(obj: CustomServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomServiceSpecProviderConfigRefPolicyResolution
 */
export enum CustomServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomServiceSpecProviderConfigRefPolicyResolve
 */
export enum CustomServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomServiceSpecProviderRefPolicyResolution
 */
export enum CustomServiceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomServiceSpecProviderRefPolicyResolve
 */
export enum CustomServiceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Dashboard is the Schema for the Dashboards API. A Google Stackdriver dashboard.
 *
 * @schema Dashboard
 */
export class Dashboard extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Dashboard"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'Dashboard',
  }

  /**
   * Renders a Kubernetes manifest for "Dashboard".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DashboardProps): any {
    return {
      ...Dashboard.GVK,
      ...toJson_DashboardProps(props),
    };
  }

  /**
   * Defines a "Dashboard" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DashboardProps) {
    super(scope, id, {
      ...Dashboard.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Dashboard.GVK,
      ...toJson_DashboardProps(resolved),
    };
  }
}

/**
 * Dashboard is the Schema for the Dashboards API. A Google Stackdriver dashboard.
 *
 * @schema Dashboard
 */
export interface DashboardProps {
  /**
   * @schema Dashboard#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DashboardSpec defines the desired state of Dashboard
   *
   * @schema Dashboard#spec
   */
  readonly spec: DashboardSpec;

}

/**
 * Converts an object of type 'DashboardProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardProps(obj: DashboardProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DashboardSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DashboardSpec defines the desired state of Dashboard
 *
 * @schema DashboardSpec
 */
export interface DashboardSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DashboardSpec#deletionPolicy
   */
  readonly deletionPolicy?: DashboardSpecDeletionPolicy;

  /**
   * @schema DashboardSpec#forProvider
   */
  readonly forProvider: DashboardSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DashboardSpec#managementPolicy
   */
  readonly managementPolicy?: DashboardSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DashboardSpec#providerConfigRef
   */
  readonly providerConfigRef?: DashboardSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DashboardSpec#providerRef
   */
  readonly providerRef?: DashboardSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DashboardSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DashboardSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DashboardSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DashboardSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DashboardSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpec(obj: DashboardSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DashboardSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DashboardSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DashboardSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DashboardSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DashboardSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DashboardSpecDeletionPolicy
 */
export enum DashboardSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DashboardSpecForProvider
 */
export interface DashboardSpecForProvider {
  /**
   * The JSON representation of a dashboard, following the format at https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards. The representation of an existing dashboard can be found by using the API Explorer
   *
   * @schema DashboardSpecForProvider#dashboardJson
   */
  readonly dashboardJson?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DashboardSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'DashboardSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecForProvider(obj: DashboardSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dashboardJson': obj.dashboardJson,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DashboardSpecManagementPolicy
 */
export enum DashboardSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DashboardSpecProviderConfigRef
 */
export interface DashboardSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DashboardSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DashboardSpecProviderConfigRef#policy
   */
  readonly policy?: DashboardSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DashboardSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecProviderConfigRef(obj: DashboardSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DashboardSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DashboardSpecProviderRef
 */
export interface DashboardSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DashboardSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DashboardSpecProviderRef#policy
   */
  readonly policy?: DashboardSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DashboardSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecProviderRef(obj: DashboardSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DashboardSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DashboardSpecPublishConnectionDetailsTo
 */
export interface DashboardSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DashboardSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DashboardSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DashboardSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DashboardSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DashboardSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsTo(obj: DashboardSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DashboardSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DashboardSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DashboardSpecWriteConnectionSecretToRef
 */
export interface DashboardSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DashboardSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DashboardSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DashboardSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecWriteConnectionSecretToRef(obj: DashboardSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DashboardSpecProviderConfigRefPolicy
 */
export interface DashboardSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DashboardSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DashboardSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DashboardSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DashboardSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DashboardSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecProviderConfigRefPolicy(obj: DashboardSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DashboardSpecProviderRefPolicy
 */
export interface DashboardSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DashboardSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DashboardSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DashboardSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DashboardSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DashboardSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecProviderRefPolicy(obj: DashboardSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRef
 */
export interface DashboardSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DashboardSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsToConfigRef(obj: DashboardSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DashboardSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DashboardSpecPublishConnectionDetailsToMetadata
 */
export interface DashboardSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DashboardSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DashboardSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DashboardSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsToMetadata(obj: DashboardSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DashboardSpecProviderConfigRefPolicyResolution
 */
export enum DashboardSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DashboardSpecProviderConfigRefPolicyResolve
 */
export enum DashboardSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DashboardSpecProviderRefPolicyResolution
 */
export enum DashboardSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DashboardSpecProviderRefPolicyResolve
 */
export enum DashboardSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DashboardSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DashboardSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DashboardSpecPublishConnectionDetailsToConfigRefPolicy(obj: DashboardSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DashboardSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Group is the Schema for the Groups API. The description of a dynamic collection of monitored resources.
 *
 * @schema Group
 */
export class Group extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Group"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'Group',
  }

  /**
   * Renders a Kubernetes manifest for "Group".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GroupProps): any {
    return {
      ...Group.GVK,
      ...toJson_GroupProps(props),
    };
  }

  /**
   * Defines a "Group" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GroupProps) {
    super(scope, id, {
      ...Group.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Group.GVK,
      ...toJson_GroupProps(resolved),
    };
  }
}

/**
 * Group is the Schema for the Groups API. The description of a dynamic collection of monitored resources.
 *
 * @schema Group
 */
export interface GroupProps {
  /**
   * @schema Group#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GroupSpec defines the desired state of Group
   *
   * @schema Group#spec
   */
  readonly spec: GroupSpec;

}

/**
 * Converts an object of type 'GroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupProps(obj: GroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupSpec defines the desired state of Group
 *
 * @schema GroupSpec
 */
export interface GroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: GroupSpecDeletionPolicy;

  /**
   * @schema GroupSpec#forProvider
   */
  readonly forProvider: GroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GroupSpec#managementPolicy
   */
  readonly managementPolicy?: GroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: GroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GroupSpec#providerRef
   */
  readonly providerRef?: GroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpec(obj: GroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_GroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GroupSpecDeletionPolicy
 */
export enum GroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GroupSpecForProvider
 */
export interface GroupSpecForProvider {
  /**
   * A user-assigned name for this group, used only for display purposes.
   *
   * @schema GroupSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The filter used to determine which monitored resources belong to this group.
   *
   * @schema GroupSpecForProvider#filter
   */
  readonly filter?: string;

  /**
   * If true, the members of this group are considered to be a cluster. The system can perform additional analysis on groups that are clusters.
   *
   * @schema GroupSpecForProvider#isCluster
   */
  readonly isCluster?: boolean;

  /**
   * The name of the group's parent, if it has one. The format is "projects/{project_id_or_number}/groups/{group_id}". For groups with no parent, parentName is the empty string, "".
   *
   * @schema GroupSpecForProvider#parentName
   */
  readonly parentName?: string;

  /**
   * Reference to a Group in monitoring to populate parentName.
   *
   * @schema GroupSpecForProvider#parentNameRef
   */
  readonly parentNameRef?: GroupSpecForProviderParentNameRef;

  /**
   * Selector for a Group in monitoring to populate parentName.
   *
   * @schema GroupSpecForProvider#parentNameSelector
   */
  readonly parentNameSelector?: GroupSpecForProviderParentNameSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema GroupSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'GroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProvider(obj: GroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'filter': obj.filter,
    'isCluster': obj.isCluster,
    'parentName': obj.parentName,
    'parentNameRef': toJson_GroupSpecForProviderParentNameRef(obj.parentNameRef),
    'parentNameSelector': toJson_GroupSpecForProviderParentNameSelector(obj.parentNameSelector),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GroupSpecManagementPolicy
 */
export enum GroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GroupSpecProviderConfigRef
 */
export interface GroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecProviderConfigRef#policy
   */
  readonly policy?: GroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderConfigRef(obj: GroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GroupSpecProviderRef
 */
export interface GroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecProviderRef#policy
   */
  readonly policy?: GroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderRef(obj: GroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GroupSpecPublishConnectionDetailsTo
 */
export interface GroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsTo(obj: GroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GroupSpecWriteConnectionSecretToRef
 */
export interface GroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecWriteConnectionSecretToRef(obj: GroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Group in monitoring to populate parentName.
 *
 * @schema GroupSpecForProviderParentNameRef
 */
export interface GroupSpecForProviderParentNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecForProviderParentNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecForProviderParentNameRef#policy
   */
  readonly policy?: GroupSpecForProviderParentNameRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecForProviderParentNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderParentNameRef(obj: GroupSpecForProviderParentNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecForProviderParentNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in monitoring to populate parentName.
 *
 * @schema GroupSpecForProviderParentNameSelector
 */
export interface GroupSpecForProviderParentNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GroupSpecForProviderParentNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupSpecForProviderParentNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupSpecForProviderParentNameSelector#policy
   */
  readonly policy?: GroupSpecForProviderParentNameSelectorPolicy;

}

/**
 * Converts an object of type 'GroupSpecForProviderParentNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderParentNameSelector(obj: GroupSpecForProviderParentNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupSpecForProviderParentNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupSpecProviderConfigRefPolicy
 */
export interface GroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderConfigRefPolicy(obj: GroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupSpecProviderRefPolicy
 */
export interface GroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderRefPolicy(obj: GroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRef
 */
export interface GroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToConfigRef(obj: GroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GroupSpecPublishConnectionDetailsToMetadata
 */
export interface GroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToMetadata(obj: GroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupSpecForProviderParentNameRefPolicy
 */
export interface GroupSpecForProviderParentNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecForProviderParentNameRefPolicy#resolution
   */
  readonly resolution?: GroupSpecForProviderParentNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecForProviderParentNameRefPolicy#resolve
   */
  readonly resolve?: GroupSpecForProviderParentNameRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecForProviderParentNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderParentNameRefPolicy(obj: GroupSpecForProviderParentNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupSpecForProviderParentNameSelectorPolicy
 */
export interface GroupSpecForProviderParentNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecForProviderParentNameSelectorPolicy#resolution
   */
  readonly resolution?: GroupSpecForProviderParentNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecForProviderParentNameSelectorPolicy#resolve
   */
  readonly resolve?: GroupSpecForProviderParentNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecForProviderParentNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProviderParentNameSelectorPolicy(obj: GroupSpecForProviderParentNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecProviderConfigRefPolicyResolution
 */
export enum GroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecProviderConfigRefPolicyResolve
 */
export enum GroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecProviderRefPolicyResolution
 */
export enum GroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecProviderRefPolicyResolve
 */
export enum GroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: GroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecForProviderParentNameRefPolicyResolution
 */
export enum GroupSpecForProviderParentNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecForProviderParentNameRefPolicyResolve
 */
export enum GroupSpecForProviderParentNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecForProviderParentNameSelectorPolicyResolution
 */
export enum GroupSpecForProviderParentNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecForProviderParentNameSelectorPolicyResolve
 */
export enum GroupSpecForProviderParentNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MetricDescriptor is the Schema for the MetricDescriptors API. Defines a metric type and its schema.
 *
 * @schema MetricDescriptor
 */
export class MetricDescriptor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MetricDescriptor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'MetricDescriptor',
  }

  /**
   * Renders a Kubernetes manifest for "MetricDescriptor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MetricDescriptorProps): any {
    return {
      ...MetricDescriptor.GVK,
      ...toJson_MetricDescriptorProps(props),
    };
  }

  /**
   * Defines a "MetricDescriptor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MetricDescriptorProps) {
    super(scope, id, {
      ...MetricDescriptor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MetricDescriptor.GVK,
      ...toJson_MetricDescriptorProps(resolved),
    };
  }
}

/**
 * MetricDescriptor is the Schema for the MetricDescriptors API. Defines a metric type and its schema.
 *
 * @schema MetricDescriptor
 */
export interface MetricDescriptorProps {
  /**
   * @schema MetricDescriptor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MetricDescriptorSpec defines the desired state of MetricDescriptor
   *
   * @schema MetricDescriptor#spec
   */
  readonly spec: MetricDescriptorSpec;

}

/**
 * Converts an object of type 'MetricDescriptorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorProps(obj: MetricDescriptorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MetricDescriptorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetricDescriptorSpec defines the desired state of MetricDescriptor
 *
 * @schema MetricDescriptorSpec
 */
export interface MetricDescriptorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MetricDescriptorSpec#deletionPolicy
   */
  readonly deletionPolicy?: MetricDescriptorSpecDeletionPolicy;

  /**
   * @schema MetricDescriptorSpec#forProvider
   */
  readonly forProvider: MetricDescriptorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MetricDescriptorSpec#managementPolicy
   */
  readonly managementPolicy?: MetricDescriptorSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MetricDescriptorSpec#providerConfigRef
   */
  readonly providerConfigRef?: MetricDescriptorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MetricDescriptorSpec#providerRef
   */
  readonly providerRef?: MetricDescriptorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MetricDescriptorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MetricDescriptorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MetricDescriptorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MetricDescriptorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MetricDescriptorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpec(obj: MetricDescriptorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MetricDescriptorSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MetricDescriptorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MetricDescriptorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MetricDescriptorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MetricDescriptorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MetricDescriptorSpecDeletionPolicy
 */
export enum MetricDescriptorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MetricDescriptorSpecForProvider
 */
export interface MetricDescriptorSpecForProvider {
  /**
   * A detailed description of the metric, which can be used in documentation.
   *
   * @schema MetricDescriptorSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example "Request count".
   *
   * @schema MetricDescriptorSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The set of labels that can be used to describe a specific instance of this metric type. In order to delete a label, the entire resource must be deleted, then created with the desired labels. Structure is documented below.
   *
   * @schema MetricDescriptorSpecForProvider#labels
   */
  readonly labels?: MetricDescriptorSpecForProviderLabels[];

  /**
   * The launch stage of the metric definition. Possible values are: LAUNCH_STAGE_UNSPECIFIED, UNIMPLEMENTED, PRELAUNCH, EARLY_ACCESS, ALPHA, BETA, GA, DEPRECATED.
   *
   * @schema MetricDescriptorSpecForProvider#launchStage
   */
  readonly launchStage?: string;

  /**
   * Metadata which can be used to guide usage of the metric. Structure is documented below.
   *
   * @schema MetricDescriptorSpecForProvider#metadata
   */
  readonly metadata?: MetricDescriptorSpecForProviderMetadata[];

  /**
   * Whether the metric records instantaneous values, changes to a value, etc. Some combinations of metricKind and valueType might not be supported. Possible values are: METRIC_KIND_UNSPECIFIED, GAUGE, DELTA, CUMULATIVE.
   *
   * @schema MetricDescriptorSpecForProvider#metricKind
   */
  readonly metricKind?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema MetricDescriptorSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The metric type, including its DNS name prefix. The type is not URL-encoded. All service defined metrics must be prefixed with the service name, in the format of {service name}/{relative metric name}, such as cloudsql.googleapis.com/database/cpu/utilization. The relative metric name must have only upper and lower-case letters, digits, '/' and underscores '_' are allowed. Additionally, the maximum number of characters allowed for the relative_metric_name is 100. All user-defined metric types have the DNS name custom.googleapis.com, external.googleapis.com, or logging.googleapis.com/user/.
   *
   * @schema MetricDescriptorSpecForProvider#type
   */
  readonly type?: string;

  /**
   * The units in which the metric value is reported. It is only applicable if the valueType is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of the stored metric values. Different systems may scale the values to be more easily displayed (so a value of 0.02KBy might be displayed as 20By, and a value of 3523KBy might be displayed as 3.5MBy). However, if the unit is KBy, then the value of the metric is always in thousands of bytes, no matter how it may be displayed. If you want a custom metric to record the exact number of CPU-seconds used by a job, you can create an INT64 CUMULATIVE metric whose unit is s{CPU} (or equivalently 1s{CPU} or just s). If the job uses 12,005 CPU-seconds, then the value is written as 12005. Alternatively, if you want a custom metric to record data in a more granular way, you can create a DOUBLE CUMULATIVE metric whose unit is ks{CPU}, and then write the value 12.005 (which is 12005/1000), or use Kis{CPU} and write 11.723 (which is 12005/1024). The supported units are a subset of The Unified Code for Units of Measure standard. More info can be found in the API documentation (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors).
   *
   * @schema MetricDescriptorSpecForProvider#unit
   */
  readonly unit?: string;

  /**
   * Whether the measurement is an integer, a floating-point number, etc. Some combinations of metricKind and valueType might not be supported. Possible values are: BOOL, INT64, DOUBLE, STRING, DISTRIBUTION.
   *
   * @schema MetricDescriptorSpecForProvider#valueType
   */
  readonly valueType?: string;

}

/**
 * Converts an object of type 'MetricDescriptorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecForProvider(obj: MetricDescriptorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'labels': obj.labels?.map(y => toJson_MetricDescriptorSpecForProviderLabels(y)),
    'launchStage': obj.launchStage,
    'metadata': obj.metadata?.map(y => toJson_MetricDescriptorSpecForProviderMetadata(y)),
    'metricKind': obj.metricKind,
    'project': obj.project,
    'type': obj.type,
    'unit': obj.unit,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MetricDescriptorSpecManagementPolicy
 */
export enum MetricDescriptorSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MetricDescriptorSpecProviderConfigRef
 */
export interface MetricDescriptorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricDescriptorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricDescriptorSpecProviderConfigRef#policy
   */
  readonly policy?: MetricDescriptorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricDescriptorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecProviderConfigRef(obj: MetricDescriptorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricDescriptorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MetricDescriptorSpecProviderRef
 */
export interface MetricDescriptorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricDescriptorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricDescriptorSpecProviderRef#policy
   */
  readonly policy?: MetricDescriptorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MetricDescriptorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecProviderRef(obj: MetricDescriptorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricDescriptorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MetricDescriptorSpecPublishConnectionDetailsTo
 */
export interface MetricDescriptorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MetricDescriptorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MetricDescriptorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MetricDescriptorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecPublishConnectionDetailsTo(obj: MetricDescriptorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MetricDescriptorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MetricDescriptorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MetricDescriptorSpecWriteConnectionSecretToRef
 */
export interface MetricDescriptorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MetricDescriptorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MetricDescriptorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MetricDescriptorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecWriteConnectionSecretToRef(obj: MetricDescriptorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricDescriptorSpecForProviderLabels
 */
export interface MetricDescriptorSpecForProviderLabels {
  /**
   * A human-readable description for the label.
   *
   * @schema MetricDescriptorSpecForProviderLabels#description
   */
  readonly description?: string;

  /**
   * The key for this label. The key must not exceed 100 characters. The first character of the key must be an upper- or lower-case letter, the remaining characters must be letters, digits or underscores, and the key must match the regular expression [a-zA-Z][a-zA-Z0-9_]*
   *
   * @schema MetricDescriptorSpecForProviderLabels#key
   */
  readonly key: string;

  /**
   * The type of data that can be assigned to the label. Default value is STRING. Possible values are: STRING, BOOL, INT64.
   *
   * @schema MetricDescriptorSpecForProviderLabels#valueType
   */
  readonly valueType?: string;

}

/**
 * Converts an object of type 'MetricDescriptorSpecForProviderLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecForProviderLabels(obj: MetricDescriptorSpecForProviderLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'key': obj.key,
    'valueType': obj.valueType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MetricDescriptorSpecForProviderMetadata
 */
export interface MetricDescriptorSpecForProviderMetadata {
  /**
   * The delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors. In [duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration).
   *
   * @schema MetricDescriptorSpecForProviderMetadata#ingestDelay
   */
  readonly ingestDelay?: string;

  /**
   * The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period. In [duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration).
   *
   * @schema MetricDescriptorSpecForProviderMetadata#samplePeriod
   */
  readonly samplePeriod?: string;

}

/**
 * Converts an object of type 'MetricDescriptorSpecForProviderMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecForProviderMetadata(obj: MetricDescriptorSpecForProviderMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ingestDelay': obj.ingestDelay,
    'samplePeriod': obj.samplePeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricDescriptorSpecProviderConfigRefPolicy
 */
export interface MetricDescriptorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricDescriptorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MetricDescriptorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricDescriptorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MetricDescriptorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricDescriptorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecProviderConfigRefPolicy(obj: MetricDescriptorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricDescriptorSpecProviderRefPolicy
 */
export interface MetricDescriptorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricDescriptorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MetricDescriptorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricDescriptorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MetricDescriptorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricDescriptorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecProviderRefPolicy(obj: MetricDescriptorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRef
 */
export interface MetricDescriptorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricDescriptorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecPublishConnectionDetailsToConfigRef(obj: MetricDescriptorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MetricDescriptorSpecPublishConnectionDetailsToMetadata
 */
export interface MetricDescriptorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MetricDescriptorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecPublishConnectionDetailsToMetadata(obj: MetricDescriptorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricDescriptorSpecProviderConfigRefPolicyResolution
 */
export enum MetricDescriptorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricDescriptorSpecProviderConfigRefPolicyResolve
 */
export enum MetricDescriptorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricDescriptorSpecProviderRefPolicyResolution
 */
export enum MetricDescriptorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricDescriptorSpecProviderRefPolicyResolve
 */
export enum MetricDescriptorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy(obj: MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MetricDescriptorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * NotificationChannel is the Schema for the NotificationChannels API. A NotificationChannel is a medium through which an alert is delivered when a policy violation is detected.
 *
 * @schema NotificationChannel
 */
export class NotificationChannel extends ApiObject {
  /**
   * Returns the apiVersion and kind for "NotificationChannel"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'NotificationChannel',
  }

  /**
   * Renders a Kubernetes manifest for "NotificationChannel".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NotificationChannelProps): any {
    return {
      ...NotificationChannel.GVK,
      ...toJson_NotificationChannelProps(props),
    };
  }

  /**
   * Defines a "NotificationChannel" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NotificationChannelProps) {
    super(scope, id, {
      ...NotificationChannel.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...NotificationChannel.GVK,
      ...toJson_NotificationChannelProps(resolved),
    };
  }
}

/**
 * NotificationChannel is the Schema for the NotificationChannels API. A NotificationChannel is a medium through which an alert is delivered when a policy violation is detected.
 *
 * @schema NotificationChannel
 */
export interface NotificationChannelProps {
  /**
   * @schema NotificationChannel#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NotificationChannelSpec defines the desired state of NotificationChannel
   *
   * @schema NotificationChannel#spec
   */
  readonly spec: NotificationChannelSpec;

}

/**
 * Converts an object of type 'NotificationChannelProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelProps(obj: NotificationChannelProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NotificationChannelSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NotificationChannelSpec defines the desired state of NotificationChannel
 *
 * @schema NotificationChannelSpec
 */
export interface NotificationChannelSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NotificationChannelSpec#deletionPolicy
   */
  readonly deletionPolicy?: NotificationChannelSpecDeletionPolicy;

  /**
   * @schema NotificationChannelSpec#forProvider
   */
  readonly forProvider: NotificationChannelSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema NotificationChannelSpec#managementPolicy
   */
  readonly managementPolicy?: NotificationChannelSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NotificationChannelSpec#providerConfigRef
   */
  readonly providerConfigRef?: NotificationChannelSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema NotificationChannelSpec#providerRef
   */
  readonly providerRef?: NotificationChannelSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NotificationChannelSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NotificationChannelSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NotificationChannelSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NotificationChannelSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NotificationChannelSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpec(obj: NotificationChannelSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NotificationChannelSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_NotificationChannelSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_NotificationChannelSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_NotificationChannelSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NotificationChannelSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NotificationChannelSpecDeletionPolicy
 */
export enum NotificationChannelSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NotificationChannelSpecForProvider
 */
export interface NotificationChannelSpecForProvider {
  /**
   * An optional human-readable description of this notification channel. This description may provide additional details, beyond the display name, for the channel. This may not exceed 1024 Unicode characters.
   *
   * @schema NotificationChannelSpecForProvider#description
   */
  readonly description?: string;

  /**
   * An optional human-readable name for this notification channel. It is recommended that you specify a non-empty and unique name in order to make it easier to identify the channels in your project, though this is not enforced. The display name is limited to 512 Unicode characters.
   *
   * @schema NotificationChannelSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Whether notifications are forwarded to the described channel. This makes it possible to disable delivery of notifications to a particular channel without removing the channel from all alerting policies that reference the channel. This is a more convenient approach when the change is temporary and you want to receive notifications from the same set of alerting policies on the channel at some point in the future.
   *
   * @schema NotificationChannelSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * If true, the notification channel will be deleted regardless of its use in alert policies (the policies will be updated to remove the channel). If false, channels that are still referenced by an existing alerting policy will fail to be deleted in a delete operation.
   *
   * @schema NotificationChannelSpecForProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * Configuration fields that define the channel and its behavior. The permissible and required labels are specified in the NotificationChannelDescriptor corresponding to the type field. They can also be configured via the sensitive_labels block, but cannot be configured in both places.
   *
   * @schema NotificationChannelSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema NotificationChannelSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Different notification type behaviors are configured primarily using the the labels field on this resource. This block contains the labels which contain secrets or passwords so that they can be marked sensitive and hidden from plan output. The name of the field, eg: password, will be the key in the labels map in the api request. Credentials may not be specified in both locations and will cause an error. Changing from one location to a different credential configuration in the config will require an apply to update state. Structure is documented below.
   *
   * @schema NotificationChannelSpecForProvider#sensitiveLabels
   */
  readonly sensitiveLabels?: NotificationChannelSpecForProviderSensitiveLabels[];

  /**
   * The type of the notification channel. This field matches the value of the NotificationChannelDescriptor.type field. See https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list to get the list of valid values such as "email", "slack", etc...
   *
   * @schema NotificationChannelSpecForProvider#type
   */
  readonly type?: string;

  /**
   * User-supplied key/value data that does not need to conform to the corresponding NotificationChannelDescriptor's schema, unlike the labels field. This field is intended to be used for organizing and identifying the NotificationChannel objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
   *
   * @schema NotificationChannelSpecForProvider#userLabels
   */
  readonly userLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'NotificationChannelSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecForProvider(obj: NotificationChannelSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'enabled': obj.enabled,
    'forceDelete': obj.forceDelete,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
    'sensitiveLabels': obj.sensitiveLabels?.map(y => toJson_NotificationChannelSpecForProviderSensitiveLabels(y)),
    'type': obj.type,
    'userLabels': ((obj.userLabels) === undefined) ? undefined : (Object.entries(obj.userLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema NotificationChannelSpecManagementPolicy
 */
export enum NotificationChannelSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NotificationChannelSpecProviderConfigRef
 */
export interface NotificationChannelSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationChannelSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationChannelSpecProviderConfigRef#policy
   */
  readonly policy?: NotificationChannelSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationChannelSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecProviderConfigRef(obj: NotificationChannelSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationChannelSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema NotificationChannelSpecProviderRef
 */
export interface NotificationChannelSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationChannelSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationChannelSpecProviderRef#policy
   */
  readonly policy?: NotificationChannelSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'NotificationChannelSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecProviderRef(obj: NotificationChannelSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationChannelSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NotificationChannelSpecPublishConnectionDetailsTo
 */
export interface NotificationChannelSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NotificationChannelSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NotificationChannelSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NotificationChannelSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecPublishConnectionDetailsTo(obj: NotificationChannelSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NotificationChannelSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NotificationChannelSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NotificationChannelSpecWriteConnectionSecretToRef
 */
export interface NotificationChannelSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NotificationChannelSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotificationChannelSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotificationChannelSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecWriteConnectionSecretToRef(obj: NotificationChannelSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NotificationChannelSpecForProviderSensitiveLabels
 */
export interface NotificationChannelSpecForProviderSensitiveLabels {
  /**
   * An authorization token for a notification channel. Channel types that support this field include: slack Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabels#authTokenSecretRef
   */
  readonly authTokenSecretRef?: NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef;

  /**
   * An password for a notification channel. Channel types that support this field include: webhook_basicauth Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabels#passwordSecretRef
   */
  readonly passwordSecretRef?: NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef;

  /**
   * An servicekey token for a notification channel. Channel types that support this field include: pagerduty Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabels#serviceKeySecretRef
   */
  readonly serviceKeySecretRef?: NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef;

}

/**
 * Converts an object of type 'NotificationChannelSpecForProviderSensitiveLabels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecForProviderSensitiveLabels(obj: NotificationChannelSpecForProviderSensitiveLabels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authTokenSecretRef': toJson_NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef(obj.authTokenSecretRef),
    'passwordSecretRef': toJson_NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef(obj.passwordSecretRef),
    'serviceKeySecretRef': toJson_NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef(obj.serviceKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationChannelSpecProviderConfigRefPolicy
 */
export interface NotificationChannelSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationChannelSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationChannelSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationChannelSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationChannelSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationChannelSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecProviderConfigRefPolicy(obj: NotificationChannelSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NotificationChannelSpecProviderRefPolicy
 */
export interface NotificationChannelSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationChannelSpecProviderRefPolicy#resolution
   */
  readonly resolution?: NotificationChannelSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationChannelSpecProviderRefPolicy#resolve
   */
  readonly resolve?: NotificationChannelSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationChannelSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecProviderRefPolicy(obj: NotificationChannelSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRef
 */
export interface NotificationChannelSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NotificationChannelSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecPublishConnectionDetailsToConfigRef(obj: NotificationChannelSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NotificationChannelSpecPublishConnectionDetailsToMetadata
 */
export interface NotificationChannelSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NotificationChannelSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecPublishConnectionDetailsToMetadata(obj: NotificationChannelSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An authorization token for a notification channel. Channel types that support this field include: slack Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef
 */
export interface NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef {
  /**
   * The key to select.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef(obj: NotificationChannelSpecForProviderSensitiveLabelsAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An password for a notification channel. Channel types that support this field include: webhook_basicauth Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef
 */
export interface NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef(obj: NotificationChannelSpecForProviderSensitiveLabelsPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An servicekey token for a notification channel. Channel types that support this field include: pagerduty Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef
 */
export interface NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef {
  /**
   * The key to select.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef(obj: NotificationChannelSpecForProviderSensitiveLabelsServiceKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationChannelSpecProviderConfigRefPolicyResolution
 */
export enum NotificationChannelSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationChannelSpecProviderConfigRefPolicyResolve
 */
export enum NotificationChannelSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationChannelSpecProviderRefPolicyResolution
 */
export enum NotificationChannelSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationChannelSpecProviderRefPolicyResolve
 */
export enum NotificationChannelSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy(obj: NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NotificationChannelSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Service is the Schema for the Services API. A Service is a discrete, autonomous, and network-accessible unit, designed to solve an individual concern (Wikipedia).
 *
 * @schema Service
 */
export class Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'Service',
  }

  /**
   * Renders a Kubernetes manifest for "Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceProps): any {
    return {
      ...Service.GVK,
      ...toJson_ServiceProps(props),
    };
  }

  /**
   * Defines a "Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id, {
      ...Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Service.GVK,
      ...toJson_ServiceProps(resolved),
    };
  }
}

/**
 * Service is the Schema for the Services API. A Service is a discrete, autonomous, and network-accessible unit, designed to solve an individual concern (Wikipedia).
 *
 * @schema Service
 */
export interface ServiceProps {
  /**
   * @schema Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSpec defines the desired state of Service
   *
   * @schema Service#spec
   */
  readonly spec: ServiceSpec;

}

/**
 * Converts an object of type 'ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceProps(obj: ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines the desired state of Service
 *
 * @schema ServiceSpec
 */
export interface ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSpecDeletionPolicy;

  /**
   * @schema ServiceSpec#forProvider
   */
  readonly forProvider: ServiceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#managementPolicy
   */
  readonly managementPolicy?: ServiceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ServiceSpec#providerRef
   */
  readonly providerRef?: ServiceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpec(obj: ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ServiceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecDeletionPolicy
 */
export enum ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceSpecForProvider
 */
export interface ServiceSpecForProvider {
  /**
   * A well-known service type, defined by its service type and service labels. Valid values of service types and services labels are described at https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli Structure is documented below.
   *
   * @schema ServiceSpecForProvider#basicService
   */
  readonly basicService?: ServiceSpecForProviderBasicService[];

  /**
   * Name used for UI elements listing this Service.
   *
   * @schema ServiceSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema ServiceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Labels which have been used to annotate the service. Label keys must start with a letter. Label keys and values may contain lowercase letters, numbers, underscores, and dashes. Label keys and values have a maximum length of 63 characters, and must be less than 128 bytes in size. Up to 64 label entries may be stored. For labels which do not have a semantic value, the empty string may be supplied for the label value.
   *
   * @schema ServiceSpecForProvider#userLabels
   */
  readonly userLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProvider(obj: ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicService': obj.basicService?.map(y => toJson_ServiceSpecForProviderBasicService(y)),
    'displayName': obj.displayName,
    'project': obj.project,
    'userLabels': ((obj.userLabels) === undefined) ? undefined : (Object.entries(obj.userLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecManagementPolicy
 */
export enum ServiceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSpecProviderConfigRef
 */
export interface ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRef(obj: ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ServiceSpecProviderRef
 */
export interface ServiceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderRef#policy
   */
  readonly policy?: ServiceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderRef(obj: ServiceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSpecPublishConnectionDetailsTo
 */
export interface ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsTo(obj: ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSpecWriteConnectionSecretToRef
 */
export interface ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecWriteConnectionSecretToRef(obj: ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderBasicService
 */
export interface ServiceSpecForProviderBasicService {
  /**
   * Labels that specify the resource that emits the monitoring data which is used for SLO reporting of this Service.
   *
   * @schema ServiceSpecForProviderBasicService#serviceLabels
   */
  readonly serviceLabels?: { [key: string]: string };

  /**
   * The type of service that this basic service defines, e.g. APP_ENGINE service type
   *
   * @schema ServiceSpecForProviderBasicService#serviceType
   */
  readonly serviceType?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderBasicService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderBasicService(obj: ServiceSpecForProviderBasicService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceLabels': ((obj.serviceLabels) === undefined) ? undefined : (Object.entries(obj.serviceLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'serviceType': obj.serviceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderConfigRefPolicy
 */
export interface ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRefPolicy(obj: ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderRefPolicy
 */
export interface ServiceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderRefPolicy(obj: ServiceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj: ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj: ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderRefPolicyResolution
 */
export enum ServiceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderRefPolicyResolve
 */
export enum ServiceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SLO is the Schema for the SLOs API. A Service-Level Objective (SLO) describes the level of desired good service.
 *
 * @schema SLO
 */
export class Slo extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SLO"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'SLO',
  }

  /**
   * Renders a Kubernetes manifest for "SLO".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SloProps): any {
    return {
      ...Slo.GVK,
      ...toJson_SloProps(props),
    };
  }

  /**
   * Defines a "SLO" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SloProps) {
    super(scope, id, {
      ...Slo.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Slo.GVK,
      ...toJson_SloProps(resolved),
    };
  }
}

/**
 * SLO is the Schema for the SLOs API. A Service-Level Objective (SLO) describes the level of desired good service.
 *
 * @schema SLO
 */
export interface SloProps {
  /**
   * @schema SLO#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SLOSpec defines the desired state of SLO
   *
   * @schema SLO#spec
   */
  readonly spec: SloSpec;

}

/**
 * Converts an object of type 'SloProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloProps(obj: SloProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SloSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SLOSpec defines the desired state of SLO
 *
 * @schema SloSpec
 */
export interface SloSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SloSpec#deletionPolicy
   */
  readonly deletionPolicy?: SloSpecDeletionPolicy;

  /**
   * @schema SloSpec#forProvider
   */
  readonly forProvider: SloSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SloSpec#managementPolicy
   */
  readonly managementPolicy?: SloSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SloSpec#providerConfigRef
   */
  readonly providerConfigRef?: SloSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SloSpec#providerRef
   */
  readonly providerRef?: SloSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SloSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SloSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SloSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SloSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SloSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpec(obj: SloSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SloSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_SloSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SloSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SloSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SloSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SloSpecDeletionPolicy
 */
export enum SloSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SloSpecForProvider
 */
export interface SloSpecForProvider {
  /**
   * Basic Service-Level Indicator (SLI) on a well-known service type. Performance will be computed on the basis of pre-defined metrics. SLIs are used to measure and calculate the quality of the Service's performance with respect to a single aspect of service quality. Exactly one of the following must be set: basic_sli, request_based_sli, windows_based_sli Structure is documented below.
   *
   * @schema SloSpecForProvider#basicSli
   */
  readonly basicSli?: SloSpecForProviderBasicSli[];

  /**
   * A calendar period, semantically "since the start of the current ". Possible values are: DAY, WEEK, FORTNIGHT, MONTH.
   *
   * @schema SloSpecForProvider#calendarPeriod
   */
  readonly calendarPeriod?: string;

  /**
   * Name used for UI elements listing this SLO.
   *
   * @schema SloSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The fraction of service that must be good in order for this objective to be met. 0 < goal <= 0.999
   *
   * @schema SloSpecForProvider#goal
   */
  readonly goal?: number;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema SloSpecForProvider#project
   */
  readonly project?: string;

  /**
   * A request-based SLI defines a SLI for which atomic units of service are counted directly. A SLI describes a good service. It is used to measure and calculate the quality of the Service's performance with respect to a single aspect of service quality. Exactly one of the following must be set: basic_sli, request_based_sli, windows_based_sli Structure is documented below.
   *
   * @schema SloSpecForProvider#requestBasedSli
   */
  readonly requestBasedSli?: SloSpecForProviderRequestBasedSli[];

  /**
   * A rolling time period, semantically "in the past X days". Must be between 1 to 30 days, inclusive.
   *
   * @schema SloSpecForProvider#rollingPeriodDays
   */
  readonly rollingPeriodDays?: number;

  /**
   * ID of the service to which this SLO belongs.
   *
   * @schema SloSpecForProvider#service
   */
  readonly service?: string;

  /**
   * Reference to a CustomService in monitoring to populate service.
   *
   * @schema SloSpecForProvider#serviceRef
   */
  readonly serviceRef?: SloSpecForProviderServiceRef;

  /**
   * Selector for a CustomService in monitoring to populate service.
   *
   * @schema SloSpecForProvider#serviceSelector
   */
  readonly serviceSelector?: SloSpecForProviderServiceSelector;

  /**
   * The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
   *
   * @schema SloSpecForProvider#sloId
   */
  readonly sloId?: string;

  /**
   * This field is intended to be used for organizing and identifying the AlertPolicy objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
   *
   * @schema SloSpecForProvider#userLabels
   */
  readonly userLabels?: { [key: string]: string };

  /**
   * A windows-based SLI defines the criteria for time windows. good_service is defined based off the count of these time windows for which the provided service was of good quality. A SLI describes a good service. It is used to measure and calculate the quality of the Service's performance with respect to a single aspect of service quality. Exactly one of the following must be set: basic_sli, request_based_sli, windows_based_sli Structure is documented below.
   *
   * @schema SloSpecForProvider#windowsBasedSli
   */
  readonly windowsBasedSli?: SloSpecForProviderWindowsBasedSli[];

}

/**
 * Converts an object of type 'SloSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProvider(obj: SloSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicSli': obj.basicSli?.map(y => toJson_SloSpecForProviderBasicSli(y)),
    'calendarPeriod': obj.calendarPeriod,
    'displayName': obj.displayName,
    'goal': obj.goal,
    'project': obj.project,
    'requestBasedSli': obj.requestBasedSli?.map(y => toJson_SloSpecForProviderRequestBasedSli(y)),
    'rollingPeriodDays': obj.rollingPeriodDays,
    'service': obj.service,
    'serviceRef': toJson_SloSpecForProviderServiceRef(obj.serviceRef),
    'serviceSelector': toJson_SloSpecForProviderServiceSelector(obj.serviceSelector),
    'sloId': obj.sloId,
    'userLabels': ((obj.userLabels) === undefined) ? undefined : (Object.entries(obj.userLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'windowsBasedSli': obj.windowsBasedSli?.map(y => toJson_SloSpecForProviderWindowsBasedSli(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SloSpecManagementPolicy
 */
export enum SloSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SloSpecProviderConfigRef
 */
export interface SloSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SloSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SloSpecProviderConfigRef#policy
   */
  readonly policy?: SloSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SloSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecProviderConfigRef(obj: SloSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SloSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SloSpecProviderRef
 */
export interface SloSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SloSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SloSpecProviderRef#policy
   */
  readonly policy?: SloSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SloSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecProviderRef(obj: SloSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SloSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SloSpecPublishConnectionDetailsTo
 */
export interface SloSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SloSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SloSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SloSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SloSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SloSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SloSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecPublishConnectionDetailsTo(obj: SloSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SloSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SloSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SloSpecWriteConnectionSecretToRef
 */
export interface SloSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SloSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SloSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SloSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecWriteConnectionSecretToRef(obj: SloSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderBasicSli
 */
export interface SloSpecForProviderBasicSli {
  /**
   * Availability based SLI, dervied from count of requests made to this service that return successfully. Structure is documented below.
   *
   * @schema SloSpecForProviderBasicSli#availability
   */
  readonly availability?: SloSpecForProviderBasicSliAvailability[];

  /**
   * Parameters for a latency threshold SLI. Structure is documented below.
   *
   * @schema SloSpecForProviderBasicSli#latency
   */
  readonly latency?: SloSpecForProviderBasicSliLatency[];

  /**
   * An optional set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
   *
   * @schema SloSpecForProviderBasicSli#location
   */
  readonly location?: string[];

  /**
   * An optional set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
   *
   * @schema SloSpecForProviderBasicSli#method
   */
  readonly method?: string[];

  /**
   * The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
   *
   * @schema SloSpecForProviderBasicSli#version
   */
  readonly version?: string[];

}

/**
 * Converts an object of type 'SloSpecForProviderBasicSli' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderBasicSli(obj: SloSpecForProviderBasicSli | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availability': obj.availability?.map(y => toJson_SloSpecForProviderBasicSliAvailability(y)),
    'latency': obj.latency?.map(y => toJson_SloSpecForProviderBasicSliLatency(y)),
    'location': obj.location?.map(y => y),
    'method': obj.method?.map(y => y),
    'version': obj.version?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderRequestBasedSli
 */
export interface SloSpecForProviderRequestBasedSli {
  /**
   * Used when good_service is defined by a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution. Defines a distribution TimeSeries filter and thresholds used for measuring good service and total service. Exactly one of distribution_cut or good_total_ratio can be set. Structure is documented below.
   *
   * @schema SloSpecForProviderRequestBasedSli#distributionCut
   */
  readonly distributionCut?: SloSpecForProviderRequestBasedSliDistributionCut[];

  /**
   * A means to compute a ratio of good_service to total_service. Defines computing this ratio with two TimeSeries monitoring filters Must specify exactly two of good, bad, and total service filters. The relationship good_service + bad_service = total_service will be assumed. Exactly one of distribution_cut or good_total_ratio can be set. Structure is documented below.
   *
   * @schema SloSpecForProviderRequestBasedSli#goodTotalRatio
   */
  readonly goodTotalRatio?: SloSpecForProviderRequestBasedSliGoodTotalRatio[];

}

/**
 * Converts an object of type 'SloSpecForProviderRequestBasedSli' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderRequestBasedSli(obj: SloSpecForProviderRequestBasedSli | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionCut': obj.distributionCut?.map(y => toJson_SloSpecForProviderRequestBasedSliDistributionCut(y)),
    'goodTotalRatio': obj.goodTotalRatio?.map(y => toJson_SloSpecForProviderRequestBasedSliGoodTotalRatio(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CustomService in monitoring to populate service.
 *
 * @schema SloSpecForProviderServiceRef
 */
export interface SloSpecForProviderServiceRef {
  /**
   * Name of the referenced object.
   *
   * @schema SloSpecForProviderServiceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SloSpecForProviderServiceRef#policy
   */
  readonly policy?: SloSpecForProviderServiceRefPolicy;

}

/**
 * Converts an object of type 'SloSpecForProviderServiceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderServiceRef(obj: SloSpecForProviderServiceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SloSpecForProviderServiceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CustomService in monitoring to populate service.
 *
 * @schema SloSpecForProviderServiceSelector
 */
export interface SloSpecForProviderServiceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SloSpecForProviderServiceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SloSpecForProviderServiceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SloSpecForProviderServiceSelector#policy
   */
  readonly policy?: SloSpecForProviderServiceSelectorPolicy;

}

/**
 * Converts an object of type 'SloSpecForProviderServiceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderServiceSelector(obj: SloSpecForProviderServiceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SloSpecForProviderServiceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSli
 */
export interface SloSpecForProviderWindowsBasedSli {
  /**
   * A TimeSeries monitoring filter with ValueType = BOOL. The window is good if any true values appear in the window. One of good_bad_metric_filter, good_total_ratio_threshold, metric_mean_in_range, metric_sum_in_range must be set for windows_based_sli.
   *
   * @schema SloSpecForProviderWindowsBasedSli#goodBadMetricFilter
   */
  readonly goodBadMetricFilter?: string;

  /**
   * Criterion that describes a window as good if its performance is high enough. One of good_bad_metric_filter, good_total_ratio_threshold, metric_mean_in_range, metric_sum_in_range must be set for windows_based_sli. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSli#goodTotalRatioThreshold
   */
  readonly goodTotalRatioThreshold?: SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold[];

  /**
   * Criterion that describes a window as good if the metric's value is in a good range, averaged across returned streams. One of good_bad_metric_filter, good_total_ratio_threshold, metric_mean_in_range, metric_sum_in_range must be set for windows_based_sli. Average value X of time_series should satisfy range.min <= X <= range.max for a good window. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSli#metricMeanInRange
   */
  readonly metricMeanInRange?: SloSpecForProviderWindowsBasedSliMetricMeanInRange[];

  /**
   * Criterion that describes a window as good if the metric's value is in a good range, summed across returned streams. Summed value X of time_series should satisfy range.min <= X <= range.max for a good window. One of good_bad_metric_filter, good_total_ratio_threshold, metric_mean_in_range, metric_sum_in_range must be set for windows_based_sli. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSli#metricSumInRange
   */
  readonly metricSumInRange?: SloSpecForProviderWindowsBasedSliMetricSumInRange[];

  /**
   * Duration over which window quality is evaluated, given as a duration string "{X}s" representing X seconds. Must be an integer fraction of a day and at least 60s.
   *
   * @schema SloSpecForProviderWindowsBasedSli#windowPeriod
   */
  readonly windowPeriod?: string;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSli' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSli(obj: SloSpecForProviderWindowsBasedSli | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'goodBadMetricFilter': obj.goodBadMetricFilter,
    'goodTotalRatioThreshold': obj.goodTotalRatioThreshold?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold(y)),
    'metricMeanInRange': obj.metricMeanInRange?.map(y => toJson_SloSpecForProviderWindowsBasedSliMetricMeanInRange(y)),
    'metricSumInRange': obj.metricSumInRange?.map(y => toJson_SloSpecForProviderWindowsBasedSliMetricSumInRange(y)),
    'windowPeriod': obj.windowPeriod,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SloSpecProviderConfigRefPolicy
 */
export interface SloSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SloSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SloSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SloSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SloSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SloSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecProviderConfigRefPolicy(obj: SloSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SloSpecProviderRefPolicy
 */
export interface SloSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SloSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SloSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SloSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SloSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SloSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecProviderRefPolicy(obj: SloSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SloSpecPublishConnectionDetailsToConfigRef
 */
export interface SloSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SloSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SloSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SloSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SloSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecPublishConnectionDetailsToConfigRef(obj: SloSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SloSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SloSpecPublishConnectionDetailsToMetadata
 */
export interface SloSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SloSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SloSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SloSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SloSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecPublishConnectionDetailsToMetadata(obj: SloSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderBasicSliAvailability
 */
export interface SloSpecForProviderBasicSliAvailability {
  /**
   * Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
   *
   * @default true.
   * @schema SloSpecForProviderBasicSliAvailability#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'SloSpecForProviderBasicSliAvailability' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderBasicSliAvailability(obj: SloSpecForProviderBasicSliAvailability | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderBasicSliLatency
 */
export interface SloSpecForProviderBasicSliLatency {
  /**
   * A duration string, e.g. 10s. Good service is defined to be the count of requests made to this service that return in no more than threshold.
   *
   * @schema SloSpecForProviderBasicSliLatency#threshold
   */
  readonly threshold: string;

}

/**
 * Converts an object of type 'SloSpecForProviderBasicSliLatency' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderBasicSliLatency(obj: SloSpecForProviderBasicSliLatency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderRequestBasedSliDistributionCut
 */
export interface SloSpecForProviderRequestBasedSliDistributionCut {
  /**
   * A TimeSeries monitoring filter aggregating values to quantify the good service provided. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
   *
   * @schema SloSpecForProviderRequestBasedSliDistributionCut#distributionFilter
   */
  readonly distributionFilter: string;

  /**
   * Range of numerical values. The computed good_service will be the count of values x in the Distribution such that range.min <= x <= range.max. inclusive of min and max. Open ranges can be defined by setting just one of min or max. Summed value X should satisfy range.min <= X <= range.max for a good window. Structure is documented below.
   *
   * @schema SloSpecForProviderRequestBasedSliDistributionCut#range
   */
  readonly range: SloSpecForProviderRequestBasedSliDistributionCutRange[];

}

/**
 * Converts an object of type 'SloSpecForProviderRequestBasedSliDistributionCut' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderRequestBasedSliDistributionCut(obj: SloSpecForProviderRequestBasedSliDistributionCut | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionFilter': obj.distributionFilter,
    'range': obj.range?.map(y => toJson_SloSpecForProviderRequestBasedSliDistributionCutRange(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderRequestBasedSliGoodTotalRatio
 */
export interface SloSpecForProviderRequestBasedSliGoodTotalRatio {
  /**
   * A TimeSeries monitoring filter quantifying bad service provided, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. Exactly two of good_service_filter,bad_service_filter,total_service_filter must be set (good + bad = total is assumed).
   *
   * @schema SloSpecForProviderRequestBasedSliGoodTotalRatio#badServiceFilter
   */
  readonly badServiceFilter?: string;

  /**
   * A TimeSeries monitoring filter quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. Exactly two of good_service_filter,bad_service_filter,total_service_filter must be set (good + bad = total is assumed).
   *
   * @schema SloSpecForProviderRequestBasedSliGoodTotalRatio#goodServiceFilter
   */
  readonly goodServiceFilter?: string;

  /**
   * A TimeSeries monitoring filter quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. Exactly two of good_service_filter,bad_service_filter,total_service_filter must be set (good + bad = total is assumed).
   *
   * @schema SloSpecForProviderRequestBasedSliGoodTotalRatio#totalServiceFilter
   */
  readonly totalServiceFilter?: string;

}

/**
 * Converts an object of type 'SloSpecForProviderRequestBasedSliGoodTotalRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderRequestBasedSliGoodTotalRatio(obj: SloSpecForProviderRequestBasedSliGoodTotalRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'badServiceFilter': obj.badServiceFilter,
    'goodServiceFilter': obj.goodServiceFilter,
    'totalServiceFilter': obj.totalServiceFilter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SloSpecForProviderServiceRefPolicy
 */
export interface SloSpecForProviderServiceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SloSpecForProviderServiceRefPolicy#resolution
   */
  readonly resolution?: SloSpecForProviderServiceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SloSpecForProviderServiceRefPolicy#resolve
   */
  readonly resolve?: SloSpecForProviderServiceRefPolicyResolve;

}

/**
 * Converts an object of type 'SloSpecForProviderServiceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderServiceRefPolicy(obj: SloSpecForProviderServiceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SloSpecForProviderServiceSelectorPolicy
 */
export interface SloSpecForProviderServiceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SloSpecForProviderServiceSelectorPolicy#resolution
   */
  readonly resolution?: SloSpecForProviderServiceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SloSpecForProviderServiceSelectorPolicy#resolve
   */
  readonly resolve?: SloSpecForProviderServiceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SloSpecForProviderServiceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderServiceSelectorPolicy(obj: SloSpecForProviderServiceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold {
  /**
   * Basic SLI to evaluate to judge window quality. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold#basicSliPerformance
   */
  readonly basicSliPerformance?: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance[];

  /**
   * Request-based SLI to evaluate to judge window quality. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold#performance
   */
  readonly performance?: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance[];

  /**
   * A duration string, e.g. 10s. Good service is defined to be the count of requests made to this service that return in no more than threshold.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold#threshold
   */
  readonly threshold?: number;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThreshold | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basicSliPerformance': obj.basicSliPerformance?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance(y)),
    'performance': obj.performance?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance(y)),
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliMetricMeanInRange
 */
export interface SloSpecForProviderWindowsBasedSliMetricMeanInRange {
  /**
   * Range of numerical values. The computed good_service will be the count of values x in the Distribution such that range.min <= x <= range.max. inclusive of min and max. Open ranges can be defined by setting just one of min or max. Summed value X should satisfy range.min <= X <= range.max for a good window. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricMeanInRange#range
   */
  readonly range: SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange[];

  /**
   * A monitoring filter specifying the TimeSeries to use for evaluating window quality. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. Summed value X should satisfy range.min <= X <= range.max for a good window.
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricMeanInRange#timeSeries
   */
  readonly timeSeries: string;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliMetricMeanInRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliMetricMeanInRange(obj: SloSpecForProviderWindowsBasedSliMetricMeanInRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': obj.range?.map(y => toJson_SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange(y)),
    'timeSeries': obj.timeSeries,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliMetricSumInRange
 */
export interface SloSpecForProviderWindowsBasedSliMetricSumInRange {
  /**
   * Range of numerical values. The computed good_service will be the count of values x in the Distribution such that range.min <= x <= range.max. inclusive of min and max. Open ranges can be defined by setting just one of min or max. Summed value X should satisfy range.min <= X <= range.max for a good window. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricSumInRange#range
   */
  readonly range: SloSpecForProviderWindowsBasedSliMetricSumInRangeRange[];

  /**
   * A monitoring filter specifying the TimeSeries to use for evaluating window quality. The provided TimeSeries must have ValueType = INT64 or ValueType = DOUBLE and MetricKind = GAUGE. Summed value X should satisfy range.min <= X <= range.max for a good window.
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricSumInRange#timeSeries
   */
  readonly timeSeries: string;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliMetricSumInRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliMetricSumInRange(obj: SloSpecForProviderWindowsBasedSliMetricSumInRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'range': obj.range?.map(y => toJson_SloSpecForProviderWindowsBasedSliMetricSumInRangeRange(y)),
    'timeSeries': obj.timeSeries,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SloSpecProviderConfigRefPolicyResolution
 */
export enum SloSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SloSpecProviderConfigRefPolicyResolve
 */
export enum SloSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SloSpecProviderRefPolicyResolution
 */
export enum SloSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SloSpecProviderRefPolicyResolve
 */
export enum SloSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SloSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SloSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SloSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SloSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SloSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SloSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SloSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecPublishConnectionDetailsToConfigRefPolicy(obj: SloSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderRequestBasedSliDistributionCutRange
 */
export interface SloSpecForProviderRequestBasedSliDistributionCutRange {
  /**
   * max value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderRequestBasedSliDistributionCutRange#max
   */
  readonly max?: number;

  /**
   * Min value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderRequestBasedSliDistributionCutRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'SloSpecForProviderRequestBasedSliDistributionCutRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderRequestBasedSliDistributionCutRange(obj: SloSpecForProviderRequestBasedSliDistributionCutRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SloSpecForProviderServiceRefPolicyResolution
 */
export enum SloSpecForProviderServiceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SloSpecForProviderServiceRefPolicyResolve
 */
export enum SloSpecForProviderServiceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SloSpecForProviderServiceSelectorPolicyResolution
 */
export enum SloSpecForProviderServiceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SloSpecForProviderServiceSelectorPolicyResolve
 */
export enum SloSpecForProviderServiceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance {
  /**
   * Availability based SLI, dervied from count of requests made to this service that return successfully. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance#availability
   */
  readonly availability?: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability[];

  /**
   * Parameters for a latency threshold SLI. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance#latency
   */
  readonly latency?: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency[];

  /**
   * An optional set of locations to which this SLI is relevant. Telemetry from other locations will not be used to calculate performance for this SLI. If omitted, this SLI applies to all locations in which the Service has activity. For service types that don't support breaking down by location, setting this field will result in an error.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance#location
   */
  readonly location?: string[];

  /**
   * An optional set of RPCs to which this SLI is relevant. Telemetry from other methods will not be used to calculate performance for this SLI. If omitted, this SLI applies to all the Service's methods. For service types that don't support breaking down by method, setting this field will result in an error.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance#method
   */
  readonly method?: string[];

  /**
   * The set of API versions to which this SLI is relevant. Telemetry from other API versions will not be used to calculate performance for this SLI. If omitted, this SLI applies to all API versions. For service types that don't support breaking down by version, setting this field will result in an error.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance#version
   */
  readonly version?: string[];

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availability': obj.availability?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability(y)),
    'latency': obj.latency?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency(y)),
    'location': obj.location?.map(y => y),
    'method': obj.method?.map(y => y),
    'version': obj.version?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance {
  /**
   * Used when good_service is defined by a count of values aggregated in a Distribution that fall into a good range. The total_service is the total count of all values aggregated in the Distribution. Defines a distribution TimeSeries filter and thresholds used for measuring good service and total service. Exactly one of distribution_cut or good_total_ratio can be set. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance#distributionCut
   */
  readonly distributionCut?: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut[];

  /**
   * A means to compute a ratio of good_service to total_service. Defines computing this ratio with two TimeSeries monitoring filters Must specify exactly two of good, bad, and total service filters. The relationship good_service + bad_service = total_service will be assumed. Exactly one of distribution_cut or good_total_ratio can be set. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance#goodTotalRatio
   */
  readonly goodTotalRatio?: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio[];

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformance | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionCut': obj.distributionCut?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut(y)),
    'goodTotalRatio': obj.goodTotalRatio?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange
 */
export interface SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange {
  /**
   * max value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange#max
   */
  readonly max?: number;

  /**
   * Min value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange(obj: SloSpecForProviderWindowsBasedSliMetricMeanInRangeRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliMetricSumInRangeRange
 */
export interface SloSpecForProviderWindowsBasedSliMetricSumInRangeRange {
  /**
   * max value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricSumInRangeRange#max
   */
  readonly max?: number;

  /**
   * Min value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderWindowsBasedSliMetricSumInRangeRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliMetricSumInRangeRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliMetricSumInRangeRange(obj: SloSpecForProviderWindowsBasedSliMetricSumInRangeRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SloSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SloSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SloSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SloSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability {
  /**
   * Whether an availability SLI is enabled or not. Must be set to true. Defaults to true.
   *
   * @default true.
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency {
  /**
   * A duration string, e.g. 10s. Good service is defined to be the count of requests made to this service that return in no more than threshold.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency#threshold
   */
  readonly threshold: string;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'threshold': obj.threshold,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut {
  /**
   * A TimeSeries monitoring filter aggregating values to quantify the good service provided. Must have ValueType = DISTRIBUTION and MetricKind = DELTA or MetricKind = CUMULATIVE.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut#distributionFilter
   */
  readonly distributionFilter: string;

  /**
   * Range of numerical values. The computed good_service will be the count of values x in the Distribution such that range.min <= x <= range.max. inclusive of min and max. Open ranges can be defined by setting just one of min or max. Summed value X should satisfy range.min <= X <= range.max for a good window. Structure is documented below.
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut#range
   */
  readonly range: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange[];

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'distributionFilter': obj.distributionFilter,
    'range': obj.range?.map(y => toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio {
  /**
   * A TimeSeries monitoring filter quantifying bad service provided, either demanded service that was not provided or demanded service that was of inadequate quality. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. Exactly two of good_service_filter,bad_service_filter,total_service_filter must be set (good + bad = total is assumed).
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio#badServiceFilter
   */
  readonly badServiceFilter?: string;

  /**
   * A TimeSeries monitoring filter quantifying good service provided. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. Exactly two of good_service_filter,bad_service_filter,total_service_filter must be set (good + bad = total is assumed).
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio#goodServiceFilter
   */
  readonly goodServiceFilter?: string;

  /**
   * A TimeSeries monitoring filter quantifying total demanded service. Must have ValueType = DOUBLE or ValueType = INT64 and must have MetricKind = DELTA or MetricKind = CUMULATIVE. Exactly two of good_service_filter,bad_service_filter,total_service_filter must be set (good + bad = total is assumed).
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio#totalServiceFilter
   */
  readonly totalServiceFilter?: string;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'badServiceFilter': obj.badServiceFilter,
    'goodServiceFilter': obj.goodServiceFilter,
    'totalServiceFilter': obj.totalServiceFilter,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange
 */
export interface SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange {
  /**
   * max value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange#max
   */
  readonly max?: number;

  /**
   * Min value for the range (inclusive). If not given, will be set to 0
   *
   * @schema SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange#min
   */
  readonly min?: number;

}

/**
 * Converts an object of type 'SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange(obj: SloSpecForProviderWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'max': obj.max,
    'min': obj.min,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * UptimeCheckConfig is the Schema for the UptimeCheckConfigs API. This message configures which resources and services to monitor for availability.
 *
 * @schema UptimeCheckConfig
 */
export class UptimeCheckConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UptimeCheckConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'monitoring.gcp.upbound.io/v1beta1',
    kind: 'UptimeCheckConfig',
  }

  /**
   * Renders a Kubernetes manifest for "UptimeCheckConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UptimeCheckConfigProps): any {
    return {
      ...UptimeCheckConfig.GVK,
      ...toJson_UptimeCheckConfigProps(props),
    };
  }

  /**
   * Defines a "UptimeCheckConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UptimeCheckConfigProps) {
    super(scope, id, {
      ...UptimeCheckConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UptimeCheckConfig.GVK,
      ...toJson_UptimeCheckConfigProps(resolved),
    };
  }
}

/**
 * UptimeCheckConfig is the Schema for the UptimeCheckConfigs API. This message configures which resources and services to monitor for availability.
 *
 * @schema UptimeCheckConfig
 */
export interface UptimeCheckConfigProps {
  /**
   * @schema UptimeCheckConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UptimeCheckConfigSpec defines the desired state of UptimeCheckConfig
   *
   * @schema UptimeCheckConfig#spec
   */
  readonly spec: UptimeCheckConfigSpec;

}

/**
 * Converts an object of type 'UptimeCheckConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigProps(obj: UptimeCheckConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UptimeCheckConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UptimeCheckConfigSpec defines the desired state of UptimeCheckConfig
 *
 * @schema UptimeCheckConfigSpec
 */
export interface UptimeCheckConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UptimeCheckConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: UptimeCheckConfigSpecDeletionPolicy;

  /**
   * @schema UptimeCheckConfigSpec#forProvider
   */
  readonly forProvider: UptimeCheckConfigSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UptimeCheckConfigSpec#managementPolicy
   */
  readonly managementPolicy?: UptimeCheckConfigSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UptimeCheckConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: UptimeCheckConfigSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UptimeCheckConfigSpec#providerRef
   */
  readonly providerRef?: UptimeCheckConfigSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UptimeCheckConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UptimeCheckConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UptimeCheckConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UptimeCheckConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpec(obj: UptimeCheckConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UptimeCheckConfigSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_UptimeCheckConfigSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UptimeCheckConfigSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UptimeCheckConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UptimeCheckConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UptimeCheckConfigSpecDeletionPolicy
 */
export enum UptimeCheckConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UptimeCheckConfigSpecForProvider
 */
export interface UptimeCheckConfigSpecForProvider {
  /**
   * The checker type to use for the check. If the monitored resource type is servicedirectory_service, checkerType must be set to VPC_CHECKERS. Possible values are: STATIC_IP_CHECKERS, VPC_CHECKERS.
   *
   * @schema UptimeCheckConfigSpecForProvider#checkerType
   */
  readonly checkerType?: string;

  /**
   * The expected content on the page the check is run against. Currently, only the first entry in the list is supported, and other entries will be ignored. The server will look for an exact match of the string in the page response's content. This field is optional and should only be specified if a content match is required. Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProvider#contentMatchers
   */
  readonly contentMatchers?: UptimeCheckConfigSpecForProviderContentMatchers[];

  /**
   * A human-friendly name for the uptime check configuration. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
   *
   * @schema UptimeCheckConfigSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Contains information needed to make an HTTP or HTTPS check. Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProvider#httpCheck
   */
  readonly httpCheck?: UptimeCheckConfigSpecForProviderHttpCheck[];

  /**
   * The monitored resource (https://cloud.google.com/monitoring/api/resources) associated with the configuration. The following monitored resource types are supported for uptime checks:  uptime_url  gce_instance  gae_app  aws_ec2_instance aws_elb_load_balancer  k8s_service  servicedirectory_service Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProvider#monitoredResource
   */
  readonly monitoredResource?: UptimeCheckConfigSpecForProviderMonitoredResource[];

  /**
   * How often, in seconds, the uptime check is performed. Currently, the only supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes), and 900s (15 minutes). Optional, defaults to 300s.
   *
   * @schema UptimeCheckConfigSpecForProvider#period
   */
  readonly period?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema UptimeCheckConfigSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The group resource associated with the configuration. Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProvider#resourceGroup
   */
  readonly resourceGroup?: UptimeCheckConfigSpecForProviderResourceGroup[];

  /**
   * The list of regions from which the check will be run. Some regions contain one location, and others contain more than one. If this field is specified, enough regions to include a minimum of 3 locations must be provided, or an error message is returned. Not specifying this field will result in uptime checks running from all regions.
   *
   * @schema UptimeCheckConfigSpecForProvider#selectedRegions
   */
  readonly selectedRegions?: string[];

  /**
   * Contains information needed to make a TCP check. Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProvider#tcpCheck
   */
  readonly tcpCheck?: UptimeCheckConfigSpecForProviderTcpCheck[];

  /**
   * The maximum amount of time to wait for the request to complete (must be between 1 and 60 seconds). Accepted formats https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Duration
   *
   * @schema UptimeCheckConfigSpecForProvider#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProvider(obj: UptimeCheckConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'checkerType': obj.checkerType,
    'contentMatchers': obj.contentMatchers?.map(y => toJson_UptimeCheckConfigSpecForProviderContentMatchers(y)),
    'displayName': obj.displayName,
    'httpCheck': obj.httpCheck?.map(y => toJson_UptimeCheckConfigSpecForProviderHttpCheck(y)),
    'monitoredResource': obj.monitoredResource?.map(y => toJson_UptimeCheckConfigSpecForProviderMonitoredResource(y)),
    'period': obj.period,
    'project': obj.project,
    'resourceGroup': obj.resourceGroup?.map(y => toJson_UptimeCheckConfigSpecForProviderResourceGroup(y)),
    'selectedRegions': obj.selectedRegions?.map(y => y),
    'tcpCheck': obj.tcpCheck?.map(y => toJson_UptimeCheckConfigSpecForProviderTcpCheck(y)),
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UptimeCheckConfigSpecManagementPolicy
 */
export enum UptimeCheckConfigSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UptimeCheckConfigSpecProviderConfigRef
 */
export interface UptimeCheckConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UptimeCheckConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UptimeCheckConfigSpecProviderConfigRef#policy
   */
  readonly policy?: UptimeCheckConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecProviderConfigRef(obj: UptimeCheckConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UptimeCheckConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UptimeCheckConfigSpecProviderRef
 */
export interface UptimeCheckConfigSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UptimeCheckConfigSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UptimeCheckConfigSpecProviderRef#policy
   */
  readonly policy?: UptimeCheckConfigSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecProviderRef(obj: UptimeCheckConfigSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UptimeCheckConfigSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UptimeCheckConfigSpecPublishConnectionDetailsTo
 */
export interface UptimeCheckConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UptimeCheckConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecPublishConnectionDetailsTo(obj: UptimeCheckConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UptimeCheckConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UptimeCheckConfigSpecWriteConnectionSecretToRef
 */
export interface UptimeCheckConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UptimeCheckConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UptimeCheckConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecWriteConnectionSecretToRef(obj: UptimeCheckConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderContentMatchers
 */
export interface UptimeCheckConfigSpecForProviderContentMatchers {
  /**
   * String or regex content to match (max 1024 bytes)
   *
   * @schema UptimeCheckConfigSpecForProviderContentMatchers#content
   */
  readonly content: string;

  /**
   * Information needed to perform a JSONPath content match. Used for ContentMatcherOption::MATCHES_JSON_PATH and ContentMatcherOption::NOT_MATCHES_JSON_PATH. Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProviderContentMatchers#jsonPathMatcher
   */
  readonly jsonPathMatcher?: UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher[];

  /**
   * The type of content matcher that will be applied to the server output, compared to the content string when the check is run. Default value is CONTAINS_STRING. Possible values are: CONTAINS_STRING, NOT_CONTAINS_STRING, MATCHES_REGEX, NOT_MATCHES_REGEX, MATCHES_JSON_PATH, NOT_MATCHES_JSON_PATH.
   *
   * @schema UptimeCheckConfigSpecForProviderContentMatchers#matcher
   */
  readonly matcher?: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderContentMatchers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderContentMatchers(obj: UptimeCheckConfigSpecForProviderContentMatchers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'content': obj.content,
    'jsonPathMatcher': obj.jsonPathMatcher?.map(y => toJson_UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher(y)),
    'matcher': obj.matcher,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderHttpCheck
 */
export interface UptimeCheckConfigSpecForProviderHttpCheck {
  /**
   * If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299. Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#acceptedResponseStatusCodes
   */
  readonly acceptedResponseStatusCodes?: UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes[];

  /**
   * The authentication information. Optional when creating an HTTP check; defaults to empty. Structure is documented below.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#authInfo
   */
  readonly authInfo?: UptimeCheckConfigSpecForProviderHttpCheckAuthInfo[];

  /**
   * The request body associated with the HTTP POST request. If contentType is URL_ENCODED, the body passed in must be URL-encoded. Users can provide a Content-Length header via the headers field or the API will do so. If the requestMethod is GET and body is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. "foo=bar" in URL-encoded form is "foo%3Dbar" and in base64 encoding is "Zm9vJTI1M0RiYXI=".
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#body
   */
  readonly body?: string;

  /**
   * The content type to use for the check. Possible values are: TYPE_UNSPECIFIED, URL_ENCODED.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#contentType
   */
  readonly contentType?: string;

  /**
   * The list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described at https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Boolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if mask_headers is set to True then the headers will be obscured with ******.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#maskHeaders
   */
  readonly maskHeaders?: boolean;

  /**
   * The path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. If the provided path does not begin with "/", a "/" will be prepended automatically. Optional (defaults to "/").
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#path
   */
  readonly path?: string;

  /**
   * The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) and path to construct the full URL. Optional (defaults to 80 without SSL, or 443 with SSL).
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#port
   */
  readonly port?: number;

  /**
   * The HTTP request method to use for the check. If set to METHOD_UNSPECIFIED then requestMethod defaults to GET. Default value is GET. Possible values are: METHOD_UNSPECIFIED, GET, POST.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#requestMethod
   */
  readonly requestMethod?: string;

  /**
   * If true, use HTTPS instead of HTTP to run the check.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#useSsl
   */
  readonly useSsl?: boolean;

  /**
   * Boolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where monitoredResource is set to uptime_url. If useSsl is false, setting validateSsl to true has no effect.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheck#validateSsl
   */
  readonly validateSsl?: boolean;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderHttpCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderHttpCheck(obj: UptimeCheckConfigSpecForProviderHttpCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptedResponseStatusCodes': obj.acceptedResponseStatusCodes?.map(y => toJson_UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes(y)),
    'authInfo': obj.authInfo?.map(y => toJson_UptimeCheckConfigSpecForProviderHttpCheckAuthInfo(y)),
    'body': obj.body,
    'contentType': obj.contentType,
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'maskHeaders': obj.maskHeaders,
    'path': obj.path,
    'port': obj.port,
    'requestMethod': obj.requestMethod,
    'useSsl': obj.useSsl,
    'validateSsl': obj.validateSsl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderMonitoredResource
 */
export interface UptimeCheckConfigSpecForProviderMonitoredResource {
  /**
   * Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone".
   *
   * @schema UptimeCheckConfigSpecForProviderMonitoredResource#labels
   */
  readonly labels: { [key: string]: string };

  /**
   * The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list).
   *
   * @schema UptimeCheckConfigSpecForProviderMonitoredResource#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderMonitoredResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderMonitoredResource(obj: UptimeCheckConfigSpecForProviderMonitoredResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderResourceGroup
 */
export interface UptimeCheckConfigSpecForProviderResourceGroup {
  /**
   * The group of resources being monitored. Should be the name of a group
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroup#groupId
   */
  readonly groupId?: string;

  /**
   * Reference to a Group in monitoring to populate groupId.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroup#groupIdRef
   */
  readonly groupIdRef?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef;

  /**
   * Selector for a Group in monitoring to populate groupId.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroup#groupIdSelector
   */
  readonly groupIdSelector?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector;

  /**
   * The resource type of the group members. Possible values are: RESOURCE_TYPE_UNSPECIFIED, INSTANCE, AWS_ELB_LOAD_BALANCER.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroup#resourceType
   */
  readonly resourceType?: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderResourceGroup' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderResourceGroup(obj: UptimeCheckConfigSpecForProviderResourceGroup | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupId': obj.groupId,
    'groupIdRef': toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef(obj.groupIdRef),
    'groupIdSelector': toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector(obj.groupIdSelector),
    'resourceType': obj.resourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderTcpCheck
 */
export interface UptimeCheckConfigSpecForProviderTcpCheck {
  /**
   * The port to the page to run the check against. Will be combined with host (specified within the MonitoredResource) to construct the full URL.
   *
   * @schema UptimeCheckConfigSpecForProviderTcpCheck#port
   */
  readonly port: number;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderTcpCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderTcpCheck(obj: UptimeCheckConfigSpecForProviderTcpCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UptimeCheckConfigSpecProviderConfigRefPolicy
 */
export interface UptimeCheckConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UptimeCheckConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UptimeCheckConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UptimeCheckConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UptimeCheckConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecProviderConfigRefPolicy(obj: UptimeCheckConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UptimeCheckConfigSpecProviderRefPolicy
 */
export interface UptimeCheckConfigSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UptimeCheckConfigSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UptimeCheckConfigSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UptimeCheckConfigSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UptimeCheckConfigSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecProviderRefPolicy(obj: UptimeCheckConfigSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef(obj: UptimeCheckConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UptimeCheckConfigSpecPublishConnectionDetailsToMetadata
 */
export interface UptimeCheckConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecPublishConnectionDetailsToMetadata(obj: UptimeCheckConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher
 */
export interface UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher {
  /**
   * Options to perform JSONPath content matching. Default value is EXACT_MATCH. Possible values are: EXACT_MATCH, REGEX_MATCH.
   *
   * @schema UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher#jsonMatcher
   */
  readonly jsonMatcher?: string;

  /**
   * JSONPath within the response output pointing to the expected ContentMatcher::content to match against.
   *
   * @schema UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher#jsonPath
   */
  readonly jsonPath: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher(obj: UptimeCheckConfigSpecForProviderContentMatchersJsonPathMatcher | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonMatcher': obj.jsonMatcher,
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes
 */
export interface UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes {
  /**
   * A class of status codes to accept. Possible values are: STATUS_CLASS_1XX, STATUS_CLASS_2XX, STATUS_CLASS_3XX, STATUS_CLASS_4XX, STATUS_CLASS_5XX, STATUS_CLASS_ANY.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes#statusClass
   */
  readonly statusClass?: string;

  /**
   * A status code to accept.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes#statusValue
   */
  readonly statusValue?: number;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes(obj: UptimeCheckConfigSpecForProviderHttpCheckAcceptedResponseStatusCodes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'statusClass': obj.statusClass,
    'statusValue': obj.statusValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UptimeCheckConfigSpecForProviderHttpCheckAuthInfo
 */
export interface UptimeCheckConfigSpecForProviderHttpCheckAuthInfo {
  /**
   * The password to authenticate. Note: This property is sensitive and will not be displayed in the plan.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheckAuthInfo#passwordSecretRef
   */
  readonly passwordSecretRef: UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef;

  /**
   * The username to authenticate.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheckAuthInfo#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderHttpCheckAuthInfo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderHttpCheckAuthInfo(obj: UptimeCheckConfigSpecForProviderHttpCheckAuthInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'passwordSecretRef': toJson_UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef(obj.passwordSecretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Group in monitoring to populate groupId.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef
 */
export interface UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef#policy
   */
  readonly policy?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef(obj: UptimeCheckConfigSpecForProviderResourceGroupGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in monitoring to populate groupId.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector
 */
export interface UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector#policy
   */
  readonly policy?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector(obj: UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UptimeCheckConfigSpecProviderConfigRefPolicyResolution
 */
export enum UptimeCheckConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UptimeCheckConfigSpecProviderConfigRefPolicyResolve
 */
export enum UptimeCheckConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UptimeCheckConfigSpecProviderRefPolicyResolution
 */
export enum UptimeCheckConfigSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UptimeCheckConfigSpecProviderRefPolicyResolve
 */
export enum UptimeCheckConfigSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password to authenticate. Note: This property is sensitive and will not be displayed in the plan.
 *
 * @schema UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef
 */
export interface UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef(obj: UptimeCheckConfigSpecForProviderHttpCheckAuthInfoPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy
 */
export interface UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy#resolution
   */
  readonly resolution?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy#resolve
   */
  readonly resolve?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy(obj: UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy
 */
export interface UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy(obj: UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UptimeCheckConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicyResolution
 */
export enum UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicyResolve
 */
export enum UptimeCheckConfigSpecForProviderResourceGroupGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicyResolution
 */
export enum UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicyResolve
 */
export enum UptimeCheckConfigSpecForProviderResourceGroupGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

