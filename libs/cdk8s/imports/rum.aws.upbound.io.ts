// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AppMonitor is the Schema for the AppMonitors API. Provides a CloudWatch RUM App Monitor resource.
 *
 * @schema AppMonitor
 */
export class AppMonitor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AppMonitor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rum.aws.upbound.io/v1beta1',
    kind: 'AppMonitor',
  }

  /**
   * Renders a Kubernetes manifest for "AppMonitor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AppMonitorProps): any {
    return {
      ...AppMonitor.GVK,
      ...toJson_AppMonitorProps(props),
    };
  }

  /**
   * Defines a "AppMonitor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AppMonitorProps) {
    super(scope, id, {
      ...AppMonitor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AppMonitor.GVK,
      ...toJson_AppMonitorProps(resolved),
    };
  }
}

/**
 * AppMonitor is the Schema for the AppMonitors API. Provides a CloudWatch RUM App Monitor resource.
 *
 * @schema AppMonitor
 */
export interface AppMonitorProps {
  /**
   * @schema AppMonitor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AppMonitorSpec defines the desired state of AppMonitor
   *
   * @schema AppMonitor#spec
   */
  readonly spec: AppMonitorSpec;

}

/**
 * Converts an object of type 'AppMonitorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorProps(obj: AppMonitorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AppMonitorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppMonitorSpec defines the desired state of AppMonitor
 *
 * @schema AppMonitorSpec
 */
export interface AppMonitorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppMonitorSpec#deletionPolicy
   */
  readonly deletionPolicy?: AppMonitorSpecDeletionPolicy;

  /**
   * @schema AppMonitorSpec#forProvider
   */
  readonly forProvider: AppMonitorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AppMonitorSpec#managementPolicy
   */
  readonly managementPolicy?: AppMonitorSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AppMonitorSpec#providerConfigRef
   */
  readonly providerConfigRef?: AppMonitorSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AppMonitorSpec#providerRef
   */
  readonly providerRef?: AppMonitorSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AppMonitorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AppMonitorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AppMonitorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AppMonitorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AppMonitorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpec(obj: AppMonitorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AppMonitorSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AppMonitorSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AppMonitorSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AppMonitorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AppMonitorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppMonitorSpecDeletionPolicy
 */
export enum AppMonitorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AppMonitorSpecForProvider
 */
export interface AppMonitorSpecForProvider {
  /**
   * configuration data for the app monitor. See app_monitor_configuration below.
   *
   * @schema AppMonitorSpecForProvider#appMonitorConfiguration
   */
  readonly appMonitorConfiguration?: AppMonitorSpecForProviderAppMonitorConfiguration[];

  /**
   * Specifies whether this app monitor allows the web client to define and send custom events. If you omit this parameter, custom events are DISABLED. See custom_events below.
   *
   * @schema AppMonitorSpecForProvider#customEvents
   */
  readonly customEvents?: AppMonitorSpecForProviderCustomEvents[];

  /**
   * Data collected by RUM is kept by RUM for 30 days and then deleted. This parameter  specifies whether RUM sends a copy of this telemetry data to Amazon CloudWatch Logs in your account. This enables you to keep the telemetry data for more than 30 days, but it does incur Amazon CloudWatch Logs charges. Default value is false.
   *
   * @schema AppMonitorSpecForProvider#cwLogEnabled
   */
  readonly cwLogEnabled?: boolean;

  /**
   * The top-level internet domain name for which your application has administrative authority.
   *
   * @schema AppMonitorSpecForProvider#domain
   */
  readonly domain?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AppMonitorSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema AppMonitorSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'AppMonitorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecForProvider(obj: AppMonitorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appMonitorConfiguration': obj.appMonitorConfiguration?.map(y => toJson_AppMonitorSpecForProviderAppMonitorConfiguration(y)),
    'customEvents': obj.customEvents?.map(y => toJson_AppMonitorSpecForProviderCustomEvents(y)),
    'cwLogEnabled': obj.cwLogEnabled,
    'domain': obj.domain,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AppMonitorSpecManagementPolicy
 */
export enum AppMonitorSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AppMonitorSpecProviderConfigRef
 */
export interface AppMonitorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppMonitorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppMonitorSpecProviderConfigRef#policy
   */
  readonly policy?: AppMonitorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AppMonitorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecProviderConfigRef(obj: AppMonitorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppMonitorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AppMonitorSpecProviderRef
 */
export interface AppMonitorSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppMonitorSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppMonitorSpecProviderRef#policy
   */
  readonly policy?: AppMonitorSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AppMonitorSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecProviderRef(obj: AppMonitorSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppMonitorSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AppMonitorSpecPublishConnectionDetailsTo
 */
export interface AppMonitorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AppMonitorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AppMonitorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AppMonitorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecPublishConnectionDetailsTo(obj: AppMonitorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AppMonitorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AppMonitorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AppMonitorSpecWriteConnectionSecretToRef
 */
export interface AppMonitorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AppMonitorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AppMonitorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AppMonitorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecWriteConnectionSecretToRef(obj: AppMonitorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppMonitorSpecForProviderAppMonitorConfiguration
 */
export interface AppMonitorSpecForProviderAppMonitorConfiguration {
  /**
   * If you set this to true, RUM web client sets two cookies, a session cookie  and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#allowCookies
   */
  readonly allowCookies?: boolean;

  /**
   * If you set this to true, RUM enables X-Ray tracing for the user sessions  that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#enableXray
   */
  readonly enableXray?: boolean;

  /**
   * A list of URLs in your website or application to exclude from RUM data collection.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#excludedPages
   */
  readonly excludedPages?: string[];

  /**
   * A list of pages in the CloudWatch RUM console that are to be displayed with a "favorite" icon.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#favoritePages
   */
  readonly favoritePages?: string[];

  /**
   * The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#guestRoleArn
   */
  readonly guestRoleArn?: string;

  /**
   * The ID of the Amazon Cognito identity pool that is used to authorize the sending of data to RUM.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#identityPoolId
   */
  readonly identityPoolId?: string;

  /**
   * If this app monitor is to collect data from only certain pages in your application, this structure lists those pages.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#includedPages
   */
  readonly includedPages?: string[];

  /**
   * Specifies the percentage of user sessions to use for RUM data collection. Choosing a higher percentage gives you more data but also incurs more costs. The number you specify is the percentage of user sessions that will be used. Default value is 0.1.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#sessionSampleRate
   */
  readonly sessionSampleRate?: number;

  /**
   * An array that lists the types of telemetry data that this app monitor is to collect. Valid values are errors, performance, and http.
   *
   * @schema AppMonitorSpecForProviderAppMonitorConfiguration#telemetries
   */
  readonly telemetries?: string[];

}

/**
 * Converts an object of type 'AppMonitorSpecForProviderAppMonitorConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecForProviderAppMonitorConfiguration(obj: AppMonitorSpecForProviderAppMonitorConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowCookies': obj.allowCookies,
    'enableXray': obj.enableXray,
    'excludedPages': obj.excludedPages?.map(y => y),
    'favoritePages': obj.favoritePages?.map(y => y),
    'guestRoleArn': obj.guestRoleArn,
    'identityPoolId': obj.identityPoolId,
    'includedPages': obj.includedPages?.map(y => y),
    'sessionSampleRate': obj.sessionSampleRate,
    'telemetries': obj.telemetries?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AppMonitorSpecForProviderCustomEvents
 */
export interface AppMonitorSpecForProviderCustomEvents {
  /**
   * Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be DISABLED. Valid values are DISABLED and ENABLED.
   *
   * @schema AppMonitorSpecForProviderCustomEvents#status
   */
  readonly status?: string;

}

/**
 * Converts an object of type 'AppMonitorSpecForProviderCustomEvents' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecForProviderCustomEvents(obj: AppMonitorSpecForProviderCustomEvents | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'status': obj.status,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppMonitorSpecProviderConfigRefPolicy
 */
export interface AppMonitorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppMonitorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AppMonitorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppMonitorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AppMonitorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppMonitorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecProviderConfigRefPolicy(obj: AppMonitorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AppMonitorSpecProviderRefPolicy
 */
export interface AppMonitorSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppMonitorSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AppMonitorSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppMonitorSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AppMonitorSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AppMonitorSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecProviderRefPolicy(obj: AppMonitorSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AppMonitorSpecPublishConnectionDetailsToConfigRef
 */
export interface AppMonitorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AppMonitorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecPublishConnectionDetailsToConfigRef(obj: AppMonitorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AppMonitorSpecPublishConnectionDetailsToMetadata
 */
export interface AppMonitorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AppMonitorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecPublishConnectionDetailsToMetadata(obj: AppMonitorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppMonitorSpecProviderConfigRefPolicyResolution
 */
export enum AppMonitorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppMonitorSpecProviderConfigRefPolicyResolve
 */
export enum AppMonitorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppMonitorSpecProviderRefPolicyResolution
 */
export enum AppMonitorSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppMonitorSpecProviderRefPolicyResolve
 */
export enum AppMonitorSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AppMonitorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AppMonitorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy(obj: AppMonitorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AppMonitorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AppMonitorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AppMonitorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AppMonitorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MetricsDestination is the Schema for the MetricsDestinations API. Provides a CloudWatch RUM Metrics Destination resource.
 *
 * @schema MetricsDestination
 */
export class MetricsDestination extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MetricsDestination"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'rum.aws.upbound.io/v1beta1',
    kind: 'MetricsDestination',
  }

  /**
   * Renders a Kubernetes manifest for "MetricsDestination".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MetricsDestinationProps): any {
    return {
      ...MetricsDestination.GVK,
      ...toJson_MetricsDestinationProps(props),
    };
  }

  /**
   * Defines a "MetricsDestination" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MetricsDestinationProps) {
    super(scope, id, {
      ...MetricsDestination.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MetricsDestination.GVK,
      ...toJson_MetricsDestinationProps(resolved),
    };
  }
}

/**
 * MetricsDestination is the Schema for the MetricsDestinations API. Provides a CloudWatch RUM Metrics Destination resource.
 *
 * @schema MetricsDestination
 */
export interface MetricsDestinationProps {
  /**
   * @schema MetricsDestination#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MetricsDestinationSpec defines the desired state of MetricsDestination
   *
   * @schema MetricsDestination#spec
   */
  readonly spec: MetricsDestinationSpec;

}

/**
 * Converts an object of type 'MetricsDestinationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationProps(obj: MetricsDestinationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MetricsDestinationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetricsDestinationSpec defines the desired state of MetricsDestination
 *
 * @schema MetricsDestinationSpec
 */
export interface MetricsDestinationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MetricsDestinationSpec#deletionPolicy
   */
  readonly deletionPolicy?: MetricsDestinationSpecDeletionPolicy;

  /**
   * @schema MetricsDestinationSpec#forProvider
   */
  readonly forProvider: MetricsDestinationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MetricsDestinationSpec#managementPolicy
   */
  readonly managementPolicy?: MetricsDestinationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MetricsDestinationSpec#providerConfigRef
   */
  readonly providerConfigRef?: MetricsDestinationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MetricsDestinationSpec#providerRef
   */
  readonly providerRef?: MetricsDestinationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MetricsDestinationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MetricsDestinationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MetricsDestinationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MetricsDestinationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MetricsDestinationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpec(obj: MetricsDestinationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MetricsDestinationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MetricsDestinationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MetricsDestinationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MetricsDestinationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MetricsDestinationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MetricsDestinationSpecDeletionPolicy
 */
export enum MetricsDestinationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MetricsDestinationSpecForProvider
 */
export interface MetricsDestinationSpecForProvider {
  /**
   * The name of the CloudWatch RUM app monitor that will send the metrics.
   *
   * @schema MetricsDestinationSpecForProvider#appMonitorName
   */
  readonly appMonitorName?: string;

  /**
   * Reference to a AppMonitor in rum to populate appMonitorName.
   *
   * @schema MetricsDestinationSpecForProvider#appMonitorNameRef
   */
  readonly appMonitorNameRef?: MetricsDestinationSpecForProviderAppMonitorNameRef;

  /**
   * Selector for a AppMonitor in rum to populate appMonitorName.
   *
   * @schema MetricsDestinationSpecForProvider#appMonitorNameSelector
   */
  readonly appMonitorNameSelector?: MetricsDestinationSpecForProviderAppMonitorNameSelector;

  /**
   * Defines the destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the CloudWatchEvidently experiment that is to be the destination and an IAM role that has permission to write to the experiment.
   *
   * @schema MetricsDestinationSpecForProvider#destination
   */
  readonly destination?: string;

  /**
   * Use this parameter only if Destination is Evidently. This parameter specifies the ARN of the Evidently experiment that will receive the extended metrics.
   *
   * @schema MetricsDestinationSpecForProvider#destinationArn
   */
  readonly destinationArn?: string;

  /**
   * This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter.
   *
   * @schema MetricsDestinationSpecForProvider#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema MetricsDestinationSpecForProvider#iamRoleArnRef
   */
  readonly iamRoleArnRef?: MetricsDestinationSpecForProviderIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema MetricsDestinationSpecForProvider#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: MetricsDestinationSpecForProviderIamRoleArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MetricsDestinationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProvider(obj: MetricsDestinationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appMonitorName': obj.appMonitorName,
    'appMonitorNameRef': toJson_MetricsDestinationSpecForProviderAppMonitorNameRef(obj.appMonitorNameRef),
    'appMonitorNameSelector': toJson_MetricsDestinationSpecForProviderAppMonitorNameSelector(obj.appMonitorNameSelector),
    'destination': obj.destination,
    'destinationArn': obj.destinationArn,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_MetricsDestinationSpecForProviderIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_MetricsDestinationSpecForProviderIamRoleArnSelector(obj.iamRoleArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MetricsDestinationSpecManagementPolicy
 */
export enum MetricsDestinationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MetricsDestinationSpecProviderConfigRef
 */
export interface MetricsDestinationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricsDestinationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricsDestinationSpecProviderConfigRef#policy
   */
  readonly policy?: MetricsDestinationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricsDestinationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecProviderConfigRef(obj: MetricsDestinationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricsDestinationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MetricsDestinationSpecProviderRef
 */
export interface MetricsDestinationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricsDestinationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricsDestinationSpecProviderRef#policy
   */
  readonly policy?: MetricsDestinationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MetricsDestinationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecProviderRef(obj: MetricsDestinationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricsDestinationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MetricsDestinationSpecPublishConnectionDetailsTo
 */
export interface MetricsDestinationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MetricsDestinationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MetricsDestinationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MetricsDestinationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecPublishConnectionDetailsTo(obj: MetricsDestinationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MetricsDestinationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MetricsDestinationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MetricsDestinationSpecWriteConnectionSecretToRef
 */
export interface MetricsDestinationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MetricsDestinationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MetricsDestinationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MetricsDestinationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecWriteConnectionSecretToRef(obj: MetricsDestinationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AppMonitor in rum to populate appMonitorName.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameRef
 */
export interface MetricsDestinationSpecForProviderAppMonitorNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameRef#policy
   */
  readonly policy?: MetricsDestinationSpecForProviderAppMonitorNameRefPolicy;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderAppMonitorNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderAppMonitorNameRef(obj: MetricsDestinationSpecForProviderAppMonitorNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricsDestinationSpecForProviderAppMonitorNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AppMonitor in rum to populate appMonitorName.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameSelector
 */
export interface MetricsDestinationSpecForProviderAppMonitorNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameSelector#policy
   */
  readonly policy?: MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderAppMonitorNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderAppMonitorNameSelector(obj: MetricsDestinationSpecForProviderAppMonitorNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnRef
 */
export interface MetricsDestinationSpecForProviderIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnRef#policy
   */
  readonly policy?: MetricsDestinationSpecForProviderIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderIamRoleArnRef(obj: MetricsDestinationSpecForProviderIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricsDestinationSpecForProviderIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnSelector
 */
export interface MetricsDestinationSpecForProviderIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnSelector#policy
   */
  readonly policy?: MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderIamRoleArnSelector(obj: MetricsDestinationSpecForProviderIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricsDestinationSpecProviderConfigRefPolicy
 */
export interface MetricsDestinationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricsDestinationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MetricsDestinationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricsDestinationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MetricsDestinationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricsDestinationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecProviderConfigRefPolicy(obj: MetricsDestinationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricsDestinationSpecProviderRefPolicy
 */
export interface MetricsDestinationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricsDestinationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MetricsDestinationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricsDestinationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MetricsDestinationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricsDestinationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecProviderRefPolicy(obj: MetricsDestinationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRef
 */
export interface MetricsDestinationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MetricsDestinationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecPublishConnectionDetailsToConfigRef(obj: MetricsDestinationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MetricsDestinationSpecPublishConnectionDetailsToMetadata
 */
export interface MetricsDestinationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MetricsDestinationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecPublishConnectionDetailsToMetadata(obj: MetricsDestinationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameRefPolicy
 */
export interface MetricsDestinationSpecForProviderAppMonitorNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameRefPolicy#resolution
   */
  readonly resolution?: MetricsDestinationSpecForProviderAppMonitorNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameRefPolicy#resolve
   */
  readonly resolve?: MetricsDestinationSpecForProviderAppMonitorNameRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderAppMonitorNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderAppMonitorNameRefPolicy(obj: MetricsDestinationSpecForProviderAppMonitorNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy
 */
export interface MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy#resolution
   */
  readonly resolution?: MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy#resolve
   */
  readonly resolve?: MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy(obj: MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnRefPolicy
 */
export interface MetricsDestinationSpecForProviderIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: MetricsDestinationSpecForProviderIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: MetricsDestinationSpecForProviderIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderIamRoleArnRefPolicy(obj: MetricsDestinationSpecForProviderIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy
 */
export interface MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: MetricsDestinationSpecForProviderIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: MetricsDestinationSpecForProviderIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy(obj: MetricsDestinationSpecForProviderIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricsDestinationSpecProviderConfigRefPolicyResolution
 */
export enum MetricsDestinationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricsDestinationSpecProviderConfigRefPolicyResolve
 */
export enum MetricsDestinationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricsDestinationSpecProviderRefPolicyResolution
 */
export enum MetricsDestinationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricsDestinationSpecProviderRefPolicyResolve
 */
export enum MetricsDestinationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj: MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameRefPolicyResolution
 */
export enum MetricsDestinationSpecForProviderAppMonitorNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameRefPolicyResolve
 */
export enum MetricsDestinationSpecForProviderAppMonitorNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicyResolution
 */
export enum MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicyResolve
 */
export enum MetricsDestinationSpecForProviderAppMonitorNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnRefPolicyResolution
 */
export enum MetricsDestinationSpecForProviderIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnRefPolicyResolve
 */
export enum MetricsDestinationSpecForProviderIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnSelectorPolicyResolution
 */
export enum MetricsDestinationSpecForProviderIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricsDestinationSpecForProviderIamRoleArnSelectorPolicyResolve
 */
export enum MetricsDestinationSpecForProviderIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MetricsDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

