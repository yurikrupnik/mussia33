// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Certificate is the Schema for the Certificates API. Provides a DMS (Data Migration Service) certificate resource.
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dms.aws.upbound.io/v1beta1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * Certificate is the Schema for the Certificates API. Provides a DMS (Data Migration Service) certificate resource.
 *
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CertificateSpec defines the desired state of Certificate
   *
   * @schema Certificate#spec
   */
  readonly spec: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateSpec defines the desired state of Certificate
 *
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateSpec#deletionPolicy
   */
  readonly deletionPolicy?: CertificateSpecDeletionPolicy;

  /**
   * @schema CertificateSpec#forProvider
   */
  readonly forProvider: CertificateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CertificateSpec#managementPolicy
   */
  readonly managementPolicy?: CertificateSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CertificateSpec#providerConfigRef
   */
  readonly providerConfigRef?: CertificateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema CertificateSpec#providerRef
   */
  readonly providerRef?: CertificateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CertificateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CertificateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CertificateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CertificateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CertificateSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_CertificateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_CertificateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_CertificateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CertificateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateSpecDeletionPolicy
 */
export enum CertificateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CertificateSpecForProvider
 */
export interface CertificateSpecForProvider {
  /**
   * The contents of the .pem X.509 certificate file for the certificate. Either certificate_pem or certificate_wallet must be set.
   *
   * @schema CertificateSpecForProvider#certificatePemSecretRef
   */
  readonly certificatePemSecretRef?: CertificateSpecForProviderCertificatePemSecretRef;

  /**
   * The contents of the Oracle Wallet certificate for use with SSL, provided as a base64-encoded String. Either certificate_pem or certificate_wallet must be set.
   *
   * @schema CertificateSpecForProvider#certificateWalletSecretRef
   */
  readonly certificateWalletSecretRef?: CertificateSpecForProviderCertificateWalletSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CertificateSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CertificateSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CertificateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProvider(obj: CertificateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificatePemSecretRef': toJson_CertificateSpecForProviderCertificatePemSecretRef(obj.certificatePemSecretRef),
    'certificateWalletSecretRef': toJson_CertificateSpecForProviderCertificateWalletSecretRef(obj.certificateWalletSecretRef),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CertificateSpecManagementPolicy
 */
export enum CertificateSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CertificateSpecProviderConfigRef
 */
export interface CertificateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderConfigRef#policy
   */
  readonly policy?: CertificateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRef(obj: CertificateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema CertificateSpecProviderRef
 */
export interface CertificateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecProviderRef#policy
   */
  readonly policy?: CertificateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderRef(obj: CertificateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CertificateSpecPublishConnectionDetailsTo
 */
export interface CertificateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CertificateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CertificateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CertificateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsTo(obj: CertificateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CertificateSpecWriteConnectionSecretToRef
 */
export interface CertificateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecWriteConnectionSecretToRef(obj: CertificateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The contents of the .pem X.509 certificate file for the certificate. Either certificate_pem or certificate_wallet must be set.
 *
 * @schema CertificateSpecForProviderCertificatePemSecretRef
 */
export interface CertificateSpecForProviderCertificatePemSecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateSpecForProviderCertificatePemSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateSpecForProviderCertificatePemSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecForProviderCertificatePemSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificatePemSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificatePemSecretRef(obj: CertificateSpecForProviderCertificatePemSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The contents of the Oracle Wallet certificate for use with SSL, provided as a base64-encoded String. Either certificate_pem or certificate_wallet must be set.
 *
 * @schema CertificateSpecForProviderCertificateWalletSecretRef
 */
export interface CertificateSpecForProviderCertificateWalletSecretRef {
  /**
   * The key to select.
   *
   * @schema CertificateSpecForProviderCertificateWalletSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema CertificateSpecForProviderCertificateWalletSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CertificateSpecForProviderCertificateWalletSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CertificateSpecForProviderCertificateWalletSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecForProviderCertificateWalletSecretRef(obj: CertificateSpecForProviderCertificateWalletSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderConfigRefPolicy
 */
export interface CertificateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderConfigRefPolicy(obj: CertificateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecProviderRefPolicy
 */
export interface CertificateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecProviderRefPolicy(obj: CertificateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRef
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CertificateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRef(obj: CertificateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CertificateSpecPublishConnectionDetailsToMetadata
 */
export interface CertificateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CertificateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToMetadata(obj: CertificateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolution
 */
export enum CertificateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderConfigRefPolicyResolve
 */
export enum CertificateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecProviderRefPolicyResolution
 */
export enum CertificateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecProviderRefPolicyResolve
 */
export enum CertificateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CertificateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CertificateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPublishConnectionDetailsToConfigRefPolicy(obj: CertificateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CertificateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Endpoint is the Schema for the Endpoints API. Provides a DMS (Data Migration Service) endpoint resource.
 *
 * @schema Endpoint
 */
export class Endpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Endpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dms.aws.upbound.io/v1beta1',
    kind: 'Endpoint',
  }

  /**
   * Renders a Kubernetes manifest for "Endpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EndpointProps): any {
    return {
      ...Endpoint.GVK,
      ...toJson_EndpointProps(props),
    };
  }

  /**
   * Defines a "Endpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EndpointProps) {
    super(scope, id, {
      ...Endpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Endpoint.GVK,
      ...toJson_EndpointProps(resolved),
    };
  }
}

/**
 * Endpoint is the Schema for the Endpoints API. Provides a DMS (Data Migration Service) endpoint resource.
 *
 * @schema Endpoint
 */
export interface EndpointProps {
  /**
   * @schema Endpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EndpointSpec defines the desired state of Endpoint
   *
   * @schema Endpoint#spec
   */
  readonly spec: EndpointSpec;

}

/**
 * Converts an object of type 'EndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointProps(obj: EndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EndpointSpec defines the desired state of Endpoint
 *
 * @schema EndpointSpec
 */
export interface EndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: EndpointSpecDeletionPolicy;

  /**
   * @schema EndpointSpec#forProvider
   */
  readonly forProvider: EndpointSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EndpointSpec#managementPolicy
   */
  readonly managementPolicy?: EndpointSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: EndpointSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EndpointSpec#providerRef
   */
  readonly providerRef?: EndpointSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpec(obj: EndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EndpointSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EndpointSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EndpointSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointSpecDeletionPolicy
 */
export enum EndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EndpointSpecForProvider
 */
export interface EndpointSpecForProvider {
  /**
   * ARN for the certificate.
   *
   * @schema EndpointSpecForProvider#certificateArn
   */
  readonly certificateArn?: string;

  /**
   * Name of the endpoint database.
   *
   * @schema EndpointSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * Configuration block for OpenSearch settings. See below.
   *
   * @schema EndpointSpecForProvider#elasticsearchSettings
   */
  readonly elasticsearchSettings?: EndpointSpecForProviderElasticsearchSettings[];

  /**
   * Type of endpoint. Valid values are source, target.
   *
   * @schema EndpointSpecForProvider#endpointType
   */
  readonly endpointType?: string;

  /**
   * Type of engine for the endpoint. Valid values are aurora, aurora-postgresql, azuredb, azure-sql-managed-instance, db2, docdb, dynamodb, elasticsearch, kafka, kinesis, mariadb, mongodb, mysql, opensearch, oracle, postgres, redshift, s3, sqlserver, sybase. Please note that some of engine names are available only for target endpoint type (e.g. redshift).
   *
   * @schema EndpointSpecForProvider#engineName
   */
  readonly engineName?: string;

  /**
   * Additional attributes associated with the connection. For available attributes for a source Endpoint, see Sources for data migration. For available attributes for a target Endpoint, see Targets for data migration.
   *
   * @schema EndpointSpecForProvider#extraConnectionAttributes
   */
  readonly extraConnectionAttributes?: string;

  /**
   * Configuration block for Kafka settings. See below.
   *
   * @schema EndpointSpecForProvider#kafkaSettings
   */
  readonly kafkaSettings?: EndpointSpecForProviderKafkaSettings[];

  /**
   * Configuration block for Kinesis settings. See below.
   *
   * @schema EndpointSpecForProvider#kinesisSettings
   */
  readonly kinesisSettings?: EndpointSpecForProviderKinesisSettings[];

  /**
   * ARN for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for kms_key_arn, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region. To encrypt an S3 target with a KMS Key, use the parameter s3_settings.server_side_encryption_kms_key_id. When engine_name is redshift, kms_key_arn is the KMS Key for the Redshift target and the parameter redshift_settings.server_side_encryption_kms_key_id encrypts the S3 intermediate storage.
   *
   * @schema EndpointSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema EndpointSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: EndpointSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema EndpointSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: EndpointSpecForProviderKmsKeyArnSelector;

  /**
   * Configuration block for MongoDB settings. See below.
   *
   * @schema EndpointSpecForProvider#mongodbSettings
   */
  readonly mongodbSettings?: EndpointSpecForProviderMongodbSettings[];

  /**
   * Password to be used to login to the endpoint database.
   *
   * @schema EndpointSpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: EndpointSpecForProviderPasswordSecretRef;

  /**
   * Port used by the endpoint database.
   *
   * @schema EndpointSpecForProvider#port
   */
  readonly port?: number;

  /**
   * @schema EndpointSpecForProvider#redisSettings
   */
  readonly redisSettings?: EndpointSpecForProviderRedisSettings[];

  /**
   * Configuration block for Redshift settings. See below.
   *
   * @schema EndpointSpecForProvider#redshiftSettings
   */
  readonly redshiftSettings?: EndpointSpecForProviderRedshiftSettings[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * (Deprecated, use the aws_dms_s3_endpoint resource instead) Configuration block for S3 settings. See below. This argument is deprecated and will be removed in a future version; use aws_dms_s3_endpoint instead
   *
   * @schema EndpointSpecForProvider#s3Settings
   */
  readonly s3Settings?: EndpointSpecForProviderS3Settings[];

  /**
   * ARN of the IAM role that specifies AWS DMS as the trusted entity and has the required permissions to access the value in SecretsManagerSecret.
   *
   * @schema EndpointSpecForProvider#secretsManagerAccessRoleArn
   */
  readonly secretsManagerAccessRoleArn?: string;

  /**
   * Reference to a Role in iam to populate secretsManagerAccessRoleArn.
   *
   * @schema EndpointSpecForProvider#secretsManagerAccessRoleArnRef
   */
  readonly secretsManagerAccessRoleArnRef?: EndpointSpecForProviderSecretsManagerAccessRoleArnRef;

  /**
   * Selector for a Role in iam to populate secretsManagerAccessRoleArn.
   *
   * @schema EndpointSpecForProvider#secretsManagerAccessRoleArnSelector
   */
  readonly secretsManagerAccessRoleArnSelector?: EndpointSpecForProviderSecretsManagerAccessRoleArnSelector;

  /**
   * Full ARN, partial ARN, or friendly name of the SecretsManagerSecret that contains the endpoint connection details. Supported only when engine_name is aurora, aurora-postgresql, mariadb, mongodb, mysql, oracle, postgres, redshift, or sqlserver.
   *
   * @schema EndpointSpecForProvider#secretsManagerArn
   */
  readonly secretsManagerArn?: string;

  /**
   * Host name of the server.
   *
   * @schema EndpointSpecForProvider#serverName
   */
  readonly serverName?: string;

  /**
   * ARN used by the service access IAM role for dynamodb endpoints.
   *
   * @schema EndpointSpecForProvider#serviceAccessRole
   */
  readonly serviceAccessRole?: string;

  /**
   * SSL mode to use for the connection. Valid values are none, require, verify-ca, verify-full
   *
   * @schema EndpointSpecForProvider#sslMode
   */
  readonly sslMode?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EndpointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * User name to be used to login to the endpoint database.
   *
   * @schema EndpointSpecForProvider#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'EndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProvider(obj: EndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateArn': obj.certificateArn,
    'databaseName': obj.databaseName,
    'elasticsearchSettings': obj.elasticsearchSettings?.map(y => toJson_EndpointSpecForProviderElasticsearchSettings(y)),
    'endpointType': obj.endpointType,
    'engineName': obj.engineName,
    'extraConnectionAttributes': obj.extraConnectionAttributes,
    'kafkaSettings': obj.kafkaSettings?.map(y => toJson_EndpointSpecForProviderKafkaSettings(y)),
    'kinesisSettings': obj.kinesisSettings?.map(y => toJson_EndpointSpecForProviderKinesisSettings(y)),
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_EndpointSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_EndpointSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'mongodbSettings': obj.mongodbSettings?.map(y => toJson_EndpointSpecForProviderMongodbSettings(y)),
    'passwordSecretRef': toJson_EndpointSpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'port': obj.port,
    'redisSettings': obj.redisSettings?.map(y => toJson_EndpointSpecForProviderRedisSettings(y)),
    'redshiftSettings': obj.redshiftSettings?.map(y => toJson_EndpointSpecForProviderRedshiftSettings(y)),
    'region': obj.region,
    's3Settings': obj.s3Settings?.map(y => toJson_EndpointSpecForProviderS3Settings(y)),
    'secretsManagerAccessRoleArn': obj.secretsManagerAccessRoleArn,
    'secretsManagerAccessRoleArnRef': toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnRef(obj.secretsManagerAccessRoleArnRef),
    'secretsManagerAccessRoleArnSelector': toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnSelector(obj.secretsManagerAccessRoleArnSelector),
    'secretsManagerArn': obj.secretsManagerArn,
    'serverName': obj.serverName,
    'serviceAccessRole': obj.serviceAccessRole,
    'sslMode': obj.sslMode,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EndpointSpecManagementPolicy
 */
export enum EndpointSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EndpointSpecProviderConfigRef
 */
export interface EndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecProviderConfigRef#policy
   */
  readonly policy?: EndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderConfigRef(obj: EndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EndpointSpecProviderRef
 */
export interface EndpointSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecProviderRef#policy
   */
  readonly policy?: EndpointSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderRef(obj: EndpointSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EndpointSpecPublishConnectionDetailsTo
 */
export interface EndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsTo(obj: EndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EndpointSpecWriteConnectionSecretToRef
 */
export interface EndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecWriteConnectionSecretToRef(obj: EndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderElasticsearchSettings
 */
export interface EndpointSpecForProviderElasticsearchSettings {
  /**
   * Endpoint for the OpenSearch cluster.
   *
   * @schema EndpointSpecForProviderElasticsearchSettings#endpointUri
   */
  readonly endpointUri: string;

  /**
   * Maximum number of seconds for which DMS retries failed API requests to the OpenSearch cluster. Default is 300.
   *
   * @default 300.
   * @schema EndpointSpecForProviderElasticsearchSettings#errorRetryDuration
   */
  readonly errorRetryDuration?: number;

  /**
   * Maximum percentage of records that can fail to be written before a full load operation stops. Default is 10.
   *
   * @default 10.
   * @schema EndpointSpecForProviderElasticsearchSettings#fullLoadErrorPercentage
   */
  readonly fullLoadErrorPercentage?: number;

  /**
   * ARN of the IAM Role with permissions to write to the OpenSearch cluster.
   *
   * @schema EndpointSpecForProviderElasticsearchSettings#serviceAccessRoleArn
   */
  readonly serviceAccessRoleArn: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderElasticsearchSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderElasticsearchSettings(obj: EndpointSpecForProviderElasticsearchSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointUri': obj.endpointUri,
    'errorRetryDuration': obj.errorRetryDuration,
    'fullLoadErrorPercentage': obj.fullLoadErrorPercentage,
    'serviceAccessRoleArn': obj.serviceAccessRoleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderKafkaSettings
 */
export interface EndpointSpecForProviderKafkaSettings {
  /**
   * Kafka broker location. Specify in the form broker-hostname-or-ip:port.
   *
   * @schema EndpointSpecForProviderKafkaSettings#broker
   */
  readonly broker: string;

  /**
   * Shows detailed control information for table definition, column definition, and table and column changes in the Kafka message output. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKafkaSettings#includeControlDetails
   */
  readonly includeControlDetails?: boolean;

  /**
   * Include NULL and empty columns for records migrated to the endpoint. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKafkaSettings#includeNullAndEmpty
   */
  readonly includeNullAndEmpty?: boolean;

  /**
   * Shows the partition value within the Kafka message output unless the partition type is schema-table-type. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKafkaSettings#includePartitionValue
   */
  readonly includePartitionValue?: boolean;

  /**
   * Includes any data definition language (DDL) operations that change the table in the control data, such as rename-table, drop-table, add-column, drop-column, and rename-column. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKafkaSettings#includeTableAlterOperations
   */
  readonly includeTableAlterOperations?: boolean;

  /**
   * Provides detailed transaction information from the source database. This information includes a commit timestamp, a log position, and values for transaction_id, previous transaction_id, and transaction_record_id (the record offset within a transaction). Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKafkaSettings#includeTransactionDetails
   */
  readonly includeTransactionDetails?: boolean;

  /**
   * Output format for the records created on the endpoint. Message format is JSON (default) or JSON_UNFORMATTED (a single line with no tab).
   *
   * @schema EndpointSpecForProviderKafkaSettings#messageFormat
   */
  readonly messageFormat?: string;

  /**
   * Maximum size in bytes for records created on the endpoint Default is 1,000,000.
   *
   * @default 1,000,000.
   * @schema EndpointSpecForProviderKafkaSettings#messageMaxBytes
   */
  readonly messageMaxBytes?: number;

  /**
   * Set this optional parameter to true to avoid adding a '0x' prefix to raw data in hexadecimal format. For example, by default, AWS DMS adds a '0x' prefix to the LOB column type in hexadecimal format moving from an Oracle source to a Kafka target. Use the no_hex_prefix endpoint setting to enable migration of RAW data type columns without adding the '0x' prefix.
   *
   * @schema EndpointSpecForProviderKafkaSettings#noHexPrefix
   */
  readonly noHexPrefix?: boolean;

  /**
   * Prefixes schema and table names to partition values, when the partition type is primary-key-type. Doing this increases data distribution among Kafka partitions. For example, suppose that a SysBench schema has thousands of tables and each table has only limited range for a primary key. In this case, the same primary key is sent from thousands of tables to the same partition, which causes throttling. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKafkaSettings#partitionIncludeSchemaTable
   */
  readonly partitionIncludeSchemaTable?: boolean;

  /**
   * Secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
   *
   * @schema EndpointSpecForProviderKafkaSettings#saslPasswordSecretRef
   */
  readonly saslPasswordSecretRef?: EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef;

  /**
   * Secure user name you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
   *
   * @schema EndpointSpecForProviderKafkaSettings#saslUsername
   */
  readonly saslUsername?: string;

  /**
   * Set secure connection to a Kafka target endpoint using Transport Layer Security (TLS). Options include ssl-encryption, ssl-authentication, and sasl-ssl. sasl-ssl requires sasl_username and sasl_password.
   *
   * @schema EndpointSpecForProviderKafkaSettings#securityProtocol
   */
  readonly securityProtocol?: string;

  /**
   * ARN for the private certificate authority (CA) cert that AWS DMS uses to securely connect to your Kafka target endpoint.
   *
   * @schema EndpointSpecForProviderKafkaSettings#sslCaCertificateArn
   */
  readonly sslCaCertificateArn?: string;

  /**
   * ARN of the client certificate used to securely connect to a Kafka target endpoint.
   *
   * @schema EndpointSpecForProviderKafkaSettings#sslClientCertificateArn
   */
  readonly sslClientCertificateArn?: string;

  /**
   * ARN for the client private key used to securely connect to a Kafka target endpoint.
   *
   * @schema EndpointSpecForProviderKafkaSettings#sslClientKeyArn
   */
  readonly sslClientKeyArn?: string;

  /**
   * Password for the client private key used to securely connect to a Kafka target endpoint.
   *
   * @schema EndpointSpecForProviderKafkaSettings#sslClientKeyPasswordSecretRef
   */
  readonly sslClientKeyPasswordSecretRef?: EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef;

  /**
   * Kafka topic for migration. Default is kafka-default-topic.
   *
   * @default kafka-default-topic.
   * @schema EndpointSpecForProviderKafkaSettings#topic
   */
  readonly topic?: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKafkaSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKafkaSettings(obj: EndpointSpecForProviderKafkaSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'broker': obj.broker,
    'includeControlDetails': obj.includeControlDetails,
    'includeNullAndEmpty': obj.includeNullAndEmpty,
    'includePartitionValue': obj.includePartitionValue,
    'includeTableAlterOperations': obj.includeTableAlterOperations,
    'includeTransactionDetails': obj.includeTransactionDetails,
    'messageFormat': obj.messageFormat,
    'messageMaxBytes': obj.messageMaxBytes,
    'noHexPrefix': obj.noHexPrefix,
    'partitionIncludeSchemaTable': obj.partitionIncludeSchemaTable,
    'saslPasswordSecretRef': toJson_EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef(obj.saslPasswordSecretRef),
    'saslUsername': obj.saslUsername,
    'securityProtocol': obj.securityProtocol,
    'sslCaCertificateArn': obj.sslCaCertificateArn,
    'sslClientCertificateArn': obj.sslClientCertificateArn,
    'sslClientKeyArn': obj.sslClientKeyArn,
    'sslClientKeyPasswordSecretRef': toJson_EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef(obj.sslClientKeyPasswordSecretRef),
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderKinesisSettings
 */
export interface EndpointSpecForProviderKinesisSettings {
  /**
   * Shows detailed control information for table definition, column definition, and table and column changes in the Kinesis message output. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKinesisSettings#includeControlDetails
   */
  readonly includeControlDetails?: boolean;

  /**
   * Include NULL and empty columns in the target. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKinesisSettings#includeNullAndEmpty
   */
  readonly includeNullAndEmpty?: boolean;

  /**
   * Shows the partition value within the Kinesis message output, unless the partition type is schema-table-type. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKinesisSettings#includePartitionValue
   */
  readonly includePartitionValue?: boolean;

  /**
   * Includes any data definition language (DDL) operations that change the table in the control data. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKinesisSettings#includeTableAlterOperations
   */
  readonly includeTableAlterOperations?: boolean;

  /**
   * Provides detailed transaction information from the source database. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKinesisSettings#includeTransactionDetails
   */
  readonly includeTransactionDetails?: boolean;

  /**
   * Output format for the records created. Default is json. Valid values are json and json-unformatted (a single line with no tab).
   *
   * @default json. Valid values are json and json-unformatted (a single line with no tab).
   * @schema EndpointSpecForProviderKinesisSettings#messageFormat
   */
  readonly messageFormat?: string;

  /**
   * Prefixes schema and table names to partition values, when the partition type is primary-key-type. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderKinesisSettings#partitionIncludeSchemaTable
   */
  readonly partitionIncludeSchemaTable?: boolean;

  /**
   * ARN of the IAM Role with permissions to write to the Kinesis data stream.
   *
   * @schema EndpointSpecForProviderKinesisSettings#serviceAccessRoleArn
   */
  readonly serviceAccessRoleArn?: string;

  /**
   * ARN of the Kinesis data stream.
   *
   * @schema EndpointSpecForProviderKinesisSettings#streamArn
   */
  readonly streamArn?: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKinesisSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKinesisSettings(obj: EndpointSpecForProviderKinesisSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'includeControlDetails': obj.includeControlDetails,
    'includeNullAndEmpty': obj.includeNullAndEmpty,
    'includePartitionValue': obj.includePartitionValue,
    'includeTableAlterOperations': obj.includeTableAlterOperations,
    'includeTransactionDetails': obj.includeTransactionDetails,
    'messageFormat': obj.messageFormat,
    'partitionIncludeSchemaTable': obj.partitionIncludeSchemaTable,
    'serviceAccessRoleArn': obj.serviceAccessRoleArn,
    'streamArn': obj.streamArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema EndpointSpecForProviderKmsKeyArnRef
 */
export interface EndpointSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: EndpointSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKmsKeyArnRef(obj: EndpointSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema EndpointSpecForProviderKmsKeyArnSelector
 */
export interface EndpointSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: EndpointSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKmsKeyArnSelector(obj: EndpointSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderMongodbSettings
 */
export interface EndpointSpecForProviderMongodbSettings {
  /**
   * Authentication mechanism to access the MongoDB source endpoint. Default is default.
   *
   * @default default.
   * @schema EndpointSpecForProviderMongodbSettings#authMechanism
   */
  readonly authMechanism?: string;

  /**
   * Authentication database name. Not used when auth_type is no. Default is admin.
   *
   * @default admin.
   * @schema EndpointSpecForProviderMongodbSettings#authSource
   */
  readonly authSource?: string;

  /**
   * Authentication type to access the MongoDB source endpoint. Default is password.
   *
   * @default password.
   * @schema EndpointSpecForProviderMongodbSettings#authType
   */
  readonly authType?: string;

  /**
   * Number of documents to preview to determine the document organization. Use this setting when nesting_level is set to one. Default is 1000.
   *
   * @default 1000.
   * @schema EndpointSpecForProviderMongodbSettings#docsToInvestigate
   */
  readonly docsToInvestigate?: string;

  /**
   * Document ID. Use this setting when nesting_level is set to none. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderMongodbSettings#extractDocId
   */
  readonly extractDocId?: string;

  /**
   * Specifies either document or table mode. Default is none. Valid values are one (table mode) and none (document mode).
   *
   * @default none. Valid values are one (table mode) and none (document mode).
   * @schema EndpointSpecForProviderMongodbSettings#nestingLevel
   */
  readonly nestingLevel?: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderMongodbSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderMongodbSettings(obj: EndpointSpecForProviderMongodbSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authMechanism': obj.authMechanism,
    'authSource': obj.authSource,
    'authType': obj.authType,
    'docsToInvestigate': obj.docsToInvestigate,
    'extractDocId': obj.extractDocId,
    'nestingLevel': obj.nestingLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password to be used to login to the endpoint database.
 *
 * @schema EndpointSpecForProviderPasswordSecretRef
 */
export interface EndpointSpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema EndpointSpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema EndpointSpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointSpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderPasswordSecretRef(obj: EndpointSpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderRedisSettings
 */
export interface EndpointSpecForProviderRedisSettings {
  /**
   * The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
   *
   * @schema EndpointSpecForProviderRedisSettings#authPasswordSecretRef
   */
  readonly authPasswordSecretRef?: EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef;

  /**
   * Authentication type to access the MongoDB source endpoint. Default is password.
   *
   * @default password.
   * @schema EndpointSpecForProviderRedisSettings#authType
   */
  readonly authType: string;

  /**
   * The username provided with the auth-role option of the AuthType setting for a Redis target endpoint.
   *
   * @schema EndpointSpecForProviderRedisSettings#authUserName
   */
  readonly authUserName?: string;

  /**
   * Port used by the endpoint database.
   *
   * @schema EndpointSpecForProviderRedisSettings#port
   */
  readonly port: number;

  /**
   * Host name of the server.
   *
   * @schema EndpointSpecForProviderRedisSettings#serverName
   */
  readonly serverName: string;

  /**
   * The Amazon Resource Name (ARN) for the certificate authority (CA) that DMS uses to connect to your Redis target endpoint.
   *
   * @schema EndpointSpecForProviderRedisSettings#sslCaCertificateArn
   */
  readonly sslCaCertificateArn?: string;

  /**
   * The plaintext option doesn't provide Transport Layer Security (TLS) encryption for traffic between endpoint and database. Options include plaintext, ssl-encryption. The default is ssl-encryption.
   *
   * @schema EndpointSpecForProviderRedisSettings#sslSecurityProtocol
   */
  readonly sslSecurityProtocol?: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderRedisSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderRedisSettings(obj: EndpointSpecForProviderRedisSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authPasswordSecretRef': toJson_EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef(obj.authPasswordSecretRef),
    'authType': obj.authType,
    'authUserName': obj.authUserName,
    'port': obj.port,
    'serverName': obj.serverName,
    'sslCaCertificateArn': obj.sslCaCertificateArn,
    'sslSecurityProtocol': obj.sslSecurityProtocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderRedshiftSettings
 */
export interface EndpointSpecForProviderRedshiftSettings {
  /**
   * Custom S3 Bucket Object prefix for intermediate storage.
   *
   * @schema EndpointSpecForProviderRedshiftSettings#bucketFolder
   */
  readonly bucketFolder?: string;

  /**
   * Custom S3 Bucket name for intermediate storage.
   *
   * @schema EndpointSpecForProviderRedshiftSettings#bucketName
   */
  readonly bucketName?: string;

  /**
   * The server-side encryption mode that you want to encrypt your intermediate .csv object files copied to S3. Defaults to SSE_S3. Valid values are SSE_S3 and SSE_KMS.
   *
   * @default SSE_S3. Valid values are SSE_S3 and SSE_KMS.
   * @schema EndpointSpecForProviderRedshiftSettings#encryptionMode
   */
  readonly encryptionMode?: string;

  /**
   * ARN or Id of KMS Key to use when encryption_mode is SSE_KMS.
   *
   * @schema EndpointSpecForProviderRedshiftSettings#serverSideEncryptionKmsKeyId
   */
  readonly serverSideEncryptionKmsKeyId?: string;

  /**
   * Amazon Resource Name (ARN) of the IAM Role with permissions to read from or write to the S3 Bucket for intermediate storage.
   *
   * @schema EndpointSpecForProviderRedshiftSettings#serviceAccessRoleArn
   */
  readonly serviceAccessRoleArn?: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderRedshiftSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderRedshiftSettings(obj: EndpointSpecForProviderRedshiftSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketFolder': obj.bucketFolder,
    'bucketName': obj.bucketName,
    'encryptionMode': obj.encryptionMode,
    'serverSideEncryptionKmsKeyId': obj.serverSideEncryptionKmsKeyId,
    'serviceAccessRoleArn': obj.serviceAccessRoleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EndpointSpecForProviderS3Settings
 */
export interface EndpointSpecForProviderS3Settings {
  /**
   * Whether to add column name information to the .csv output file. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#addColumnName
   */
  readonly addColumnName?: boolean;

  /**
   * S3 object prefix.
   *
   * @schema EndpointSpecForProviderS3Settings#bucketFolder
   */
  readonly bucketFolder?: string;

  /**
   * S3 bucket name.
   *
   * @schema EndpointSpecForProviderS3Settings#bucketName
   */
  readonly bucketName?: string;

  /**
   * Predefined (canned) access control list for objects created in an S3 bucket. Valid values include none, private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, and bucket-owner-full-control. Default is none.
   *
   * @default none.
   * @schema EndpointSpecForProviderS3Settings#cannedAclForObjects
   */
  readonly cannedAclForObjects?: string;

  /**
   * Whether to write insert and update operations to .csv or .parquet output files. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#cdcInsertsAndUpdates
   */
  readonly cdcInsertsAndUpdates?: boolean;

  /**
   * Whether to write insert operations to .csv or .parquet output files. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#cdcInsertsOnly
   */
  readonly cdcInsertsOnly?: boolean;

  /**
   * Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. Default is 60.
   *
   * @default 60.
   * @schema EndpointSpecForProviderS3Settings#cdcMaxBatchInterval
   */
  readonly cdcMaxBatchInterval?: number;

  /**
   * Minimum file size condition as defined in kilobytes to output a file to Amazon S3. Default is 32000. NOTE: Previously, this setting was measured in megabytes but now represents kilobytes. Update configurations accordingly.
   *
   * @default 32000. NOTE: Previously, this setting was measured in megabytes but now represents kilobytes. Update configurations accordingly.
   * @schema EndpointSpecForProviderS3Settings#cdcMinFileSize
   */
  readonly cdcMinFileSize?: number;

  /**
   * Folder path of CDC files. For an S3 source, this setting is required if a task captures change data; otherwise, it's optional. If cdc_path is set, AWS DMS reads CDC files from this path and replicates the data changes to the target endpoint. Supported in AWS DMS versions 3.4.2 and later.
   *
   * @schema EndpointSpecForProviderS3Settings#cdcPath
   */
  readonly cdcPath?: string;

  /**
   * Set to compress target files. Default is NONE. Valid values are GZIP and NONE.
   *
   * @default NONE. Valid values are GZIP and NONE.
   * @schema EndpointSpecForProviderS3Settings#compressionType
   */
  readonly compressionType?: string;

  /**
   * Delimiter used to separate columns in the source files. Default is ,.
   *
   * @default .
   * @schema EndpointSpecForProviderS3Settings#csvDelimiter
   */
  readonly csvDelimiter?: string;

  /**
   * String to use for all columns not included in the supplemental log.
   *
   * @schema EndpointSpecForProviderS3Settings#csvNoSupValue
   */
  readonly csvNoSupValue?: string;

  /**
   * String to as null when writing to the target.
   *
   * @schema EndpointSpecForProviderS3Settings#csvNullValue
   */
  readonly csvNullValue?: string;

  /**
   * Delimiter used to separate rows in the source files. Default is \n.
   *
   * @default n.
   * @schema EndpointSpecForProviderS3Settings#csvRowDelimiter
   */
  readonly csvRowDelimiter?: string;

  /**
   * Output format for the files that AWS DMS uses to create S3 objects. Valid values are csv and parquet. Default is csv.
   *
   * @default csv.
   * @schema EndpointSpecForProviderS3Settings#dataFormat
   */
  readonly dataFormat?: string;

  /**
   * Size of one data page in bytes. Default is 1048576 (1 MiB).
   *
   * @default 1048576 (1 MiB).
   * @schema EndpointSpecForProviderS3Settings#dataPageSize
   */
  readonly dataPageSize?: number;

  /**
   * Date separating delimiter to use during folder partitioning. Valid values are SLASH, UNDERSCORE, DASH, and NONE. Default is SLASH.
   *
   * @default SLASH.
   * @schema EndpointSpecForProviderS3Settings#datePartitionDelimiter
   */
  readonly datePartitionDelimiter?: string;

  /**
   * Partition S3 bucket folders based on transaction commit dates. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#datePartitionEnabled
   */
  readonly datePartitionEnabled?: boolean;

  /**
   * Date format to use during folder partitioning. Use this parameter when date_partition_enabled is set to true. Valid values are YYYYMMDD, YYYYMMDDHH, YYYYMM, MMYYYYDD, and DDMMYYYY. Default is YYYYMMDD.
   *
   * @default YYYYMMDD.
   * @schema EndpointSpecForProviderS3Settings#datePartitionSequence
   */
  readonly datePartitionSequence?: string;

  /**
   * Maximum size in bytes of an encoded dictionary page of a column. Default is 1048576 (1 MiB).
   *
   * @default 1048576 (1 MiB).
   * @schema EndpointSpecForProviderS3Settings#dictPageSizeLimit
   */
  readonly dictPageSizeLimit?: number;

  /**
   * Whether to enable statistics for Parquet pages and row groups. Default is true.
   *
   * @default true.
   * @schema EndpointSpecForProviderS3Settings#enableStatistics
   */
  readonly enableStatistics?: boolean;

  /**
   * Type of encoding to use. Value values are rle_dictionary, plain, and plain_dictionary. Default is rle_dictionary.
   *
   * @default rle_dictionary.
   * @schema EndpointSpecForProviderS3Settings#encodingType
   */
  readonly encodingType?: string;

  /**
   * Server-side encryption mode that you want to encrypt your .csv or .parquet object files copied to S3. Valid values are SSE_S3 and SSE_KMS. Default is SSE_S3.
   *
   * @default SSE_S3.
   * @schema EndpointSpecForProviderS3Settings#encryptionMode
   */
  readonly encryptionMode?: string;

  /**
   * JSON document that describes how AWS DMS should interpret the data.
   *
   * @schema EndpointSpecForProviderS3Settings#externalTableDefinition
   */
  readonly externalTableDefinition?: string;

  /**
   * When this value is set to 1, DMS ignores the first row header in a .csv file. Default is 0.
   *
   * @default 0.
   * @schema EndpointSpecForProviderS3Settings#ignoreHeaderRows
   */
  readonly ignoreHeaderRows?: number;

  /**
   * Deprecated. This setting has no effect. Will be removed in a future version. This setting has no effect, is deprecated, and will be removed in a future version
   *
   * @schema EndpointSpecForProviderS3Settings#ignoreHeadersRow
   */
  readonly ignoreHeadersRow?: number;

  /**
   * Whether to enable a full load to write INSERT operations to the .csv output files only to indicate how the rows were added to the source database. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#includeOpForFullLoad
   */
  readonly includeOpForFullLoad?: boolean;

  /**
   * Maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. Valid values are from 1 to 1048576. Default is 1048576 (1 GB).
   *
   * @default 1048576 (1 GB).
   * @schema EndpointSpecForProviderS3Settings#maxFileSize
   */
  readonly maxFileSize?: number;

  /**
   * - Specifies the precision of any TIMESTAMP column values written to an S3 object file in .parquet format. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#parquetTimestampInMillisecond
   */
  readonly parquetTimestampInMillisecond?: boolean;

  /**
   * Version of the .parquet file format. Default is parquet-1-0. Valid values are parquet-1-0 and parquet-2-0.
   *
   * @default parquet-1-0. Valid values are parquet-1-0 and parquet-2-0.
   * @schema EndpointSpecForProviderS3Settings#parquetVersion
   */
  readonly parquetVersion?: string;

  /**
   * Whether DMS saves the transaction order for a CDC load on the S3 target specified by cdc_path. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#preserveTransactions
   */
  readonly preserveTransactions?: boolean;

  /**
   * For an S3 source, whether each leading double quotation mark has to be followed by an ending double quotation mark. Default is true.
   *
   * @default true.
   * @schema EndpointSpecForProviderS3Settings#rfc4180
   */
  readonly rfc4180?: boolean;

  /**
   * Number of rows in a row group. Default is 10000.
   *
   * @default 10000.
   * @schema EndpointSpecForProviderS3Settings#rowGroupLength
   */
  readonly rowGroupLength?: number;

  /**
   * ARN or Id of KMS Key to use when encryption_mode is SSE_KMS.
   *
   * @schema EndpointSpecForProviderS3Settings#serverSideEncryptionKmsKeyId
   */
  readonly serverSideEncryptionKmsKeyId?: string;

  /**
   * ARN of the IAM Role with permissions to read from or write to the S3 Bucket.
   *
   * @schema EndpointSpecForProviderS3Settings#serviceAccessRoleArn
   */
  readonly serviceAccessRoleArn?: string;

  /**
   * Column to add with timestamp information to the endpoint data for an Amazon S3 target.
   *
   * @schema EndpointSpecForProviderS3Settings#timestampColumnName
   */
  readonly timestampColumnName?: string;

  /**
   * Whether to use csv_no_sup_value for columns not included in the supplemental log.
   *
   * @schema EndpointSpecForProviderS3Settings#useCsvNoSupValue
   */
  readonly useCsvNoSupValue?: boolean;

  /**
   * When set to true, uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time. When set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target. Default is false.
   *
   * @default false.
   * @schema EndpointSpecForProviderS3Settings#useTaskStartTimeForFullLoadTimestamp
   */
  readonly useTaskStartTimeForFullLoadTimestamp?: boolean;

}

/**
 * Converts an object of type 'EndpointSpecForProviderS3Settings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderS3Settings(obj: EndpointSpecForProviderS3Settings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addColumnName': obj.addColumnName,
    'bucketFolder': obj.bucketFolder,
    'bucketName': obj.bucketName,
    'cannedAclForObjects': obj.cannedAclForObjects,
    'cdcInsertsAndUpdates': obj.cdcInsertsAndUpdates,
    'cdcInsertsOnly': obj.cdcInsertsOnly,
    'cdcMaxBatchInterval': obj.cdcMaxBatchInterval,
    'cdcMinFileSize': obj.cdcMinFileSize,
    'cdcPath': obj.cdcPath,
    'compressionType': obj.compressionType,
    'csvDelimiter': obj.csvDelimiter,
    'csvNoSupValue': obj.csvNoSupValue,
    'csvNullValue': obj.csvNullValue,
    'csvRowDelimiter': obj.csvRowDelimiter,
    'dataFormat': obj.dataFormat,
    'dataPageSize': obj.dataPageSize,
    'datePartitionDelimiter': obj.datePartitionDelimiter,
    'datePartitionEnabled': obj.datePartitionEnabled,
    'datePartitionSequence': obj.datePartitionSequence,
    'dictPageSizeLimit': obj.dictPageSizeLimit,
    'enableStatistics': obj.enableStatistics,
    'encodingType': obj.encodingType,
    'encryptionMode': obj.encryptionMode,
    'externalTableDefinition': obj.externalTableDefinition,
    'ignoreHeaderRows': obj.ignoreHeaderRows,
    'ignoreHeadersRow': obj.ignoreHeadersRow,
    'includeOpForFullLoad': obj.includeOpForFullLoad,
    'maxFileSize': obj.maxFileSize,
    'parquetTimestampInMillisecond': obj.parquetTimestampInMillisecond,
    'parquetVersion': obj.parquetVersion,
    'preserveTransactions': obj.preserveTransactions,
    'rfc4180': obj.rfc4180,
    'rowGroupLength': obj.rowGroupLength,
    'serverSideEncryptionKmsKeyId': obj.serverSideEncryptionKmsKeyId,
    'serviceAccessRoleArn': obj.serviceAccessRoleArn,
    'timestampColumnName': obj.timestampColumnName,
    'useCsvNoSupValue': obj.useCsvNoSupValue,
    'useTaskStartTimeForFullLoadTimestamp': obj.useTaskStartTimeForFullLoadTimestamp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate secretsManagerAccessRoleArn.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRef
 */
export interface EndpointSpecForProviderSecretsManagerAccessRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRef#policy
   */
  readonly policy?: EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecretsManagerAccessRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnRef(obj: EndpointSpecForProviderSecretsManagerAccessRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate secretsManagerAccessRoleArn.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelector
 */
export interface EndpointSpecForProviderSecretsManagerAccessRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelector#policy
   */
  readonly policy?: EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecretsManagerAccessRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnSelector(obj: EndpointSpecForProviderSecretsManagerAccessRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecProviderConfigRefPolicy
 */
export interface EndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderConfigRefPolicy(obj: EndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecProviderRefPolicy
 */
export interface EndpointSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecProviderRefPolicy(obj: EndpointSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface EndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsToConfigRef(obj: EndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EndpointSpecPublishConnectionDetailsToMetadata
 */
export interface EndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsToMetadata(obj: EndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Secure password you created when you first set up your MSK cluster to validate a client identity and make an encrypted connection between server and client using SASL-SSL authentication.
 *
 * @schema EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef
 */
export interface EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef(obj: EndpointSpecForProviderKafkaSettingsSaslPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the client private key used to securely connect to a Kafka target endpoint.
 *
 * @schema EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef
 */
export interface EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef(obj: EndpointSpecForProviderKafkaSettingsSslClientKeyPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecForProviderKmsKeyArnRefPolicy
 */
export interface EndpointSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKmsKeyArnRefPolicy(obj: EndpointSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface EndpointSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderKmsKeyArnSelectorPolicy(obj: EndpointSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The password provided with the auth-role and auth-token options of the AuthType setting for a Redis target endpoint.
 *
 * @schema EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef
 */
export interface EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef(obj: EndpointSpecForProviderRedisSettingsAuthPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy
 */
export interface EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy(obj: EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy
 */
export interface EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy(obj: EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecProviderConfigRefPolicyResolution
 */
export enum EndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecProviderConfigRefPolicyResolve
 */
export enum EndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecProviderRefPolicyResolution
 */
export enum EndpointSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecProviderRefPolicyResolve
 */
export enum EndpointSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: EndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum EndpointSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum EndpointSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum EndpointSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum EndpointSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicyResolution
 */
export enum EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicyResolve
 */
export enum EndpointSpecForProviderSecretsManagerAccessRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicyResolution
 */
export enum EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicyResolve
 */
export enum EndpointSpecForProviderSecretsManagerAccessRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a DMS (Data Migration Service) event subscription resource.
 *
 * @schema EventSubscription
 */
export class EventSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dms.aws.upbound.io/v1beta1',
    kind: 'EventSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "EventSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventSubscriptionProps): any {
    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(props),
    };
  }

  /**
   * Defines a "EventSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventSubscriptionProps) {
    super(scope, id, {
      ...EventSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(resolved),
    };
  }
}

/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a DMS (Data Migration Service) event subscription resource.
 *
 * @schema EventSubscription
 */
export interface EventSubscriptionProps {
  /**
   * @schema EventSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventSubscriptionSpec defines the desired state of EventSubscription
   *
   * @schema EventSubscription#spec
   */
  readonly spec: EventSubscriptionSpec;

}

/**
 * Converts an object of type 'EventSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionProps(obj: EventSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSubscriptionSpec defines the desired state of EventSubscription
 *
 * @schema EventSubscriptionSpec
 */
export interface EventSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventSubscriptionSpecDeletionPolicy;

  /**
   * @schema EventSubscriptionSpec#forProvider
   */
  readonly forProvider: EventSubscriptionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventSubscriptionSpec#managementPolicy
   */
  readonly managementPolicy?: EventSubscriptionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventSubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EventSubscriptionSpec#providerRef
   */
  readonly providerRef?: EventSubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpec(obj: EventSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventSubscriptionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EventSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EventSubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventSubscriptionSpecDeletionPolicy
 */
export enum EventSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventSubscriptionSpecForProvider
 */
export interface EventSubscriptionSpecForProvider {
  /**
   * Whether the event subscription should be enabled.
   *
   * @schema EventSubscriptionSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * List of event categories to listen for, see DescribeEventCategories for a canonical list.
   *
   * @schema EventSubscriptionSpecForProvider#eventCategories
   */
  readonly eventCategories?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * SNS topic arn to send events on.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArn
   */
  readonly snsTopicArn?: string;

  /**
   * Reference to a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnRef
   */
  readonly snsTopicArnRef?: EventSubscriptionSpecForProviderSnsTopicArnRef;

  /**
   * Selector for a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnSelector
   */
  readonly snsTopicArnSelector?: EventSubscriptionSpecForProviderSnsTopicArnSelector;

  /**
   * Ids of sources to listen to.
   *
   * @schema EventSubscriptionSpecForProvider#sourceIds
   */
  readonly sourceIds?: string[];

  /**
   * Type of source for events. Valid values: replication-instance or replication-task
   *
   * @schema EventSubscriptionSpecForProvider#sourceType
   */
  readonly sourceType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EventSubscriptionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProvider(obj: EventSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'eventCategories': obj.eventCategories?.map(y => y),
    'region': obj.region,
    'snsTopicArn': obj.snsTopicArn,
    'snsTopicArnRef': toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj.snsTopicArnRef),
    'snsTopicArnSelector': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj.snsTopicArnSelector),
    'sourceIds': obj.sourceIds?.map(y => y),
    'sourceType': obj.sourceType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventSubscriptionSpecManagementPolicy
 */
export enum EventSubscriptionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventSubscriptionSpecProviderConfigRef
 */
export interface EventSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRef(obj: EventSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EventSubscriptionSpecProviderRef
 */
export interface EventSubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRef(obj: EventSubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsTo
 */
export interface EventSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj: EventSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventSubscriptionSpecWriteConnectionSecretToRef
 */
export interface EventSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj: EventSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRef
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj: EventSubscriptionSpecForProviderSnsTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj: EventSubscriptionSpecForProviderSnsTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicy
 */
export interface EventSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj: EventSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderRefPolicy
 */
export interface EventSubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRefPolicy(obj: EventSubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj: EventSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReplicationInstance is the Schema for the ReplicationInstances API. Provides a DMS (Data Migration Service) replication instance resource.
 *
 * @schema ReplicationInstance
 */
export class ReplicationInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicationInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dms.aws.upbound.io/v1beta1',
    kind: 'ReplicationInstance',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicationInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicationInstanceProps): any {
    return {
      ...ReplicationInstance.GVK,
      ...toJson_ReplicationInstanceProps(props),
    };
  }

  /**
   * Defines a "ReplicationInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicationInstanceProps) {
    super(scope, id, {
      ...ReplicationInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicationInstance.GVK,
      ...toJson_ReplicationInstanceProps(resolved),
    };
  }
}

/**
 * ReplicationInstance is the Schema for the ReplicationInstances API. Provides a DMS (Data Migration Service) replication instance resource.
 *
 * @schema ReplicationInstance
 */
export interface ReplicationInstanceProps {
  /**
   * @schema ReplicationInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicationInstanceSpec defines the desired state of ReplicationInstance
   *
   * @schema ReplicationInstance#spec
   */
  readonly spec: ReplicationInstanceSpec;

}

/**
 * Converts an object of type 'ReplicationInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceProps(obj: ReplicationInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicationInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicationInstanceSpec defines the desired state of ReplicationInstance
 *
 * @schema ReplicationInstanceSpec
 */
export interface ReplicationInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReplicationInstanceSpecDeletionPolicy;

  /**
   * @schema ReplicationInstanceSpec#forProvider
   */
  readonly forProvider: ReplicationInstanceSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationInstanceSpec#managementPolicy
   */
  readonly managementPolicy?: ReplicationInstanceSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReplicationInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReplicationInstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReplicationInstanceSpec#providerRef
   */
  readonly providerRef?: ReplicationInstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReplicationInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReplicationInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReplicationInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReplicationInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReplicationInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpec(obj: ReplicationInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReplicationInstanceSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReplicationInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReplicationInstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReplicationInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReplicationInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationInstanceSpecDeletionPolicy
 */
export enum ReplicationInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReplicationInstanceSpecForProvider
 */
export interface ReplicationInstanceSpecForProvider {
  /**
   * The amount of storage (in gigabytes) to be initially allocated for the replication instance.
   *
   * @schema ReplicationInstanceSpecForProvider#allocatedStorage
   */
  readonly allocatedStorage?: number;

  /**
   * Indicates that major version upgrades are allowed.
   *
   * @schema ReplicationInstanceSpecForProvider#allowMajorVersionUpgrade
   */
  readonly allowMajorVersionUpgrade?: boolean;

  /**
   * Indicates whether the changes should be applied immediately or during the next maintenance window. Only used when updating an existing resource.
   *
   * @schema ReplicationInstanceSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * Indicates that minor engine upgrades will be applied automatically to the replication instance during the maintenance window.
   *
   * @schema ReplicationInstanceSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The EC2 Availability Zone that the replication instance will be created in.
   *
   * @schema ReplicationInstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The engine version number of the replication instance.
   *
   * @schema ReplicationInstanceSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The Amazon Resource Name (ARN) for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for kms_key_arn, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
   *
   * @schema ReplicationInstanceSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema ReplicationInstanceSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: ReplicationInstanceSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema ReplicationInstanceSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: ReplicationInstanceSpecForProviderKmsKeyArnSelector;

  /**
   * Specifies if the replication instance is a multi-az deployment. You cannot set the availability_zone parameter if the multi_az parameter is set to true.
   *
   * @schema ReplicationInstanceSpecForProvider#multiAz
   */
  readonly multiAz?: boolean;

  /**
   * The weekly time range during which system maintenance can occur, in Universal Coordinated Time (UTC).
   *
   * @schema ReplicationInstanceSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Specifies the accessibility options for the replication instance. A value of true represents an instance with a public IP address. A value of false represents an instance with a private IP address.
   *
   * @schema ReplicationInstanceSpecForProvider#publiclyAccessible
   */
  readonly publiclyAccessible?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReplicationInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The compute and memory capacity of the replication instance as specified by the replication instance class. See AWS DMS User Guide for available instance sizes and advice on which one to choose.
   *
   * @schema ReplicationInstanceSpecForProvider#replicationInstanceClass
   */
  readonly replicationInstanceClass?: string;

  /**
   * A subnet group to associate with the replication instance.
   *
   * @schema ReplicationInstanceSpecForProvider#replicationSubnetGroupId
   */
  readonly replicationSubnetGroupId?: string;

  /**
   * Reference to a ReplicationSubnetGroup in dms to populate replicationSubnetGroupId.
   *
   * @schema ReplicationInstanceSpecForProvider#replicationSubnetGroupIdRef
   */
  readonly replicationSubnetGroupIdRef?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef;

  /**
   * Selector for a ReplicationSubnetGroup in dms to populate replicationSubnetGroupId.
   *
   * @schema ReplicationInstanceSpecForProvider#replicationSubnetGroupIdSelector
   */
  readonly replicationSubnetGroupIdSelector?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema ReplicationInstanceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ReplicationInstanceSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ReplicationInstanceSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * A list of VPC security group IDs to be used with the replication instance. The VPC security groups must work with the VPC containing the replication instance.
   *
   * @schema ReplicationInstanceSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProvider(obj: ReplicationInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allocatedStorage': obj.allocatedStorage,
    'allowMajorVersionUpgrade': obj.allowMajorVersionUpgrade,
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'engineVersion': obj.engineVersion,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_ReplicationInstanceSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_ReplicationInstanceSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'multiAz': obj.multiAz,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'publiclyAccessible': obj.publiclyAccessible,
    'region': obj.region,
    'replicationInstanceClass': obj.replicationInstanceClass,
    'replicationSubnetGroupId': obj.replicationSubnetGroupId,
    'replicationSubnetGroupIdRef': toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef(obj.replicationSubnetGroupIdRef),
    'replicationSubnetGroupIdSelector': toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector(obj.replicationSubnetGroupIdSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationInstanceSpecManagementPolicy
 */
export enum ReplicationInstanceSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReplicationInstanceSpecProviderConfigRef
 */
export interface ReplicationInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: ReplicationInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecProviderConfigRef(obj: ReplicationInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReplicationInstanceSpecProviderRef
 */
export interface ReplicationInstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationInstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationInstanceSpecProviderRef#policy
   */
  readonly policy?: ReplicationInstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecProviderRef(obj: ReplicationInstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationInstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReplicationInstanceSpecPublishConnectionDetailsTo
 */
export interface ReplicationInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReplicationInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReplicationInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecPublishConnectionDetailsTo(obj: ReplicationInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReplicationInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReplicationInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReplicationInstanceSpecWriteConnectionSecretToRef
 */
export interface ReplicationInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReplicationInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicationInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecWriteConnectionSecretToRef(obj: ReplicationInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnRef
 */
export interface ReplicationInstanceSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderKmsKeyArnRef(obj: ReplicationInstanceSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelector
 */
export interface ReplicationInstanceSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderKmsKeyArnSelector(obj: ReplicationInstanceSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ReplicationSubnetGroup in dms to populate replicationSubnetGroupId.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef
 */
export interface ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef#policy
   */
  readonly policy?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef(obj: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ReplicationSubnetGroup in dms to populate replicationSubnetGroupId.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector
 */
export interface ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector#policy
   */
  readonly policy?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector(obj: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs
 */
export interface ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs(obj: ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector
 */
export interface ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector(obj: ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationInstanceSpecProviderConfigRefPolicy
 */
export interface ReplicationInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecProviderConfigRefPolicy(obj: ReplicationInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationInstanceSpecProviderRefPolicy
 */
export interface ReplicationInstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecProviderRefPolicy(obj: ReplicationInstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface ReplicationInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecPublishConnectionDetailsToConfigRef(obj: ReplicationInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReplicationInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface ReplicationInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecPublishConnectionDetailsToMetadata(obj: ReplicationInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy
 */
export interface ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy(obj: ReplicationInstanceSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy(obj: ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy
 */
export interface ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy(obj: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy
 */
export interface ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy(obj: ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecProviderConfigRefPolicyResolution
 */
export enum ReplicationInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecProviderConfigRefPolicyResolve
 */
export enum ReplicationInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecProviderRefPolicyResolution
 */
export enum ReplicationInstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecProviderRefPolicyResolve
 */
export enum ReplicationInstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum ReplicationInstanceSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum ReplicationInstanceSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum ReplicationInstanceSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicyResolution
 */
export enum ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicyResolve
 */
export enum ReplicationInstanceSpecForProviderReplicationSubnetGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicyResolution
 */
export enum ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicyResolve
 */
export enum ReplicationInstanceSpecForProviderReplicationSubnetGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ReplicationInstanceSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ReplicationInstanceSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReplicationInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReplicationSubnetGroup is the Schema for the ReplicationSubnetGroups API. Provides a DMS (Data Migration Service) subnet group resource.
 *
 * @schema ReplicationSubnetGroup
 */
export class ReplicationSubnetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicationSubnetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dms.aws.upbound.io/v1beta1',
    kind: 'ReplicationSubnetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicationSubnetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicationSubnetGroupProps): any {
    return {
      ...ReplicationSubnetGroup.GVK,
      ...toJson_ReplicationSubnetGroupProps(props),
    };
  }

  /**
   * Defines a "ReplicationSubnetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicationSubnetGroupProps) {
    super(scope, id, {
      ...ReplicationSubnetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicationSubnetGroup.GVK,
      ...toJson_ReplicationSubnetGroupProps(resolved),
    };
  }
}

/**
 * ReplicationSubnetGroup is the Schema for the ReplicationSubnetGroups API. Provides a DMS (Data Migration Service) subnet group resource.
 *
 * @schema ReplicationSubnetGroup
 */
export interface ReplicationSubnetGroupProps {
  /**
   * @schema ReplicationSubnetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicationSubnetGroupSpec defines the desired state of ReplicationSubnetGroup
   *
   * @schema ReplicationSubnetGroup#spec
   */
  readonly spec: ReplicationSubnetGroupSpec;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupProps(obj: ReplicationSubnetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicationSubnetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicationSubnetGroupSpec defines the desired state of ReplicationSubnetGroup
 *
 * @schema ReplicationSubnetGroupSpec
 */
export interface ReplicationSubnetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationSubnetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReplicationSubnetGroupSpecDeletionPolicy;

  /**
   * @schema ReplicationSubnetGroupSpec#forProvider
   */
  readonly forProvider: ReplicationSubnetGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationSubnetGroupSpec#managementPolicy
   */
  readonly managementPolicy?: ReplicationSubnetGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReplicationSubnetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReplicationSubnetGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReplicationSubnetGroupSpec#providerRef
   */
  readonly providerRef?: ReplicationSubnetGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReplicationSubnetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReplicationSubnetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReplicationSubnetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReplicationSubnetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpec(obj: ReplicationSubnetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReplicationSubnetGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReplicationSubnetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReplicationSubnetGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReplicationSubnetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationSubnetGroupSpecDeletionPolicy
 */
export enum ReplicationSubnetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReplicationSubnetGroupSpecForProvider
 */
export interface ReplicationSubnetGroupSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReplicationSubnetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Description for the subnet group.
   *
   * @schema ReplicationSubnetGroupSpecForProvider#replicationSubnetGroupDescription
   */
  readonly replicationSubnetGroupDescription?: string;

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema ReplicationSubnetGroupSpecForProvider#subnetIdRefs
   */
  readonly subnetIdRefs?: ReplicationSubnetGroupSpecForProviderSubnetIdRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema ReplicationSubnetGroupSpecForProvider#subnetIdSelector
   */
  readonly subnetIdSelector?: ReplicationSubnetGroupSpecForProviderSubnetIdSelector;

  /**
   * List of at least 2 EC2 subnet IDs for the subnet group. The subnets must cover at least 2 availability zones.
   *
   * @schema ReplicationSubnetGroupSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ReplicationSubnetGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecForProvider(obj: ReplicationSubnetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'replicationSubnetGroupDescription': obj.replicationSubnetGroupDescription,
    'subnetIdRefs': obj.subnetIdRefs?.map(y => toJson_ReplicationSubnetGroupSpecForProviderSubnetIdRefs(y)),
    'subnetIdSelector': toJson_ReplicationSubnetGroupSpecForProviderSubnetIdSelector(obj.subnetIdSelector),
    'subnetIds': obj.subnetIds?.map(y => y),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationSubnetGroupSpecManagementPolicy
 */
export enum ReplicationSubnetGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReplicationSubnetGroupSpecProviderConfigRef
 */
export interface ReplicationSubnetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationSubnetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationSubnetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ReplicationSubnetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecProviderConfigRef(obj: ReplicationSubnetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationSubnetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReplicationSubnetGroupSpecProviderRef
 */
export interface ReplicationSubnetGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationSubnetGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationSubnetGroupSpecProviderRef#policy
   */
  readonly policy?: ReplicationSubnetGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecProviderRef(obj: ReplicationSubnetGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationSubnetGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsTo
 */
export interface ReplicationSubnetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsTo(obj: ReplicationSubnetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReplicationSubnetGroupSpecWriteConnectionSecretToRef
 */
export interface ReplicationSubnetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReplicationSubnetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicationSubnetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecWriteConnectionSecretToRef(obj: ReplicationSubnetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefs
 */
export interface ReplicationSubnetGroupSpecForProviderSubnetIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefs#policy
   */
  readonly policy?: ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecForProviderSubnetIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecForProviderSubnetIdRefs(obj: ReplicationSubnetGroupSpecForProviderSubnetIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelector
 */
export interface ReplicationSubnetGroupSpecForProviderSubnetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelector#policy
   */
  readonly policy?: ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecForProviderSubnetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecForProviderSubnetIdSelector(obj: ReplicationSubnetGroupSpecForProviderSubnetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationSubnetGroupSpecProviderConfigRefPolicy
 */
export interface ReplicationSubnetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationSubnetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationSubnetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationSubnetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationSubnetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecProviderConfigRefPolicy(obj: ReplicationSubnetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationSubnetGroupSpecProviderRefPolicy
 */
export interface ReplicationSubnetGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationSubnetGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReplicationSubnetGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationSubnetGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReplicationSubnetGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecProviderRefPolicy(obj: ReplicationSubnetGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef(obj: ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata(obj: ReplicationSubnetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy
 */
export interface ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy#resolution
   */
  readonly resolution?: ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy#resolve
   */
  readonly resolve?: ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy(obj: ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy
 */
export interface ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy(obj: ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationSubnetGroupSpecProviderConfigRefPolicyResolution
 */
export enum ReplicationSubnetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationSubnetGroupSpecProviderConfigRefPolicyResolve
 */
export enum ReplicationSubnetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationSubnetGroupSpecProviderRefPolicyResolution
 */
export enum ReplicationSubnetGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationSubnetGroupSpecProviderRefPolicyResolve
 */
export enum ReplicationSubnetGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicyResolution
 */
export enum ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicyResolve
 */
export enum ReplicationSubnetGroupSpecForProviderSubnetIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution
 */
export enum ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve
 */
export enum ReplicationSubnetGroupSpecForProviderSubnetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReplicationSubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ReplicationTask is the Schema for the ReplicationTasks API. Provides a DMS (Data Migration Service) replication task resource.
 *
 * @schema ReplicationTask
 */
export class ReplicationTask extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ReplicationTask"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dms.aws.upbound.io/v1beta1',
    kind: 'ReplicationTask',
  }

  /**
   * Renders a Kubernetes manifest for "ReplicationTask".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ReplicationTaskProps): any {
    return {
      ...ReplicationTask.GVK,
      ...toJson_ReplicationTaskProps(props),
    };
  }

  /**
   * Defines a "ReplicationTask" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ReplicationTaskProps) {
    super(scope, id, {
      ...ReplicationTask.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ReplicationTask.GVK,
      ...toJson_ReplicationTaskProps(resolved),
    };
  }
}

/**
 * ReplicationTask is the Schema for the ReplicationTasks API. Provides a DMS (Data Migration Service) replication task resource.
 *
 * @schema ReplicationTask
 */
export interface ReplicationTaskProps {
  /**
   * @schema ReplicationTask#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ReplicationTaskSpec defines the desired state of ReplicationTask
   *
   * @schema ReplicationTask#spec
   */
  readonly spec: ReplicationTaskSpec;

}

/**
 * Converts an object of type 'ReplicationTaskProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskProps(obj: ReplicationTaskProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ReplicationTaskSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ReplicationTaskSpec defines the desired state of ReplicationTask
 *
 * @schema ReplicationTaskSpec
 */
export interface ReplicationTaskSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationTaskSpec#deletionPolicy
   */
  readonly deletionPolicy?: ReplicationTaskSpecDeletionPolicy;

  /**
   * @schema ReplicationTaskSpec#forProvider
   */
  readonly forProvider: ReplicationTaskSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ReplicationTaskSpec#managementPolicy
   */
  readonly managementPolicy?: ReplicationTaskSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ReplicationTaskSpec#providerConfigRef
   */
  readonly providerConfigRef?: ReplicationTaskSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ReplicationTaskSpec#providerRef
   */
  readonly providerRef?: ReplicationTaskSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ReplicationTaskSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ReplicationTaskSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ReplicationTaskSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ReplicationTaskSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ReplicationTaskSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpec(obj: ReplicationTaskSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ReplicationTaskSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ReplicationTaskSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ReplicationTaskSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ReplicationTaskSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ReplicationTaskSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationTaskSpecDeletionPolicy
 */
export enum ReplicationTaskSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ReplicationTaskSpecForProvider
 */
export interface ReplicationTaskSpecForProvider {
  /**
   * Indicates when you want a change data capture (CDC) operation to start. The value can be in date, checkpoint, or LSN/SCN format depending on the source engine. For more information, see Determining a CDC native start point.
   *
   * @schema ReplicationTaskSpecForProvider#cdcStartPosition
   */
  readonly cdcStartPosition?: string;

  /**
   * The Unix timestamp integer for the start of the Change Data Capture (CDC) operation.
   *
   * @schema ReplicationTaskSpecForProvider#cdcStartTime
   */
  readonly cdcStartTime?: string;

  /**
   * The migration type. Can be one of full-load | cdc | full-load-and-cdc.
   *
   * @schema ReplicationTaskSpecForProvider#migrationType
   */
  readonly migrationType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ReplicationTaskSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the replication instance.
   *
   * @schema ReplicationTaskSpecForProvider#replicationInstanceArn
   */
  readonly replicationInstanceArn?: string;

  /**
   * Reference to a ReplicationInstance in dms to populate replicationInstanceArn.
   *
   * @schema ReplicationTaskSpecForProvider#replicationInstanceArnRef
   */
  readonly replicationInstanceArnRef?: ReplicationTaskSpecForProviderReplicationInstanceArnRef;

  /**
   * Selector for a ReplicationInstance in dms to populate replicationInstanceArn.
   *
   * @schema ReplicationTaskSpecForProvider#replicationInstanceArnSelector
   */
  readonly replicationInstanceArnSelector?: ReplicationTaskSpecForProviderReplicationInstanceArnSelector;

  /**
   * An escaped JSON string that contains the task settings. For a complete list of task settings, see Task Settings for AWS Database Migration Service Tasks.
   *
   * @schema ReplicationTaskSpecForProvider#replicationTaskSettings
   */
  readonly replicationTaskSettings?: string;

  /**
   * The Amazon Resource Name (ARN) string that uniquely identifies the source endpoint.
   *
   * @schema ReplicationTaskSpecForProvider#sourceEndpointArn
   */
  readonly sourceEndpointArn?: string;

  /**
   * Reference to a Endpoint in dms to populate sourceEndpointArn.
   *
   * @schema ReplicationTaskSpecForProvider#sourceEndpointArnRef
   */
  readonly sourceEndpointArnRef?: ReplicationTaskSpecForProviderSourceEndpointArnRef;

  /**
   * Selector for a Endpoint in dms to populate sourceEndpointArn.
   *
   * @schema ReplicationTaskSpecForProvider#sourceEndpointArnSelector
   */
  readonly sourceEndpointArnSelector?: ReplicationTaskSpecForProviderSourceEndpointArnSelector;

  /**
   * Whether to run or stop the replication task.
   *
   * @schema ReplicationTaskSpecForProvider#startReplicationTask
   */
  readonly startReplicationTask?: boolean;

  /**
   * An escaped JSON string that contains the table mappings. For information on table mapping see Using Table Mapping with an AWS Database Migration Service Task to Select and Filter Data
   *
   * @schema ReplicationTaskSpecForProvider#tableMappings
   */
  readonly tableMappings?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ReplicationTaskSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The Amazon Resource Name (ARN) string that uniquely identifies the target endpoint.
   *
   * @schema ReplicationTaskSpecForProvider#targetEndpointArn
   */
  readonly targetEndpointArn?: string;

  /**
   * Reference to a Endpoint in dms to populate targetEndpointArn.
   *
   * @schema ReplicationTaskSpecForProvider#targetEndpointArnRef
   */
  readonly targetEndpointArnRef?: ReplicationTaskSpecForProviderTargetEndpointArnRef;

  /**
   * Selector for a Endpoint in dms to populate targetEndpointArn.
   *
   * @schema ReplicationTaskSpecForProvider#targetEndpointArnSelector
   */
  readonly targetEndpointArnSelector?: ReplicationTaskSpecForProviderTargetEndpointArnSelector;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProvider(obj: ReplicationTaskSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cdcStartPosition': obj.cdcStartPosition,
    'cdcStartTime': obj.cdcStartTime,
    'migrationType': obj.migrationType,
    'region': obj.region,
    'replicationInstanceArn': obj.replicationInstanceArn,
    'replicationInstanceArnRef': toJson_ReplicationTaskSpecForProviderReplicationInstanceArnRef(obj.replicationInstanceArnRef),
    'replicationInstanceArnSelector': toJson_ReplicationTaskSpecForProviderReplicationInstanceArnSelector(obj.replicationInstanceArnSelector),
    'replicationTaskSettings': obj.replicationTaskSettings,
    'sourceEndpointArn': obj.sourceEndpointArn,
    'sourceEndpointArnRef': toJson_ReplicationTaskSpecForProviderSourceEndpointArnRef(obj.sourceEndpointArnRef),
    'sourceEndpointArnSelector': toJson_ReplicationTaskSpecForProviderSourceEndpointArnSelector(obj.sourceEndpointArnSelector),
    'startReplicationTask': obj.startReplicationTask,
    'tableMappings': obj.tableMappings,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetEndpointArn': obj.targetEndpointArn,
    'targetEndpointArnRef': toJson_ReplicationTaskSpecForProviderTargetEndpointArnRef(obj.targetEndpointArnRef),
    'targetEndpointArnSelector': toJson_ReplicationTaskSpecForProviderTargetEndpointArnSelector(obj.targetEndpointArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ReplicationTaskSpecManagementPolicy
 */
export enum ReplicationTaskSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ReplicationTaskSpecProviderConfigRef
 */
export interface ReplicationTaskSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationTaskSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationTaskSpecProviderConfigRef#policy
   */
  readonly policy?: ReplicationTaskSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecProviderConfigRef(obj: ReplicationTaskSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationTaskSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ReplicationTaskSpecProviderRef
 */
export interface ReplicationTaskSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationTaskSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationTaskSpecProviderRef#policy
   */
  readonly policy?: ReplicationTaskSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecProviderRef(obj: ReplicationTaskSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationTaskSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ReplicationTaskSpecPublishConnectionDetailsTo
 */
export interface ReplicationTaskSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ReplicationTaskSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ReplicationTaskSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ReplicationTaskSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecPublishConnectionDetailsTo(obj: ReplicationTaskSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ReplicationTaskSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ReplicationTaskSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ReplicationTaskSpecWriteConnectionSecretToRef
 */
export interface ReplicationTaskSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ReplicationTaskSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ReplicationTaskSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ReplicationTaskSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecWriteConnectionSecretToRef(obj: ReplicationTaskSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ReplicationInstance in dms to populate replicationInstanceArn.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRef
 */
export interface ReplicationTaskSpecForProviderReplicationInstanceArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRef#policy
   */
  readonly policy?: ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderReplicationInstanceArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderReplicationInstanceArnRef(obj: ReplicationTaskSpecForProviderReplicationInstanceArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ReplicationInstance in dms to populate replicationInstanceArn.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelector
 */
export interface ReplicationTaskSpecForProviderReplicationInstanceArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelector#policy
   */
  readonly policy?: ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderReplicationInstanceArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderReplicationInstanceArnSelector(obj: ReplicationTaskSpecForProviderReplicationInstanceArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Endpoint in dms to populate sourceEndpointArn.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnRef
 */
export interface ReplicationTaskSpecForProviderSourceEndpointArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnRef#policy
   */
  readonly policy?: ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderSourceEndpointArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderSourceEndpointArnRef(obj: ReplicationTaskSpecForProviderSourceEndpointArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Endpoint in dms to populate sourceEndpointArn.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelector
 */
export interface ReplicationTaskSpecForProviderSourceEndpointArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelector#policy
   */
  readonly policy?: ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderSourceEndpointArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderSourceEndpointArnSelector(obj: ReplicationTaskSpecForProviderSourceEndpointArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Endpoint in dms to populate targetEndpointArn.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnRef
 */
export interface ReplicationTaskSpecForProviderTargetEndpointArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnRef#policy
   */
  readonly policy?: ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderTargetEndpointArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderTargetEndpointArnRef(obj: ReplicationTaskSpecForProviderTargetEndpointArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Endpoint in dms to populate targetEndpointArn.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelector
 */
export interface ReplicationTaskSpecForProviderTargetEndpointArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelector#policy
   */
  readonly policy?: ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderTargetEndpointArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderTargetEndpointArnSelector(obj: ReplicationTaskSpecForProviderTargetEndpointArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationTaskSpecProviderConfigRefPolicy
 */
export interface ReplicationTaskSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecProviderConfigRefPolicy(obj: ReplicationTaskSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationTaskSpecProviderRefPolicy
 */
export interface ReplicationTaskSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecProviderRefPolicy(obj: ReplicationTaskSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRef
 */
export interface ReplicationTaskSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ReplicationTaskSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecPublishConnectionDetailsToConfigRef(obj: ReplicationTaskSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ReplicationTaskSpecPublishConnectionDetailsToMetadata
 */
export interface ReplicationTaskSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ReplicationTaskSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecPublishConnectionDetailsToMetadata(obj: ReplicationTaskSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy
 */
export interface ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy(obj: ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy
 */
export interface ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy(obj: ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy
 */
export interface ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecForProviderSourceEndpointArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecForProviderSourceEndpointArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy(obj: ReplicationTaskSpecForProviderSourceEndpointArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy
 */
export interface ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy(obj: ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy
 */
export interface ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecForProviderTargetEndpointArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecForProviderTargetEndpointArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy(obj: ReplicationTaskSpecForProviderTargetEndpointArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy
 */
export interface ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy(obj: ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecProviderConfigRefPolicyResolution
 */
export enum ReplicationTaskSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecProviderConfigRefPolicyResolve
 */
export enum ReplicationTaskSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecProviderRefPolicyResolution
 */
export enum ReplicationTaskSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecProviderRefPolicyResolve
 */
export enum ReplicationTaskSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy(obj: ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicyResolution
 */
export enum ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicyResolve
 */
export enum ReplicationTaskSpecForProviderReplicationInstanceArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicyResolution
 */
export enum ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicyResolve
 */
export enum ReplicationTaskSpecForProviderReplicationInstanceArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnRefPolicyResolution
 */
export enum ReplicationTaskSpecForProviderSourceEndpointArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnRefPolicyResolve
 */
export enum ReplicationTaskSpecForProviderSourceEndpointArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicyResolution
 */
export enum ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicyResolve
 */
export enum ReplicationTaskSpecForProviderSourceEndpointArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnRefPolicyResolution
 */
export enum ReplicationTaskSpecForProviderTargetEndpointArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnRefPolicyResolve
 */
export enum ReplicationTaskSpecForProviderTargetEndpointArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicyResolution
 */
export enum ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicyResolve
 */
export enum ReplicationTaskSpecForProviderTargetEndpointArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ReplicationTaskSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * S3Endpoint is the Schema for the S3Endpoints API. Provides a DMS (Data Migration Service) S3 endpoint resource.
 *
 * @schema S3Endpoint
 */
export class S3Endpoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "S3Endpoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dms.aws.upbound.io/v1beta1',
    kind: 'S3Endpoint',
  }

  /**
   * Renders a Kubernetes manifest for "S3Endpoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: S3EndpointProps): any {
    return {
      ...S3Endpoint.GVK,
      ...toJson_S3EndpointProps(props),
    };
  }

  /**
   * Defines a "S3Endpoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: S3EndpointProps) {
    super(scope, id, {
      ...S3Endpoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...S3Endpoint.GVK,
      ...toJson_S3EndpointProps(resolved),
    };
  }
}

/**
 * S3Endpoint is the Schema for the S3Endpoints API. Provides a DMS (Data Migration Service) S3 endpoint resource.
 *
 * @schema S3Endpoint
 */
export interface S3EndpointProps {
  /**
   * @schema S3Endpoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * S3EndpointSpec defines the desired state of S3Endpoint
   *
   * @schema S3Endpoint#spec
   */
  readonly spec: S3EndpointSpec;

}

/**
 * Converts an object of type 'S3EndpointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointProps(obj: S3EndpointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_S3EndpointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * S3EndpointSpec defines the desired state of S3Endpoint
 *
 * @schema S3EndpointSpec
 */
export interface S3EndpointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema S3EndpointSpec#deletionPolicy
   */
  readonly deletionPolicy?: S3EndpointSpecDeletionPolicy;

  /**
   * @schema S3EndpointSpec#forProvider
   */
  readonly forProvider: S3EndpointSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema S3EndpointSpec#managementPolicy
   */
  readonly managementPolicy?: S3EndpointSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema S3EndpointSpec#providerConfigRef
   */
  readonly providerConfigRef?: S3EndpointSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema S3EndpointSpec#providerRef
   */
  readonly providerRef?: S3EndpointSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema S3EndpointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: S3EndpointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema S3EndpointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: S3EndpointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'S3EndpointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpec(obj: S3EndpointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_S3EndpointSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_S3EndpointSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_S3EndpointSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_S3EndpointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_S3EndpointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema S3EndpointSpecDeletionPolicy
 */
export enum S3EndpointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema S3EndpointSpecForProvider
 */
export interface S3EndpointSpecForProvider {
  /**
   * Whether to add column name information to the .csv output file. Default is false.
   *
   * @default false.
   * @schema S3EndpointSpecForProvider#addColumnName
   */
  readonly addColumnName?: boolean;

  /**
   * Whether to add padding. Default is false. (Ignored for source endpoints.)
   *
   * @default false. (Ignored for source endpoints.)
   * @schema S3EndpointSpecForProvider#addTrailingPaddingCharacter
   */
  readonly addTrailingPaddingCharacter?: boolean;

  /**
   * S3 object prefix.
   *
   * @schema S3EndpointSpecForProvider#bucketFolder
   */
  readonly bucketFolder?: string;

  /**
   * S3 bucket name.
   *
   * @schema S3EndpointSpecForProvider#bucketName
   */
  readonly bucketName?: string;

  /**
   * Predefined (canned) access control list for objects created in an S3 bucket. Valid values include none, private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, and bucket-owner-full-control. Default is none.
   *
   * @default none.
   * @schema S3EndpointSpecForProvider#cannedAclForObjects
   */
  readonly cannedAclForObjects?: string;

  /**
   * Whether to write insert and update operations to .csv or .parquet output files. Default is false.
   *
   * @default false.
   * @schema S3EndpointSpecForProvider#cdcInsertsAndUpdates
   */
  readonly cdcInsertsAndUpdates?: boolean;

  /**
   * Whether to write insert operations to .csv or .parquet output files. Default is false.
   *
   * @default false.
   * @schema S3EndpointSpecForProvider#cdcInsertsOnly
   */
  readonly cdcInsertsOnly?: boolean;

  /**
   * Maximum length of the interval, defined in seconds, after which to output a file to Amazon S3. (AWS default is 60.)
   *
   * @schema S3EndpointSpecForProvider#cdcMaxBatchInterval
   */
  readonly cdcMaxBatchInterval?: number;

  /**
   * Minimum file size condition as defined in kilobytes to output a file to Amazon S3. (AWS default is 32000 KB.)
   *
   * @schema S3EndpointSpecForProvider#cdcMinFileSize
   */
  readonly cdcMinFileSize?: number;

  /**
   * Folder path of CDC files. If cdc_path is set, AWS DMS reads CDC files from this path and replicates the data changes to the target endpoint. Supported in AWS DMS versions 3.4.2 and later.
   *
   * @schema S3EndpointSpecForProvider#cdcPath
   */
  readonly cdcPath?: string;

  /**
   * ARN for the certificate.
   *
   * @schema S3EndpointSpecForProvider#certificateArn
   */
  readonly certificateArn?: string;

  /**
   * Set to compress target files. Valid values are GZIP and NONE. Default is NONE. (Ignored for source endpoints.)
   *
   * @default NONE. (Ignored for source endpoints.)
   * @schema S3EndpointSpecForProvider#compressionType
   */
  readonly compressionType?: string;

  /**
   * Delimiter used to separate columns in the source files. Default is ,.
   *
   * @default .
   * @schema S3EndpointSpecForProvider#csvDelimiter
   */
  readonly csvDelimiter?: string;

  /**
   * Only applies if output files for a CDC load are written in .csv format. If use_csv_no_sup_value is set to true, string to use for all columns not included in the supplemental log. If you do not specify a string value, DMS uses the null value for these columns regardless of use_csv_no_sup_value. (Ignored for source endpoints.)
   *
   * @schema S3EndpointSpecForProvider#csvNoSupValue
   */
  readonly csvNoSupValue?: string;

  /**
   * String to as null when writing to the target. (AWS default is NULL.)
   *
   * @schema S3EndpointSpecForProvider#csvNullValue
   */
  readonly csvNullValue?: string;

  /**
   * Delimiter used to separate rows in the source files. Default is newline (i.e., \n).
   *
   * @default newline (i.e., \n).
   * @schema S3EndpointSpecForProvider#csvRowDelimiter
   */
  readonly csvRowDelimiter?: string;

  /**
   * Output format for the files that AWS DMS uses to create S3 objects. Valid values are csv and parquet.  (Ignored for source endpoints -- only csv is valid.)
   *
   * @schema S3EndpointSpecForProvider#dataFormat
   */
  readonly dataFormat?: string;

  /**
   * Size of one data page in bytes. (AWS default is 1 MiB, i.e., 1048576.)
   *
   * @schema S3EndpointSpecForProvider#dataPageSize
   */
  readonly dataPageSize?: number;

  /**
   * Date separating delimiter to use during folder partitioning. Valid values are SLASH, UNDERSCORE, DASH, and NONE. (AWS default is SLASH.) (Ignored for source endpoints.)
   *
   * @schema S3EndpointSpecForProvider#datePartitionDelimiter
   */
  readonly datePartitionDelimiter?: string;

  /**
   * Partition S3 bucket folders based on transaction commit dates. Default is false. (Ignored for source endpoints.)
   *
   * @default false. (Ignored for source endpoints.)
   * @schema S3EndpointSpecForProvider#datePartitionEnabled
   */
  readonly datePartitionEnabled?: boolean;

  /**
   * Date format to use during folder partitioning. Use this parameter when date_partition_enabled is set to true. Valid values are YYYYMMDD, YYYYMMDDHH, YYYYMM, MMYYYYDD, and DDMMYYYY. (AWS default is YYYYMMDD.) (Ignored for source endpoints.)
   *
   * @schema S3EndpointSpecForProvider#datePartitionSequence
   */
  readonly datePartitionSequence?: string;

  /**
   * Convert the current UTC time to a timezone. The conversion occurs when a date partition folder is created and a CDC filename is generated. The timezone format is Area/Location (e.g., Europe/Paris). Use this when date_partition_enabled is true. (Ignored for source endpoints.)
   *
   * @schema S3EndpointSpecForProvider#datePartitionTimezone
   */
  readonly datePartitionTimezone?: string;

  /**
   * Undocumented argument for use as directed by AWS Support.
   *
   * @schema S3EndpointSpecForProvider#detachTargetOnLobLookupFailureParquet
   */
  readonly detachTargetOnLobLookupFailureParquet?: boolean;

  /**
   * Maximum size in bytes of an encoded dictionary page of a column. (AWS default is 1 MiB, i.e., 1048576.)
   *
   * @schema S3EndpointSpecForProvider#dictPageSizeLimit
   */
  readonly dictPageSizeLimit?: number;

  /**
   * Whether to enable statistics for Parquet pages and row groups. Default is true.
   *
   * @default true.
   * @schema S3EndpointSpecForProvider#enableStatistics
   */
  readonly enableStatistics?: boolean;

  /**
   * Type of encoding to use. Value values are rle_dictionary, plain, and plain_dictionary. (AWS default is rle_dictionary.)
   *
   * @schema S3EndpointSpecForProvider#encodingType
   */
  readonly encodingType?: string;

  /**
   * Server-side encryption mode that you want to encrypt your .csv or .parquet object files copied to S3. Valid values are SSE_S3 and SSE_KMS. (AWS default is SSE_S3.) (Ignored for source endpoints -- only SSE_S3 is valid.)
   *
   * @schema S3EndpointSpecForProvider#encryptionMode
   */
  readonly encryptionMode?: string;

  /**
   * Type of endpoint. Valid values are source, target.
   *
   * @schema S3EndpointSpecForProvider#endpointType
   */
  readonly endpointType?: string;

  /**
   * Bucket owner to prevent sniping. Value is an AWS account ID.
   *
   * @schema S3EndpointSpecForProvider#expectedBucketOwner
   */
  readonly expectedBucketOwner?: string;

  /**
   * JSON document that describes how AWS DMS should interpret the data.
   *
   * @schema S3EndpointSpecForProvider#externalTableDefinition
   */
  readonly externalTableDefinition?: string;

  /**
   * When this value is set to 1, DMS ignores the first row header in a .csv file. (AWS default is 0.)
   *
   * @schema S3EndpointSpecForProvider#ignoreHeaderRows
   */
  readonly ignoreHeaderRows?: number;

  /**
   * Whether to enable a full load to write INSERT operations to the .csv output files only to indicate how the rows were added to the source database. Default is false.
   *
   * @default false.
   * @schema S3EndpointSpecForProvider#includeOpForFullLoad
   */
  readonly includeOpForFullLoad?: boolean;

  /**
   * ARN for the KMS key that will be used to encrypt the connection parameters. If you do not specify a value for kms_key_arn, then AWS DMS will use your default encryption key. AWS KMS creates the default encryption key for your AWS account. Your AWS account has a different default encryption key for each AWS region.
   *
   * @schema S3EndpointSpecForProvider#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyArn.
   *
   * @schema S3EndpointSpecForProvider#kmsKeyArnRef
   */
  readonly kmsKeyArnRef?: S3EndpointSpecForProviderKmsKeyArnRef;

  /**
   * Selector for a Key in kms to populate kmsKeyArn.
   *
   * @schema S3EndpointSpecForProvider#kmsKeyArnSelector
   */
  readonly kmsKeyArnSelector?: S3EndpointSpecForProviderKmsKeyArnSelector;

  /**
   * Maximum size (in KB) of any .csv file to be created while migrating to an S3 target during full load. Valid values are from 1 to 1048576. (AWS default is 1 GB, i.e., 1048576.)
   *
   * @schema S3EndpointSpecForProvider#maxFileSize
   */
  readonly maxFileSize?: number;

  /**
   * - Specifies the precision of any TIMESTAMP column values written to an S3 object file in .parquet format. Default is false. (Ignored for source endpoints.)
   *
   * @default false. (Ignored for source endpoints.)
   * @schema S3EndpointSpecForProvider#parquetTimestampInMillisecond
   */
  readonly parquetTimestampInMillisecond?: boolean;

  /**
   * Version of the .parquet file format. Valid values are parquet-1-0 and parquet-2-0. (AWS default is parquet-1-0.) (Ignored for source endpoints.)
   *
   * @schema S3EndpointSpecForProvider#parquetVersion
   */
  readonly parquetVersion?: string;

  /**
   * Whether DMS saves the transaction order for a CDC load on the S3 target specified by cdc_path. Default is false. (Ignored for source endpoints.)
   *
   * @default false. (Ignored for source endpoints.)
   * @schema S3EndpointSpecForProvider#preserveTransactions
   */
  readonly preserveTransactions?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema S3EndpointSpecForProvider#region
   */
  readonly region: string;

  /**
   * For an S3 source, whether each leading double quotation mark has to be followed by an ending double quotation mark. Default is true.
   *
   * @default true.
   * @schema S3EndpointSpecForProvider#rfc4180
   */
  readonly rfc4180?: boolean;

  /**
   * Number of rows in a row group. (AWS default is 10000.)
   *
   * @schema S3EndpointSpecForProvider#rowGroupLength
   */
  readonly rowGroupLength?: number;

  /**
   * When encryption_mode is SSE_KMS, ARN for the AWS KMS key. (Ignored for source endpoints -- only SSE_S3 encryption_mode is valid.)
   *
   * @schema S3EndpointSpecForProvider#serverSideEncryptionKmsKeyId
   */
  readonly serverSideEncryptionKmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate serverSideEncryptionKmsKeyId.
   *
   * @schema S3EndpointSpecForProvider#serverSideEncryptionKmsKeyIdRef
   */
  readonly serverSideEncryptionKmsKeyIdRef?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate serverSideEncryptionKmsKeyId.
   *
   * @schema S3EndpointSpecForProvider#serverSideEncryptionKmsKeyIdSelector
   */
  readonly serverSideEncryptionKmsKeyIdSelector?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector;

  /**
   * ARN of the IAM role with permissions to the S3 Bucket.
   *
   * @schema S3EndpointSpecForProvider#serviceAccessRoleArn
   */
  readonly serviceAccessRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceAccessRoleArn.
   *
   * @schema S3EndpointSpecForProvider#serviceAccessRoleArnRef
   */
  readonly serviceAccessRoleArnRef?: S3EndpointSpecForProviderServiceAccessRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceAccessRoleArn.
   *
   * @schema S3EndpointSpecForProvider#serviceAccessRoleArnSelector
   */
  readonly serviceAccessRoleArnSelector?: S3EndpointSpecForProviderServiceAccessRoleArnSelector;

  /**
   * SSL mode to use for the connection. Valid values are none, require, verify-ca, verify-full. (AWS default is none.)
   *
   * @schema S3EndpointSpecForProvider#sslMode
   */
  readonly sslMode?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema S3EndpointSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Column to add with timestamp information to the endpoint data for an Amazon S3 target.
   *
   * @schema S3EndpointSpecForProvider#timestampColumnName
   */
  readonly timestampColumnName?: string;

  /**
   * Whether to use csv_no_sup_value for columns not included in the supplemental log. (Ignored for source endpoints.)
   *
   * @schema S3EndpointSpecForProvider#useCsvNoSupValue
   */
  readonly useCsvNoSupValue?: boolean;

  /**
   * When set to true, uses the task start time as the timestamp column value instead of the time data is written to target. For full load, when set to true, each row of the timestamp column contains the task start time. For CDC loads, each row of the timestamp column contains the transaction commit time.When set to false, the full load timestamp in the timestamp column increments with the time data arrives at the target. Default is false.
   *
   * @default false.
   * @schema S3EndpointSpecForProvider#useTaskStartTimeForFullLoadTimestamp
   */
  readonly useTaskStartTimeForFullLoadTimestamp?: boolean;

}

/**
 * Converts an object of type 'S3EndpointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProvider(obj: S3EndpointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addColumnName': obj.addColumnName,
    'addTrailingPaddingCharacter': obj.addTrailingPaddingCharacter,
    'bucketFolder': obj.bucketFolder,
    'bucketName': obj.bucketName,
    'cannedAclForObjects': obj.cannedAclForObjects,
    'cdcInsertsAndUpdates': obj.cdcInsertsAndUpdates,
    'cdcInsertsOnly': obj.cdcInsertsOnly,
    'cdcMaxBatchInterval': obj.cdcMaxBatchInterval,
    'cdcMinFileSize': obj.cdcMinFileSize,
    'cdcPath': obj.cdcPath,
    'certificateArn': obj.certificateArn,
    'compressionType': obj.compressionType,
    'csvDelimiter': obj.csvDelimiter,
    'csvNoSupValue': obj.csvNoSupValue,
    'csvNullValue': obj.csvNullValue,
    'csvRowDelimiter': obj.csvRowDelimiter,
    'dataFormat': obj.dataFormat,
    'dataPageSize': obj.dataPageSize,
    'datePartitionDelimiter': obj.datePartitionDelimiter,
    'datePartitionEnabled': obj.datePartitionEnabled,
    'datePartitionSequence': obj.datePartitionSequence,
    'datePartitionTimezone': obj.datePartitionTimezone,
    'detachTargetOnLobLookupFailureParquet': obj.detachTargetOnLobLookupFailureParquet,
    'dictPageSizeLimit': obj.dictPageSizeLimit,
    'enableStatistics': obj.enableStatistics,
    'encodingType': obj.encodingType,
    'encryptionMode': obj.encryptionMode,
    'endpointType': obj.endpointType,
    'expectedBucketOwner': obj.expectedBucketOwner,
    'externalTableDefinition': obj.externalTableDefinition,
    'ignoreHeaderRows': obj.ignoreHeaderRows,
    'includeOpForFullLoad': obj.includeOpForFullLoad,
    'kmsKeyArn': obj.kmsKeyArn,
    'kmsKeyArnRef': toJson_S3EndpointSpecForProviderKmsKeyArnRef(obj.kmsKeyArnRef),
    'kmsKeyArnSelector': toJson_S3EndpointSpecForProviderKmsKeyArnSelector(obj.kmsKeyArnSelector),
    'maxFileSize': obj.maxFileSize,
    'parquetTimestampInMillisecond': obj.parquetTimestampInMillisecond,
    'parquetVersion': obj.parquetVersion,
    'preserveTransactions': obj.preserveTransactions,
    'region': obj.region,
    'rfc4180': obj.rfc4180,
    'rowGroupLength': obj.rowGroupLength,
    'serverSideEncryptionKmsKeyId': obj.serverSideEncryptionKmsKeyId,
    'serverSideEncryptionKmsKeyIdRef': toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef(obj.serverSideEncryptionKmsKeyIdRef),
    'serverSideEncryptionKmsKeyIdSelector': toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector(obj.serverSideEncryptionKmsKeyIdSelector),
    'serviceAccessRoleArn': obj.serviceAccessRoleArn,
    'serviceAccessRoleArnRef': toJson_S3EndpointSpecForProviderServiceAccessRoleArnRef(obj.serviceAccessRoleArnRef),
    'serviceAccessRoleArnSelector': toJson_S3EndpointSpecForProviderServiceAccessRoleArnSelector(obj.serviceAccessRoleArnSelector),
    'sslMode': obj.sslMode,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'timestampColumnName': obj.timestampColumnName,
    'useCsvNoSupValue': obj.useCsvNoSupValue,
    'useTaskStartTimeForFullLoadTimestamp': obj.useTaskStartTimeForFullLoadTimestamp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema S3EndpointSpecManagementPolicy
 */
export enum S3EndpointSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema S3EndpointSpecProviderConfigRef
 */
export interface S3EndpointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema S3EndpointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema S3EndpointSpecProviderConfigRef#policy
   */
  readonly policy?: S3EndpointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecProviderConfigRef(obj: S3EndpointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_S3EndpointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema S3EndpointSpecProviderRef
 */
export interface S3EndpointSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema S3EndpointSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema S3EndpointSpecProviderRef#policy
   */
  readonly policy?: S3EndpointSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecProviderRef(obj: S3EndpointSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_S3EndpointSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema S3EndpointSpecPublishConnectionDetailsTo
 */
export interface S3EndpointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: S3EndpointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: S3EndpointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'S3EndpointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecPublishConnectionDetailsTo(obj: S3EndpointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_S3EndpointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_S3EndpointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema S3EndpointSpecWriteConnectionSecretToRef
 */
export interface S3EndpointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema S3EndpointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema S3EndpointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'S3EndpointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecWriteConnectionSecretToRef(obj: S3EndpointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyArn.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnRef
 */
export interface S3EndpointSpecForProviderKmsKeyArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnRef#policy
   */
  readonly policy?: S3EndpointSpecForProviderKmsKeyArnRefPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderKmsKeyArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderKmsKeyArnRef(obj: S3EndpointSpecForProviderKmsKeyArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_S3EndpointSpecForProviderKmsKeyArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyArn.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnSelector
 */
export interface S3EndpointSpecForProviderKmsKeyArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnSelector#policy
   */
  readonly policy?: S3EndpointSpecForProviderKmsKeyArnSelectorPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderKmsKeyArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderKmsKeyArnSelector(obj: S3EndpointSpecForProviderKmsKeyArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_S3EndpointSpecForProviderKmsKeyArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate serverSideEncryptionKmsKeyId.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef
 */
export interface S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef#policy
   */
  readonly policy?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef(obj: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate serverSideEncryptionKmsKeyId.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector
 */
export interface S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector#policy
   */
  readonly policy?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector(obj: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceAccessRoleArn.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnRef
 */
export interface S3EndpointSpecForProviderServiceAccessRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnRef#policy
   */
  readonly policy?: S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServiceAccessRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServiceAccessRoleArnRef(obj: S3EndpointSpecForProviderServiceAccessRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceAccessRoleArn.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelector
 */
export interface S3EndpointSpecForProviderServiceAccessRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelector#policy
   */
  readonly policy?: S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServiceAccessRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServiceAccessRoleArnSelector(obj: S3EndpointSpecForProviderServiceAccessRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema S3EndpointSpecProviderConfigRefPolicy
 */
export interface S3EndpointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecProviderConfigRefPolicy(obj: S3EndpointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema S3EndpointSpecProviderRefPolicy
 */
export interface S3EndpointSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecProviderRefPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecProviderRefPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecProviderRefPolicy(obj: S3EndpointSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema S3EndpointSpecPublishConnectionDetailsToConfigRef
 */
export interface S3EndpointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'S3EndpointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecPublishConnectionDetailsToConfigRef(obj: S3EndpointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema S3EndpointSpecPublishConnectionDetailsToMetadata
 */
export interface S3EndpointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'S3EndpointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecPublishConnectionDetailsToMetadata(obj: S3EndpointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnRefPolicy
 */
export interface S3EndpointSpecForProviderKmsKeyArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnRefPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecForProviderKmsKeyArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnRefPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecForProviderKmsKeyArnRefPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderKmsKeyArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderKmsKeyArnRefPolicy(obj: S3EndpointSpecForProviderKmsKeyArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnSelectorPolicy
 */
export interface S3EndpointSpecForProviderKmsKeyArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnSelectorPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecForProviderKmsKeyArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecForProviderKmsKeyArnSelectorPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecForProviderKmsKeyArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderKmsKeyArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderKmsKeyArnSelectorPolicy(obj: S3EndpointSpecForProviderKmsKeyArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy
 */
export interface S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy(obj: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy
 */
export interface S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy(obj: S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy
 */
export interface S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecForProviderServiceAccessRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecForProviderServiceAccessRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy(obj: S3EndpointSpecForProviderServiceAccessRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy
 */
export interface S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy(obj: S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecProviderConfigRefPolicyResolution
 */
export enum S3EndpointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecProviderConfigRefPolicyResolve
 */
export enum S3EndpointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecProviderRefPolicyResolution
 */
export enum S3EndpointSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecProviderRefPolicyResolve
 */
export enum S3EndpointSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: S3EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: S3EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy(obj: S3EndpointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnRefPolicyResolution
 */
export enum S3EndpointSpecForProviderKmsKeyArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnRefPolicyResolve
 */
export enum S3EndpointSpecForProviderKmsKeyArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnSelectorPolicyResolution
 */
export enum S3EndpointSpecForProviderKmsKeyArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecForProviderKmsKeyArnSelectorPolicyResolve
 */
export enum S3EndpointSpecForProviderKmsKeyArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicyResolution
 */
export enum S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicyResolve
 */
export enum S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolution
 */
export enum S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolve
 */
export enum S3EndpointSpecForProviderServerSideEncryptionKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnRefPolicyResolution
 */
export enum S3EndpointSpecForProviderServiceAccessRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnRefPolicyResolve
 */
export enum S3EndpointSpecForProviderServiceAccessRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicyResolution
 */
export enum S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicyResolve
 */
export enum S3EndpointSpecForProviderServiceAccessRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema S3EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum S3EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema S3EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum S3EndpointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

