// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * BudgetResourceAssociation is the Schema for the BudgetResourceAssociations API. Manages a Service Catalog Budget Resource Association
 *
 * @schema BudgetResourceAssociation
 */
export class BudgetResourceAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "BudgetResourceAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'BudgetResourceAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "BudgetResourceAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: BudgetResourceAssociationProps): any {
    return {
      ...BudgetResourceAssociation.GVK,
      ...toJson_BudgetResourceAssociationProps(props),
    };
  }

  /**
   * Defines a "BudgetResourceAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: BudgetResourceAssociationProps) {
    super(scope, id, {
      ...BudgetResourceAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...BudgetResourceAssociation.GVK,
      ...toJson_BudgetResourceAssociationProps(resolved),
    };
  }
}

/**
 * BudgetResourceAssociation is the Schema for the BudgetResourceAssociations API. Manages a Service Catalog Budget Resource Association
 *
 * @schema BudgetResourceAssociation
 */
export interface BudgetResourceAssociationProps {
  /**
   * @schema BudgetResourceAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * BudgetResourceAssociationSpec defines the desired state of BudgetResourceAssociation
   *
   * @schema BudgetResourceAssociation#spec
   */
  readonly spec: BudgetResourceAssociationSpec;

}

/**
 * Converts an object of type 'BudgetResourceAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationProps(obj: BudgetResourceAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_BudgetResourceAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BudgetResourceAssociationSpec defines the desired state of BudgetResourceAssociation
 *
 * @schema BudgetResourceAssociationSpec
 */
export interface BudgetResourceAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BudgetResourceAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: BudgetResourceAssociationSpecDeletionPolicy;

  /**
   * @schema BudgetResourceAssociationSpec#forProvider
   */
  readonly forProvider: BudgetResourceAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema BudgetResourceAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: BudgetResourceAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema BudgetResourceAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: BudgetResourceAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema BudgetResourceAssociationSpec#providerRef
   */
  readonly providerRef?: BudgetResourceAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema BudgetResourceAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: BudgetResourceAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema BudgetResourceAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: BudgetResourceAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpec(obj: BudgetResourceAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_BudgetResourceAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_BudgetResourceAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_BudgetResourceAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_BudgetResourceAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_BudgetResourceAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BudgetResourceAssociationSpecDeletionPolicy
 */
export enum BudgetResourceAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema BudgetResourceAssociationSpecForProvider
 */
export interface BudgetResourceAssociationSpecForProvider {
  /**
   * Budget name.
   *
   * @schema BudgetResourceAssociationSpecForProvider#budgetName
   */
  readonly budgetName?: string;

  /**
   * Reference to a Budget in budgets to populate budgetName.
   *
   * @schema BudgetResourceAssociationSpecForProvider#budgetNameRef
   */
  readonly budgetNameRef?: BudgetResourceAssociationSpecForProviderBudgetNameRef;

  /**
   * Selector for a Budget in budgets to populate budgetName.
   *
   * @schema BudgetResourceAssociationSpecForProvider#budgetNameSelector
   */
  readonly budgetNameSelector?: BudgetResourceAssociationSpecForProviderBudgetNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema BudgetResourceAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Resource identifier.
   *
   * @schema BudgetResourceAssociationSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Product to populate resourceId.
   *
   * @schema BudgetResourceAssociationSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: BudgetResourceAssociationSpecForProviderResourceIdRef;

  /**
   * Selector for a Product to populate resourceId.
   *
   * @schema BudgetResourceAssociationSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: BudgetResourceAssociationSpecForProviderResourceIdSelector;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProvider(obj: BudgetResourceAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'budgetName': obj.budgetName,
    'budgetNameRef': toJson_BudgetResourceAssociationSpecForProviderBudgetNameRef(obj.budgetNameRef),
    'budgetNameSelector': toJson_BudgetResourceAssociationSpecForProviderBudgetNameSelector(obj.budgetNameSelector),
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_BudgetResourceAssociationSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_BudgetResourceAssociationSpecForProviderResourceIdSelector(obj.resourceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema BudgetResourceAssociationSpecManagementPolicy
 */
export enum BudgetResourceAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema BudgetResourceAssociationSpecProviderConfigRef
 */
export interface BudgetResourceAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetResourceAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetResourceAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: BudgetResourceAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecProviderConfigRef(obj: BudgetResourceAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetResourceAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema BudgetResourceAssociationSpecProviderRef
 */
export interface BudgetResourceAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetResourceAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetResourceAssociationSpecProviderRef#policy
   */
  readonly policy?: BudgetResourceAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecProviderRef(obj: BudgetResourceAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetResourceAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema BudgetResourceAssociationSpecPublishConnectionDetailsTo
 */
export interface BudgetResourceAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecPublishConnectionDetailsTo(obj: BudgetResourceAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema BudgetResourceAssociationSpecWriteConnectionSecretToRef
 */
export interface BudgetResourceAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema BudgetResourceAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema BudgetResourceAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecWriteConnectionSecretToRef(obj: BudgetResourceAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Budget in budgets to populate budgetName.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameRef
 */
export interface BudgetResourceAssociationSpecForProviderBudgetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameRef#policy
   */
  readonly policy?: BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderBudgetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderBudgetNameRef(obj: BudgetResourceAssociationSpecForProviderBudgetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Budget in budgets to populate budgetName.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelector
 */
export interface BudgetResourceAssociationSpecForProviderBudgetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelector#policy
   */
  readonly policy?: BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderBudgetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderBudgetNameSelector(obj: BudgetResourceAssociationSpecForProviderBudgetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Product to populate resourceId.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdRef
 */
export interface BudgetResourceAssociationSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdRef#policy
   */
  readonly policy?: BudgetResourceAssociationSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderResourceIdRef(obj: BudgetResourceAssociationSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetResourceAssociationSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Product to populate resourceId.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdSelector
 */
export interface BudgetResourceAssociationSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderResourceIdSelector(obj: BudgetResourceAssociationSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetResourceAssociationSpecProviderConfigRefPolicy
 */
export interface BudgetResourceAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetResourceAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: BudgetResourceAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetResourceAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: BudgetResourceAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecProviderConfigRefPolicy(obj: BudgetResourceAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetResourceAssociationSpecProviderRefPolicy
 */
export interface BudgetResourceAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetResourceAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: BudgetResourceAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetResourceAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: BudgetResourceAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecProviderRefPolicy(obj: BudgetResourceAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef(obj: BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata(obj: BudgetResourceAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy
 */
export interface BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy#resolution
   */
  readonly resolution?: BudgetResourceAssociationSpecForProviderBudgetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy#resolve
   */
  readonly resolve?: BudgetResourceAssociationSpecForProviderBudgetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy(obj: BudgetResourceAssociationSpecForProviderBudgetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy
 */
export interface BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy#resolution
   */
  readonly resolution?: BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy#resolve
   */
  readonly resolve?: BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy(obj: BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdRefPolicy
 */
export interface BudgetResourceAssociationSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: BudgetResourceAssociationSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: BudgetResourceAssociationSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderResourceIdRefPolicy(obj: BudgetResourceAssociationSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy
 */
export interface BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy(obj: BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetResourceAssociationSpecProviderConfigRefPolicyResolution
 */
export enum BudgetResourceAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetResourceAssociationSpecProviderConfigRefPolicyResolve
 */
export enum BudgetResourceAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetResourceAssociationSpecProviderRefPolicyResolution
 */
export enum BudgetResourceAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetResourceAssociationSpecProviderRefPolicyResolve
 */
export enum BudgetResourceAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameRefPolicyResolution
 */
export enum BudgetResourceAssociationSpecForProviderBudgetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameRefPolicyResolve
 */
export enum BudgetResourceAssociationSpecForProviderBudgetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicyResolution
 */
export enum BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicyResolve
 */
export enum BudgetResourceAssociationSpecForProviderBudgetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdRefPolicyResolution
 */
export enum BudgetResourceAssociationSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdRefPolicyResolve
 */
export enum BudgetResourceAssociationSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum BudgetResourceAssociationSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum BudgetResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Constraint is the Schema for the Constraints API. Manages a Service Catalog Constraint
 *
 * @schema Constraint
 */
export class Constraint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Constraint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'Constraint',
  }

  /**
   * Renders a Kubernetes manifest for "Constraint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConstraintProps): any {
    return {
      ...Constraint.GVK,
      ...toJson_ConstraintProps(props),
    };
  }

  /**
   * Defines a "Constraint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConstraintProps) {
    super(scope, id, {
      ...Constraint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Constraint.GVK,
      ...toJson_ConstraintProps(resolved),
    };
  }
}

/**
 * Constraint is the Schema for the Constraints API. Manages a Service Catalog Constraint
 *
 * @schema Constraint
 */
export interface ConstraintProps {
  /**
   * @schema Constraint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConstraintSpec defines the desired state of Constraint
   *
   * @schema Constraint#spec
   */
  readonly spec: ConstraintSpec;

}

/**
 * Converts an object of type 'ConstraintProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintProps(obj: ConstraintProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConstraintSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConstraintSpec defines the desired state of Constraint
 *
 * @schema ConstraintSpec
 */
export interface ConstraintSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConstraintSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConstraintSpecDeletionPolicy;

  /**
   * @schema ConstraintSpec#forProvider
   */
  readonly forProvider: ConstraintSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConstraintSpec#managementPolicy
   */
  readonly managementPolicy?: ConstraintSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConstraintSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConstraintSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConstraintSpec#providerRef
   */
  readonly providerRef?: ConstraintSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConstraintSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConstraintSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConstraintSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConstraintSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConstraintSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpec(obj: ConstraintSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConstraintSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ConstraintSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConstraintSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConstraintSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConstraintSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConstraintSpecDeletionPolicy
 */
export enum ConstraintSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConstraintSpecForProvider
 */
export interface ConstraintSpecForProvider {
  /**
   * Language code. Valid values: en (English), jp (Japanese), zh (Chinese). Default value is en.
   *
   * @schema ConstraintSpecForProvider#acceptLanguage
   */
  readonly acceptLanguage?: string;

  /**
   * Description of the constraint.
   *
   * @schema ConstraintSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Constraint parameters in JSON format. The syntax depends on the constraint type. See details below.
   *
   * @schema ConstraintSpecForProvider#parameters
   */
  readonly parameters?: string;

  /**
   * Portfolio identifier.
   *
   * @schema ConstraintSpecForProvider#portfolioId
   */
  readonly portfolioId?: string;

  /**
   * Reference to a Portfolio in servicecatalog to populate portfolioId.
   *
   * @schema ConstraintSpecForProvider#portfolioIdRef
   */
  readonly portfolioIdRef?: ConstraintSpecForProviderPortfolioIdRef;

  /**
   * Selector for a Portfolio in servicecatalog to populate portfolioId.
   *
   * @schema ConstraintSpecForProvider#portfolioIdSelector
   */
  readonly portfolioIdSelector?: ConstraintSpecForProviderPortfolioIdSelector;

  /**
   * Product identifier.
   *
   * @schema ConstraintSpecForProvider#productId
   */
  readonly productId?: string;

  /**
   * Reference to a Product in servicecatalog to populate productId.
   *
   * @schema ConstraintSpecForProvider#productIdRef
   */
  readonly productIdRef?: ConstraintSpecForProviderProductIdRef;

  /**
   * Selector for a Product in servicecatalog to populate productId.
   *
   * @schema ConstraintSpecForProvider#productIdSelector
   */
  readonly productIdSelector?: ConstraintSpecForProviderProductIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConstraintSpecForProvider#region
   */
  readonly region: string;

  /**
   * Type of constraint. Valid values are LAUNCH, NOTIFICATION, RESOURCE_UPDATE, STACKSET, and TEMPLATE.
   *
   * @schema ConstraintSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConstraintSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProvider(obj: ConstraintSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptLanguage': obj.acceptLanguage,
    'description': obj.description,
    'parameters': obj.parameters,
    'portfolioId': obj.portfolioId,
    'portfolioIdRef': toJson_ConstraintSpecForProviderPortfolioIdRef(obj.portfolioIdRef),
    'portfolioIdSelector': toJson_ConstraintSpecForProviderPortfolioIdSelector(obj.portfolioIdSelector),
    'productId': obj.productId,
    'productIdRef': toJson_ConstraintSpecForProviderProductIdRef(obj.productIdRef),
    'productIdSelector': toJson_ConstraintSpecForProviderProductIdSelector(obj.productIdSelector),
    'region': obj.region,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConstraintSpecManagementPolicy
 */
export enum ConstraintSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConstraintSpecProviderConfigRef
 */
export interface ConstraintSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConstraintSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConstraintSpecProviderConfigRef#policy
   */
  readonly policy?: ConstraintSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConstraintSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecProviderConfigRef(obj: ConstraintSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConstraintSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConstraintSpecProviderRef
 */
export interface ConstraintSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConstraintSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConstraintSpecProviderRef#policy
   */
  readonly policy?: ConstraintSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConstraintSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecProviderRef(obj: ConstraintSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConstraintSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConstraintSpecPublishConnectionDetailsTo
 */
export interface ConstraintSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConstraintSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConstraintSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConstraintSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConstraintSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConstraintSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConstraintSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecPublishConnectionDetailsTo(obj: ConstraintSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConstraintSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConstraintSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConstraintSpecWriteConnectionSecretToRef
 */
export interface ConstraintSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConstraintSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConstraintSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConstraintSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecWriteConnectionSecretToRef(obj: ConstraintSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Portfolio in servicecatalog to populate portfolioId.
 *
 * @schema ConstraintSpecForProviderPortfolioIdRef
 */
export interface ConstraintSpecForProviderPortfolioIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConstraintSpecForProviderPortfolioIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConstraintSpecForProviderPortfolioIdRef#policy
   */
  readonly policy?: ConstraintSpecForProviderPortfolioIdRefPolicy;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderPortfolioIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderPortfolioIdRef(obj: ConstraintSpecForProviderPortfolioIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConstraintSpecForProviderPortfolioIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Portfolio in servicecatalog to populate portfolioId.
 *
 * @schema ConstraintSpecForProviderPortfolioIdSelector
 */
export interface ConstraintSpecForProviderPortfolioIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConstraintSpecForProviderPortfolioIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConstraintSpecForProviderPortfolioIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConstraintSpecForProviderPortfolioIdSelector#policy
   */
  readonly policy?: ConstraintSpecForProviderPortfolioIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderPortfolioIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderPortfolioIdSelector(obj: ConstraintSpecForProviderPortfolioIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConstraintSpecForProviderPortfolioIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Product in servicecatalog to populate productId.
 *
 * @schema ConstraintSpecForProviderProductIdRef
 */
export interface ConstraintSpecForProviderProductIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConstraintSpecForProviderProductIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConstraintSpecForProviderProductIdRef#policy
   */
  readonly policy?: ConstraintSpecForProviderProductIdRefPolicy;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderProductIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderProductIdRef(obj: ConstraintSpecForProviderProductIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConstraintSpecForProviderProductIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Product in servicecatalog to populate productId.
 *
 * @schema ConstraintSpecForProviderProductIdSelector
 */
export interface ConstraintSpecForProviderProductIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConstraintSpecForProviderProductIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConstraintSpecForProviderProductIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConstraintSpecForProviderProductIdSelector#policy
   */
  readonly policy?: ConstraintSpecForProviderProductIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderProductIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderProductIdSelector(obj: ConstraintSpecForProviderProductIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConstraintSpecForProviderProductIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConstraintSpecProviderConfigRefPolicy
 */
export interface ConstraintSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConstraintSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConstraintSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConstraintSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConstraintSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConstraintSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecProviderConfigRefPolicy(obj: ConstraintSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConstraintSpecProviderRefPolicy
 */
export interface ConstraintSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConstraintSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConstraintSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConstraintSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConstraintSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConstraintSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecProviderRefPolicy(obj: ConstraintSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConstraintSpecPublishConnectionDetailsToConfigRef
 */
export interface ConstraintSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConstraintSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConstraintSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConstraintSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConstraintSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecPublishConnectionDetailsToConfigRef(obj: ConstraintSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConstraintSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConstraintSpecPublishConnectionDetailsToMetadata
 */
export interface ConstraintSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConstraintSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConstraintSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConstraintSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConstraintSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecPublishConnectionDetailsToMetadata(obj: ConstraintSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConstraintSpecForProviderPortfolioIdRefPolicy
 */
export interface ConstraintSpecForProviderPortfolioIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConstraintSpecForProviderPortfolioIdRefPolicy#resolution
   */
  readonly resolution?: ConstraintSpecForProviderPortfolioIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConstraintSpecForProviderPortfolioIdRefPolicy#resolve
   */
  readonly resolve?: ConstraintSpecForProviderPortfolioIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderPortfolioIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderPortfolioIdRefPolicy(obj: ConstraintSpecForProviderPortfolioIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConstraintSpecForProviderPortfolioIdSelectorPolicy
 */
export interface ConstraintSpecForProviderPortfolioIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConstraintSpecForProviderPortfolioIdSelectorPolicy#resolution
   */
  readonly resolution?: ConstraintSpecForProviderPortfolioIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConstraintSpecForProviderPortfolioIdSelectorPolicy#resolve
   */
  readonly resolve?: ConstraintSpecForProviderPortfolioIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderPortfolioIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderPortfolioIdSelectorPolicy(obj: ConstraintSpecForProviderPortfolioIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConstraintSpecForProviderProductIdRefPolicy
 */
export interface ConstraintSpecForProviderProductIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConstraintSpecForProviderProductIdRefPolicy#resolution
   */
  readonly resolution?: ConstraintSpecForProviderProductIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConstraintSpecForProviderProductIdRefPolicy#resolve
   */
  readonly resolve?: ConstraintSpecForProviderProductIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderProductIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderProductIdRefPolicy(obj: ConstraintSpecForProviderProductIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConstraintSpecForProviderProductIdSelectorPolicy
 */
export interface ConstraintSpecForProviderProductIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConstraintSpecForProviderProductIdSelectorPolicy#resolution
   */
  readonly resolution?: ConstraintSpecForProviderProductIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConstraintSpecForProviderProductIdSelectorPolicy#resolve
   */
  readonly resolve?: ConstraintSpecForProviderProductIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConstraintSpecForProviderProductIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecForProviderProductIdSelectorPolicy(obj: ConstraintSpecForProviderProductIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConstraintSpecProviderConfigRefPolicyResolution
 */
export enum ConstraintSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConstraintSpecProviderConfigRefPolicyResolve
 */
export enum ConstraintSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConstraintSpecProviderRefPolicyResolution
 */
export enum ConstraintSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConstraintSpecProviderRefPolicyResolve
 */
export enum ConstraintSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConstraintSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConstraintSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConstraintSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConstraintSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConstraintSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConstraintSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConstraintSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConstraintSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConstraintSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConstraintSpecForProviderPortfolioIdRefPolicyResolution
 */
export enum ConstraintSpecForProviderPortfolioIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConstraintSpecForProviderPortfolioIdRefPolicyResolve
 */
export enum ConstraintSpecForProviderPortfolioIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConstraintSpecForProviderPortfolioIdSelectorPolicyResolution
 */
export enum ConstraintSpecForProviderPortfolioIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConstraintSpecForProviderPortfolioIdSelectorPolicyResolve
 */
export enum ConstraintSpecForProviderPortfolioIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConstraintSpecForProviderProductIdRefPolicyResolution
 */
export enum ConstraintSpecForProviderProductIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConstraintSpecForProviderProductIdRefPolicyResolve
 */
export enum ConstraintSpecForProviderProductIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConstraintSpecForProviderProductIdSelectorPolicyResolution
 */
export enum ConstraintSpecForProviderProductIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConstraintSpecForProviderProductIdSelectorPolicyResolve
 */
export enum ConstraintSpecForProviderProductIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConstraintSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConstraintSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConstraintSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConstraintSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Portfolio is the Schema for the Portfolios API. Provides a resource to create a Service Catalog portfolio
 *
 * @schema Portfolio
 */
export class Portfolio extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Portfolio"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'Portfolio',
  }

  /**
   * Renders a Kubernetes manifest for "Portfolio".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PortfolioProps): any {
    return {
      ...Portfolio.GVK,
      ...toJson_PortfolioProps(props),
    };
  }

  /**
   * Defines a "Portfolio" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PortfolioProps) {
    super(scope, id, {
      ...Portfolio.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Portfolio.GVK,
      ...toJson_PortfolioProps(resolved),
    };
  }
}

/**
 * Portfolio is the Schema for the Portfolios API. Provides a resource to create a Service Catalog portfolio
 *
 * @schema Portfolio
 */
export interface PortfolioProps {
  /**
   * @schema Portfolio#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PortfolioSpec defines the desired state of Portfolio
   *
   * @schema Portfolio#spec
   */
  readonly spec: PortfolioSpec;

}

/**
 * Converts an object of type 'PortfolioProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioProps(obj: PortfolioProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PortfolioSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortfolioSpec defines the desired state of Portfolio
 *
 * @schema PortfolioSpec
 */
export interface PortfolioSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PortfolioSpec#deletionPolicy
   */
  readonly deletionPolicy?: PortfolioSpecDeletionPolicy;

  /**
   * @schema PortfolioSpec#forProvider
   */
  readonly forProvider: PortfolioSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PortfolioSpec#managementPolicy
   */
  readonly managementPolicy?: PortfolioSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PortfolioSpec#providerConfigRef
   */
  readonly providerConfigRef?: PortfolioSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PortfolioSpec#providerRef
   */
  readonly providerRef?: PortfolioSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PortfolioSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PortfolioSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PortfolioSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PortfolioSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PortfolioSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpec(obj: PortfolioSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PortfolioSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PortfolioSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PortfolioSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PortfolioSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PortfolioSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PortfolioSpecDeletionPolicy
 */
export enum PortfolioSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PortfolioSpecForProvider
 */
export interface PortfolioSpecForProvider {
  /**
   * Description of the portfolio
   *
   * @schema PortfolioSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the portfolio.
   *
   * @schema PortfolioSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Name of the person or organization who owns the portfolio.
   *
   * @schema PortfolioSpecForProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PortfolioSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PortfolioSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PortfolioSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecForProvider(obj: PortfolioSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'providerName': obj.providerName,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PortfolioSpecManagementPolicy
 */
export enum PortfolioSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PortfolioSpecProviderConfigRef
 */
export interface PortfolioSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PortfolioSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PortfolioSpecProviderConfigRef#policy
   */
  readonly policy?: PortfolioSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PortfolioSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecProviderConfigRef(obj: PortfolioSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PortfolioSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PortfolioSpecProviderRef
 */
export interface PortfolioSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PortfolioSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PortfolioSpecProviderRef#policy
   */
  readonly policy?: PortfolioSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PortfolioSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecProviderRef(obj: PortfolioSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PortfolioSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PortfolioSpecPublishConnectionDetailsTo
 */
export interface PortfolioSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PortfolioSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PortfolioSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PortfolioSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PortfolioSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PortfolioSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PortfolioSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecPublishConnectionDetailsTo(obj: PortfolioSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PortfolioSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PortfolioSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PortfolioSpecWriteConnectionSecretToRef
 */
export interface PortfolioSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PortfolioSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PortfolioSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PortfolioSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecWriteConnectionSecretToRef(obj: PortfolioSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PortfolioSpecProviderConfigRefPolicy
 */
export interface PortfolioSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PortfolioSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PortfolioSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecProviderConfigRefPolicy(obj: PortfolioSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PortfolioSpecProviderRefPolicy
 */
export interface PortfolioSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PortfolioSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PortfolioSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecProviderRefPolicy(obj: PortfolioSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PortfolioSpecPublishConnectionDetailsToConfigRef
 */
export interface PortfolioSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PortfolioSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PortfolioSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PortfolioSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PortfolioSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecPublishConnectionDetailsToConfigRef(obj: PortfolioSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PortfolioSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PortfolioSpecPublishConnectionDetailsToMetadata
 */
export interface PortfolioSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PortfolioSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PortfolioSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PortfolioSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PortfolioSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecPublishConnectionDetailsToMetadata(obj: PortfolioSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioSpecProviderConfigRefPolicyResolution
 */
export enum PortfolioSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioSpecProviderConfigRefPolicyResolve
 */
export enum PortfolioSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioSpecProviderRefPolicyResolution
 */
export enum PortfolioSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioSpecProviderRefPolicyResolve
 */
export enum PortfolioSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PortfolioSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PortfolioSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PortfolioSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PortfolioSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioSpecPublishConnectionDetailsToConfigRefPolicy(obj: PortfolioSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PortfolioSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PortfolioSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PortfolioShare is the Schema for the PortfolioShares API. Manages a Service Catalog Portfolio Share
 *
 * @schema PortfolioShare
 */
export class PortfolioShare extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PortfolioShare"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'PortfolioShare',
  }

  /**
   * Renders a Kubernetes manifest for "PortfolioShare".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PortfolioShareProps): any {
    return {
      ...PortfolioShare.GVK,
      ...toJson_PortfolioShareProps(props),
    };
  }

  /**
   * Defines a "PortfolioShare" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PortfolioShareProps) {
    super(scope, id, {
      ...PortfolioShare.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PortfolioShare.GVK,
      ...toJson_PortfolioShareProps(resolved),
    };
  }
}

/**
 * PortfolioShare is the Schema for the PortfolioShares API. Manages a Service Catalog Portfolio Share
 *
 * @schema PortfolioShare
 */
export interface PortfolioShareProps {
  /**
   * @schema PortfolioShare#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PortfolioShareSpec defines the desired state of PortfolioShare
   *
   * @schema PortfolioShare#spec
   */
  readonly spec: PortfolioShareSpec;

}

/**
 * Converts an object of type 'PortfolioShareProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareProps(obj: PortfolioShareProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PortfolioShareSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PortfolioShareSpec defines the desired state of PortfolioShare
 *
 * @schema PortfolioShareSpec
 */
export interface PortfolioShareSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PortfolioShareSpec#deletionPolicy
   */
  readonly deletionPolicy?: PortfolioShareSpecDeletionPolicy;

  /**
   * @schema PortfolioShareSpec#forProvider
   */
  readonly forProvider: PortfolioShareSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PortfolioShareSpec#managementPolicy
   */
  readonly managementPolicy?: PortfolioShareSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PortfolioShareSpec#providerConfigRef
   */
  readonly providerConfigRef?: PortfolioShareSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PortfolioShareSpec#providerRef
   */
  readonly providerRef?: PortfolioShareSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PortfolioShareSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PortfolioShareSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PortfolioShareSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PortfolioShareSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PortfolioShareSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpec(obj: PortfolioShareSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PortfolioShareSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PortfolioShareSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PortfolioShareSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PortfolioShareSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PortfolioShareSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PortfolioShareSpecDeletionPolicy
 */
export enum PortfolioShareSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PortfolioShareSpecForProvider
 */
export interface PortfolioShareSpecForProvider {
  /**
   * Language code. Valid values: en (English), jp (Japanese), zh (Chinese). Default value is en.
   *
   * @schema PortfolioShareSpecForProvider#acceptLanguage
   */
  readonly acceptLanguage?: string;

  /**
   * Portfolio identifier.
   *
   * @schema PortfolioShareSpecForProvider#portfolioId
   */
  readonly portfolioId?: string;

  /**
   * Reference to a Portfolio in servicecatalog to populate portfolioId.
   *
   * @schema PortfolioShareSpecForProvider#portfolioIdRef
   */
  readonly portfolioIdRef?: PortfolioShareSpecForProviderPortfolioIdRef;

  /**
   * Selector for a Portfolio in servicecatalog to populate portfolioId.
   *
   * @schema PortfolioShareSpecForProvider#portfolioIdSelector
   */
  readonly portfolioIdSelector?: PortfolioShareSpecForProviderPortfolioIdSelector;

  /**
   * Identifier of the principal with whom you will share the portfolio. Valid values AWS account IDs and ARNs of AWS Organizations and organizational units.
   *
   * @schema PortfolioShareSpecForProvider#principalId
   */
  readonly principalId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PortfolioShareSpecForProvider#region
   */
  readonly region: string;

  /**
   * Enables or disables Principal sharing when creating the portfolio share. If this flag is not provided, principal sharing is disabled.
   *
   * @schema PortfolioShareSpecForProvider#sharePrincipals
   */
  readonly sharePrincipals?: boolean;

  /**
   * Whether to enable sharing of aws_servicecatalog_tag_option resources when creating the portfolio share.
   *
   * @schema PortfolioShareSpecForProvider#shareTagOptions
   */
  readonly shareTagOptions?: boolean;

  /**
   * Type of portfolio share. Valid values are ACCOUNT (an external account), ORGANIZATION (a share to every account in an organization), ORGANIZATIONAL_UNIT, ORGANIZATION_MEMBER_ACCOUNT (a share to an account in an organization).
   *
   * @schema PortfolioShareSpecForProvider#type
   */
  readonly type?: string;

  /**
   * Whether to wait (up to the timeout) for the share to be accepted. Organizational shares are automatically accepted.
   *
   * @schema PortfolioShareSpecForProvider#waitForAcceptance
   */
  readonly waitForAcceptance?: boolean;

}

/**
 * Converts an object of type 'PortfolioShareSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecForProvider(obj: PortfolioShareSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptLanguage': obj.acceptLanguage,
    'portfolioId': obj.portfolioId,
    'portfolioIdRef': toJson_PortfolioShareSpecForProviderPortfolioIdRef(obj.portfolioIdRef),
    'portfolioIdSelector': toJson_PortfolioShareSpecForProviderPortfolioIdSelector(obj.portfolioIdSelector),
    'principalId': obj.principalId,
    'region': obj.region,
    'sharePrincipals': obj.sharePrincipals,
    'shareTagOptions': obj.shareTagOptions,
    'type': obj.type,
    'waitForAcceptance': obj.waitForAcceptance,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PortfolioShareSpecManagementPolicy
 */
export enum PortfolioShareSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PortfolioShareSpecProviderConfigRef
 */
export interface PortfolioShareSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PortfolioShareSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PortfolioShareSpecProviderConfigRef#policy
   */
  readonly policy?: PortfolioShareSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PortfolioShareSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecProviderConfigRef(obj: PortfolioShareSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PortfolioShareSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PortfolioShareSpecProviderRef
 */
export interface PortfolioShareSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PortfolioShareSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PortfolioShareSpecProviderRef#policy
   */
  readonly policy?: PortfolioShareSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PortfolioShareSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecProviderRef(obj: PortfolioShareSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PortfolioShareSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PortfolioShareSpecPublishConnectionDetailsTo
 */
export interface PortfolioShareSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PortfolioShareSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PortfolioShareSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PortfolioShareSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecPublishConnectionDetailsTo(obj: PortfolioShareSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PortfolioShareSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PortfolioShareSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PortfolioShareSpecWriteConnectionSecretToRef
 */
export interface PortfolioShareSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PortfolioShareSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PortfolioShareSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PortfolioShareSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecWriteConnectionSecretToRef(obj: PortfolioShareSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Portfolio in servicecatalog to populate portfolioId.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdRef
 */
export interface PortfolioShareSpecForProviderPortfolioIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdRef#policy
   */
  readonly policy?: PortfolioShareSpecForProviderPortfolioIdRefPolicy;

}

/**
 * Converts an object of type 'PortfolioShareSpecForProviderPortfolioIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecForProviderPortfolioIdRef(obj: PortfolioShareSpecForProviderPortfolioIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PortfolioShareSpecForProviderPortfolioIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Portfolio in servicecatalog to populate portfolioId.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdSelector
 */
export interface PortfolioShareSpecForProviderPortfolioIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdSelector#policy
   */
  readonly policy?: PortfolioShareSpecForProviderPortfolioIdSelectorPolicy;

}

/**
 * Converts an object of type 'PortfolioShareSpecForProviderPortfolioIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecForProviderPortfolioIdSelector(obj: PortfolioShareSpecForProviderPortfolioIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PortfolioShareSpecForProviderPortfolioIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PortfolioShareSpecProviderConfigRefPolicy
 */
export interface PortfolioShareSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioShareSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PortfolioShareSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioShareSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PortfolioShareSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioShareSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecProviderConfigRefPolicy(obj: PortfolioShareSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PortfolioShareSpecProviderRefPolicy
 */
export interface PortfolioShareSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioShareSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PortfolioShareSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioShareSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PortfolioShareSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioShareSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecProviderRefPolicy(obj: PortfolioShareSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRef
 */
export interface PortfolioShareSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PortfolioShareSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecPublishConnectionDetailsToConfigRef(obj: PortfolioShareSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PortfolioShareSpecPublishConnectionDetailsToMetadata
 */
export interface PortfolioShareSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PortfolioShareSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecPublishConnectionDetailsToMetadata(obj: PortfolioShareSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdRefPolicy
 */
export interface PortfolioShareSpecForProviderPortfolioIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdRefPolicy#resolution
   */
  readonly resolution?: PortfolioShareSpecForProviderPortfolioIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdRefPolicy#resolve
   */
  readonly resolve?: PortfolioShareSpecForProviderPortfolioIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioShareSpecForProviderPortfolioIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecForProviderPortfolioIdRefPolicy(obj: PortfolioShareSpecForProviderPortfolioIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdSelectorPolicy
 */
export interface PortfolioShareSpecForProviderPortfolioIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdSelectorPolicy#resolution
   */
  readonly resolution?: PortfolioShareSpecForProviderPortfolioIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioShareSpecForProviderPortfolioIdSelectorPolicy#resolve
   */
  readonly resolve?: PortfolioShareSpecForProviderPortfolioIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioShareSpecForProviderPortfolioIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecForProviderPortfolioIdSelectorPolicy(obj: PortfolioShareSpecForProviderPortfolioIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioShareSpecProviderConfigRefPolicyResolution
 */
export enum PortfolioShareSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioShareSpecProviderConfigRefPolicyResolve
 */
export enum PortfolioShareSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioShareSpecProviderRefPolicyResolution
 */
export enum PortfolioShareSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioShareSpecProviderRefPolicyResolve
 */
export enum PortfolioShareSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy(obj: PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdRefPolicyResolution
 */
export enum PortfolioShareSpecForProviderPortfolioIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdRefPolicyResolve
 */
export enum PortfolioShareSpecForProviderPortfolioIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdSelectorPolicyResolution
 */
export enum PortfolioShareSpecForProviderPortfolioIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioShareSpecForProviderPortfolioIdSelectorPolicyResolve
 */
export enum PortfolioShareSpecForProviderPortfolioIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PortfolioShareSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PrincipalPortfolioAssociation is the Schema for the PrincipalPortfolioAssociations API. Manages a Service Catalog Principal Portfolio Association
 *
 * @schema PrincipalPortfolioAssociation
 */
export class PrincipalPortfolioAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PrincipalPortfolioAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'PrincipalPortfolioAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "PrincipalPortfolioAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PrincipalPortfolioAssociationProps): any {
    return {
      ...PrincipalPortfolioAssociation.GVK,
      ...toJson_PrincipalPortfolioAssociationProps(props),
    };
  }

  /**
   * Defines a "PrincipalPortfolioAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PrincipalPortfolioAssociationProps) {
    super(scope, id, {
      ...PrincipalPortfolioAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PrincipalPortfolioAssociation.GVK,
      ...toJson_PrincipalPortfolioAssociationProps(resolved),
    };
  }
}

/**
 * PrincipalPortfolioAssociation is the Schema for the PrincipalPortfolioAssociations API. Manages a Service Catalog Principal Portfolio Association
 *
 * @schema PrincipalPortfolioAssociation
 */
export interface PrincipalPortfolioAssociationProps {
  /**
   * @schema PrincipalPortfolioAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PrincipalPortfolioAssociationSpec defines the desired state of PrincipalPortfolioAssociation
   *
   * @schema PrincipalPortfolioAssociation#spec
   */
  readonly spec: PrincipalPortfolioAssociationSpec;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationProps(obj: PrincipalPortfolioAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PrincipalPortfolioAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PrincipalPortfolioAssociationSpec defines the desired state of PrincipalPortfolioAssociation
 *
 * @schema PrincipalPortfolioAssociationSpec
 */
export interface PrincipalPortfolioAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PrincipalPortfolioAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: PrincipalPortfolioAssociationSpecDeletionPolicy;

  /**
   * @schema PrincipalPortfolioAssociationSpec#forProvider
   */
  readonly forProvider: PrincipalPortfolioAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PrincipalPortfolioAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: PrincipalPortfolioAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PrincipalPortfolioAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: PrincipalPortfolioAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PrincipalPortfolioAssociationSpec#providerRef
   */
  readonly providerRef?: PrincipalPortfolioAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PrincipalPortfolioAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PrincipalPortfolioAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpec(obj: PrincipalPortfolioAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PrincipalPortfolioAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PrincipalPortfolioAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PrincipalPortfolioAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PrincipalPortfolioAssociationSpecDeletionPolicy
 */
export enum PrincipalPortfolioAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PrincipalPortfolioAssociationSpecForProvider
 */
export interface PrincipalPortfolioAssociationSpecForProvider {
  /**
   * Language code. Valid values: en (English), jp (Japanese), zh (Chinese). Default value is en.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#acceptLanguage
   */
  readonly acceptLanguage?: string;

  /**
   * Portfolio identifier.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#portfolioId
   */
  readonly portfolioId?: string;

  /**
   * Reference to a Portfolio to populate portfolioId.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#portfolioIdRef
   */
  readonly portfolioIdRef?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef;

  /**
   * Selector for a Portfolio to populate portfolioId.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#portfolioIdSelector
   */
  readonly portfolioIdSelector?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector;

  /**
   * Principal ARN.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#principalArn
   */
  readonly principalArn?: string;

  /**
   * Reference to a User in iam to populate principalArn.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#principalArnRef
   */
  readonly principalArnRef?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef;

  /**
   * Selector for a User in iam to populate principalArn.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#principalArnSelector
   */
  readonly principalArnSelector?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector;

  /**
   * Principal type. Setting this argument empty (e.g., principal_type = "") will result in an error. Valid value is IAM. Default is IAM.
   *
   * @default IAM.
   * @schema PrincipalPortfolioAssociationSpecForProvider#principalType
   */
  readonly principalType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PrincipalPortfolioAssociationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProvider(obj: PrincipalPortfolioAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptLanguage': obj.acceptLanguage,
    'portfolioId': obj.portfolioId,
    'portfolioIdRef': toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef(obj.portfolioIdRef),
    'portfolioIdSelector': toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector(obj.portfolioIdSelector),
    'principalArn': obj.principalArn,
    'principalArnRef': toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef(obj.principalArnRef),
    'principalArnSelector': toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector(obj.principalArnSelector),
    'principalType': obj.principalType,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PrincipalPortfolioAssociationSpecManagementPolicy
 */
export enum PrincipalPortfolioAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PrincipalPortfolioAssociationSpecProviderConfigRef
 */
export interface PrincipalPortfolioAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: PrincipalPortfolioAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecProviderConfigRef(obj: PrincipalPortfolioAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrincipalPortfolioAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PrincipalPortfolioAssociationSpecProviderRef
 */
export interface PrincipalPortfolioAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderRef#policy
   */
  readonly policy?: PrincipalPortfolioAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecProviderRef(obj: PrincipalPortfolioAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrincipalPortfolioAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo
 */
export interface PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo(obj: PrincipalPortfolioAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef
 */
export interface PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef(obj: PrincipalPortfolioAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Portfolio to populate portfolioId.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef
 */
export interface PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef#policy
   */
  readonly policy?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef(obj: PrincipalPortfolioAssociationSpecForProviderPortfolioIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Portfolio to populate portfolioId.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector
 */
export interface PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector#policy
   */
  readonly policy?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector(obj: PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in iam to populate principalArn.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef
 */
export interface PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef#policy
   */
  readonly policy?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef(obj: PrincipalPortfolioAssociationSpecForProviderPrincipalArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in iam to populate principalArn.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector
 */
export interface PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector#policy
   */
  readonly policy?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector(obj: PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrincipalPortfolioAssociationSpecProviderConfigRefPolicy
 */
export interface PrincipalPortfolioAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PrincipalPortfolioAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PrincipalPortfolioAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecProviderConfigRefPolicy(obj: PrincipalPortfolioAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrincipalPortfolioAssociationSpecProviderRefPolicy
 */
export interface PrincipalPortfolioAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PrincipalPortfolioAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrincipalPortfolioAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PrincipalPortfolioAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecProviderRefPolicy(obj: PrincipalPortfolioAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef(obj: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata(obj: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy
 */
export interface PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy#resolution
   */
  readonly resolution?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy#resolve
   */
  readonly resolve?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy(obj: PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy
 */
export interface PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy#resolution
   */
  readonly resolution?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy#resolve
   */
  readonly resolve?: PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy(obj: PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy
 */
export interface PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy#resolution
   */
  readonly resolution?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy#resolve
   */
  readonly resolve?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy(obj: PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy
 */
export interface PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy#resolution
   */
  readonly resolution?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy#resolve
   */
  readonly resolve?: PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy(obj: PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrincipalPortfolioAssociationSpecProviderConfigRefPolicyResolution
 */
export enum PrincipalPortfolioAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrincipalPortfolioAssociationSpecProviderConfigRefPolicyResolve
 */
export enum PrincipalPortfolioAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrincipalPortfolioAssociationSpecProviderRefPolicyResolution
 */
export enum PrincipalPortfolioAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrincipalPortfolioAssociationSpecProviderRefPolicyResolve
 */
export enum PrincipalPortfolioAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolution
 */
export enum PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolve
 */
export enum PrincipalPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolution
 */
export enum PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolve
 */
export enum PrincipalPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicyResolution
 */
export enum PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicyResolve
 */
export enum PrincipalPortfolioAssociationSpecForProviderPrincipalArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicyResolution
 */
export enum PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicyResolve
 */
export enum PrincipalPortfolioAssociationSpecForProviderPrincipalArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PrincipalPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Product is the Schema for the Products API. Manages a Service Catalog Product
 *
 * @schema Product
 */
export class Product extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Product"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'Product',
  }

  /**
   * Renders a Kubernetes manifest for "Product".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProductProps): any {
    return {
      ...Product.GVK,
      ...toJson_ProductProps(props),
    };
  }

  /**
   * Defines a "Product" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProductProps) {
    super(scope, id, {
      ...Product.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Product.GVK,
      ...toJson_ProductProps(resolved),
    };
  }
}

/**
 * Product is the Schema for the Products API. Manages a Service Catalog Product
 *
 * @schema Product
 */
export interface ProductProps {
  /**
   * @schema Product#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProductSpec defines the desired state of Product
   *
   * @schema Product#spec
   */
  readonly spec: ProductSpec;

}

/**
 * Converts an object of type 'ProductProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductProps(obj: ProductProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProductSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProductSpec defines the desired state of Product
 *
 * @schema ProductSpec
 */
export interface ProductSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProductSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProductSpecDeletionPolicy;

  /**
   * @schema ProductSpec#forProvider
   */
  readonly forProvider: ProductSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProductSpec#managementPolicy
   */
  readonly managementPolicy?: ProductSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProductSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProductSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProductSpec#providerRef
   */
  readonly providerRef?: ProductSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProductSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProductSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProductSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProductSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProductSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpec(obj: ProductSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProductSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ProductSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProductSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProductSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProductSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProductSpecDeletionPolicy
 */
export enum ProductSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProductSpecForProvider
 */
export interface ProductSpecForProvider {
  /**
   * Language code. Valid values: en (English), jp (Japanese), zh (Chinese). Default value is en.
   *
   * @schema ProductSpecForProvider#acceptLanguage
   */
  readonly acceptLanguage?: string;

  /**
   * Description of the product.
   *
   * @schema ProductSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Distributor (i.e., vendor) of the product.
   *
   * @schema ProductSpecForProvider#distributor
   */
  readonly distributor?: string;

  /**
   * Name of the product.
   *
   * @schema ProductSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Owner of the product.
   *
   * @schema ProductSpecForProvider#owner
   */
  readonly owner?: string;

  /**
   * Configuration block for provisioning artifact (i.e., version) parameters. Detailed below.
   *
   * @schema ProductSpecForProvider#provisioningArtifactParameters
   */
  readonly provisioningArtifactParameters?: ProductSpecForProviderProvisioningArtifactParameters[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProductSpecForProvider#region
   */
  readonly region: string;

  /**
   * Support information about the product.
   *
   * @schema ProductSpecForProvider#supportDescription
   */
  readonly supportDescription?: string;

  /**
   * Contact email for product support.
   *
   * @schema ProductSpecForProvider#supportEmail
   */
  readonly supportEmail?: string;

  /**
   * Contact URL for product support.
   *
   * @schema ProductSpecForProvider#supportUrl
   */
  readonly supportUrl?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ProductSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Type of product. See AWS Docs for valid list of values.
   *
   * @schema ProductSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProductSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecForProvider(obj: ProductSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptLanguage': obj.acceptLanguage,
    'description': obj.description,
    'distributor': obj.distributor,
    'name': obj.name,
    'owner': obj.owner,
    'provisioningArtifactParameters': obj.provisioningArtifactParameters?.map(y => toJson_ProductSpecForProviderProvisioningArtifactParameters(y)),
    'region': obj.region,
    'supportDescription': obj.supportDescription,
    'supportEmail': obj.supportEmail,
    'supportUrl': obj.supportUrl,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProductSpecManagementPolicy
 */
export enum ProductSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProductSpecProviderConfigRef
 */
export interface ProductSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSpecProviderConfigRef#policy
   */
  readonly policy?: ProductSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecProviderConfigRef(obj: ProductSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProductSpecProviderRef
 */
export interface ProductSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSpecProviderRef#policy
   */
  readonly policy?: ProductSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProductSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecProviderRef(obj: ProductSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProductSpecPublishConnectionDetailsTo
 */
export interface ProductSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProductSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProductSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProductSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProductSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProductSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProductSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecPublishConnectionDetailsTo(obj: ProductSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProductSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProductSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProductSpecWriteConnectionSecretToRef
 */
export interface ProductSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProductSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProductSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProductSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecWriteConnectionSecretToRef(obj: ProductSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ProductSpecForProviderProvisioningArtifactParameters
 */
export interface ProductSpecForProviderProvisioningArtifactParameters {
  /**
   * Description of the provisioning artifact (i.e., version), including how it differs from the previous provisioning artifact.
   *
   * @schema ProductSpecForProviderProvisioningArtifactParameters#description
   */
  readonly description?: string;

  /**
   * Whether AWS Service Catalog stops validating the specified provisioning artifact template even if it is invalid.
   *
   * @schema ProductSpecForProviderProvisioningArtifactParameters#disableTemplateValidation
   */
  readonly disableTemplateValidation?: boolean;

  /**
   * Name of the provisioning artifact (for example, v1, v2beta). No spaces are allowed.
   *
   * @schema ProductSpecForProviderProvisioningArtifactParameters#name
   */
  readonly name?: string;

  /**
   * Template source as the physical ID of the resource that contains the template. Currently only supports CloudFormation stack ARN. Specify the physical ID as arn:[partition]:cloudformation:[region]:[account ID]:stack/[stack name]/[resource ID].
   *
   * @schema ProductSpecForProviderProvisioningArtifactParameters#templatePhysicalId
   */
  readonly templatePhysicalId?: string;

  /**
   * Template source as URL of the CloudFormation template in Amazon S3.
   *
   * @schema ProductSpecForProviderProvisioningArtifactParameters#templateUrl
   */
  readonly templateUrl?: string;

  /**
   * Type of provisioning artifact. See AWS Docs for valid list of values.
   *
   * @schema ProductSpecForProviderProvisioningArtifactParameters#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProductSpecForProviderProvisioningArtifactParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecForProviderProvisioningArtifactParameters(obj: ProductSpecForProviderProvisioningArtifactParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'disableTemplateValidation': obj.disableTemplateValidation,
    'name': obj.name,
    'templatePhysicalId': obj.templatePhysicalId,
    'templateUrl': obj.templateUrl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductSpecProviderConfigRefPolicy
 */
export interface ProductSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProductSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProductSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecProviderConfigRefPolicy(obj: ProductSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductSpecProviderRefPolicy
 */
export interface ProductSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProductSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProductSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecProviderRefPolicy(obj: ProductSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProductSpecPublishConnectionDetailsToConfigRef
 */
export interface ProductSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProductSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecPublishConnectionDetailsToConfigRef(obj: ProductSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProductSpecPublishConnectionDetailsToMetadata
 */
export interface ProductSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProductSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProductSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecPublishConnectionDetailsToMetadata(obj: ProductSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSpecProviderConfigRefPolicyResolution
 */
export enum ProductSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSpecProviderConfigRefPolicyResolve
 */
export enum ProductSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSpecProviderRefPolicyResolution
 */
export enum ProductSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSpecProviderRefPolicyResolve
 */
export enum ProductSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProductSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProductSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProductSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProductSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProductSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProductSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProductSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProductPortfolioAssociation is the Schema for the ProductPortfolioAssociations API. Manages a Service Catalog Product Portfolio Association
 *
 * @schema ProductPortfolioAssociation
 */
export class ProductPortfolioAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProductPortfolioAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'ProductPortfolioAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ProductPortfolioAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProductPortfolioAssociationProps): any {
    return {
      ...ProductPortfolioAssociation.GVK,
      ...toJson_ProductPortfolioAssociationProps(props),
    };
  }

  /**
   * Defines a "ProductPortfolioAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProductPortfolioAssociationProps) {
    super(scope, id, {
      ...ProductPortfolioAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProductPortfolioAssociation.GVK,
      ...toJson_ProductPortfolioAssociationProps(resolved),
    };
  }
}

/**
 * ProductPortfolioAssociation is the Schema for the ProductPortfolioAssociations API. Manages a Service Catalog Product Portfolio Association
 *
 * @schema ProductPortfolioAssociation
 */
export interface ProductPortfolioAssociationProps {
  /**
   * @schema ProductPortfolioAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProductPortfolioAssociationSpec defines the desired state of ProductPortfolioAssociation
   *
   * @schema ProductPortfolioAssociation#spec
   */
  readonly spec: ProductPortfolioAssociationSpec;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationProps(obj: ProductPortfolioAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProductPortfolioAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProductPortfolioAssociationSpec defines the desired state of ProductPortfolioAssociation
 *
 * @schema ProductPortfolioAssociationSpec
 */
export interface ProductPortfolioAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProductPortfolioAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProductPortfolioAssociationSpecDeletionPolicy;

  /**
   * @schema ProductPortfolioAssociationSpec#forProvider
   */
  readonly forProvider: ProductPortfolioAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProductPortfolioAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: ProductPortfolioAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProductPortfolioAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProductPortfolioAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProductPortfolioAssociationSpec#providerRef
   */
  readonly providerRef?: ProductPortfolioAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProductPortfolioAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProductPortfolioAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProductPortfolioAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProductPortfolioAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpec(obj: ProductPortfolioAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProductPortfolioAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ProductPortfolioAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProductPortfolioAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProductPortfolioAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProductPortfolioAssociationSpecDeletionPolicy
 */
export enum ProductPortfolioAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProductPortfolioAssociationSpecForProvider
 */
export interface ProductPortfolioAssociationSpecForProvider {
  /**
   * Language code. Valid values: en (English), jp (Japanese), zh (Chinese). Default value is en.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#acceptLanguage
   */
  readonly acceptLanguage?: string;

  /**
   * Portfolio identifier.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#portfolioId
   */
  readonly portfolioId?: string;

  /**
   * Reference to a Portfolio to populate portfolioId.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#portfolioIdRef
   */
  readonly portfolioIdRef?: ProductPortfolioAssociationSpecForProviderPortfolioIdRef;

  /**
   * Selector for a Portfolio to populate portfolioId.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#portfolioIdSelector
   */
  readonly portfolioIdSelector?: ProductPortfolioAssociationSpecForProviderPortfolioIdSelector;

  /**
   * Product identifier.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#productId
   */
  readonly productId?: string;

  /**
   * Reference to a Product to populate productId.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#productIdRef
   */
  readonly productIdRef?: ProductPortfolioAssociationSpecForProviderProductIdRef;

  /**
   * Selector for a Product to populate productId.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#productIdSelector
   */
  readonly productIdSelector?: ProductPortfolioAssociationSpecForProviderProductIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Identifier of the source portfolio.
   *
   * @schema ProductPortfolioAssociationSpecForProvider#sourcePortfolioId
   */
  readonly sourcePortfolioId?: string;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProvider(obj: ProductPortfolioAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptLanguage': obj.acceptLanguage,
    'portfolioId': obj.portfolioId,
    'portfolioIdRef': toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdRef(obj.portfolioIdRef),
    'portfolioIdSelector': toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdSelector(obj.portfolioIdSelector),
    'productId': obj.productId,
    'productIdRef': toJson_ProductPortfolioAssociationSpecForProviderProductIdRef(obj.productIdRef),
    'productIdSelector': toJson_ProductPortfolioAssociationSpecForProviderProductIdSelector(obj.productIdSelector),
    'region': obj.region,
    'sourcePortfolioId': obj.sourcePortfolioId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProductPortfolioAssociationSpecManagementPolicy
 */
export enum ProductPortfolioAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProductPortfolioAssociationSpecProviderConfigRef
 */
export interface ProductPortfolioAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductPortfolioAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductPortfolioAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: ProductPortfolioAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecProviderConfigRef(obj: ProductPortfolioAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductPortfolioAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProductPortfolioAssociationSpecProviderRef
 */
export interface ProductPortfolioAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductPortfolioAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductPortfolioAssociationSpecProviderRef#policy
   */
  readonly policy?: ProductPortfolioAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecProviderRef(obj: ProductPortfolioAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductPortfolioAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsTo
 */
export interface ProductPortfolioAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsTo(obj: ProductPortfolioAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProductPortfolioAssociationSpecWriteConnectionSecretToRef
 */
export interface ProductPortfolioAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProductPortfolioAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProductPortfolioAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecWriteConnectionSecretToRef(obj: ProductPortfolioAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Portfolio to populate portfolioId.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRef
 */
export interface ProductPortfolioAssociationSpecForProviderPortfolioIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRef#policy
   */
  readonly policy?: ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderPortfolioIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdRef(obj: ProductPortfolioAssociationSpecForProviderPortfolioIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Portfolio to populate portfolioId.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelector
 */
export interface ProductPortfolioAssociationSpecForProviderPortfolioIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelector#policy
   */
  readonly policy?: ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderPortfolioIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdSelector(obj: ProductPortfolioAssociationSpecForProviderPortfolioIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Product to populate productId.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdRef
 */
export interface ProductPortfolioAssociationSpecForProviderProductIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdRef#policy
   */
  readonly policy?: ProductPortfolioAssociationSpecForProviderProductIdRefPolicy;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderProductIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderProductIdRef(obj: ProductPortfolioAssociationSpecForProviderProductIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductPortfolioAssociationSpecForProviderProductIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Product to populate productId.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdSelector
 */
export interface ProductPortfolioAssociationSpecForProviderProductIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdSelector#policy
   */
  readonly policy?: ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderProductIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderProductIdSelector(obj: ProductPortfolioAssociationSpecForProviderProductIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductPortfolioAssociationSpecProviderConfigRefPolicy
 */
export interface ProductPortfolioAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductPortfolioAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProductPortfolioAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductPortfolioAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProductPortfolioAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecProviderConfigRefPolicy(obj: ProductPortfolioAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductPortfolioAssociationSpecProviderRefPolicy
 */
export interface ProductPortfolioAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductPortfolioAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProductPortfolioAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductPortfolioAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProductPortfolioAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecProviderRefPolicy(obj: ProductPortfolioAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef(obj: ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata(obj: ProductPortfolioAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy
 */
export interface ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy#resolution
   */
  readonly resolution?: ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy#resolve
   */
  readonly resolve?: ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy(obj: ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy
 */
export interface ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy#resolution
   */
  readonly resolution?: ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy#resolve
   */
  readonly resolve?: ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy(obj: ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdRefPolicy
 */
export interface ProductPortfolioAssociationSpecForProviderProductIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdRefPolicy#resolution
   */
  readonly resolution?: ProductPortfolioAssociationSpecForProviderProductIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdRefPolicy#resolve
   */
  readonly resolve?: ProductPortfolioAssociationSpecForProviderProductIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderProductIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderProductIdRefPolicy(obj: ProductPortfolioAssociationSpecForProviderProductIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy
 */
export interface ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy#resolution
   */
  readonly resolution?: ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy#resolve
   */
  readonly resolve?: ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy(obj: ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductPortfolioAssociationSpecProviderConfigRefPolicyResolution
 */
export enum ProductPortfolioAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductPortfolioAssociationSpecProviderConfigRefPolicyResolve
 */
export enum ProductPortfolioAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductPortfolioAssociationSpecProviderRefPolicyResolution
 */
export enum ProductPortfolioAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductPortfolioAssociationSpecProviderRefPolicyResolve
 */
export enum ProductPortfolioAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolution
 */
export enum ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolve
 */
export enum ProductPortfolioAssociationSpecForProviderPortfolioIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolution
 */
export enum ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolve
 */
export enum ProductPortfolioAssociationSpecForProviderPortfolioIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdRefPolicyResolution
 */
export enum ProductPortfolioAssociationSpecForProviderProductIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdRefPolicyResolve
 */
export enum ProductPortfolioAssociationSpecForProviderProductIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicyResolution
 */
export enum ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicyResolve
 */
export enum ProductPortfolioAssociationSpecForProviderProductIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProductPortfolioAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ProvisioningArtifact is the Schema for the ProvisioningArtifacts API. Manages a Service Catalog Provisioning Artifact
 *
 * @schema ProvisioningArtifact
 */
export class ProvisioningArtifact extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProvisioningArtifact"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'ProvisioningArtifact',
  }

  /**
   * Renders a Kubernetes manifest for "ProvisioningArtifact".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProvisioningArtifactProps): any {
    return {
      ...ProvisioningArtifact.GVK,
      ...toJson_ProvisioningArtifactProps(props),
    };
  }

  /**
   * Defines a "ProvisioningArtifact" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProvisioningArtifactProps) {
    super(scope, id, {
      ...ProvisioningArtifact.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProvisioningArtifact.GVK,
      ...toJson_ProvisioningArtifactProps(resolved),
    };
  }
}

/**
 * ProvisioningArtifact is the Schema for the ProvisioningArtifacts API. Manages a Service Catalog Provisioning Artifact
 *
 * @schema ProvisioningArtifact
 */
export interface ProvisioningArtifactProps {
  /**
   * @schema ProvisioningArtifact#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ProvisioningArtifactSpec defines the desired state of ProvisioningArtifact
   *
   * @schema ProvisioningArtifact#spec
   */
  readonly spec: ProvisioningArtifactSpec;

}

/**
 * Converts an object of type 'ProvisioningArtifactProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactProps(obj: ProvisioningArtifactProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProvisioningArtifactSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProvisioningArtifactSpec defines the desired state of ProvisioningArtifact
 *
 * @schema ProvisioningArtifactSpec
 */
export interface ProvisioningArtifactSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProvisioningArtifactSpec#deletionPolicy
   */
  readonly deletionPolicy?: ProvisioningArtifactSpecDeletionPolicy;

  /**
   * @schema ProvisioningArtifactSpec#forProvider
   */
  readonly forProvider: ProvisioningArtifactSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ProvisioningArtifactSpec#managementPolicy
   */
  readonly managementPolicy?: ProvisioningArtifactSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ProvisioningArtifactSpec#providerConfigRef
   */
  readonly providerConfigRef?: ProvisioningArtifactSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ProvisioningArtifactSpec#providerRef
   */
  readonly providerRef?: ProvisioningArtifactSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ProvisioningArtifactSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ProvisioningArtifactSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ProvisioningArtifactSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ProvisioningArtifactSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpec(obj: ProvisioningArtifactSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ProvisioningArtifactSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ProvisioningArtifactSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ProvisioningArtifactSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ProvisioningArtifactSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ProvisioningArtifactSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProvisioningArtifactSpecDeletionPolicy
 */
export enum ProvisioningArtifactSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ProvisioningArtifactSpecForProvider
 */
export interface ProvisioningArtifactSpecForProvider {
  /**
   * Language code. Valid values: en (English), jp (Japanese), zh (Chinese). The default value is en.
   *
   * @schema ProvisioningArtifactSpecForProvider#acceptLanguage
   */
  readonly acceptLanguage?: string;

  /**
   * Whether the product version is active. Inactive provisioning artifacts are invisible to end users. End users cannot launch or update a provisioned product from an inactive provisioning artifact. Default is true.
   *
   * @default true.
   * @schema ProvisioningArtifactSpecForProvider#active
   */
  readonly active?: boolean;

  /**
   * Description of the provisioning artifact (i.e., version), including how it differs from the previous provisioning artifact.
   *
   * @schema ProvisioningArtifactSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Whether AWS Service Catalog stops validating the specified provisioning artifact template even if it is invalid.
   *
   * @schema ProvisioningArtifactSpecForProvider#disableTemplateValidation
   */
  readonly disableTemplateValidation?: boolean;

  /**
   * Information set by the administrator to provide guidance to end users about which provisioning artifacts to use. Valid values are DEFAULT and DEPRECATED. The default is DEFAULT. Users are able to make updates to a provisioned product of a deprecated version but cannot launch new provisioned products using a deprecated version.
   *
   * @schema ProvisioningArtifactSpecForProvider#guidance
   */
  readonly guidance?: string;

  /**
   * Name of the provisioning artifact (for example, v1, v2beta). No spaces are allowed.
   *
   * @schema ProvisioningArtifactSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Identifier of the product.
   *
   * @schema ProvisioningArtifactSpecForProvider#productId
   */
  readonly productId?: string;

  /**
   * Reference to a Product in servicecatalog to populate productId.
   *
   * @schema ProvisioningArtifactSpecForProvider#productIdRef
   */
  readonly productIdRef?: ProvisioningArtifactSpecForProviderProductIdRef;

  /**
   * Selector for a Product in servicecatalog to populate productId.
   *
   * @schema ProvisioningArtifactSpecForProvider#productIdSelector
   */
  readonly productIdSelector?: ProvisioningArtifactSpecForProviderProductIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ProvisioningArtifactSpecForProvider#region
   */
  readonly region: string;

  /**
   * Template source as the physical ID of the resource that contains the template. Currently only supports CloudFormation stack ARN. Specify the physical ID as arn:[partition]:cloudformation:[region]:[account ID]:stack/[stack name]/[resource ID].
   *
   * @schema ProvisioningArtifactSpecForProvider#templatePhysicalId
   */
  readonly templatePhysicalId?: string;

  /**
   * Template source as URL of the CloudFormation template in Amazon S3.
   *
   * @schema ProvisioningArtifactSpecForProvider#templateUrl
   */
  readonly templateUrl?: string;

  /**
   * Type of provisioning artifact. See AWS Docs for valid list of values.
   *
   * @schema ProvisioningArtifactSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecForProvider(obj: ProvisioningArtifactSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptLanguage': obj.acceptLanguage,
    'active': obj.active,
    'description': obj.description,
    'disableTemplateValidation': obj.disableTemplateValidation,
    'guidance': obj.guidance,
    'name': obj.name,
    'productId': obj.productId,
    'productIdRef': toJson_ProvisioningArtifactSpecForProviderProductIdRef(obj.productIdRef),
    'productIdSelector': toJson_ProvisioningArtifactSpecForProviderProductIdSelector(obj.productIdSelector),
    'region': obj.region,
    'templatePhysicalId': obj.templatePhysicalId,
    'templateUrl': obj.templateUrl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ProvisioningArtifactSpecManagementPolicy
 */
export enum ProvisioningArtifactSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ProvisioningArtifactSpecProviderConfigRef
 */
export interface ProvisioningArtifactSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisioningArtifactSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisioningArtifactSpecProviderConfigRef#policy
   */
  readonly policy?: ProvisioningArtifactSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecProviderConfigRef(obj: ProvisioningArtifactSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisioningArtifactSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ProvisioningArtifactSpecProviderRef
 */
export interface ProvisioningArtifactSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisioningArtifactSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisioningArtifactSpecProviderRef#policy
   */
  readonly policy?: ProvisioningArtifactSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecProviderRef(obj: ProvisioningArtifactSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisioningArtifactSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ProvisioningArtifactSpecPublishConnectionDetailsTo
 */
export interface ProvisioningArtifactSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ProvisioningArtifactSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecPublishConnectionDetailsTo(obj: ProvisioningArtifactSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ProvisioningArtifactSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ProvisioningArtifactSpecWriteConnectionSecretToRef
 */
export interface ProvisioningArtifactSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ProvisioningArtifactSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ProvisioningArtifactSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecWriteConnectionSecretToRef(obj: ProvisioningArtifactSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Product in servicecatalog to populate productId.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdRef
 */
export interface ProvisioningArtifactSpecForProviderProductIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdRef#policy
   */
  readonly policy?: ProvisioningArtifactSpecForProviderProductIdRefPolicy;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecForProviderProductIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecForProviderProductIdRef(obj: ProvisioningArtifactSpecForProviderProductIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisioningArtifactSpecForProviderProductIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Product in servicecatalog to populate productId.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdSelector
 */
export interface ProvisioningArtifactSpecForProviderProductIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdSelector#policy
   */
  readonly policy?: ProvisioningArtifactSpecForProviderProductIdSelectorPolicy;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecForProviderProductIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecForProviderProductIdSelector(obj: ProvisioningArtifactSpecForProviderProductIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ProvisioningArtifactSpecForProviderProductIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProvisioningArtifactSpecProviderConfigRefPolicy
 */
export interface ProvisioningArtifactSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningArtifactSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ProvisioningArtifactSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningArtifactSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ProvisioningArtifactSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecProviderConfigRefPolicy(obj: ProvisioningArtifactSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProvisioningArtifactSpecProviderRefPolicy
 */
export interface ProvisioningArtifactSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningArtifactSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ProvisioningArtifactSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningArtifactSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ProvisioningArtifactSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecProviderRefPolicy(obj: ProvisioningArtifactSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef
 */
export interface ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef(obj: ProvisioningArtifactSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ProvisioningArtifactSpecPublishConnectionDetailsToMetadata
 */
export interface ProvisioningArtifactSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecPublishConnectionDetailsToMetadata(obj: ProvisioningArtifactSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdRefPolicy
 */
export interface ProvisioningArtifactSpecForProviderProductIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdRefPolicy#resolution
   */
  readonly resolution?: ProvisioningArtifactSpecForProviderProductIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdRefPolicy#resolve
   */
  readonly resolve?: ProvisioningArtifactSpecForProviderProductIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecForProviderProductIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecForProviderProductIdRefPolicy(obj: ProvisioningArtifactSpecForProviderProductIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdSelectorPolicy
 */
export interface ProvisioningArtifactSpecForProviderProductIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdSelectorPolicy#resolution
   */
  readonly resolution?: ProvisioningArtifactSpecForProviderProductIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningArtifactSpecForProviderProductIdSelectorPolicy#resolve
   */
  readonly resolve?: ProvisioningArtifactSpecForProviderProductIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecForProviderProductIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecForProviderProductIdSelectorPolicy(obj: ProvisioningArtifactSpecForProviderProductIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningArtifactSpecProviderConfigRefPolicyResolution
 */
export enum ProvisioningArtifactSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningArtifactSpecProviderConfigRefPolicyResolve
 */
export enum ProvisioningArtifactSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningArtifactSpecProviderRefPolicyResolution
 */
export enum ProvisioningArtifactSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningArtifactSpecProviderRefPolicyResolve
 */
export enum ProvisioningArtifactSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy(obj: ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdRefPolicyResolution
 */
export enum ProvisioningArtifactSpecForProviderProductIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdRefPolicyResolve
 */
export enum ProvisioningArtifactSpecForProviderProductIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdSelectorPolicyResolution
 */
export enum ProvisioningArtifactSpecForProviderProductIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningArtifactSpecForProviderProductIdSelectorPolicyResolve
 */
export enum ProvisioningArtifactSpecForProviderProductIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ProvisioningArtifactSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceAction is the Schema for the ServiceActions API. Manages a Service Catalog Service Action
 *
 * @schema ServiceAction
 */
export class ServiceAction extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceAction"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'ServiceAction',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceAction".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceActionProps): any {
    return {
      ...ServiceAction.GVK,
      ...toJson_ServiceActionProps(props),
    };
  }

  /**
   * Defines a "ServiceAction" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceActionProps) {
    super(scope, id, {
      ...ServiceAction.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceAction.GVK,
      ...toJson_ServiceActionProps(resolved),
    };
  }
}

/**
 * ServiceAction is the Schema for the ServiceActions API. Manages a Service Catalog Service Action
 *
 * @schema ServiceAction
 */
export interface ServiceActionProps {
  /**
   * @schema ServiceAction#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceActionSpec defines the desired state of ServiceAction
   *
   * @schema ServiceAction#spec
   */
  readonly spec: ServiceActionSpec;

}

/**
 * Converts an object of type 'ServiceActionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionProps(obj: ServiceActionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceActionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceActionSpec defines the desired state of ServiceAction
 *
 * @schema ServiceActionSpec
 */
export interface ServiceActionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceActionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceActionSpecDeletionPolicy;

  /**
   * @schema ServiceActionSpec#forProvider
   */
  readonly forProvider: ServiceActionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceActionSpec#managementPolicy
   */
  readonly managementPolicy?: ServiceActionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceActionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceActionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ServiceActionSpec#providerRef
   */
  readonly providerRef?: ServiceActionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceActionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceActionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceActionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceActionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceActionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpec(obj: ServiceActionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceActionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ServiceActionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ServiceActionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ServiceActionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceActionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceActionSpecDeletionPolicy
 */
export enum ServiceActionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceActionSpecForProvider
 */
export interface ServiceActionSpecForProvider {
  /**
   * Language code. Valid values are en (English), jp (Japanese), and zh (Chinese). Default is en.
   *
   * @default en.
   * @schema ServiceActionSpecForProvider#acceptLanguage
   */
  readonly acceptLanguage?: string;

  /**
   * Self-service action definition configuration block. Detailed below.
   *
   * @schema ServiceActionSpecForProvider#definition
   */
  readonly definition?: ServiceActionSpecForProviderDefinition[];

  /**
   * Self-service action description.
   *
   * @schema ServiceActionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Self-service action name.
   *
   * @schema ServiceActionSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ServiceActionSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ServiceActionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecForProvider(obj: ServiceActionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceptLanguage': obj.acceptLanguage,
    'definition': obj.definition?.map(y => toJson_ServiceActionSpecForProviderDefinition(y)),
    'description': obj.description,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceActionSpecManagementPolicy
 */
export enum ServiceActionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceActionSpecProviderConfigRef
 */
export interface ServiceActionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceActionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceActionSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceActionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceActionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecProviderConfigRef(obj: ServiceActionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceActionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ServiceActionSpecProviderRef
 */
export interface ServiceActionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceActionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceActionSpecProviderRef#policy
   */
  readonly policy?: ServiceActionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ServiceActionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecProviderRef(obj: ServiceActionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceActionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceActionSpecPublishConnectionDetailsTo
 */
export interface ServiceActionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceActionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceActionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceActionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecPublishConnectionDetailsTo(obj: ServiceActionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceActionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceActionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceActionSpecWriteConnectionSecretToRef
 */
export interface ServiceActionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceActionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceActionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceActionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecWriteConnectionSecretToRef(obj: ServiceActionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceActionSpecForProviderDefinition
 */
export interface ServiceActionSpecForProviderDefinition {
  /**
   * ARN of the role that performs the self-service actions on your behalf. For example, arn:aws:iam::12345678910:role/ActionRole. To reuse the provisioned product launch role, set to LAUNCH_ROLE.
   *
   * @schema ServiceActionSpecForProviderDefinition#assumeRole
   */
  readonly assumeRole?: string;

  /**
   * Name of the SSM document. For example, AWS-RestartEC2Instance. If you are using a shared SSM document, you must provide the ARN instead of the name.
   *
   * @schema ServiceActionSpecForProviderDefinition#name
   */
  readonly name: string;

  /**
   * List of parameters in JSON format. For example: [{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}] or [{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}].
   *
   * @schema ServiceActionSpecForProviderDefinition#parameters
   */
  readonly parameters?: string;

  /**
   * Service action definition type. Valid value is SSM_AUTOMATION. Default is SSM_AUTOMATION.
   *
   * @default SSM_AUTOMATION.
   * @schema ServiceActionSpecForProviderDefinition#type
   */
  readonly type?: string;

  /**
   * SSM document version. For example, 1.
   *
   * @schema ServiceActionSpecForProviderDefinition#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ServiceActionSpecForProviderDefinition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecForProviderDefinition(obj: ServiceActionSpecForProviderDefinition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assumeRole': obj.assumeRole,
    'name': obj.name,
    'parameters': obj.parameters,
    'type': obj.type,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceActionSpecProviderConfigRefPolicy
 */
export interface ServiceActionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceActionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceActionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceActionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceActionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceActionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecProviderConfigRefPolicy(obj: ServiceActionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceActionSpecProviderRefPolicy
 */
export interface ServiceActionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceActionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ServiceActionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceActionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ServiceActionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceActionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecProviderRefPolicy(obj: ServiceActionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceActionSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceActionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceActionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecPublishConnectionDetailsToConfigRef(obj: ServiceActionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceActionSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceActionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceActionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecPublishConnectionDetailsToMetadata(obj: ServiceActionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceActionSpecProviderConfigRefPolicyResolution
 */
export enum ServiceActionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceActionSpecProviderConfigRefPolicyResolve
 */
export enum ServiceActionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceActionSpecProviderRefPolicyResolution
 */
export enum ServiceActionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceActionSpecProviderRefPolicyResolve
 */
export enum ServiceActionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceActionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceActionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceActionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceActionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceActionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceActionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceActionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TagOption is the Schema for the TagOptions API. Manages a Service Catalog Tag Option
 *
 * @schema TagOption
 */
export class TagOption extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TagOption"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'TagOption',
  }

  /**
   * Renders a Kubernetes manifest for "TagOption".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TagOptionProps): any {
    return {
      ...TagOption.GVK,
      ...toJson_TagOptionProps(props),
    };
  }

  /**
   * Defines a "TagOption" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TagOptionProps) {
    super(scope, id, {
      ...TagOption.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TagOption.GVK,
      ...toJson_TagOptionProps(resolved),
    };
  }
}

/**
 * TagOption is the Schema for the TagOptions API. Manages a Service Catalog Tag Option
 *
 * @schema TagOption
 */
export interface TagOptionProps {
  /**
   * @schema TagOption#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TagOptionSpec defines the desired state of TagOption
   *
   * @schema TagOption#spec
   */
  readonly spec: TagOptionSpec;

}

/**
 * Converts an object of type 'TagOptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionProps(obj: TagOptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TagOptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TagOptionSpec defines the desired state of TagOption
 *
 * @schema TagOptionSpec
 */
export interface TagOptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagOptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: TagOptionSpecDeletionPolicy;

  /**
   * @schema TagOptionSpec#forProvider
   */
  readonly forProvider: TagOptionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagOptionSpec#managementPolicy
   */
  readonly managementPolicy?: TagOptionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TagOptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: TagOptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TagOptionSpec#providerRef
   */
  readonly providerRef?: TagOptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TagOptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TagOptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TagOptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TagOptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TagOptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpec(obj: TagOptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TagOptionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TagOptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TagOptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TagOptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TagOptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagOptionSpecDeletionPolicy
 */
export enum TagOptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TagOptionSpecForProvider
 */
export interface TagOptionSpecForProvider {
  /**
   * Whether tag option is active. Default is true.
   *
   * @default true.
   * @schema TagOptionSpecForProvider#active
   */
  readonly active?: boolean;

  /**
   * Tag option key.
   *
   * @schema TagOptionSpecForProvider#key
   */
  readonly key?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TagOptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Tag option value.
   *
   * @schema TagOptionSpecForProvider#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'TagOptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecForProvider(obj: TagOptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
    'key': obj.key,
    'region': obj.region,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagOptionSpecManagementPolicy
 */
export enum TagOptionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TagOptionSpecProviderConfigRef
 */
export interface TagOptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionSpecProviderConfigRef#policy
   */
  readonly policy?: TagOptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TagOptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecProviderConfigRef(obj: TagOptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TagOptionSpecProviderRef
 */
export interface TagOptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionSpecProviderRef#policy
   */
  readonly policy?: TagOptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TagOptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecProviderRef(obj: TagOptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TagOptionSpecPublishConnectionDetailsTo
 */
export interface TagOptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TagOptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TagOptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TagOptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TagOptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TagOptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TagOptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecPublishConnectionDetailsTo(obj: TagOptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TagOptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TagOptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TagOptionSpecWriteConnectionSecretToRef
 */
export interface TagOptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TagOptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TagOptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TagOptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecWriteConnectionSecretToRef(obj: TagOptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagOptionSpecProviderConfigRefPolicy
 */
export interface TagOptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TagOptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TagOptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecProviderConfigRefPolicy(obj: TagOptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagOptionSpecProviderRefPolicy
 */
export interface TagOptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TagOptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TagOptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecProviderRefPolicy(obj: TagOptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TagOptionSpecPublishConnectionDetailsToConfigRef
 */
export interface TagOptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TagOptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TagOptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecPublishConnectionDetailsToConfigRef(obj: TagOptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TagOptionSpecPublishConnectionDetailsToMetadata
 */
export interface TagOptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagOptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagOptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TagOptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TagOptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecPublishConnectionDetailsToMetadata(obj: TagOptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionSpecProviderConfigRefPolicyResolution
 */
export enum TagOptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionSpecProviderConfigRefPolicyResolve
 */
export enum TagOptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionSpecProviderRefPolicyResolution
 */
export enum TagOptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionSpecProviderRefPolicyResolve
 */
export enum TagOptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TagOptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TagOptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TagOptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TagOptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: TagOptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TagOptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TagOptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TagOptionResourceAssociation is the Schema for the TagOptionResourceAssociations API. Manages a Service Catalog Tag Option Resource Association
 *
 * @schema TagOptionResourceAssociation
 */
export class TagOptionResourceAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TagOptionResourceAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'servicecatalog.aws.upbound.io/v1beta1',
    kind: 'TagOptionResourceAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "TagOptionResourceAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TagOptionResourceAssociationProps): any {
    return {
      ...TagOptionResourceAssociation.GVK,
      ...toJson_TagOptionResourceAssociationProps(props),
    };
  }

  /**
   * Defines a "TagOptionResourceAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TagOptionResourceAssociationProps) {
    super(scope, id, {
      ...TagOptionResourceAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TagOptionResourceAssociation.GVK,
      ...toJson_TagOptionResourceAssociationProps(resolved),
    };
  }
}

/**
 * TagOptionResourceAssociation is the Schema for the TagOptionResourceAssociations API. Manages a Service Catalog Tag Option Resource Association
 *
 * @schema TagOptionResourceAssociation
 */
export interface TagOptionResourceAssociationProps {
  /**
   * @schema TagOptionResourceAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TagOptionResourceAssociationSpec defines the desired state of TagOptionResourceAssociation
   *
   * @schema TagOptionResourceAssociation#spec
   */
  readonly spec: TagOptionResourceAssociationSpec;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationProps(obj: TagOptionResourceAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TagOptionResourceAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TagOptionResourceAssociationSpec defines the desired state of TagOptionResourceAssociation
 *
 * @schema TagOptionResourceAssociationSpec
 */
export interface TagOptionResourceAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagOptionResourceAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: TagOptionResourceAssociationSpecDeletionPolicy;

  /**
   * @schema TagOptionResourceAssociationSpec#forProvider
   */
  readonly forProvider: TagOptionResourceAssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagOptionResourceAssociationSpec#managementPolicy
   */
  readonly managementPolicy?: TagOptionResourceAssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TagOptionResourceAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: TagOptionResourceAssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TagOptionResourceAssociationSpec#providerRef
   */
  readonly providerRef?: TagOptionResourceAssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TagOptionResourceAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TagOptionResourceAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TagOptionResourceAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TagOptionResourceAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpec(obj: TagOptionResourceAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TagOptionResourceAssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TagOptionResourceAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TagOptionResourceAssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TagOptionResourceAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagOptionResourceAssociationSpecDeletionPolicy
 */
export enum TagOptionResourceAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TagOptionResourceAssociationSpecForProvider
 */
export interface TagOptionResourceAssociationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TagOptionResourceAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * Resource identifier.
   *
   * @schema TagOptionResourceAssociationSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Product to populate resourceId.
   *
   * @schema TagOptionResourceAssociationSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: TagOptionResourceAssociationSpecForProviderResourceIdRef;

  /**
   * Selector for a Product to populate resourceId.
   *
   * @schema TagOptionResourceAssociationSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: TagOptionResourceAssociationSpecForProviderResourceIdSelector;

  /**
   * Tag Option identifier.
   *
   * @schema TagOptionResourceAssociationSpecForProvider#tagOptionId
   */
  readonly tagOptionId?: string;

  /**
   * Reference to a TagOption to populate tagOptionId.
   *
   * @schema TagOptionResourceAssociationSpecForProvider#tagOptionIdRef
   */
  readonly tagOptionIdRef?: TagOptionResourceAssociationSpecForProviderTagOptionIdRef;

  /**
   * Selector for a TagOption to populate tagOptionId.
   *
   * @schema TagOptionResourceAssociationSpecForProvider#tagOptionIdSelector
   */
  readonly tagOptionIdSelector?: TagOptionResourceAssociationSpecForProviderTagOptionIdSelector;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProvider(obj: TagOptionResourceAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_TagOptionResourceAssociationSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_TagOptionResourceAssociationSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'tagOptionId': obj.tagOptionId,
    'tagOptionIdRef': toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdRef(obj.tagOptionIdRef),
    'tagOptionIdSelector': toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdSelector(obj.tagOptionIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagOptionResourceAssociationSpecManagementPolicy
 */
export enum TagOptionResourceAssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TagOptionResourceAssociationSpecProviderConfigRef
 */
export interface TagOptionResourceAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionResourceAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionResourceAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: TagOptionResourceAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecProviderConfigRef(obj: TagOptionResourceAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionResourceAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TagOptionResourceAssociationSpecProviderRef
 */
export interface TagOptionResourceAssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionResourceAssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionResourceAssociationSpecProviderRef#policy
   */
  readonly policy?: TagOptionResourceAssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecProviderRef(obj: TagOptionResourceAssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionResourceAssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsTo
 */
export interface TagOptionResourceAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsTo(obj: TagOptionResourceAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TagOptionResourceAssociationSpecWriteConnectionSecretToRef
 */
export interface TagOptionResourceAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TagOptionResourceAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TagOptionResourceAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecWriteConnectionSecretToRef(obj: TagOptionResourceAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Product to populate resourceId.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdRef
 */
export interface TagOptionResourceAssociationSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdRef#policy
   */
  readonly policy?: TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderResourceIdRef(obj: TagOptionResourceAssociationSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Product to populate resourceId.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelector
 */
export interface TagOptionResourceAssociationSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderResourceIdSelector(obj: TagOptionResourceAssociationSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TagOption to populate tagOptionId.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRef
 */
export interface TagOptionResourceAssociationSpecForProviderTagOptionIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRef#policy
   */
  readonly policy?: TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderTagOptionIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdRef(obj: TagOptionResourceAssociationSpecForProviderTagOptionIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TagOption to populate tagOptionId.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelector
 */
export interface TagOptionResourceAssociationSpecForProviderTagOptionIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelector#policy
   */
  readonly policy?: TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderTagOptionIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdSelector(obj: TagOptionResourceAssociationSpecForProviderTagOptionIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagOptionResourceAssociationSpecProviderConfigRefPolicy
 */
export interface TagOptionResourceAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionResourceAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TagOptionResourceAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionResourceAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TagOptionResourceAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecProviderConfigRefPolicy(obj: TagOptionResourceAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagOptionResourceAssociationSpecProviderRefPolicy
 */
export interface TagOptionResourceAssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionResourceAssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TagOptionResourceAssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionResourceAssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TagOptionResourceAssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecProviderRefPolicy(obj: TagOptionResourceAssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef(obj: TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata(obj: TagOptionResourceAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy
 */
export interface TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: TagOptionResourceAssociationSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: TagOptionResourceAssociationSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy(obj: TagOptionResourceAssociationSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy
 */
export interface TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy(obj: TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy
 */
export interface TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy#resolution
   */
  readonly resolution?: TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy#resolve
   */
  readonly resolve?: TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy(obj: TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy
 */
export interface TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy#resolution
   */
  readonly resolution?: TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy#resolve
   */
  readonly resolve?: TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy(obj: TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionResourceAssociationSpecProviderConfigRefPolicyResolution
 */
export enum TagOptionResourceAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionResourceAssociationSpecProviderConfigRefPolicyResolve
 */
export enum TagOptionResourceAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionResourceAssociationSpecProviderRefPolicyResolution
 */
export enum TagOptionResourceAssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionResourceAssociationSpecProviderRefPolicyResolve
 */
export enum TagOptionResourceAssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdRefPolicyResolution
 */
export enum TagOptionResourceAssociationSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdRefPolicyResolve
 */
export enum TagOptionResourceAssociationSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum TagOptionResourceAssociationSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicyResolution
 */
export enum TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicyResolve
 */
export enum TagOptionResourceAssociationSpecForProviderTagOptionIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicyResolution
 */
export enum TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicyResolve
 */
export enum TagOptionResourceAssociationSpecForProviderTagOptionIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TagOptionResourceAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

