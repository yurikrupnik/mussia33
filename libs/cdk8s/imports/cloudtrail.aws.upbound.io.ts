// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * EventDataStore is the Schema for the EventDataStores API. Provides a CloudTrail Event Data Store resource.
 *
 * @schema EventDataStore
 */
export class EventDataStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventDataStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudtrail.aws.upbound.io/v1beta1',
    kind: 'EventDataStore',
  }

  /**
   * Renders a Kubernetes manifest for "EventDataStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventDataStoreProps): any {
    return {
      ...EventDataStore.GVK,
      ...toJson_EventDataStoreProps(props),
    };
  }

  /**
   * Defines a "EventDataStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventDataStoreProps) {
    super(scope, id, {
      ...EventDataStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventDataStore.GVK,
      ...toJson_EventDataStoreProps(resolved),
    };
  }
}

/**
 * EventDataStore is the Schema for the EventDataStores API. Provides a CloudTrail Event Data Store resource.
 *
 * @schema EventDataStore
 */
export interface EventDataStoreProps {
  /**
   * @schema EventDataStore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventDataStoreSpec defines the desired state of EventDataStore
   *
   * @schema EventDataStore#spec
   */
  readonly spec: EventDataStoreSpec;

}

/**
 * Converts an object of type 'EventDataStoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreProps(obj: EventDataStoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventDataStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventDataStoreSpec defines the desired state of EventDataStore
 *
 * @schema EventDataStoreSpec
 */
export interface EventDataStoreSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventDataStoreSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventDataStoreSpecDeletionPolicy;

  /**
   * @schema EventDataStoreSpec#forProvider
   */
  readonly forProvider: EventDataStoreSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EventDataStoreSpec#managementPolicy
   */
  readonly managementPolicy?: EventDataStoreSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventDataStoreSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventDataStoreSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EventDataStoreSpec#providerRef
   */
  readonly providerRef?: EventDataStoreSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventDataStoreSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventDataStoreSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventDataStoreSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventDataStoreSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventDataStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpec(obj: EventDataStoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventDataStoreSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EventDataStoreSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EventDataStoreSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EventDataStoreSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventDataStoreSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventDataStoreSpecDeletionPolicy
 */
export enum EventDataStoreSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventDataStoreSpecForProvider
 */
export interface EventDataStoreSpecForProvider {
  /**
   * The advanced event selectors to use to select the events for the data store. For more information about how to use advanced event selectors, see Log events by using advanced event selectors in the CloudTrail User Guide.
   *
   * @schema EventDataStoreSpecForProvider#advancedEventSelector
   */
  readonly advancedEventSelector?: EventDataStoreSpecForProviderAdvancedEventSelector[];

  /**
   * Specifies the AWS KMS key ID to use to encrypt the events delivered by CloudTrail. The value can be an alias name prefixed by alias/, a fully specified ARN to an alias, a fully specified ARN to a key, or a globally unique identifier.
   *
   * @schema EventDataStoreSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema EventDataStoreSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: EventDataStoreSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema EventDataStoreSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: EventDataStoreSpecForProviderKmsKeyIdSelector;

  /**
   * Specifies whether the event data store includes events from all regions, or only from the region in which the event data store is created. Default: true.
   *
   * @schema EventDataStoreSpecForProvider#multiRegionEnabled
   */
  readonly multiRegionEnabled?: boolean;

  /**
   * The name of the event data store.
   *
   * @schema EventDataStoreSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Specifies whether an event data store collects events logged for an organization in AWS Organizations. Default: false.
   *
   * @schema EventDataStoreSpecForProvider#organizationEnabled
   */
  readonly organizationEnabled?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventDataStoreSpecForProvider#region
   */
  readonly region: string;

  /**
   * The retention period of the event data store, in days. You can set a retention period of up to 2555 days, the equivalent of seven years. Default: 2555.
   *
   * @schema EventDataStoreSpecForProvider#retentionPeriod
   */
  readonly retentionPeriod?: number;

  /**
   * Key-value map of resource tags.
   *
   * @schema EventDataStoreSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Specifies whether termination protection is enabled for the event data store. If termination protection is enabled, you cannot delete the event data store until termination protection is disabled. Default: true.
   *
   * @schema EventDataStoreSpecForProvider#terminationProtectionEnabled
   */
  readonly terminationProtectionEnabled?: boolean;

}

/**
 * Converts an object of type 'EventDataStoreSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecForProvider(obj: EventDataStoreSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedEventSelector': obj.advancedEventSelector?.map(y => toJson_EventDataStoreSpecForProviderAdvancedEventSelector(y)),
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_EventDataStoreSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_EventDataStoreSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'multiRegionEnabled': obj.multiRegionEnabled,
    'name': obj.name,
    'organizationEnabled': obj.organizationEnabled,
    'region': obj.region,
    'retentionPeriod': obj.retentionPeriod,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'terminationProtectionEnabled': obj.terminationProtectionEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EventDataStoreSpecManagementPolicy
 */
export enum EventDataStoreSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventDataStoreSpecProviderConfigRef
 */
export interface EventDataStoreSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDataStoreSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDataStoreSpecProviderConfigRef#policy
   */
  readonly policy?: EventDataStoreSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventDataStoreSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecProviderConfigRef(obj: EventDataStoreSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDataStoreSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EventDataStoreSpecProviderRef
 */
export interface EventDataStoreSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDataStoreSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDataStoreSpecProviderRef#policy
   */
  readonly policy?: EventDataStoreSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EventDataStoreSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecProviderRef(obj: EventDataStoreSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDataStoreSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventDataStoreSpecPublishConnectionDetailsTo
 */
export interface EventDataStoreSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventDataStoreSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventDataStoreSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventDataStoreSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecPublishConnectionDetailsTo(obj: EventDataStoreSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventDataStoreSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventDataStoreSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventDataStoreSpecWriteConnectionSecretToRef
 */
export interface EventDataStoreSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventDataStoreSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventDataStoreSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventDataStoreSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecWriteConnectionSecretToRef(obj: EventDataStoreSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventDataStoreSpecForProviderAdvancedEventSelector
 */
export interface EventDataStoreSpecForProviderAdvancedEventSelector {
  /**
   * Specifies the selector statements in an advanced event selector. Fields documented below.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelector#fieldSelector
   */
  readonly fieldSelector?: EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector[];

  /**
   * The name of the event data store.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelector#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'EventDataStoreSpecForProviderAdvancedEventSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecForProviderAdvancedEventSelector(obj: EventDataStoreSpecForProviderAdvancedEventSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldSelector': obj.fieldSelector?.map(y => toJson_EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdRef
 */
export interface EventDataStoreSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: EventDataStoreSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'EventDataStoreSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecForProviderKmsKeyIdRef(obj: EventDataStoreSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDataStoreSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdSelector
 */
export interface EventDataStoreSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'EventDataStoreSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecForProviderKmsKeyIdSelector(obj: EventDataStoreSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDataStoreSpecProviderConfigRefPolicy
 */
export interface EventDataStoreSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDataStoreSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventDataStoreSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDataStoreSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventDataStoreSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDataStoreSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecProviderConfigRefPolicy(obj: EventDataStoreSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDataStoreSpecProviderRefPolicy
 */
export interface EventDataStoreSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDataStoreSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EventDataStoreSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDataStoreSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EventDataStoreSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDataStoreSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecProviderRefPolicy(obj: EventDataStoreSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRef
 */
export interface EventDataStoreSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventDataStoreSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecPublishConnectionDetailsToConfigRef(obj: EventDataStoreSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventDataStoreSpecPublishConnectionDetailsToMetadata
 */
export interface EventDataStoreSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventDataStoreSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecPublishConnectionDetailsToMetadata(obj: EventDataStoreSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector
 */
export interface EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector {
  /**
   * A list of values that includes events that match the last few characters of the event record field specified as the value of field.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector#endsWith
   */
  readonly endsWith?: string[];

  /**
   * A list of values that includes events that match the exact value of the event record field specified as the value of field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector#equals
   */
  readonly equals?: string[];

  /**
   * Specifies a field in an event record on which to filter events to be logged. You can specify only the following values: readOnly, eventSource, eventName, eventCategory, resources.type, resources.ARN.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector#field
   */
  readonly field?: string;

  /**
   * A list of values that excludes events that match the last few characters of the event record field specified as the value of field.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector#notEndsWith
   */
  readonly notEndsWith?: string[];

  /**
   * A list of values that excludes events that match the exact value of the event record field specified as the value of field.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector#notEquals
   */
  readonly notEquals?: string[];

  /**
   * A list of values that excludes events that match the first few characters of the event record field specified as the value of field.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector#notStartsWith
   */
  readonly notStartsWith?: string[];

  /**
   * A list of values that includes events that match the first few characters of the event record field specified as the value of field.
   *
   * @schema EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector#startsWith
   */
  readonly startsWith?: string[];

}

/**
 * Converts an object of type 'EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector(obj: EventDataStoreSpecForProviderAdvancedEventSelectorFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endsWith': obj.endsWith?.map(y => y),
    'equals': obj.equals?.map(y => y),
    'field': obj.field,
    'notEndsWith': obj.notEndsWith?.map(y => y),
    'notEquals': obj.notEquals?.map(y => y),
    'notStartsWith': obj.notStartsWith?.map(y => y),
    'startsWith': obj.startsWith?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdRefPolicy
 */
export interface EventDataStoreSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: EventDataStoreSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: EventDataStoreSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDataStoreSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecForProviderKmsKeyIdRefPolicy(obj: EventDataStoreSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: EventDataStoreSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: EventDataStoreSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy(obj: EventDataStoreSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDataStoreSpecProviderConfigRefPolicyResolution
 */
export enum EventDataStoreSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDataStoreSpecProviderConfigRefPolicyResolve
 */
export enum EventDataStoreSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDataStoreSpecProviderRefPolicyResolution
 */
export enum EventDataStoreSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDataStoreSpecProviderRefPolicyResolve
 */
export enum EventDataStoreSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum EventDataStoreSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum EventDataStoreSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum EventDataStoreSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDataStoreSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum EventDataStoreSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventDataStoreSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Trail is the Schema for the Trails API. Provides a CloudTrail resource.
 *
 * @schema Trail
 */
export class Trail extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Trail"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudtrail.aws.upbound.io/v1beta1',
    kind: 'Trail',
  }

  /**
   * Renders a Kubernetes manifest for "Trail".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TrailProps): any {
    return {
      ...Trail.GVK,
      ...toJson_TrailProps(props),
    };
  }

  /**
   * Defines a "Trail" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TrailProps) {
    super(scope, id, {
      ...Trail.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Trail.GVK,
      ...toJson_TrailProps(resolved),
    };
  }
}

/**
 * Trail is the Schema for the Trails API. Provides a CloudTrail resource.
 *
 * @schema Trail
 */
export interface TrailProps {
  /**
   * @schema Trail#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrailSpec defines the desired state of Trail
   *
   * @schema Trail#spec
   */
  readonly spec: TrailSpec;

}

/**
 * Converts an object of type 'TrailProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailProps(obj: TrailProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrailSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrailSpec defines the desired state of Trail
 *
 * @schema TrailSpec
 */
export interface TrailSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrailSpec#deletionPolicy
   */
  readonly deletionPolicy?: TrailSpecDeletionPolicy;

  /**
   * @schema TrailSpec#forProvider
   */
  readonly forProvider: TrailSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrailSpec#managementPolicy
   */
  readonly managementPolicy?: TrailSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TrailSpec#providerConfigRef
   */
  readonly providerConfigRef?: TrailSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TrailSpec#providerRef
   */
  readonly providerRef?: TrailSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TrailSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrailSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TrailSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrailSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrailSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpec(obj: TrailSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrailSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TrailSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TrailSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TrailSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrailSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrailSpecDeletionPolicy
 */
export enum TrailSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrailSpecForProvider
 */
export interface TrailSpecForProvider {
  /**
   * Specifies an advanced event selector for enabling data event logging. Fields documented below. Conflicts with event_selector.
   *
   * @schema TrailSpecForProvider#advancedEventSelector
   */
  readonly advancedEventSelector?: TrailSpecForProviderAdvancedEventSelector[];

  /**
   * Log group name using an ARN that represents the log group to which CloudTrail logs will be delivered. Note that CloudTrail requires the Log Stream wildcard.
   *
   * @schema TrailSpecForProvider#cloudWatchLogsGroupArn
   */
  readonly cloudWatchLogsGroupArn?: string;

  /**
   * Role for the CloudWatch Logs endpoint to assume to write to a user’s log group.
   *
   * @schema TrailSpecForProvider#cloudWatchLogsRoleArn
   */
  readonly cloudWatchLogsRoleArn?: string;

  /**
   * Reference to a Role in iam to populate cloudWatchLogsRoleArn.
   *
   * @schema TrailSpecForProvider#cloudWatchLogsRoleArnRef
   */
  readonly cloudWatchLogsRoleArnRef?: TrailSpecForProviderCloudWatchLogsRoleArnRef;

  /**
   * Selector for a Role in iam to populate cloudWatchLogsRoleArn.
   *
   * @schema TrailSpecForProvider#cloudWatchLogsRoleArnSelector
   */
  readonly cloudWatchLogsRoleArnSelector?: TrailSpecForProviderCloudWatchLogsRoleArnSelector;

  /**
   * Whether log file integrity validation is enabled. Defaults to false.
   *
   * @default false.
   * @schema TrailSpecForProvider#enableLogFileValidation
   */
  readonly enableLogFileValidation?: boolean;

  /**
   * Enables logging for the trail. Defaults to true. Setting this to false will pause logging.
   *
   * @default true. Setting this to false will pause logging.
   * @schema TrailSpecForProvider#enableLogging
   */
  readonly enableLogging?: boolean;

  /**
   * Specifies an event selector for enabling data event logging. Fields documented below. Please note the CloudTrail limits when configuring these. Conflicts with advanced_event_selector.
   *
   * @schema TrailSpecForProvider#eventSelector
   */
  readonly eventSelector?: TrailSpecForProviderEventSelector[];

  /**
   * Whether the trail is publishing events from global services such as IAM to the log files. Defaults to true.
   *
   * @default true.
   * @schema TrailSpecForProvider#includeGlobalServiceEvents
   */
  readonly includeGlobalServiceEvents?: boolean;

  /**
   * Configuration block for identifying unusual operational activity. See details below.
   *
   * @schema TrailSpecForProvider#insightSelector
   */
  readonly insightSelector?: TrailSpecForProviderInsightSelector[];

  /**
   * Whether the trail is created in the current region or in all regions. Defaults to false.
   *
   * @default false.
   * @schema TrailSpecForProvider#isMultiRegionTrail
   */
  readonly isMultiRegionTrail?: boolean;

  /**
   * Whether the trail is an AWS Organizations trail. Organization trails log events for the master account and all member accounts. Can only be created in the organization master account. Defaults to false.
   *
   * @default false.
   * @schema TrailSpecForProvider#isOrganizationTrail
   */
  readonly isOrganizationTrail?: boolean;

  /**
   * KMS key ARN to use to encrypt the logs delivered by CloudTrail.
   *
   * @schema TrailSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema TrailSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: TrailSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema TrailSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: TrailSpecForProviderKmsKeyIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrailSpecForProvider#region
   */
  readonly region: string;

  /**
   * Name of the S3 bucket designated for publishing log files.
   *
   * @schema TrailSpecForProvider#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * Reference to a Bucket in s3 to populate s3BucketName.
   *
   * @schema TrailSpecForProvider#s3BucketNameRef
   */
  readonly s3BucketNameRef?: TrailSpecForProviderS3BucketNameRef;

  /**
   * Selector for a Bucket in s3 to populate s3BucketName.
   *
   * @schema TrailSpecForProvider#s3BucketNameSelector
   */
  readonly s3BucketNameSelector?: TrailSpecForProviderS3BucketNameSelector;

  /**
   * S3 key prefix that follows the name of the bucket you have designated for log file delivery.
   *
   * @schema TrailSpecForProvider#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

  /**
   * Name of the Amazon SNS topic defined for notification of log file delivery.
   *
   * @schema TrailSpecForProvider#snsTopicName
   */
  readonly snsTopicName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TrailSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TrailSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProvider(obj: TrailSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedEventSelector': obj.advancedEventSelector?.map(y => toJson_TrailSpecForProviderAdvancedEventSelector(y)),
    'cloudWatchLogsGroupArn': obj.cloudWatchLogsGroupArn,
    'cloudWatchLogsRoleArn': obj.cloudWatchLogsRoleArn,
    'cloudWatchLogsRoleArnRef': toJson_TrailSpecForProviderCloudWatchLogsRoleArnRef(obj.cloudWatchLogsRoleArnRef),
    'cloudWatchLogsRoleArnSelector': toJson_TrailSpecForProviderCloudWatchLogsRoleArnSelector(obj.cloudWatchLogsRoleArnSelector),
    'enableLogFileValidation': obj.enableLogFileValidation,
    'enableLogging': obj.enableLogging,
    'eventSelector': obj.eventSelector?.map(y => toJson_TrailSpecForProviderEventSelector(y)),
    'includeGlobalServiceEvents': obj.includeGlobalServiceEvents,
    'insightSelector': obj.insightSelector?.map(y => toJson_TrailSpecForProviderInsightSelector(y)),
    'isMultiRegionTrail': obj.isMultiRegionTrail,
    'isOrganizationTrail': obj.isOrganizationTrail,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_TrailSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_TrailSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'region': obj.region,
    's3BucketName': obj.s3BucketName,
    's3BucketNameRef': toJson_TrailSpecForProviderS3BucketNameRef(obj.s3BucketNameRef),
    's3BucketNameSelector': toJson_TrailSpecForProviderS3BucketNameSelector(obj.s3BucketNameSelector),
    's3KeyPrefix': obj.s3KeyPrefix,
    'snsTopicName': obj.snsTopicName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrailSpecManagementPolicy
 */
export enum TrailSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TrailSpecProviderConfigRef
 */
export interface TrailSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrailSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrailSpecProviderConfigRef#policy
   */
  readonly policy?: TrailSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrailSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecProviderConfigRef(obj: TrailSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrailSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TrailSpecProviderRef
 */
export interface TrailSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrailSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrailSpecProviderRef#policy
   */
  readonly policy?: TrailSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TrailSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecProviderRef(obj: TrailSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrailSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TrailSpecPublishConnectionDetailsTo
 */
export interface TrailSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TrailSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrailSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrailSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrailSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrailSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrailSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecPublishConnectionDetailsTo(obj: TrailSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrailSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrailSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TrailSpecWriteConnectionSecretToRef
 */
export interface TrailSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrailSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrailSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrailSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecWriteConnectionSecretToRef(obj: TrailSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TrailSpecForProviderAdvancedEventSelector
 */
export interface TrailSpecForProviderAdvancedEventSelector {
  /**
   * Specifies the selector statements in an advanced event selector. Fields documented below.
   *
   * @schema TrailSpecForProviderAdvancedEventSelector#fieldSelector
   */
  readonly fieldSelector: TrailSpecForProviderAdvancedEventSelectorFieldSelector[];

  /**
   * Name of the trail.
   *
   * @schema TrailSpecForProviderAdvancedEventSelector#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TrailSpecForProviderAdvancedEventSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderAdvancedEventSelector(obj: TrailSpecForProviderAdvancedEventSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldSelector': obj.fieldSelector?.map(y => toJson_TrailSpecForProviderAdvancedEventSelectorFieldSelector(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate cloudWatchLogsRoleArn.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnRef
 */
export interface TrailSpecForProviderCloudWatchLogsRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnRef#policy
   */
  readonly policy?: TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TrailSpecForProviderCloudWatchLogsRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderCloudWatchLogsRoleArnRef(obj: TrailSpecForProviderCloudWatchLogsRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate cloudWatchLogsRoleArn.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelector
 */
export interface TrailSpecForProviderCloudWatchLogsRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelector#policy
   */
  readonly policy?: TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TrailSpecForProviderCloudWatchLogsRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderCloudWatchLogsRoleArnSelector(obj: TrailSpecForProviderCloudWatchLogsRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TrailSpecForProviderEventSelector
 */
export interface TrailSpecForProviderEventSelector {
  /**
   * Configuration block for data events. See details below.
   *
   * @schema TrailSpecForProviderEventSelector#dataResource
   */
  readonly dataResource?: TrailSpecForProviderEventSelectorDataResource[];

  /**
   * A set of event sources to exclude. Valid values include: kms.amazonaws.com and rdsdata.amazonaws.com. include_management_events must be set totrue to allow this.
   *
   * @schema TrailSpecForProviderEventSelector#excludeManagementEventSources
   */
  readonly excludeManagementEventSources?: string[];

  /**
   * Whether to include management events for your trail. Defaults to true.
   *
   * @default true.
   * @schema TrailSpecForProviderEventSelector#includeManagementEvents
   */
  readonly includeManagementEvents?: boolean;

  /**
   * Type of events to log. Valid values are ReadOnly, WriteOnly, All. Default value is All.
   *
   * @schema TrailSpecForProviderEventSelector#readWriteType
   */
  readonly readWriteType?: string;

}

/**
 * Converts an object of type 'TrailSpecForProviderEventSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderEventSelector(obj: TrailSpecForProviderEventSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataResource': obj.dataResource?.map(y => toJson_TrailSpecForProviderEventSelectorDataResource(y)),
    'excludeManagementEventSources': obj.excludeManagementEventSources?.map(y => y),
    'includeManagementEvents': obj.includeManagementEvents,
    'readWriteType': obj.readWriteType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TrailSpecForProviderInsightSelector
 */
export interface TrailSpecForProviderInsightSelector {
  /**
   * Type of insights to log on a trail. Valid values are: ApiCallRateInsight and ApiErrorRateInsight.
   *
   * @schema TrailSpecForProviderInsightSelector#insightType
   */
  readonly insightType: string;

}

/**
 * Converts an object of type 'TrailSpecForProviderInsightSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderInsightSelector(obj: TrailSpecForProviderInsightSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'insightType': obj.insightType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema TrailSpecForProviderKmsKeyIdRef
 */
export interface TrailSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrailSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrailSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: TrailSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'TrailSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderKmsKeyIdRef(obj: TrailSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrailSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema TrailSpecForProviderKmsKeyIdSelector
 */
export interface TrailSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrailSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrailSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrailSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: TrailSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrailSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderKmsKeyIdSelector(obj: TrailSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrailSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate s3BucketName.
 *
 * @schema TrailSpecForProviderS3BucketNameRef
 */
export interface TrailSpecForProviderS3BucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrailSpecForProviderS3BucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrailSpecForProviderS3BucketNameRef#policy
   */
  readonly policy?: TrailSpecForProviderS3BucketNameRefPolicy;

}

/**
 * Converts an object of type 'TrailSpecForProviderS3BucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderS3BucketNameRef(obj: TrailSpecForProviderS3BucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrailSpecForProviderS3BucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate s3BucketName.
 *
 * @schema TrailSpecForProviderS3BucketNameSelector
 */
export interface TrailSpecForProviderS3BucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TrailSpecForProviderS3BucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrailSpecForProviderS3BucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrailSpecForProviderS3BucketNameSelector#policy
   */
  readonly policy?: TrailSpecForProviderS3BucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'TrailSpecForProviderS3BucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderS3BucketNameSelector(obj: TrailSpecForProviderS3BucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrailSpecForProviderS3BucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrailSpecProviderConfigRefPolicy
 */
export interface TrailSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrailSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrailSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecProviderConfigRefPolicy(obj: TrailSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrailSpecProviderRefPolicy
 */
export interface TrailSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TrailSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TrailSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecProviderRefPolicy(obj: TrailSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TrailSpecPublishConnectionDetailsToConfigRef
 */
export interface TrailSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrailSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrailSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrailSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrailSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecPublishConnectionDetailsToConfigRef(obj: TrailSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrailSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrailSpecPublishConnectionDetailsToMetadata
 */
export interface TrailSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrailSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TrailSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrailSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrailSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecPublishConnectionDetailsToMetadata(obj: TrailSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector
 */
export interface TrailSpecForProviderAdvancedEventSelectorFieldSelector {
  /**
   * A list of values that includes events that match the last few characters of the event record field specified as the value of field.
   *
   * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector#endsWith
   */
  readonly endsWith?: string[];

  /**
   * A list of values that includes events that match the exact value of the event record field specified as the value of field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
   *
   * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector#equals
   */
  readonly equals?: string[];

  /**
   * Field in an event record on which to filter events to be logged. You can specify only the following values: readOnly, eventSource, eventName, eventCategory, resources.type, resources.ARN.
   *
   * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector#field
   */
  readonly field: string;

  /**
   * A list of values that excludes events that match the last few characters of the event record field specified as the value of field.
   *
   * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector#notEndsWith
   */
  readonly notEndsWith?: string[];

  /**
   * A list of values that excludes events that match the exact value of the event record field specified as the value of field.
   *
   * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector#notEquals
   */
  readonly notEquals?: string[];

  /**
   * A list of values that excludes events that match the first few characters of the event record field specified as the value of field.
   *
   * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector#notStartsWith
   */
  readonly notStartsWith?: string[];

  /**
   * A list of values that includes events that match the first few characters of the event record field specified as the value of field.
   *
   * @schema TrailSpecForProviderAdvancedEventSelectorFieldSelector#startsWith
   */
  readonly startsWith?: string[];

}

/**
 * Converts an object of type 'TrailSpecForProviderAdvancedEventSelectorFieldSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderAdvancedEventSelectorFieldSelector(obj: TrailSpecForProviderAdvancedEventSelectorFieldSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endsWith': obj.endsWith?.map(y => y),
    'equals': obj.equals?.map(y => y),
    'field': obj.field,
    'notEndsWith': obj.notEndsWith?.map(y => y),
    'notEquals': obj.notEquals?.map(y => y),
    'notStartsWith': obj.notStartsWith?.map(y => y),
    'startsWith': obj.startsWith?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy
 */
export interface TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy#resolution
   */
  readonly resolution?: TrailSpecForProviderCloudWatchLogsRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy#resolve
   */
  readonly resolve?: TrailSpecForProviderCloudWatchLogsRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy(obj: TrailSpecForProviderCloudWatchLogsRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy
 */
export interface TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy(obj: TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TrailSpecForProviderEventSelectorDataResource
 */
export interface TrailSpecForProviderEventSelectorDataResource {
  /**
   * Resource type in which you want to log data events. You can specify only the following value: "AWS::S3::Object", "AWS::Lambda::Function" and "AWS::DynamoDB::Table".
   *
   * @schema TrailSpecForProviderEventSelectorDataResource#type
   */
  readonly type: string;

  /**
   * List of ARN strings or partial ARN strings to specify selectors for data audit events over data resources. ARN list is specific to single-valued type. For example, arn:aws:s3:::<bucket name>/ for all objects in a bucket, arn:aws:s3:::<bucket name>/key for specific objects, arn:aws:lambda for all lambda events within an account, arn:aws:lambda:<region>:<account number>:function:<function name> for a specific Lambda function, arn:aws:dynamodb for all DDB events for all tables within an account, or arn:aws:dynamodb:<region>:<account number>:table/<table name> for a specific DynamoDB table.
   *
   * @schema TrailSpecForProviderEventSelectorDataResource#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'TrailSpecForProviderEventSelectorDataResource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderEventSelectorDataResource(obj: TrailSpecForProviderEventSelectorDataResource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrailSpecForProviderKmsKeyIdRefPolicy
 */
export interface TrailSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: TrailSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: TrailSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderKmsKeyIdRefPolicy(obj: TrailSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrailSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface TrailSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: TrailSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: TrailSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderKmsKeyIdSelectorPolicy(obj: TrailSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrailSpecForProviderS3BucketNameRefPolicy
 */
export interface TrailSpecForProviderS3BucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecForProviderS3BucketNameRefPolicy#resolution
   */
  readonly resolution?: TrailSpecForProviderS3BucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecForProviderS3BucketNameRefPolicy#resolve
   */
  readonly resolve?: TrailSpecForProviderS3BucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecForProviderS3BucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderS3BucketNameRefPolicy(obj: TrailSpecForProviderS3BucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrailSpecForProviderS3BucketNameSelectorPolicy
 */
export interface TrailSpecForProviderS3BucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecForProviderS3BucketNameSelectorPolicy#resolution
   */
  readonly resolution?: TrailSpecForProviderS3BucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecForProviderS3BucketNameSelectorPolicy#resolve
   */
  readonly resolve?: TrailSpecForProviderS3BucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecForProviderS3BucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecForProviderS3BucketNameSelectorPolicy(obj: TrailSpecForProviderS3BucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecProviderConfigRefPolicyResolution
 */
export enum TrailSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecProviderConfigRefPolicyResolve
 */
export enum TrailSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecProviderRefPolicyResolution
 */
export enum TrailSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecProviderRefPolicyResolve
 */
export enum TrailSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrailSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrailSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TrailSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrailSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TrailSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrailSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrailSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrailSpecPublishConnectionDetailsToConfigRefPolicy(obj: TrailSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnRefPolicyResolution
 */
export enum TrailSpecForProviderCloudWatchLogsRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnRefPolicyResolve
 */
export enum TrailSpecForProviderCloudWatchLogsRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicyResolution
 */
export enum TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicyResolve
 */
export enum TrailSpecForProviderCloudWatchLogsRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum TrailSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum TrailSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum TrailSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum TrailSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecForProviderS3BucketNameRefPolicyResolution
 */
export enum TrailSpecForProviderS3BucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecForProviderS3BucketNameRefPolicyResolve
 */
export enum TrailSpecForProviderS3BucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecForProviderS3BucketNameSelectorPolicyResolution
 */
export enum TrailSpecForProviderS3BucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecForProviderS3BucketNameSelectorPolicyResolve
 */
export enum TrailSpecForProviderS3BucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TrailSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrailSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TrailSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrailSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

