// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Node is the Schema for the Nodes API. A Cloud TPU instance.
 *
 * @schema Node
 */
export class Node extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Node"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'tpu.gcp.upbound.io/v1beta1',
    kind: 'Node',
  }

  /**
   * Renders a Kubernetes manifest for "Node".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: NodeProps): any {
    return {
      ...Node.GVK,
      ...toJson_NodeProps(props),
    };
  }

  /**
   * Defines a "Node" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: NodeProps) {
    super(scope, id, {
      ...Node.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Node.GVK,
      ...toJson_NodeProps(resolved),
    };
  }
}

/**
 * Node is the Schema for the Nodes API. A Cloud TPU instance.
 *
 * @schema Node
 */
export interface NodeProps {
  /**
   * @schema Node#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * NodeSpec defines the desired state of Node
   *
   * @schema Node#spec
   */
  readonly spec: NodeSpec;

}

/**
 * Converts an object of type 'NodeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeProps(obj: NodeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_NodeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NodeSpec defines the desired state of Node
 *
 * @schema NodeSpec
 */
export interface NodeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema NodeSpec#deletionPolicy
   */
  readonly deletionPolicy?: NodeSpecDeletionPolicy;

  /**
   * @schema NodeSpec#forProvider
   */
  readonly forProvider: NodeSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema NodeSpec#providerConfigRef
   */
  readonly providerConfigRef?: NodeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema NodeSpec#providerRef
   */
  readonly providerRef?: NodeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema NodeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: NodeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema NodeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: NodeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'NodeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpec(obj: NodeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_NodeSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_NodeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_NodeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_NodeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_NodeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema NodeSpecDeletionPolicy
 */
export enum NodeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema NodeSpecForProvider
 */
export interface NodeSpecForProvider {
  /**
   * The type of hardware accelerators associated with this node.
   *
   * @schema NodeSpecForProvider#acceleratorType
   */
  readonly acceleratorType: string;

  /**
   * The CIDR block that the TPU node will use when selecting an IP address. This CIDR block must be a /29 block; the Compute Engine networks API forbids a smaller block, and using a larger block would be wasteful (a node can only consume one IP address). Errors will occur if the CIDR block has already been used for a currently existing TPU node, the CIDR block conflicts with any subnetworks in the user's provided network, or the provided network is peered with another network that is using that CIDR block.
   *
   * @schema NodeSpecForProvider#cidrBlock
   */
  readonly cidrBlock?: string;

  /**
   * The user-supplied description of the TPU. Maximum of 512 characters.
   *
   * @schema NodeSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Resource labels to represent user provided metadata.
   *
   * @schema NodeSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of a network to peer the TPU node to. It must be a preexisting Compute Engine network inside of the project on which this API has been activated. If none is provided, "default" will be used.
   *
   * @schema NodeSpecForProvider#network
   */
  readonly network?: string;

  /**
   * Reference to a Connection in servicenetworking to populate network.
   *
   * @schema NodeSpecForProvider#networkRef
   */
  readonly networkRef?: NodeSpecForProviderNetworkRef;

  /**
   * Selector for a Connection in servicenetworking to populate network.
   *
   * @schema NodeSpecForProvider#networkSelector
   */
  readonly networkSelector?: NodeSpecForProviderNetworkSelector;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema NodeSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Sets the scheduling options for this TPU instance. Structure is documented below.
   *
   * @schema NodeSpecForProvider#schedulingConfig
   */
  readonly schedulingConfig?: NodeSpecForProviderSchedulingConfig[];

  /**
   * The version of Tensorflow running in the Node.
   *
   * @schema NodeSpecForProvider#tensorflowVersion
   */
  readonly tensorflowVersion: string;

  /**
   * Whether the VPC peering for the node is set up through Service Networking API. The VPC Peering should be set up before provisioning the node. If this field is set, cidr_block field should not be specified. If the network that you want to peer the TPU Node to is a Shared VPC network, the node must be created with this this field enabled.
   *
   * @schema NodeSpecForProvider#useServiceNetworking
   */
  readonly useServiceNetworking?: boolean;

  /**
   * The GCP location for the TPU. If it is not provided, the provider zone is used.
   *
   * @schema NodeSpecForProvider#zone
   */
  readonly zone: string;

}

/**
 * Converts an object of type 'NodeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecForProvider(obj: NodeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorType': obj.acceleratorType,
    'cidrBlock': obj.cidrBlock,
    'description': obj.description,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'network': obj.network,
    'networkRef': toJson_NodeSpecForProviderNetworkRef(obj.networkRef),
    'networkSelector': toJson_NodeSpecForProviderNetworkSelector(obj.networkSelector),
    'project': obj.project,
    'schedulingConfig': obj.schedulingConfig?.map(y => toJson_NodeSpecForProviderSchedulingConfig(y)),
    'tensorflowVersion': obj.tensorflowVersion,
    'useServiceNetworking': obj.useServiceNetworking,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema NodeSpecProviderConfigRef
 */
export interface NodeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeSpecProviderConfigRef#policy
   */
  readonly policy?: NodeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecProviderConfigRef(obj: NodeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema NodeSpecProviderRef
 */
export interface NodeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeSpecProviderRef#policy
   */
  readonly policy?: NodeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'NodeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecProviderRef(obj: NodeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema NodeSpecPublishConnectionDetailsTo
 */
export interface NodeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema NodeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: NodeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema NodeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: NodeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema NodeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'NodeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecPublishConnectionDetailsTo(obj: NodeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_NodeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_NodeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema NodeSpecWriteConnectionSecretToRef
 */
export interface NodeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema NodeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema NodeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'NodeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecWriteConnectionSecretToRef(obj: NodeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Connection in servicenetworking to populate network.
 *
 * @schema NodeSpecForProviderNetworkRef
 */
export interface NodeSpecForProviderNetworkRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeSpecForProviderNetworkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeSpecForProviderNetworkRef#policy
   */
  readonly policy?: NodeSpecForProviderNetworkRefPolicy;

}

/**
 * Converts an object of type 'NodeSpecForProviderNetworkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecForProviderNetworkRef(obj: NodeSpecForProviderNetworkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeSpecForProviderNetworkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Connection in servicenetworking to populate network.
 *
 * @schema NodeSpecForProviderNetworkSelector
 */
export interface NodeSpecForProviderNetworkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema NodeSpecForProviderNetworkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema NodeSpecForProviderNetworkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema NodeSpecForProviderNetworkSelector#policy
   */
  readonly policy?: NodeSpecForProviderNetworkSelectorPolicy;

}

/**
 * Converts an object of type 'NodeSpecForProviderNetworkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecForProviderNetworkSelector(obj: NodeSpecForProviderNetworkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_NodeSpecForProviderNetworkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema NodeSpecForProviderSchedulingConfig
 */
export interface NodeSpecForProviderSchedulingConfig {
  /**
   * Defines whether the TPU instance is preemptible.
   *
   * @schema NodeSpecForProviderSchedulingConfig#preemptible
   */
  readonly preemptible: boolean;

}

/**
 * Converts an object of type 'NodeSpecForProviderSchedulingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecForProviderSchedulingConfig(obj: NodeSpecForProviderSchedulingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preemptible': obj.preemptible,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeSpecProviderConfigRefPolicy
 */
export interface NodeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: NodeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: NodeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecProviderConfigRefPolicy(obj: NodeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeSpecProviderRefPolicy
 */
export interface NodeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: NodeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: NodeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecProviderRefPolicy(obj: NodeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema NodeSpecPublishConnectionDetailsToConfigRef
 */
export interface NodeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema NodeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema NodeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: NodeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'NodeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecPublishConnectionDetailsToConfigRef(obj: NodeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_NodeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema NodeSpecPublishConnectionDetailsToMetadata
 */
export interface NodeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema NodeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema NodeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'NodeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecPublishConnectionDetailsToMetadata(obj: NodeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema NodeSpecForProviderNetworkRefPolicy
 */
export interface NodeSpecForProviderNetworkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeSpecForProviderNetworkRefPolicy#resolution
   */
  readonly resolution?: NodeSpecForProviderNetworkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeSpecForProviderNetworkRefPolicy#resolve
   */
  readonly resolve?: NodeSpecForProviderNetworkRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeSpecForProviderNetworkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecForProviderNetworkRefPolicy(obj: NodeSpecForProviderNetworkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema NodeSpecForProviderNetworkSelectorPolicy
 */
export interface NodeSpecForProviderNetworkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeSpecForProviderNetworkSelectorPolicy#resolution
   */
  readonly resolution?: NodeSpecForProviderNetworkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeSpecForProviderNetworkSelectorPolicy#resolve
   */
  readonly resolve?: NodeSpecForProviderNetworkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'NodeSpecForProviderNetworkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecForProviderNetworkSelectorPolicy(obj: NodeSpecForProviderNetworkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeSpecProviderConfigRefPolicyResolution
 */
export enum NodeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeSpecProviderConfigRefPolicyResolve
 */
export enum NodeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeSpecProviderRefPolicyResolution
 */
export enum NodeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeSpecProviderRefPolicyResolve
 */
export enum NodeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema NodeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface NodeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema NodeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: NodeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema NodeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: NodeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'NodeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_NodeSpecPublishConnectionDetailsToConfigRefPolicy(obj: NodeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeSpecForProviderNetworkRefPolicyResolution
 */
export enum NodeSpecForProviderNetworkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeSpecForProviderNetworkRefPolicyResolve
 */
export enum NodeSpecForProviderNetworkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeSpecForProviderNetworkSelectorPolicyResolution
 */
export enum NodeSpecForProviderNetworkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeSpecForProviderNetworkSelectorPolicyResolve
 */
export enum NodeSpecForProviderNetworkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema NodeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum NodeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema NodeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum NodeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

