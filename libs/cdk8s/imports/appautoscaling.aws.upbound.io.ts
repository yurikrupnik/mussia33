// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Policy is the Schema for the Policys API. Provides an Application AutoScaling Policy resource.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appautoscaling.aws.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. Provides an Application AutoScaling Policy resource.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PolicySpec#initProvider
   */
  readonly initProvider?: PolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PolicySpec#managementPolicies
   */
  readonly managementPolicies?: PolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_PolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * Policy type. Valid values are StepScaling and TargetTrackingScaling. Defaults to StepScaling. Certain services only support only one policy type. For more information see the Target Tracking Scaling Policies and Step Scaling Policies documentation.
   *
   * @default StepScaling. Certain services only support only one policy type. For more information see the Target Tracking Scaling Policies and Step Scaling Policies documentation.
   * @schema PolicySpecForProvider#policyType
   */
  readonly policyType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema PolicySpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Target in appautoscaling to populate resourceId.
   *
   * @schema PolicySpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: PolicySpecForProviderResourceIdRef;

  /**
   * Selector for a Target in appautoscaling to populate resourceId.
   *
   * @schema PolicySpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: PolicySpecForProviderResourceIdSelector;

  /**
   * Scalable dimension of the scalable target. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema PolicySpecForProvider#scalableDimension
   */
  readonly scalableDimension?: string;

  /**
   * Reference to a Target in appautoscaling to populate scalableDimension.
   *
   * @schema PolicySpecForProvider#scalableDimensionRef
   */
  readonly scalableDimensionRef?: PolicySpecForProviderScalableDimensionRef;

  /**
   * Selector for a Target in appautoscaling to populate scalableDimension.
   *
   * @schema PolicySpecForProvider#scalableDimensionSelector
   */
  readonly scalableDimensionSelector?: PolicySpecForProviderScalableDimensionSelector;

  /**
   * AWS service namespace of the scalable target. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema PolicySpecForProvider#serviceNamespace
   */
  readonly serviceNamespace?: string;

  /**
   * Reference to a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema PolicySpecForProvider#serviceNamespaceRef
   */
  readonly serviceNamespaceRef?: PolicySpecForProviderServiceNamespaceRef;

  /**
   * Selector for a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema PolicySpecForProvider#serviceNamespaceSelector
   */
  readonly serviceNamespaceSelector?: PolicySpecForProviderServiceNamespaceSelector;

  /**
   * Step scaling policy configuration, requires policy_type = "StepScaling" (default). See supported fields below.
   *
   * @schema PolicySpecForProvider#stepScalingPolicyConfiguration
   */
  readonly stepScalingPolicyConfiguration?: PolicySpecForProviderStepScalingPolicyConfiguration[];

  /**
   * Target tracking policy, requires policy_type = "TargetTrackingScaling". See supported fields below.
   *
   * @schema PolicySpecForProvider#targetTrackingScalingPolicyConfiguration
   */
  readonly targetTrackingScalingPolicyConfiguration?: PolicySpecForProviderTargetTrackingScalingPolicyConfiguration[];

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyType': obj.policyType,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_PolicySpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_PolicySpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'scalableDimension': obj.scalableDimension,
    'scalableDimensionRef': toJson_PolicySpecForProviderScalableDimensionRef(obj.scalableDimensionRef),
    'scalableDimensionSelector': toJson_PolicySpecForProviderScalableDimensionSelector(obj.scalableDimensionSelector),
    'serviceNamespace': obj.serviceNamespace,
    'serviceNamespaceRef': toJson_PolicySpecForProviderServiceNamespaceRef(obj.serviceNamespaceRef),
    'serviceNamespaceSelector': toJson_PolicySpecForProviderServiceNamespaceSelector(obj.serviceNamespaceSelector),
    'stepScalingPolicyConfiguration': obj.stepScalingPolicyConfiguration?.map(y => toJson_PolicySpecForProviderStepScalingPolicyConfiguration(y)),
    'targetTrackingScalingPolicyConfiguration': obj.targetTrackingScalingPolicyConfiguration?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PolicySpecInitProvider
 */
export interface PolicySpecInitProvider {
  /**
   * Policy type. Valid values are StepScaling and TargetTrackingScaling. Defaults to StepScaling. Certain services only support only one policy type. For more information see the Target Tracking Scaling Policies and Step Scaling Policies documentation.
   *
   * @default StepScaling. Certain services only support only one policy type. For more information see the Target Tracking Scaling Policies and Step Scaling Policies documentation.
   * @schema PolicySpecInitProvider#policyType
   */
  readonly policyType?: string;

  /**
   * Step scaling policy configuration, requires policy_type = "StepScaling" (default). See supported fields below.
   *
   * @schema PolicySpecInitProvider#stepScalingPolicyConfiguration
   */
  readonly stepScalingPolicyConfiguration?: PolicySpecInitProviderStepScalingPolicyConfiguration[];

  /**
   * Target tracking policy, requires policy_type = "TargetTrackingScaling". See supported fields below.
   *
   * @schema PolicySpecInitProvider#targetTrackingScalingPolicyConfiguration
   */
  readonly targetTrackingScalingPolicyConfiguration?: PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration[];

}

/**
 * Converts an object of type 'PolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProvider(obj: PolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyType': obj.policyType,
    'stepScalingPolicyConfiguration': obj.stepScalingPolicyConfiguration?.map(y => toJson_PolicySpecInitProviderStepScalingPolicyConfiguration(y)),
    'targetTrackingScalingPolicyConfiguration': obj.targetTrackingScalingPolicyConfiguration?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PolicySpecManagementPolicies
 */
export enum PolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate resourceId.
 *
 * @schema PolicySpecForProviderResourceIdRef
 */
export interface PolicySpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderResourceIdRef#policy
   */
  readonly policy?: PolicySpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdRef(obj: PolicySpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate resourceId.
 *
 * @schema PolicySpecForProviderResourceIdSelector
 */
export interface PolicySpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderResourceIdSelector#policy
   */
  readonly policy?: PolicySpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdSelector(obj: PolicySpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate scalableDimension.
 *
 * @schema PolicySpecForProviderScalableDimensionRef
 */
export interface PolicySpecForProviderScalableDimensionRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderScalableDimensionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderScalableDimensionRef#policy
   */
  readonly policy?: PolicySpecForProviderScalableDimensionRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionRef(obj: PolicySpecForProviderScalableDimensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderScalableDimensionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate scalableDimension.
 *
 * @schema PolicySpecForProviderScalableDimensionSelector
 */
export interface PolicySpecForProviderScalableDimensionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderScalableDimensionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderScalableDimensionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderScalableDimensionSelector#policy
   */
  readonly policy?: PolicySpecForProviderScalableDimensionSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionSelector(obj: PolicySpecForProviderScalableDimensionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderScalableDimensionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema PolicySpecForProviderServiceNamespaceRef
 */
export interface PolicySpecForProviderServiceNamespaceRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderServiceNamespaceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderServiceNamespaceRef#policy
   */
  readonly policy?: PolicySpecForProviderServiceNamespaceRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceRef(obj: PolicySpecForProviderServiceNamespaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderServiceNamespaceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelector
 */
export interface PolicySpecForProviderServiceNamespaceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelector#policy
   */
  readonly policy?: PolicySpecForProviderServiceNamespaceSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceSelector(obj: PolicySpecForProviderServiceNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderServiceNamespaceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderStepScalingPolicyConfiguration
 */
export interface PolicySpecForProviderStepScalingPolicyConfiguration {
  /**
   * Whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are ChangeInCapacity, ExactCapacity, and PercentChangeInCapacity.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#adjustmentType
   */
  readonly adjustmentType?: string;

  /**
   * Amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#cooldown
   */
  readonly cooldown?: number;

  /**
   * Aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#metricAggregationType
   */
  readonly metricAggregationType?: string;

  /**
   * Minimum number to adjust your scalable dimension as a result of a scaling activity. If the adjustment type is PercentChangeInCapacity, the scaling policy changes the scalable dimension of the scalable target by this amount.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#minAdjustmentMagnitude
   */
  readonly minAdjustmentMagnitude?: number;

  /**
   * Set of adjustments that manage scaling. These have the following structure:
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#stepAdjustment
   */
  readonly stepAdjustment?: PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment[];

}

/**
 * Converts an object of type 'PolicySpecForProviderStepScalingPolicyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderStepScalingPolicyConfiguration(obj: PolicySpecForProviderStepScalingPolicyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adjustmentType': obj.adjustmentType,
    'cooldown': obj.cooldown,
    'metricAggregationType': obj.metricAggregationType,
    'minAdjustmentMagnitude': obj.minAdjustmentMagnitude,
    'stepAdjustment': obj.stepAdjustment?.map(y => toJson_PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfiguration {
  /**
   * Custom CloudWatch metric. Documentation can be found  at: AWS Customized Metric Specification. See supported fields below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#customizedMetricSpecification
   */
  readonly customizedMetricSpecification?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification[];

  /**
   * Whether scale in by the target tracking policy is disabled. If the value is true, scale in is disabled and the target tracking policy won't remove capacity from the scalable resource. Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource. The default value is false.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#disableScaleIn
   */
  readonly disableScaleIn?: boolean;

  /**
   * Predefined metric. See supported fields below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#predefinedMetricSpecification
   */
  readonly predefinedMetricSpecification?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification[];

  /**
   * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#scaleInCooldown
   */
  readonly scaleInCooldown?: number;

  /**
   * Amount of time, in seconds, after a scale out activity completes before another scale out activity can start.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#scaleOutCooldown
   */
  readonly scaleOutCooldown?: number;

  /**
   * Target value for the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#targetValue
   */
  readonly targetValue?: number;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfiguration(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedMetricSpecification': obj.customizedMetricSpecification?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification(y)),
    'disableScaleIn': obj.disableScaleIn,
    'predefinedMetricSpecification': obj.predefinedMetricSpecification?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification(y)),
    'scaleInCooldown': obj.scaleInCooldown,
    'scaleOutCooldown': obj.scaleOutCooldown,
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderStepScalingPolicyConfiguration
 */
export interface PolicySpecInitProviderStepScalingPolicyConfiguration {
  /**
   * Whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are ChangeInCapacity, ExactCapacity, and PercentChangeInCapacity.
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfiguration#adjustmentType
   */
  readonly adjustmentType?: string;

  /**
   * Amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfiguration#cooldown
   */
  readonly cooldown?: number;

  /**
   * Aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfiguration#metricAggregationType
   */
  readonly metricAggregationType?: string;

  /**
   * Minimum number to adjust your scalable dimension as a result of a scaling activity. If the adjustment type is PercentChangeInCapacity, the scaling policy changes the scalable dimension of the scalable target by this amount.
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfiguration#minAdjustmentMagnitude
   */
  readonly minAdjustmentMagnitude?: number;

  /**
   * Set of adjustments that manage scaling. These have the following structure:
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfiguration#stepAdjustment
   */
  readonly stepAdjustment?: PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment[];

}

/**
 * Converts an object of type 'PolicySpecInitProviderStepScalingPolicyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderStepScalingPolicyConfiguration(obj: PolicySpecInitProviderStepScalingPolicyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adjustmentType': obj.adjustmentType,
    'cooldown': obj.cooldown,
    'metricAggregationType': obj.metricAggregationType,
    'minAdjustmentMagnitude': obj.minAdjustmentMagnitude,
    'stepAdjustment': obj.stepAdjustment?.map(y => toJson_PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration {
  /**
   * Custom CloudWatch metric. Documentation can be found  at: AWS Customized Metric Specification. See supported fields below.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration#customizedMetricSpecification
   */
  readonly customizedMetricSpecification?: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification[];

  /**
   * Whether scale in by the target tracking policy is disabled. If the value is true, scale in is disabled and the target tracking policy won't remove capacity from the scalable resource. Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource. The default value is false.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration#disableScaleIn
   */
  readonly disableScaleIn?: boolean;

  /**
   * Predefined metric. See supported fields below.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration#predefinedMetricSpecification
   */
  readonly predefinedMetricSpecification?: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification[];

  /**
   * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration#scaleInCooldown
   */
  readonly scaleInCooldown?: number;

  /**
   * Amount of time, in seconds, after a scale out activity completes before another scale out activity can start.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration#scaleOutCooldown
   */
  readonly scaleOutCooldown?: number;

  /**
   * Target value for the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration#targetValue
   */
  readonly targetValue?: number;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedMetricSpecification': obj.customizedMetricSpecification?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification(y)),
    'disableScaleIn': obj.disableScaleIn,
    'predefinedMetricSpecification': obj.predefinedMetricSpecification?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification(y)),
    'scaleInCooldown': obj.scaleInCooldown,
    'scaleOutCooldown': obj.scaleOutCooldown,
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderResourceIdRefPolicy
 */
export interface PolicySpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdRefPolicy(obj: PolicySpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderResourceIdSelectorPolicy
 */
export interface PolicySpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdSelectorPolicy(obj: PolicySpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderScalableDimensionRefPolicy
 */
export interface PolicySpecForProviderScalableDimensionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderScalableDimensionRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderScalableDimensionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderScalableDimensionRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderScalableDimensionRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionRefPolicy(obj: PolicySpecForProviderScalableDimensionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderScalableDimensionSelectorPolicy
 */
export interface PolicySpecForProviderScalableDimensionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderScalableDimensionSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderScalableDimensionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderScalableDimensionSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderScalableDimensionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionSelectorPolicy(obj: PolicySpecForProviderScalableDimensionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderServiceNamespaceRefPolicy
 */
export interface PolicySpecForProviderServiceNamespaceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderServiceNamespaceRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderServiceNamespaceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderServiceNamespaceRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderServiceNamespaceRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceRefPolicy(obj: PolicySpecForProviderServiceNamespaceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelectorPolicy
 */
export interface PolicySpecForProviderServiceNamespaceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderServiceNamespaceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderServiceNamespaceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceSelectorPolicy(obj: PolicySpecForProviderServiceNamespaceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment
 */
export interface PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment {
  /**
   * Lower bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as negative infinity.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment#metricIntervalLowerBound
   */
  readonly metricIntervalLowerBound?: string;

  /**
   * Upper bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as infinity. The upper bound must be greater than the lower bound.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment#metricIntervalUpperBound
   */
  readonly metricIntervalUpperBound?: string;

  /**
   * Number of members by which to scale, when the adjustment bounds are breached. A positive value scales up. A negative value scales down.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment#scalingAdjustment
   */
  readonly scalingAdjustment?: number;

}

/**
 * Converts an object of type 'PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment(obj: PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricIntervalLowerBound': obj.metricIntervalLowerBound,
    'metricIntervalUpperBound': obj.metricIntervalUpperBound,
    'scalingAdjustment': obj.scalingAdjustment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification {
  /**
   * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#dimensions
   */
  readonly dimensions?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#metricName
   */
  readonly metricName?: string;

  /**
   * Metrics to include, as a metric data query.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#metrics
   */
  readonly metrics?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics[];

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#namespace
   */
  readonly namespace?: string;

  /**
   * Statistic of the metric. Valid values: Average, Minimum, Maximum, SampleCount, and Sum.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#statistic
   */
  readonly statistic?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions(y)),
    'metricName': obj.metricName,
    'metrics': obj.metrics?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics(y)),
    'namespace': obj.namespace,
    'statistic': obj.statistic,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification {
  /**
   * Metric type.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Reserved for future use if the predefined_metric_type is not ALBRequestCountPerTarget. If the predefined_metric_type is ALBRequestCountPerTarget, you must specify this argument. Documentation can be found at: AWS Predefined Scaling Metric Specification. Must be less than or equal to 1023 characters in length.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment
 */
export interface PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment {
  /**
   * Lower bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as negative infinity.
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment#metricIntervalLowerBound
   */
  readonly metricIntervalLowerBound?: string;

  /**
   * Upper bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as infinity. The upper bound must be greater than the lower bound.
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment#metricIntervalUpperBound
   */
  readonly metricIntervalUpperBound?: string;

  /**
   * Number of members by which to scale, when the adjustment bounds are breached. A positive value scales up. A negative value scales down.
   *
   * @schema PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment#scalingAdjustment
   */
  readonly scalingAdjustment?: number;

}

/**
 * Converts an object of type 'PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment(obj: PolicySpecInitProviderStepScalingPolicyConfigurationStepAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricIntervalLowerBound': obj.metricIntervalLowerBound,
    'metricIntervalUpperBound': obj.metricIntervalUpperBound,
    'scalingAdjustment': obj.scalingAdjustment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification {
  /**
   * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#dimensions
   */
  readonly dimensions?: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#metricName
   */
  readonly metricName?: string;

  /**
   * Metrics to include, as a metric data query.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#metrics
   */
  readonly metrics?: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics[];

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#namespace
   */
  readonly namespace?: string;

  /**
   * Statistic of the metric. Valid values: Average, Minimum, Maximum, SampleCount, and Sum.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#statistic
   */
  readonly statistic?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions(y)),
    'metricName': obj.metricName,
    'metrics': obj.metrics?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics(y)),
    'namespace': obj.namespace,
    'statistic': obj.statistic,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification {
  /**
   * Metric type.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType?: string;

  /**
   * Reserved for future use if the predefined_metric_type is not ALBRequestCountPerTarget. If the predefined_metric_type is ALBRequestCountPerTarget, you must specify this argument. Documentation can be found at: AWS Predefined Scaling Metric Specification. Must be less than or equal to 1023 characters in length.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderResourceIdRefPolicyResolution
 */
export enum PolicySpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderResourceIdRefPolicyResolve
 */
export enum PolicySpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderResourceIdSelectorPolicyResolution
 */
export enum PolicySpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderResourceIdSelectorPolicyResolve
 */
export enum PolicySpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderScalableDimensionRefPolicyResolution
 */
export enum PolicySpecForProviderScalableDimensionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderScalableDimensionRefPolicyResolve
 */
export enum PolicySpecForProviderScalableDimensionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderScalableDimensionSelectorPolicyResolution
 */
export enum PolicySpecForProviderScalableDimensionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderScalableDimensionSelectorPolicyResolve
 */
export enum PolicySpecForProviderScalableDimensionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderServiceNamespaceRefPolicyResolution
 */
export enum PolicySpecForProviderServiceNamespaceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderServiceNamespaceRefPolicyResolve
 */
export enum PolicySpecForProviderServiceNamespaceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelectorPolicyResolution
 */
export enum PolicySpecForProviderServiceNamespaceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelectorPolicyResolve
 */
export enum PolicySpecForProviderServiceNamespaceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions {
  /**
   * Name of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in target tracking scaling policy.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#metricStat
   */
  readonly metricStat?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions {
  /**
   * Name of the dimension.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in target tracking scaling policy.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#id
   */
  readonly id?: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#metricStat
   */
  readonly metricStat?: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#metric
   */
  readonly metric?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#metric
   */
  readonly metric?: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#stat
   */
  readonly stat?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric {
  /**
   * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric {
  /**
   * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#metricName
   */
  readonly metricName?: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions {
  /**
   * Name of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions
 */
export interface PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions {
  /**
   * Name of the dimension.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#name
   */
  readonly name?: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(obj: PolicySpecInitProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ScheduledAction is the Schema for the ScheduledActions API. Provides an Application AutoScaling ScheduledAction resource.
 *
 * @schema ScheduledAction
 */
export class ScheduledAction extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScheduledAction"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appautoscaling.aws.upbound.io/v1beta1',
    kind: 'ScheduledAction',
  }

  /**
   * Renders a Kubernetes manifest for "ScheduledAction".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduledActionProps): any {
    return {
      ...ScheduledAction.GVK,
      ...toJson_ScheduledActionProps(props),
    };
  }

  /**
   * Defines a "ScheduledAction" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduledActionProps) {
    super(scope, id, {
      ...ScheduledAction.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScheduledAction.GVK,
      ...toJson_ScheduledActionProps(resolved),
    };
  }
}

/**
 * ScheduledAction is the Schema for the ScheduledActions API. Provides an Application AutoScaling ScheduledAction resource.
 *
 * @schema ScheduledAction
 */
export interface ScheduledActionProps {
  /**
   * @schema ScheduledAction#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduledActionSpec defines the desired state of ScheduledAction
   *
   * @schema ScheduledAction#spec
   */
  readonly spec: ScheduledActionSpec;

}

/**
 * Converts an object of type 'ScheduledActionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionProps(obj: ScheduledActionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduledActionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduledActionSpec defines the desired state of ScheduledAction
 *
 * @schema ScheduledActionSpec
 */
export interface ScheduledActionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduledActionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScheduledActionSpecDeletionPolicy;

  /**
   * @schema ScheduledActionSpec#forProvider
   */
  readonly forProvider: ScheduledActionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ScheduledActionSpec#initProvider
   */
  readonly initProvider?: ScheduledActionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ScheduledActionSpec#managementPolicies
   */
  readonly managementPolicies?: ScheduledActionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScheduledActionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScheduledActionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScheduledActionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScheduledActionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScheduledActionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScheduledActionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScheduledActionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpec(obj: ScheduledActionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScheduledActionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ScheduledActionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ScheduledActionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ScheduledActionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScheduledActionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduledActionSpecDeletionPolicy
 */
export enum ScheduledActionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScheduledActionSpecForProvider
 */
export interface ScheduledActionSpecForProvider {
  /**
   * Date and time for the scheduled action to end in RFC 3339 format. The timezone is not affected by the setting of timezone.
   *
   * @schema ScheduledActionSpecForProvider#endTime
   */
  readonly endTime?: string;

  /**
   * Name of the scheduled action.
   *
   * @schema ScheduledActionSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScheduledActionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Identifier of the resource associated with the scheduled action. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema ScheduledActionSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Target in appautoscaling to populate resourceId.
   *
   * @schema ScheduledActionSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: ScheduledActionSpecForProviderResourceIdRef;

  /**
   * Selector for a Target in appautoscaling to populate resourceId.
   *
   * @schema ScheduledActionSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: ScheduledActionSpecForProviderResourceIdSelector;

  /**
   * Scalable dimension. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference Example: ecs:service:DesiredCount
   *
   * @schema ScheduledActionSpecForProvider#scalableDimension
   */
  readonly scalableDimension?: string;

  /**
   * Reference to a Target in appautoscaling to populate scalableDimension.
   *
   * @schema ScheduledActionSpecForProvider#scalableDimensionRef
   */
  readonly scalableDimensionRef?: ScheduledActionSpecForProviderScalableDimensionRef;

  /**
   * Selector for a Target in appautoscaling to populate scalableDimension.
   *
   * @schema ScheduledActionSpecForProvider#scalableDimensionSelector
   */
  readonly scalableDimensionSelector?: ScheduledActionSpecForProviderScalableDimensionSelector;

  /**
   * New minimum and maximum capacity. You can set both values or just one. See below
   *
   * @schema ScheduledActionSpecForProvider#scalableTargetAction
   */
  readonly scalableTargetAction?: ScheduledActionSpecForProviderScalableTargetAction[];

  /**
   * Schedule for this action. The following formats are supported: At expressions - at(yyyy-mm-ddThh:mm:ss), Rate expressions - rate(valueunit), Cron expressions - cron(fields). Times for at expressions and cron expressions are evaluated using the time zone configured in timezone. Documentation can be found in the Timezone parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema ScheduledActionSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * Namespace of the AWS service. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference Example: ecs
   *
   * @schema ScheduledActionSpecForProvider#serviceNamespace
   */
  readonly serviceNamespace?: string;

  /**
   * Reference to a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema ScheduledActionSpecForProvider#serviceNamespaceRef
   */
  readonly serviceNamespaceRef?: ScheduledActionSpecForProviderServiceNamespaceRef;

  /**
   * Selector for a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema ScheduledActionSpecForProvider#serviceNamespaceSelector
   */
  readonly serviceNamespaceSelector?: ScheduledActionSpecForProviderServiceNamespaceSelector;

  /**
   * Date and time for the scheduled action to start in RFC 3339 format. The timezone is not affected by the setting of timezone.
   *
   * @schema ScheduledActionSpecForProvider#startTime
   */
  readonly startTime?: string;

  /**
   * Time zone used when setting a scheduled action by using an at or cron expression. Does not affect timezone for start_time and end_time. Valid values are the canonical names of the IANA time zones supported by Joda-Time, such as Etc/GMT+9 or Pacific/Tahiti. Default is UTC.
   *
   * @default UTC.
   * @schema ScheduledActionSpecForProvider#timezone
   */
  readonly timezone?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProvider(obj: ScheduledActionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'name': obj.name,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_ScheduledActionSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_ScheduledActionSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'scalableDimension': obj.scalableDimension,
    'scalableDimensionRef': toJson_ScheduledActionSpecForProviderScalableDimensionRef(obj.scalableDimensionRef),
    'scalableDimensionSelector': toJson_ScheduledActionSpecForProviderScalableDimensionSelector(obj.scalableDimensionSelector),
    'scalableTargetAction': obj.scalableTargetAction?.map(y => toJson_ScheduledActionSpecForProviderScalableTargetAction(y)),
    'schedule': obj.schedule,
    'serviceNamespace': obj.serviceNamespace,
    'serviceNamespaceRef': toJson_ScheduledActionSpecForProviderServiceNamespaceRef(obj.serviceNamespaceRef),
    'serviceNamespaceSelector': toJson_ScheduledActionSpecForProviderServiceNamespaceSelector(obj.serviceNamespaceSelector),
    'startTime': obj.startTime,
    'timezone': obj.timezone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ScheduledActionSpecInitProvider
 */
export interface ScheduledActionSpecInitProvider {
  /**
   * Date and time for the scheduled action to end in RFC 3339 format. The timezone is not affected by the setting of timezone.
   *
   * @schema ScheduledActionSpecInitProvider#endTime
   */
  readonly endTime?: string;

  /**
   * Name of the scheduled action.
   *
   * @schema ScheduledActionSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * New minimum and maximum capacity. You can set both values or just one. See below
   *
   * @schema ScheduledActionSpecInitProvider#scalableTargetAction
   */
  readonly scalableTargetAction?: ScheduledActionSpecInitProviderScalableTargetAction[];

  /**
   * Schedule for this action. The following formats are supported: At expressions - at(yyyy-mm-ddThh:mm:ss), Rate expressions - rate(valueunit), Cron expressions - cron(fields). Times for at expressions and cron expressions are evaluated using the time zone configured in timezone. Documentation can be found in the Timezone parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema ScheduledActionSpecInitProvider#schedule
   */
  readonly schedule?: string;

  /**
   * Date and time for the scheduled action to start in RFC 3339 format. The timezone is not affected by the setting of timezone.
   *
   * @schema ScheduledActionSpecInitProvider#startTime
   */
  readonly startTime?: string;

  /**
   * Time zone used when setting a scheduled action by using an at or cron expression. Does not affect timezone for start_time and end_time. Valid values are the canonical names of the IANA time zones supported by Joda-Time, such as Etc/GMT+9 or Pacific/Tahiti. Default is UTC.
   *
   * @default UTC.
   * @schema ScheduledActionSpecInitProvider#timezone
   */
  readonly timezone?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecInitProvider(obj: ScheduledActionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'name': obj.name,
    'scalableTargetAction': obj.scalableTargetAction?.map(y => toJson_ScheduledActionSpecInitProviderScalableTargetAction(y)),
    'schedule': obj.schedule,
    'startTime': obj.startTime,
    'timezone': obj.timezone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ScheduledActionSpecManagementPolicies
 */
export enum ScheduledActionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScheduledActionSpecProviderConfigRef
 */
export interface ScheduledActionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecProviderConfigRef#policy
   */
  readonly policy?: ScheduledActionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderConfigRef(obj: ScheduledActionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsTo
 */
export interface ScheduledActionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScheduledActionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScheduledActionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsTo(obj: ScheduledActionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScheduledActionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScheduledActionSpecWriteConnectionSecretToRef
 */
export interface ScheduledActionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScheduledActionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScheduledActionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecWriteConnectionSecretToRef(obj: ScheduledActionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate resourceId.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRef
 */
export interface ScheduledActionSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRef#policy
   */
  readonly policy?: ScheduledActionSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdRef(obj: ScheduledActionSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate resourceId.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelector
 */
export interface ScheduledActionSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: ScheduledActionSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdSelector(obj: ScheduledActionSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduledActionSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate scalableDimension.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRef
 */
export interface ScheduledActionSpecForProviderScalableDimensionRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRef#policy
   */
  readonly policy?: ScheduledActionSpecForProviderScalableDimensionRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionRef(obj: ScheduledActionSpecForProviderScalableDimensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecForProviderScalableDimensionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate scalableDimension.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelector
 */
export interface ScheduledActionSpecForProviderScalableDimensionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelector#policy
   */
  readonly policy?: ScheduledActionSpecForProviderScalableDimensionSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionSelector(obj: ScheduledActionSpecForProviderScalableDimensionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduledActionSpecForProviderScalableDimensionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduledActionSpecForProviderScalableTargetAction
 */
export interface ScheduledActionSpecForProviderScalableTargetAction {
  /**
   * Maximum capacity. At least one of max_capacity or min_capacity must be set.
   *
   * @schema ScheduledActionSpecForProviderScalableTargetAction#maxCapacity
   */
  readonly maxCapacity?: string;

  /**
   * Minimum capacity. At least one of min_capacity or max_capacity must be set.
   *
   * @schema ScheduledActionSpecForProviderScalableTargetAction#minCapacity
   */
  readonly minCapacity?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableTargetAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableTargetAction(obj: ScheduledActionSpecForProviderScalableTargetAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRef
 */
export interface ScheduledActionSpecForProviderServiceNamespaceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRef#policy
   */
  readonly policy?: ScheduledActionSpecForProviderServiceNamespaceRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceRef(obj: ScheduledActionSpecForProviderServiceNamespaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecForProviderServiceNamespaceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelector
 */
export interface ScheduledActionSpecForProviderServiceNamespaceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelector#policy
   */
  readonly policy?: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceSelector(obj: ScheduledActionSpecForProviderServiceNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduledActionSpecInitProviderScalableTargetAction
 */
export interface ScheduledActionSpecInitProviderScalableTargetAction {
  /**
   * Maximum capacity. At least one of max_capacity or min_capacity must be set.
   *
   * @schema ScheduledActionSpecInitProviderScalableTargetAction#maxCapacity
   */
  readonly maxCapacity?: string;

  /**
   * Minimum capacity. At least one of min_capacity or max_capacity must be set.
   *
   * @schema ScheduledActionSpecInitProviderScalableTargetAction#minCapacity
   */
  readonly minCapacity?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecInitProviderScalableTargetAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecInitProviderScalableTargetAction(obj: ScheduledActionSpecInitProviderScalableTargetAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicy
 */
export interface ScheduledActionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderConfigRefPolicy(obj: ScheduledActionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef
 */
export interface ScheduledActionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRef(obj: ScheduledActionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata
 */
export interface ScheduledActionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToMetadata(obj: ScheduledActionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRefPolicy
 */
export interface ScheduledActionSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdRefPolicy(obj: ScheduledActionSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicy
 */
export interface ScheduledActionSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdSelectorPolicy(obj: ScheduledActionSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicy
 */
export interface ScheduledActionSpecForProviderScalableDimensionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderScalableDimensionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderScalableDimensionRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionRefPolicy(obj: ScheduledActionSpecForProviderScalableDimensionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicy
 */
export interface ScheduledActionSpecForProviderScalableDimensionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionSelectorPolicy(obj: ScheduledActionSpecForProviderScalableDimensionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicy
 */
export interface ScheduledActionSpecForProviderServiceNamespaceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceRefPolicy(obj: ScheduledActionSpecForProviderServiceNamespaceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy
 */
export interface ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy(obj: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicyResolution
 */
export enum ScheduledActionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicyResolve
 */
export enum ScheduledActionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRefPolicyResolution
 */
export enum ScheduledActionSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRefPolicyResolve
 */
export enum ScheduledActionSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum ScheduledActionSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum ScheduledActionSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicyResolution
 */
export enum ScheduledActionSpecForProviderScalableDimensionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicyResolve
 */
export enum ScheduledActionSpecForProviderScalableDimensionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolution
 */
export enum ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolve
 */
export enum ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolution
 */
export enum ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolve
 */
export enum ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolution
 */
export enum ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolve
 */
export enum ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Target is the Schema for the Targets API. Provides an Application AutoScaling ScalableTarget resource.
 *
 * @schema Target
 */
export class Target extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Target"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appautoscaling.aws.upbound.io/v1beta1',
    kind: 'Target',
  }

  /**
   * Renders a Kubernetes manifest for "Target".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TargetProps): any {
    return {
      ...Target.GVK,
      ...toJson_TargetProps(props),
    };
  }

  /**
   * Defines a "Target" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TargetProps) {
    super(scope, id, {
      ...Target.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Target.GVK,
      ...toJson_TargetProps(resolved),
    };
  }
}

/**
 * Target is the Schema for the Targets API. Provides an Application AutoScaling ScalableTarget resource.
 *
 * @schema Target
 */
export interface TargetProps {
  /**
   * @schema Target#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TargetSpec defines the desired state of Target
   *
   * @schema Target#spec
   */
  readonly spec: TargetSpec;

}

/**
 * Converts an object of type 'TargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetProps(obj: TargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetSpec defines the desired state of Target
 *
 * @schema TargetSpec
 */
export interface TargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: TargetSpecDeletionPolicy;

  /**
   * @schema TargetSpec#forProvider
   */
  readonly forProvider: TargetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TargetSpec#initProvider
   */
  readonly initProvider?: TargetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TargetSpec#managementPolicies
   */
  readonly managementPolicies?: TargetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: TargetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpec(obj: TargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TargetSpecForProvider(obj.forProvider),
    'initProvider': toJson_TargetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TargetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TargetSpecDeletionPolicy
 */
export enum TargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TargetSpecForProvider
 */
export interface TargetSpecForProvider {
  /**
   * Max capacity of the scalable target.
   *
   * @schema TargetSpecForProvider#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * Min capacity of the scalable target.
   *
   * @schema TargetSpecForProvider#minCapacity
   */
  readonly minCapacity?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * ARN of the IAM role that allows Application AutoScaling to modify your scalable target on your behalf. This defaults to an IAM Service-Linked Role for most services and custom IAM Roles are ignored by the API for those namespaces. See the AWS Application Auto Scaling documentation for more information about how this service interacts with IAM.
   *
   * @schema TargetSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema TargetSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: TargetSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema TargetSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: TargetSpecForProviderRoleArnSelector;

  /**
   * Scalable dimension of the scalable target. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecForProvider#scalableDimension
   */
  readonly scalableDimension?: string;

  /**
   * AWS service namespace of the scalable target. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecForProvider#serviceNamespace
   */
  readonly serviceNamespace?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TargetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProvider(obj: TargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_TargetSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_TargetSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'scalableDimension': obj.scalableDimension,
    'serviceNamespace': obj.serviceNamespace,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TargetSpecInitProvider
 */
export interface TargetSpecInitProvider {
  /**
   * Max capacity of the scalable target.
   *
   * @schema TargetSpecInitProvider#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * Min capacity of the scalable target.
   *
   * @schema TargetSpecInitProvider#minCapacity
   */
  readonly minCapacity?: number;

  /**
   * Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecInitProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Scalable dimension of the scalable target. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecInitProvider#scalableDimension
   */
  readonly scalableDimension?: string;

  /**
   * AWS service namespace of the scalable target. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecInitProvider#serviceNamespace
   */
  readonly serviceNamespace?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TargetSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TargetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecInitProvider(obj: TargetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
    'resourceId': obj.resourceId,
    'scalableDimension': obj.scalableDimension,
    'serviceNamespace': obj.serviceNamespace,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TargetSpecManagementPolicies
 */
export enum TargetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TargetSpecProviderConfigRef
 */
export interface TargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecProviderConfigRef#policy
   */
  readonly policy?: TargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRef(obj: TargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TargetSpecPublishConnectionDetailsTo
 */
export interface TargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsTo(obj: TargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TargetSpecWriteConnectionSecretToRef
 */
export interface TargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecWriteConnectionSecretToRef(obj: TargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema TargetSpecForProviderRoleArnRef
 */
export interface TargetSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderRoleArnRef#policy
   */
  readonly policy?: TargetSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnRef(obj: TargetSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema TargetSpecForProviderRoleArnSelector
 */
export interface TargetSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: TargetSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnSelector(obj: TargetSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecProviderConfigRefPolicy
 */
export interface TargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRefPolicy(obj: TargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRef
 */
export interface TargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj: TargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TargetSpecPublishConnectionDetailsToMetadata
 */
export interface TargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToMetadata(obj: TargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicy
 */
export interface TargetSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnRefPolicy(obj: TargetSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicy
 */
export interface TargetSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnSelectorPolicy(obj: TargetSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolution
 */
export enum TargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolve
 */
export enum TargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: TargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicyResolution
 */
export enum TargetSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicyResolve
 */
export enum TargetSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum TargetSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum TargetSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

