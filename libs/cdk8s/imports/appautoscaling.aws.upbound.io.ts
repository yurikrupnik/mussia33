// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Policy is the Schema for the Policys API. Provides an Application AutoScaling Policy resource.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appautoscaling.aws.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. Provides an Application AutoScaling Policy resource.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#managementPolicy
   */
  readonly managementPolicy?: PolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PolicySpec#providerRef
   */
  readonly providerRef?: PolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * Policy type. Valid values are StepScaling and TargetTrackingScaling. Defaults to StepScaling. Certain services only support only one policy type. For more information see the Target Tracking Scaling Policies and Step Scaling Policies documentation.
   *
   * @default StepScaling. Certain services only support only one policy type. For more information see the Target Tracking Scaling Policies and Step Scaling Policies documentation.
   * @schema PolicySpecForProvider#policyType
   */
  readonly policyType?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PolicySpecForProvider#region
   */
  readonly region: string;

  /**
   * Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema PolicySpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Target in appautoscaling to populate resourceId.
   *
   * @schema PolicySpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: PolicySpecForProviderResourceIdRef;

  /**
   * Selector for a Target in appautoscaling to populate resourceId.
   *
   * @schema PolicySpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: PolicySpecForProviderResourceIdSelector;

  /**
   * Scalable dimension of the scalable target. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema PolicySpecForProvider#scalableDimension
   */
  readonly scalableDimension?: string;

  /**
   * Reference to a Target in appautoscaling to populate scalableDimension.
   *
   * @schema PolicySpecForProvider#scalableDimensionRef
   */
  readonly scalableDimensionRef?: PolicySpecForProviderScalableDimensionRef;

  /**
   * Selector for a Target in appautoscaling to populate scalableDimension.
   *
   * @schema PolicySpecForProvider#scalableDimensionSelector
   */
  readonly scalableDimensionSelector?: PolicySpecForProviderScalableDimensionSelector;

  /**
   * AWS service namespace of the scalable target. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema PolicySpecForProvider#serviceNamespace
   */
  readonly serviceNamespace?: string;

  /**
   * Reference to a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema PolicySpecForProvider#serviceNamespaceRef
   */
  readonly serviceNamespaceRef?: PolicySpecForProviderServiceNamespaceRef;

  /**
   * Selector for a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema PolicySpecForProvider#serviceNamespaceSelector
   */
  readonly serviceNamespaceSelector?: PolicySpecForProviderServiceNamespaceSelector;

  /**
   * Step scaling policy configuration, requires policy_type = "StepScaling" (default). See supported fields below.
   *
   * @schema PolicySpecForProvider#stepScalingPolicyConfiguration
   */
  readonly stepScalingPolicyConfiguration?: PolicySpecForProviderStepScalingPolicyConfiguration[];

  /**
   * Target tracking policy, requires policy_type = "TargetTrackingScaling". See supported fields below.
   *
   * @schema PolicySpecForProvider#targetTrackingScalingPolicyConfiguration
   */
  readonly targetTrackingScalingPolicyConfiguration?: PolicySpecForProviderTargetTrackingScalingPolicyConfiguration[];

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policyType': obj.policyType,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_PolicySpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_PolicySpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'scalableDimension': obj.scalableDimension,
    'scalableDimensionRef': toJson_PolicySpecForProviderScalableDimensionRef(obj.scalableDimensionRef),
    'scalableDimensionSelector': toJson_PolicySpecForProviderScalableDimensionSelector(obj.scalableDimensionSelector),
    'serviceNamespace': obj.serviceNamespace,
    'serviceNamespaceRef': toJson_PolicySpecForProviderServiceNamespaceRef(obj.serviceNamespaceRef),
    'serviceNamespaceSelector': toJson_PolicySpecForProviderServiceNamespaceSelector(obj.serviceNamespaceSelector),
    'stepScalingPolicyConfiguration': obj.stepScalingPolicyConfiguration?.map(y => toJson_PolicySpecForProviderStepScalingPolicyConfiguration(y)),
    'targetTrackingScalingPolicyConfiguration': obj.targetTrackingScalingPolicyConfiguration?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecManagementPolicy
 */
export enum PolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PolicySpecProviderRef
 */
export interface PolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderRef#policy
   */
  readonly policy?: PolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRef(obj: PolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate resourceId.
 *
 * @schema PolicySpecForProviderResourceIdRef
 */
export interface PolicySpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderResourceIdRef#policy
   */
  readonly policy?: PolicySpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdRef(obj: PolicySpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate resourceId.
 *
 * @schema PolicySpecForProviderResourceIdSelector
 */
export interface PolicySpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderResourceIdSelector#policy
   */
  readonly policy?: PolicySpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdSelector(obj: PolicySpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate scalableDimension.
 *
 * @schema PolicySpecForProviderScalableDimensionRef
 */
export interface PolicySpecForProviderScalableDimensionRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderScalableDimensionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderScalableDimensionRef#policy
   */
  readonly policy?: PolicySpecForProviderScalableDimensionRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionRef(obj: PolicySpecForProviderScalableDimensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderScalableDimensionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate scalableDimension.
 *
 * @schema PolicySpecForProviderScalableDimensionSelector
 */
export interface PolicySpecForProviderScalableDimensionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderScalableDimensionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderScalableDimensionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderScalableDimensionSelector#policy
   */
  readonly policy?: PolicySpecForProviderScalableDimensionSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionSelector(obj: PolicySpecForProviderScalableDimensionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderScalableDimensionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema PolicySpecForProviderServiceNamespaceRef
 */
export interface PolicySpecForProviderServiceNamespaceRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecForProviderServiceNamespaceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecForProviderServiceNamespaceRef#policy
   */
  readonly policy?: PolicySpecForProviderServiceNamespaceRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceRef(obj: PolicySpecForProviderServiceNamespaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecForProviderServiceNamespaceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelector
 */
export interface PolicySpecForProviderServiceNamespaceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelector#policy
   */
  readonly policy?: PolicySpecForProviderServiceNamespaceSelectorPolicy;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceSelector(obj: PolicySpecForProviderServiceNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PolicySpecForProviderServiceNamespaceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderStepScalingPolicyConfiguration
 */
export interface PolicySpecForProviderStepScalingPolicyConfiguration {
  /**
   * Whether the adjustment is an absolute number or a percentage of the current capacity. Valid values are ChangeInCapacity, ExactCapacity, and PercentChangeInCapacity.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#adjustmentType
   */
  readonly adjustmentType?: string;

  /**
   * Amount of time, in seconds, after a scaling activity completes and before the next scaling activity can start.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#cooldown
   */
  readonly cooldown?: number;

  /**
   * Aggregation type for the policy's metrics. Valid values are "Minimum", "Maximum", and "Average". Without a value, AWS will treat the aggregation type as "Average".
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#metricAggregationType
   */
  readonly metricAggregationType?: string;

  /**
   * Minimum number to adjust your scalable dimension as a result of a scaling activity. If the adjustment type is PercentChangeInCapacity, the scaling policy changes the scalable dimension of the scalable target by this amount.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#minAdjustmentMagnitude
   */
  readonly minAdjustmentMagnitude?: number;

  /**
   * Set of adjustments that manage scaling. These have the following structure:
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfiguration#stepAdjustment
   */
  readonly stepAdjustment?: PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment[];

}

/**
 * Converts an object of type 'PolicySpecForProviderStepScalingPolicyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderStepScalingPolicyConfiguration(obj: PolicySpecForProviderStepScalingPolicyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'adjustmentType': obj.adjustmentType,
    'cooldown': obj.cooldown,
    'metricAggregationType': obj.metricAggregationType,
    'minAdjustmentMagnitude': obj.minAdjustmentMagnitude,
    'stepAdjustment': obj.stepAdjustment?.map(y => toJson_PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfiguration {
  /**
   * Custom CloudWatch metric. Documentation can be found  at: AWS Customized Metric Specification. See supported fields below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#customizedMetricSpecification
   */
  readonly customizedMetricSpecification?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification[];

  /**
   * Whether scale in by the target tracking policy is disabled. If the value is true, scale in is disabled and the target tracking policy won't remove capacity from the scalable resource. Otherwise, scale in is enabled and the target tracking policy can remove capacity from the scalable resource. The default value is false.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#disableScaleIn
   */
  readonly disableScaleIn?: boolean;

  /**
   * Predefined metric. See supported fields below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#predefinedMetricSpecification
   */
  readonly predefinedMetricSpecification?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification[];

  /**
   * Amount of time, in seconds, after a scale in activity completes before another scale in activity can start.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#scaleInCooldown
   */
  readonly scaleInCooldown?: number;

  /**
   * Amount of time, in seconds, after a scale out activity completes before another scale out activity can start.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#scaleOutCooldown
   */
  readonly scaleOutCooldown?: number;

  /**
   * Target value for the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfiguration#targetValue
   */
  readonly targetValue: number;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfiguration(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customizedMetricSpecification': obj.customizedMetricSpecification?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification(y)),
    'disableScaleIn': obj.disableScaleIn,
    'predefinedMetricSpecification': obj.predefinedMetricSpecification?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification(y)),
    'scaleInCooldown': obj.scaleInCooldown,
    'scaleOutCooldown': obj.scaleOutCooldown,
    'targetValue': obj.targetValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderRefPolicy
 */
export interface PolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderRefPolicy(obj: PolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderResourceIdRefPolicy
 */
export interface PolicySpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdRefPolicy(obj: PolicySpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderResourceIdSelectorPolicy
 */
export interface PolicySpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderResourceIdSelectorPolicy(obj: PolicySpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderScalableDimensionRefPolicy
 */
export interface PolicySpecForProviderScalableDimensionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderScalableDimensionRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderScalableDimensionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderScalableDimensionRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderScalableDimensionRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionRefPolicy(obj: PolicySpecForProviderScalableDimensionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderScalableDimensionSelectorPolicy
 */
export interface PolicySpecForProviderScalableDimensionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderScalableDimensionSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderScalableDimensionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderScalableDimensionSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderScalableDimensionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderScalableDimensionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderScalableDimensionSelectorPolicy(obj: PolicySpecForProviderScalableDimensionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecForProviderServiceNamespaceRefPolicy
 */
export interface PolicySpecForProviderServiceNamespaceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderServiceNamespaceRefPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderServiceNamespaceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderServiceNamespaceRefPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderServiceNamespaceRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceRefPolicy(obj: PolicySpecForProviderServiceNamespaceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelectorPolicy
 */
export interface PolicySpecForProviderServiceNamespaceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelectorPolicy#resolution
   */
  readonly resolution?: PolicySpecForProviderServiceNamespaceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecForProviderServiceNamespaceSelectorPolicy#resolve
   */
  readonly resolve?: PolicySpecForProviderServiceNamespaceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecForProviderServiceNamespaceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderServiceNamespaceSelectorPolicy(obj: PolicySpecForProviderServiceNamespaceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment
 */
export interface PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment {
  /**
   * Lower bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as negative infinity.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment#metricIntervalLowerBound
   */
  readonly metricIntervalLowerBound?: string;

  /**
   * Upper bound for the difference between the alarm threshold and the CloudWatch metric. Without a value, AWS will treat this bound as infinity. The upper bound must be greater than the lower bound.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment#metricIntervalUpperBound
   */
  readonly metricIntervalUpperBound?: string;

  /**
   * Number of members by which to scale, when the adjustment bounds are breached. A positive value scales up. A negative value scales down.
   *
   * @schema PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment#scalingAdjustment
   */
  readonly scalingAdjustment: number;

}

/**
 * Converts an object of type 'PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment(obj: PolicySpecForProviderStepScalingPolicyConfigurationStepAdjustment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricIntervalLowerBound': obj.metricIntervalLowerBound,
    'metricIntervalUpperBound': obj.metricIntervalUpperBound,
    'scalingAdjustment': obj.scalingAdjustment,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification {
  /**
   * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#dimensions
   */
  readonly dimensions?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#metricName
   */
  readonly metricName?: string;

  /**
   * Metrics to include, as a metric data query.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#metrics
   */
  readonly metrics?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics[];

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#namespace
   */
  readonly namespace?: string;

  /**
   * Statistic of the metric. Valid values: Average, Minimum, Maximum, SampleCount, and Sum.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#statistic
   */
  readonly statistic?: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions(y)),
    'metricName': obj.metricName,
    'metrics': obj.metrics?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics(y)),
    'namespace': obj.namespace,
    'statistic': obj.statistic,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification {
  /**
   * Metric type.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification#predefinedMetricType
   */
  readonly predefinedMetricType: string;

  /**
   * Reserved for future use if the predefined_metric_type is not ALBRequestCountPerTarget. If the predefined_metric_type is ALBRequestCountPerTarget, you must specify this argument. Documentation can be found at: AWS Predefined Scaling Metric Specification. Must be less than or equal to 1023 characters in length.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification#resourceLabel
   */
  readonly resourceLabel?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'predefinedMetricType': obj.predefinedMetricType,
    'resourceLabel': obj.resourceLabel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderRefPolicyResolution
 */
export enum PolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderRefPolicyResolve
 */
export enum PolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderResourceIdRefPolicyResolution
 */
export enum PolicySpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderResourceIdRefPolicyResolve
 */
export enum PolicySpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderResourceIdSelectorPolicyResolution
 */
export enum PolicySpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderResourceIdSelectorPolicyResolve
 */
export enum PolicySpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderScalableDimensionRefPolicyResolution
 */
export enum PolicySpecForProviderScalableDimensionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderScalableDimensionRefPolicyResolve
 */
export enum PolicySpecForProviderScalableDimensionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderScalableDimensionSelectorPolicyResolution
 */
export enum PolicySpecForProviderScalableDimensionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderScalableDimensionSelectorPolicyResolve
 */
export enum PolicySpecForProviderScalableDimensionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderServiceNamespaceRefPolicyResolution
 */
export enum PolicySpecForProviderServiceNamespaceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderServiceNamespaceRefPolicyResolve
 */
export enum PolicySpecForProviderServiceNamespaceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelectorPolicyResolution
 */
export enum PolicySpecForProviderServiceNamespaceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecForProviderServiceNamespaceSelectorPolicyResolve
 */
export enum PolicySpecForProviderServiceNamespaceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions {
  /**
   * Name of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions#name
   */
  readonly name: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics {
  /**
   * Math expression used on the returned metric. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#expression
   */
  readonly expression?: string;

  /**
   * Short name for the metric used in target tracking scaling policy.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#id
   */
  readonly id: string;

  /**
   * Human-readable label for this metric or expression.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#label
   */
  readonly label?: string;

  /**
   * Structure that defines CloudWatch metric to be used in target tracking scaling policy. You must specify either expression or metric_stat, but not both.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#metricStat
   */
  readonly metricStat?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat[];

  /**
   * Boolean that indicates whether to return the timestamps and raw data values of this metric, the default is true
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics#returnData
   */
  readonly returnData?: boolean;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'id': obj.id,
    'label': obj.label,
    'metricStat': obj.metricStat?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat(y)),
    'returnData': obj.returnData,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat {
  /**
   * Structure that defines the CloudWatch metric to return, including the metric name, namespace, and dimensions.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#metric
   */
  readonly metric: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric[];

  /**
   * Statistic of the metrics to return.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#stat
   */
  readonly stat: string;

  /**
   * Unit of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat#unit
   */
  readonly unit?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStat | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metric': obj.metric?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(y)),
    'stat': obj.stat,
    'unit': obj.unit,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric {
  /**
   * Configuration block(s) with the dimensions of the metric if the metric was published with dimensions. Detailed below.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#dimensions
   */
  readonly dimensions?: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions[];

  /**
   * Name of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#metricName
   */
  readonly metricName: string;

  /**
   * Namespace of the metric.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensions': obj.dimensions?.map(y => toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(y)),
    'metricName': obj.metricName,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions
 */
export interface PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions {
  /**
   * Name of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#name
   */
  readonly name: string;

  /**
   * Value of the dimension.
   *
   * @schema PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions(obj: PolicySpecForProviderTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecificationMetricsMetricStatMetricDimensions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ScheduledAction is the Schema for the ScheduledActions API. Provides an Application AutoScaling ScheduledAction resource.
 *
 * @schema ScheduledAction
 */
export class ScheduledAction extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ScheduledAction"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appautoscaling.aws.upbound.io/v1beta1',
    kind: 'ScheduledAction',
  }

  /**
   * Renders a Kubernetes manifest for "ScheduledAction".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ScheduledActionProps): any {
    return {
      ...ScheduledAction.GVK,
      ...toJson_ScheduledActionProps(props),
    };
  }

  /**
   * Defines a "ScheduledAction" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ScheduledActionProps) {
    super(scope, id, {
      ...ScheduledAction.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ScheduledAction.GVK,
      ...toJson_ScheduledActionProps(resolved),
    };
  }
}

/**
 * ScheduledAction is the Schema for the ScheduledActions API. Provides an Application AutoScaling ScheduledAction resource.
 *
 * @schema ScheduledAction
 */
export interface ScheduledActionProps {
  /**
   * @schema ScheduledAction#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ScheduledActionSpec defines the desired state of ScheduledAction
   *
   * @schema ScheduledAction#spec
   */
  readonly spec: ScheduledActionSpec;

}

/**
 * Converts an object of type 'ScheduledActionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionProps(obj: ScheduledActionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ScheduledActionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ScheduledActionSpec defines the desired state of ScheduledAction
 *
 * @schema ScheduledActionSpec
 */
export interface ScheduledActionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduledActionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ScheduledActionSpecDeletionPolicy;

  /**
   * @schema ScheduledActionSpec#forProvider
   */
  readonly forProvider: ScheduledActionSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ScheduledActionSpec#managementPolicy
   */
  readonly managementPolicy?: ScheduledActionSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ScheduledActionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ScheduledActionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ScheduledActionSpec#providerRef
   */
  readonly providerRef?: ScheduledActionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ScheduledActionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ScheduledActionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ScheduledActionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ScheduledActionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ScheduledActionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpec(obj: ScheduledActionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ScheduledActionSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ScheduledActionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ScheduledActionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ScheduledActionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ScheduledActionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduledActionSpecDeletionPolicy
 */
export enum ScheduledActionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ScheduledActionSpecForProvider
 */
export interface ScheduledActionSpecForProvider {
  /**
   * Date and time for the scheduled action to end in RFC 3339 format. The timezone is not affected by the setting of timezone.
   *
   * @schema ScheduledActionSpecForProvider#endTime
   */
  readonly endTime?: string;

  /**
   * Name of the scheduled action.
   *
   * @schema ScheduledActionSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ScheduledActionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Identifier of the resource associated with the scheduled action. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema ScheduledActionSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a Target in appautoscaling to populate resourceId.
   *
   * @schema ScheduledActionSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: ScheduledActionSpecForProviderResourceIdRef;

  /**
   * Selector for a Target in appautoscaling to populate resourceId.
   *
   * @schema ScheduledActionSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: ScheduledActionSpecForProviderResourceIdSelector;

  /**
   * Scalable dimension. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference Example: ecs:service:DesiredCount
   *
   * @schema ScheduledActionSpecForProvider#scalableDimension
   */
  readonly scalableDimension?: string;

  /**
   * Reference to a Target in appautoscaling to populate scalableDimension.
   *
   * @schema ScheduledActionSpecForProvider#scalableDimensionRef
   */
  readonly scalableDimensionRef?: ScheduledActionSpecForProviderScalableDimensionRef;

  /**
   * Selector for a Target in appautoscaling to populate scalableDimension.
   *
   * @schema ScheduledActionSpecForProvider#scalableDimensionSelector
   */
  readonly scalableDimensionSelector?: ScheduledActionSpecForProviderScalableDimensionSelector;

  /**
   * New minimum and maximum capacity. You can set both values or just one. See below
   *
   * @schema ScheduledActionSpecForProvider#scalableTargetAction
   */
  readonly scalableTargetAction?: ScheduledActionSpecForProviderScalableTargetAction[];

  /**
   * Schedule for this action. The following formats are supported: At expressions - at(yyyy-mm-ddThh:mm:ss), Rate expressions - rate(valueunit), Cron expressions - cron(fields). Times for at expressions and cron expressions are evaluated using the time zone configured in timezone. Documentation can be found in the Timezone parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema ScheduledActionSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * Namespace of the AWS service. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference Example: ecs
   *
   * @schema ScheduledActionSpecForProvider#serviceNamespace
   */
  readonly serviceNamespace?: string;

  /**
   * Reference to a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema ScheduledActionSpecForProvider#serviceNamespaceRef
   */
  readonly serviceNamespaceRef?: ScheduledActionSpecForProviderServiceNamespaceRef;

  /**
   * Selector for a Target in appautoscaling to populate serviceNamespace.
   *
   * @schema ScheduledActionSpecForProvider#serviceNamespaceSelector
   */
  readonly serviceNamespaceSelector?: ScheduledActionSpecForProviderServiceNamespaceSelector;

  /**
   * Date and time for the scheduled action to start in RFC 3339 format. The timezone is not affected by the setting of timezone.
   *
   * @schema ScheduledActionSpecForProvider#startTime
   */
  readonly startTime?: string;

  /**
   * Time zone used when setting a scheduled action by using an at or cron expression. Does not affect timezone for start_time and end_time. Valid values are the canonical names of the IANA time zones supported by Joda-Time, such as Etc/GMT+9 or Pacific/Tahiti. Default is UTC.
   *
   * @default UTC.
   * @schema ScheduledActionSpecForProvider#timezone
   */
  readonly timezone?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProvider(obj: ScheduledActionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endTime': obj.endTime,
    'name': obj.name,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_ScheduledActionSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_ScheduledActionSpecForProviderResourceIdSelector(obj.resourceIdSelector),
    'scalableDimension': obj.scalableDimension,
    'scalableDimensionRef': toJson_ScheduledActionSpecForProviderScalableDimensionRef(obj.scalableDimensionRef),
    'scalableDimensionSelector': toJson_ScheduledActionSpecForProviderScalableDimensionSelector(obj.scalableDimensionSelector),
    'scalableTargetAction': obj.scalableTargetAction?.map(y => toJson_ScheduledActionSpecForProviderScalableTargetAction(y)),
    'schedule': obj.schedule,
    'serviceNamespace': obj.serviceNamespace,
    'serviceNamespaceRef': toJson_ScheduledActionSpecForProviderServiceNamespaceRef(obj.serviceNamespaceRef),
    'serviceNamespaceSelector': toJson_ScheduledActionSpecForProviderServiceNamespaceSelector(obj.serviceNamespaceSelector),
    'startTime': obj.startTime,
    'timezone': obj.timezone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ScheduledActionSpecManagementPolicy
 */
export enum ScheduledActionSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ScheduledActionSpecProviderConfigRef
 */
export interface ScheduledActionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecProviderConfigRef#policy
   */
  readonly policy?: ScheduledActionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderConfigRef(obj: ScheduledActionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ScheduledActionSpecProviderRef
 */
export interface ScheduledActionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecProviderRef#policy
   */
  readonly policy?: ScheduledActionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderRef(obj: ScheduledActionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsTo
 */
export interface ScheduledActionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ScheduledActionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ScheduledActionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsTo(obj: ScheduledActionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ScheduledActionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ScheduledActionSpecWriteConnectionSecretToRef
 */
export interface ScheduledActionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ScheduledActionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ScheduledActionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecWriteConnectionSecretToRef(obj: ScheduledActionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate resourceId.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRef
 */
export interface ScheduledActionSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRef#policy
   */
  readonly policy?: ScheduledActionSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdRef(obj: ScheduledActionSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate resourceId.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelector
 */
export interface ScheduledActionSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: ScheduledActionSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdSelector(obj: ScheduledActionSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduledActionSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate scalableDimension.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRef
 */
export interface ScheduledActionSpecForProviderScalableDimensionRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRef#policy
   */
  readonly policy?: ScheduledActionSpecForProviderScalableDimensionRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionRef(obj: ScheduledActionSpecForProviderScalableDimensionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecForProviderScalableDimensionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate scalableDimension.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelector
 */
export interface ScheduledActionSpecForProviderScalableDimensionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelector#policy
   */
  readonly policy?: ScheduledActionSpecForProviderScalableDimensionSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionSelector(obj: ScheduledActionSpecForProviderScalableDimensionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduledActionSpecForProviderScalableDimensionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ScheduledActionSpecForProviderScalableTargetAction
 */
export interface ScheduledActionSpecForProviderScalableTargetAction {
  /**
   * Maximum capacity. At least one of max_capacity or min_capacity must be set.
   *
   * @schema ScheduledActionSpecForProviderScalableTargetAction#maxCapacity
   */
  readonly maxCapacity?: string;

  /**
   * Minimum capacity. At least one of min_capacity or max_capacity must be set.
   *
   * @schema ScheduledActionSpecForProviderScalableTargetAction#minCapacity
   */
  readonly minCapacity?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableTargetAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableTargetAction(obj: ScheduledActionSpecForProviderScalableTargetAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRef
 */
export interface ScheduledActionSpecForProviderServiceNamespaceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRef#policy
   */
  readonly policy?: ScheduledActionSpecForProviderServiceNamespaceRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceRef(obj: ScheduledActionSpecForProviderServiceNamespaceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecForProviderServiceNamespaceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Target in appautoscaling to populate serviceNamespace.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelector
 */
export interface ScheduledActionSpecForProviderServiceNamespaceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelector#policy
   */
  readonly policy?: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceSelector(obj: ScheduledActionSpecForProviderServiceNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicy
 */
export interface ScheduledActionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderConfigRefPolicy(obj: ScheduledActionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecProviderRefPolicy
 */
export interface ScheduledActionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecProviderRefPolicy(obj: ScheduledActionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef
 */
export interface ScheduledActionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRef(obj: ScheduledActionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata
 */
export interface ScheduledActionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToMetadata(obj: ScheduledActionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRefPolicy
 */
export interface ScheduledActionSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdRefPolicy(obj: ScheduledActionSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicy
 */
export interface ScheduledActionSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderResourceIdSelectorPolicy(obj: ScheduledActionSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicy
 */
export interface ScheduledActionSpecForProviderScalableDimensionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderScalableDimensionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderScalableDimensionRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionRefPolicy(obj: ScheduledActionSpecForProviderScalableDimensionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicy
 */
export interface ScheduledActionSpecForProviderScalableDimensionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderScalableDimensionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderScalableDimensionSelectorPolicy(obj: ScheduledActionSpecForProviderScalableDimensionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicy
 */
export interface ScheduledActionSpecForProviderServiceNamespaceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceRefPolicy(obj: ScheduledActionSpecForProviderServiceNamespaceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy
 */
export interface ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy(obj: ScheduledActionSpecForProviderServiceNamespaceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicyResolution
 */
export enum ScheduledActionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecProviderConfigRefPolicyResolve
 */
export enum ScheduledActionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecProviderRefPolicyResolution
 */
export enum ScheduledActionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecProviderRefPolicyResolve
 */
export enum ScheduledActionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRefPolicyResolution
 */
export enum ScheduledActionSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderResourceIdRefPolicyResolve
 */
export enum ScheduledActionSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum ScheduledActionSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum ScheduledActionSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicyResolution
 */
export enum ScheduledActionSpecForProviderScalableDimensionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionRefPolicyResolve
 */
export enum ScheduledActionSpecForProviderScalableDimensionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolution
 */
export enum ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolve
 */
export enum ScheduledActionSpecForProviderScalableDimensionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolution
 */
export enum ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolve
 */
export enum ScheduledActionSpecForProviderServiceNamespaceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolution
 */
export enum ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolve
 */
export enum ScheduledActionSpecForProviderServiceNamespaceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ScheduledActionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Target is the Schema for the Targets API. Provides an Application AutoScaling ScalableTarget resource.
 *
 * @schema Target
 */
export class Target extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Target"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appautoscaling.aws.upbound.io/v1beta1',
    kind: 'Target',
  }

  /**
   * Renders a Kubernetes manifest for "Target".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TargetProps): any {
    return {
      ...Target.GVK,
      ...toJson_TargetProps(props),
    };
  }

  /**
   * Defines a "Target" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TargetProps) {
    super(scope, id, {
      ...Target.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Target.GVK,
      ...toJson_TargetProps(resolved),
    };
  }
}

/**
 * Target is the Schema for the Targets API. Provides an Application AutoScaling ScalableTarget resource.
 *
 * @schema Target
 */
export interface TargetProps {
  /**
   * @schema Target#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TargetSpec defines the desired state of Target
   *
   * @schema Target#spec
   */
  readonly spec: TargetSpec;

}

/**
 * Converts an object of type 'TargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetProps(obj: TargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TargetSpec defines the desired state of Target
 *
 * @schema TargetSpec
 */
export interface TargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: TargetSpecDeletionPolicy;

  /**
   * @schema TargetSpec#forProvider
   */
  readonly forProvider: TargetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TargetSpec#managementPolicy
   */
  readonly managementPolicy?: TargetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: TargetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TargetSpec#providerRef
   */
  readonly providerRef?: TargetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpec(obj: TargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TargetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TargetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TargetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TargetSpecDeletionPolicy
 */
export enum TargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TargetSpecForProvider
 */
export interface TargetSpecForProvider {
  /**
   * Max capacity of the scalable target.
   *
   * @schema TargetSpecForProvider#maxCapacity
   */
  readonly maxCapacity?: number;

  /**
   * Min capacity of the scalable target.
   *
   * @schema TargetSpecForProvider#minCapacity
   */
  readonly minCapacity?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Resource type and unique identifier string for the resource associated with the scaling policy. Documentation can be found in the ResourceId parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecForProvider#resourceId
   */
  readonly resourceId: string;

  /**
   * ARN of the IAM role that allows Application AutoScaling to modify your scalable target on your behalf. This defaults to an IAM Service-Linked Role for most services and custom IAM Roles are ignored by the API for those namespaces. See the AWS Application Auto Scaling documentation for more information about how this service interacts with IAM.
   *
   * @schema TargetSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema TargetSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: TargetSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema TargetSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: TargetSpecForProviderRoleArnSelector;

  /**
   * Scalable dimension of the scalable target. Documentation can be found in the ScalableDimension parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecForProvider#scalableDimension
   */
  readonly scalableDimension: string;

  /**
   * AWS service namespace of the scalable target. Documentation can be found in the ServiceNamespace parameter at: AWS Application Auto Scaling API Reference
   *
   * @schema TargetSpecForProvider#serviceNamespace
   */
  readonly serviceNamespace: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema TargetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'TargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProvider(obj: TargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxCapacity': obj.maxCapacity,
    'minCapacity': obj.minCapacity,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_TargetSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_TargetSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'scalableDimension': obj.scalableDimension,
    'serviceNamespace': obj.serviceNamespace,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TargetSpecManagementPolicy
 */
export enum TargetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TargetSpecProviderConfigRef
 */
export interface TargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecProviderConfigRef#policy
   */
  readonly policy?: TargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRef(obj: TargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TargetSpecProviderRef
 */
export interface TargetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecProviderRef#policy
   */
  readonly policy?: TargetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderRef(obj: TargetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TargetSpecPublishConnectionDetailsTo
 */
export interface TargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsTo(obj: TargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TargetSpecWriteConnectionSecretToRef
 */
export interface TargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecWriteConnectionSecretToRef(obj: TargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema TargetSpecForProviderRoleArnRef
 */
export interface TargetSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecForProviderRoleArnRef#policy
   */
  readonly policy?: TargetSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnRef(obj: TargetSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema TargetSpecForProviderRoleArnSelector
 */
export interface TargetSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TargetSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TargetSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TargetSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: TargetSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnSelector(obj: TargetSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TargetSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecProviderConfigRefPolicy
 */
export interface TargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderConfigRefPolicy(obj: TargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecProviderRefPolicy
 */
export interface TargetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TargetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TargetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecProviderRefPolicy(obj: TargetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRef
 */
export interface TargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRef(obj: TargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TargetSpecPublishConnectionDetailsToMetadata
 */
export interface TargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToMetadata(obj: TargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicy
 */
export interface TargetSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnRefPolicy(obj: TargetSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicy
 */
export interface TargetSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TargetSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TargetSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecForProviderRoleArnSelectorPolicy(obj: TargetSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolution
 */
export enum TargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecProviderConfigRefPolicyResolve
 */
export enum TargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecProviderRefPolicyResolution
 */
export enum TargetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecProviderRefPolicyResolve
 */
export enum TargetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: TargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicyResolution
 */
export enum TargetSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRoleArnRefPolicyResolve
 */
export enum TargetSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum TargetSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum TargetSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

