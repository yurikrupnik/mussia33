// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ByteMatchSet is the Schema for the ByteMatchSets API. Provides a AWS WAF Regional ByteMatchSet resource for use with ALB.
 *
 * @schema ByteMatchSet
 */
export class ByteMatchSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ByteMatchSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'ByteMatchSet',
  }

  /**
   * Renders a Kubernetes manifest for "ByteMatchSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ByteMatchSetProps): any {
    return {
      ...ByteMatchSet.GVK,
      ...toJson_ByteMatchSetProps(props),
    };
  }

  /**
   * Defines a "ByteMatchSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ByteMatchSetProps) {
    super(scope, id, {
      ...ByteMatchSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ByteMatchSet.GVK,
      ...toJson_ByteMatchSetProps(resolved),
    };
  }
}

/**
 * ByteMatchSet is the Schema for the ByteMatchSets API. Provides a AWS WAF Regional ByteMatchSet resource for use with ALB.
 *
 * @schema ByteMatchSet
 */
export interface ByteMatchSetProps {
  /**
   * @schema ByteMatchSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ByteMatchSetSpec defines the desired state of ByteMatchSet
   *
   * @schema ByteMatchSet#spec
   */
  readonly spec: ByteMatchSetSpec;

}

/**
 * Converts an object of type 'ByteMatchSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetProps(obj: ByteMatchSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ByteMatchSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ByteMatchSetSpec defines the desired state of ByteMatchSet
 *
 * @schema ByteMatchSetSpec
 */
export interface ByteMatchSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ByteMatchSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ByteMatchSetSpecDeletionPolicy;

  /**
   * @schema ByteMatchSetSpec#forProvider
   */
  readonly forProvider: ByteMatchSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ByteMatchSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ByteMatchSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ByteMatchSetSpec#providerRef
   */
  readonly providerRef?: ByteMatchSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ByteMatchSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ByteMatchSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ByteMatchSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ByteMatchSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ByteMatchSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpec(obj: ByteMatchSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ByteMatchSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ByteMatchSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ByteMatchSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ByteMatchSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ByteMatchSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ByteMatchSetSpecDeletionPolicy
 */
export enum ByteMatchSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ByteMatchSetSpecForProvider
 */
export interface ByteMatchSetSpecForProvider {
  /**
   * Settings for the ByteMatchSet, such as the bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests. ByteMatchTuple documented below.
   *
   * @schema ByteMatchSetSpecForProvider#byteMatchTuples
   */
  readonly byteMatchTuples?: ByteMatchSetSpecForProviderByteMatchTuples[];

  /**
   * The name or description of the ByteMatchSet.
   *
   * @schema ByteMatchSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ByteMatchSetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ByteMatchSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecForProvider(obj: ByteMatchSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'byteMatchTuples': obj.byteMatchTuples?.map(y => toJson_ByteMatchSetSpecForProviderByteMatchTuples(y)),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ByteMatchSetSpecProviderConfigRef
 */
export interface ByteMatchSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ByteMatchSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ByteMatchSetSpecProviderConfigRef#policy
   */
  readonly policy?: ByteMatchSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ByteMatchSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecProviderConfigRef(obj: ByteMatchSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ByteMatchSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ByteMatchSetSpecProviderRef
 */
export interface ByteMatchSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ByteMatchSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ByteMatchSetSpecProviderRef#policy
   */
  readonly policy?: ByteMatchSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ByteMatchSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecProviderRef(obj: ByteMatchSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ByteMatchSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ByteMatchSetSpecPublishConnectionDetailsTo
 */
export interface ByteMatchSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ByteMatchSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ByteMatchSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ByteMatchSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecPublishConnectionDetailsTo(obj: ByteMatchSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ByteMatchSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ByteMatchSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ByteMatchSetSpecWriteConnectionSecretToRef
 */
export interface ByteMatchSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ByteMatchSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ByteMatchSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ByteMatchSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecWriteConnectionSecretToRef(obj: ByteMatchSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ByteMatchSetSpecForProviderByteMatchTuples
 */
export interface ByteMatchSetSpecForProviderByteMatchTuples {
  /**
   * Settings for the ByteMatchTuple. FieldToMatch documented below.
   *
   * @schema ByteMatchSetSpecForProviderByteMatchTuples#fieldToMatch
   */
  readonly fieldToMatch: ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch[];

  /**
   * Within the portion of a web request that you want to search.
   *
   * @schema ByteMatchSetSpecForProviderByteMatchTuples#positionalConstraint
   */
  readonly positionalConstraint: string;

  /**
   * The value that you want AWS WAF to search for. The maximum length of the value is 50 bytes.
   *
   * @schema ByteMatchSetSpecForProviderByteMatchTuples#targetString
   */
  readonly targetString?: string;

  /**
   * The formatting way for web request.
   *
   * @schema ByteMatchSetSpecForProviderByteMatchTuples#textTransformation
   */
  readonly textTransformation: string;

}

/**
 * Converts an object of type 'ByteMatchSetSpecForProviderByteMatchTuples' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecForProviderByteMatchTuples(obj: ByteMatchSetSpecForProviderByteMatchTuples | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldToMatch': obj.fieldToMatch?.map(y => toJson_ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch(y)),
    'positionalConstraint': obj.positionalConstraint,
    'targetString': obj.targetString,
    'textTransformation': obj.textTransformation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ByteMatchSetSpecProviderConfigRefPolicy
 */
export interface ByteMatchSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ByteMatchSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ByteMatchSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ByteMatchSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ByteMatchSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ByteMatchSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecProviderConfigRefPolicy(obj: ByteMatchSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ByteMatchSetSpecProviderRefPolicy
 */
export interface ByteMatchSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ByteMatchSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ByteMatchSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ByteMatchSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ByteMatchSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ByteMatchSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecProviderRefPolicy(obj: ByteMatchSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRef
 */
export interface ByteMatchSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ByteMatchSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecPublishConnectionDetailsToConfigRef(obj: ByteMatchSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ByteMatchSetSpecPublishConnectionDetailsToMetadata
 */
export interface ByteMatchSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ByteMatchSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecPublishConnectionDetailsToMetadata(obj: ByteMatchSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch
 */
export interface ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch {
  /**
   * When the value of Type is HEADER, enter the name of the header that you want AWS WAF to search, for example, User-Agent or Referer. If the value of Type is any other value, omit Data.
   *
   * @schema ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch#data
   */
  readonly data?: string;

  /**
   * The part of the web request that you want AWS WAF to search for a specified string.
   *
   * @schema ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch(obj: ByteMatchSetSpecForProviderByteMatchTuplesFieldToMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ByteMatchSetSpecProviderConfigRefPolicyResolution
 */
export enum ByteMatchSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ByteMatchSetSpecProviderConfigRefPolicyResolve
 */
export enum ByteMatchSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ByteMatchSetSpecProviderRefPolicyResolution
 */
export enum ByteMatchSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ByteMatchSetSpecProviderRefPolicyResolve
 */
export enum ByteMatchSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ByteMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GeoMatchSet is the Schema for the GeoMatchSets API. Provides a AWS WAF Regional Geo Match Set resource.
 *
 * @schema GeoMatchSet
 */
export class GeoMatchSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GeoMatchSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'GeoMatchSet',
  }

  /**
   * Renders a Kubernetes manifest for "GeoMatchSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GeoMatchSetProps): any {
    return {
      ...GeoMatchSet.GVK,
      ...toJson_GeoMatchSetProps(props),
    };
  }

  /**
   * Defines a "GeoMatchSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GeoMatchSetProps) {
    super(scope, id, {
      ...GeoMatchSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GeoMatchSet.GVK,
      ...toJson_GeoMatchSetProps(resolved),
    };
  }
}

/**
 * GeoMatchSet is the Schema for the GeoMatchSets API. Provides a AWS WAF Regional Geo Match Set resource.
 *
 * @schema GeoMatchSet
 */
export interface GeoMatchSetProps {
  /**
   * @schema GeoMatchSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GeoMatchSetSpec defines the desired state of GeoMatchSet
   *
   * @schema GeoMatchSet#spec
   */
  readonly spec: GeoMatchSetSpec;

}

/**
 * Converts an object of type 'GeoMatchSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetProps(obj: GeoMatchSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GeoMatchSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GeoMatchSetSpec defines the desired state of GeoMatchSet
 *
 * @schema GeoMatchSetSpec
 */
export interface GeoMatchSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema GeoMatchSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: GeoMatchSetSpecDeletionPolicy;

  /**
   * @schema GeoMatchSetSpec#forProvider
   */
  readonly forProvider: GeoMatchSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GeoMatchSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: GeoMatchSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GeoMatchSetSpec#providerRef
   */
  readonly providerRef?: GeoMatchSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GeoMatchSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GeoMatchSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GeoMatchSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GeoMatchSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GeoMatchSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpec(obj: GeoMatchSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GeoMatchSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_GeoMatchSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GeoMatchSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GeoMatchSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GeoMatchSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema GeoMatchSetSpecDeletionPolicy
 */
export enum GeoMatchSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GeoMatchSetSpecForProvider
 */
export interface GeoMatchSetSpecForProvider {
  /**
   * The Geo Match Constraint objects which contain the country that you want AWS WAF to search for.
   *
   * @schema GeoMatchSetSpecForProvider#geoMatchConstraint
   */
  readonly geoMatchConstraint?: GeoMatchSetSpecForProviderGeoMatchConstraint[];

  /**
   * The name or description of the Geo Match Set.
   *
   * @schema GeoMatchSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GeoMatchSetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'GeoMatchSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecForProvider(obj: GeoMatchSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'geoMatchConstraint': obj.geoMatchConstraint?.map(y => toJson_GeoMatchSetSpecForProviderGeoMatchConstraint(y)),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GeoMatchSetSpecProviderConfigRef
 */
export interface GeoMatchSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeoMatchSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeoMatchSetSpecProviderConfigRef#policy
   */
  readonly policy?: GeoMatchSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GeoMatchSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecProviderConfigRef(obj: GeoMatchSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeoMatchSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GeoMatchSetSpecProviderRef
 */
export interface GeoMatchSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeoMatchSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeoMatchSetSpecProviderRef#policy
   */
  readonly policy?: GeoMatchSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GeoMatchSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecProviderRef(obj: GeoMatchSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeoMatchSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GeoMatchSetSpecPublishConnectionDetailsTo
 */
export interface GeoMatchSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GeoMatchSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GeoMatchSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GeoMatchSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecPublishConnectionDetailsTo(obj: GeoMatchSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GeoMatchSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GeoMatchSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GeoMatchSetSpecWriteConnectionSecretToRef
 */
export interface GeoMatchSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GeoMatchSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GeoMatchSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GeoMatchSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecWriteConnectionSecretToRef(obj: GeoMatchSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GeoMatchSetSpecForProviderGeoMatchConstraint
 */
export interface GeoMatchSetSpecForProviderGeoMatchConstraint {
  /**
   * The type of geographical area you want AWS WAF to search for. Currently Country is the only valid value.
   *
   * @schema GeoMatchSetSpecForProviderGeoMatchConstraint#type
   */
  readonly type: string;

  /**
   * The country that you want AWS WAF to search for. This is the two-letter country code, e.g., US, CA, RU, CN, etc. See docs for all supported values.
   *
   * @schema GeoMatchSetSpecForProviderGeoMatchConstraint#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'GeoMatchSetSpecForProviderGeoMatchConstraint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecForProviderGeoMatchConstraint(obj: GeoMatchSetSpecForProviderGeoMatchConstraint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GeoMatchSetSpecProviderConfigRefPolicy
 */
export interface GeoMatchSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeoMatchSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GeoMatchSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeoMatchSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GeoMatchSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GeoMatchSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecProviderConfigRefPolicy(obj: GeoMatchSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GeoMatchSetSpecProviderRefPolicy
 */
export interface GeoMatchSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeoMatchSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GeoMatchSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeoMatchSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GeoMatchSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GeoMatchSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecProviderRefPolicy(obj: GeoMatchSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRef
 */
export interface GeoMatchSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GeoMatchSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecPublishConnectionDetailsToConfigRef(obj: GeoMatchSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GeoMatchSetSpecPublishConnectionDetailsToMetadata
 */
export interface GeoMatchSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GeoMatchSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecPublishConnectionDetailsToMetadata(obj: GeoMatchSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeoMatchSetSpecProviderConfigRefPolicyResolution
 */
export enum GeoMatchSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeoMatchSetSpecProviderConfigRefPolicyResolve
 */
export enum GeoMatchSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeoMatchSetSpecProviderRefPolicyResolution
 */
export enum GeoMatchSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeoMatchSetSpecProviderRefPolicyResolve
 */
export enum GeoMatchSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GeoMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * IPSet is the Schema for the IPSets API. Provides a AWS WAF Regional IPSet resource for use with ALB.
 *
 * @schema IPSet
 */
export class IpSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IPSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'IPSet',
  }

  /**
   * Renders a Kubernetes manifest for "IPSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IpSetProps): any {
    return {
      ...IpSet.GVK,
      ...toJson_IpSetProps(props),
    };
  }

  /**
   * Defines a "IPSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IpSetProps) {
    super(scope, id, {
      ...IpSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IpSet.GVK,
      ...toJson_IpSetProps(resolved),
    };
  }
}

/**
 * IPSet is the Schema for the IPSets API. Provides a AWS WAF Regional IPSet resource for use with ALB.
 *
 * @schema IPSet
 */
export interface IpSetProps {
  /**
   * @schema IPSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IPSetSpec defines the desired state of IPSet
   *
   * @schema IPSet#spec
   */
  readonly spec: IpSetSpec;

}

/**
 * Converts an object of type 'IpSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetProps(obj: IpSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IpSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IPSetSpec defines the desired state of IPSet
 *
 * @schema IpSetSpec
 */
export interface IpSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema IpSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: IpSetSpecDeletionPolicy;

  /**
   * @schema IpSetSpec#forProvider
   */
  readonly forProvider: IpSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IpSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: IpSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IpSetSpec#providerRef
   */
  readonly providerRef?: IpSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IpSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IpSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IpSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IpSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IpSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpec(obj: IpSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IpSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_IpSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IpSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IpSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IpSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema IpSetSpecDeletionPolicy
 */
export enum IpSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IpSetSpecForProvider
 */
export interface IpSetSpecForProvider {
  /**
   * One or more pairs specifying the IP address type (IPV4 or IPV6) and the IP address range (in CIDR notation) from which web requests originate.
   *
   * @schema IpSetSpecForProvider#ipSetDescriptor
   */
  readonly ipSetDescriptor?: IpSetSpecForProviderIpSetDescriptor[];

  /**
   * The name or description of the IPSet.
   *
   * @schema IpSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IpSetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'IpSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecForProvider(obj: IpSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ipSetDescriptor': obj.ipSetDescriptor?.map(y => toJson_IpSetSpecForProviderIpSetDescriptor(y)),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IpSetSpecProviderConfigRef
 */
export interface IpSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IpSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IpSetSpecProviderConfigRef#policy
   */
  readonly policy?: IpSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IpSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecProviderConfigRef(obj: IpSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IpSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IpSetSpecProviderRef
 */
export interface IpSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IpSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IpSetSpecProviderRef#policy
   */
  readonly policy?: IpSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IpSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecProviderRef(obj: IpSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IpSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IpSetSpecPublishConnectionDetailsTo
 */
export interface IpSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IpSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IpSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IpSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IpSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IpSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IpSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecPublishConnectionDetailsTo(obj: IpSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IpSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IpSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IpSetSpecWriteConnectionSecretToRef
 */
export interface IpSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IpSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IpSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IpSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecWriteConnectionSecretToRef(obj: IpSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema IpSetSpecForProviderIpSetDescriptor
 */
export interface IpSetSpecForProviderIpSetDescriptor {
  /**
   * The string like IPV4 or IPV6.
   *
   * @schema IpSetSpecForProviderIpSetDescriptor#type
   */
  readonly type: string;

  /**
   * The CIDR notation.
   *
   * @schema IpSetSpecForProviderIpSetDescriptor#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'IpSetSpecForProviderIpSetDescriptor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecForProviderIpSetDescriptor(obj: IpSetSpecForProviderIpSetDescriptor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IpSetSpecProviderConfigRefPolicy
 */
export interface IpSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IpSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IpSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IpSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IpSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IpSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecProviderConfigRefPolicy(obj: IpSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IpSetSpecProviderRefPolicy
 */
export interface IpSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IpSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IpSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IpSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IpSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IpSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecProviderRefPolicy(obj: IpSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IpSetSpecPublishConnectionDetailsToConfigRef
 */
export interface IpSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IpSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IpSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IpSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IpSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecPublishConnectionDetailsToConfigRef(obj: IpSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IpSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IpSetSpecPublishConnectionDetailsToMetadata
 */
export interface IpSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IpSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IpSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IpSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IpSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecPublishConnectionDetailsToMetadata(obj: IpSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IpSetSpecProviderConfigRefPolicyResolution
 */
export enum IpSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IpSetSpecProviderConfigRefPolicyResolve
 */
export enum IpSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IpSetSpecProviderRefPolicyResolution
 */
export enum IpSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IpSetSpecProviderRefPolicyResolve
 */
export enum IpSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IpSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IpSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IpSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IpSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IpSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IpSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IpSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IpSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: IpSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IpSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IpSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IpSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IpSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RateBasedRule is the Schema for the RateBasedRules API. Provides a AWS WAF Regional rate based rule resource.
 *
 * @schema RateBasedRule
 */
export class RateBasedRule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RateBasedRule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'RateBasedRule',
  }

  /**
   * Renders a Kubernetes manifest for "RateBasedRule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RateBasedRuleProps): any {
    return {
      ...RateBasedRule.GVK,
      ...toJson_RateBasedRuleProps(props),
    };
  }

  /**
   * Defines a "RateBasedRule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RateBasedRuleProps) {
    super(scope, id, {
      ...RateBasedRule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RateBasedRule.GVK,
      ...toJson_RateBasedRuleProps(resolved),
    };
  }
}

/**
 * RateBasedRule is the Schema for the RateBasedRules API. Provides a AWS WAF Regional rate based rule resource.
 *
 * @schema RateBasedRule
 */
export interface RateBasedRuleProps {
  /**
   * @schema RateBasedRule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RateBasedRuleSpec defines the desired state of RateBasedRule
   *
   * @schema RateBasedRule#spec
   */
  readonly spec: RateBasedRuleSpec;

}

/**
 * Converts an object of type 'RateBasedRuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleProps(obj: RateBasedRuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RateBasedRuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateBasedRuleSpec defines the desired state of RateBasedRule
 *
 * @schema RateBasedRuleSpec
 */
export interface RateBasedRuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RateBasedRuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: RateBasedRuleSpecDeletionPolicy;

  /**
   * @schema RateBasedRuleSpec#forProvider
   */
  readonly forProvider: RateBasedRuleSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RateBasedRuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: RateBasedRuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RateBasedRuleSpec#providerRef
   */
  readonly providerRef?: RateBasedRuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RateBasedRuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RateBasedRuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RateBasedRuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RateBasedRuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RateBasedRuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpec(obj: RateBasedRuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RateBasedRuleSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RateBasedRuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RateBasedRuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RateBasedRuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RateBasedRuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RateBasedRuleSpecDeletionPolicy
 */
export enum RateBasedRuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RateBasedRuleSpecForProvider
 */
export interface RateBasedRuleSpecForProvider {
  /**
   * The name or description for the Amazon CloudWatch metric of this rule.
   *
   * @schema RateBasedRuleSpecForProvider#metricName
   */
  readonly metricName: string;

  /**
   * The name or description of the rule.
   *
   * @schema RateBasedRuleSpecForProvider#name
   */
  readonly name: string;

  /**
   * The objects to include in a rule (documented below).
   *
   * @schema RateBasedRuleSpecForProvider#predicate
   */
  readonly predicate?: RateBasedRuleSpecForProviderPredicate[];

  /**
   * Valid value is IP.
   *
   * @schema RateBasedRuleSpecForProvider#rateKey
   */
  readonly rateKey: string;

  /**
   * The maximum number of requests, which have an identical value in the field specified by the RateKey, allowed in a five-minute period. Minimum value is 100.
   *
   * @schema RateBasedRuleSpecForProvider#rateLimit
   */
  readonly rateLimit: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RateBasedRuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RateBasedRuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RateBasedRuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecForProvider(obj: RateBasedRuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'name': obj.name,
    'predicate': obj.predicate?.map(y => toJson_RateBasedRuleSpecForProviderPredicate(y)),
    'rateKey': obj.rateKey,
    'rateLimit': obj.rateLimit,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RateBasedRuleSpecProviderConfigRef
 */
export interface RateBasedRuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RateBasedRuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RateBasedRuleSpecProviderConfigRef#policy
   */
  readonly policy?: RateBasedRuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RateBasedRuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecProviderConfigRef(obj: RateBasedRuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RateBasedRuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RateBasedRuleSpecProviderRef
 */
export interface RateBasedRuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RateBasedRuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RateBasedRuleSpecProviderRef#policy
   */
  readonly policy?: RateBasedRuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RateBasedRuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecProviderRef(obj: RateBasedRuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RateBasedRuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RateBasedRuleSpecPublishConnectionDetailsTo
 */
export interface RateBasedRuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RateBasedRuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RateBasedRuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RateBasedRuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecPublishConnectionDetailsTo(obj: RateBasedRuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RateBasedRuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RateBasedRuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RateBasedRuleSpecWriteConnectionSecretToRef
 */
export interface RateBasedRuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RateBasedRuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RateBasedRuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RateBasedRuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecWriteConnectionSecretToRef(obj: RateBasedRuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RateBasedRuleSpecForProviderPredicate
 */
export interface RateBasedRuleSpecForProviderPredicate {
  /**
   * A unique identifier for a predicate in the rule, such as Byte Match Set ID or IPSet ID.
   *
   * @schema RateBasedRuleSpecForProviderPredicate#dataId
   */
  readonly dataId?: string;

  /**
   * Reference to a IPSet in wafregional to populate dataId.
   *
   * @schema RateBasedRuleSpecForProviderPredicate#dataIdRef
   */
  readonly dataIdRef?: RateBasedRuleSpecForProviderPredicateDataIdRef;

  /**
   * Selector for a IPSet in wafregional to populate dataId.
   *
   * @schema RateBasedRuleSpecForProviderPredicate#dataIdSelector
   */
  readonly dataIdSelector?: RateBasedRuleSpecForProviderPredicateDataIdSelector;

  /**
   * Set this to false if you want to allow, block, or count requests based on the settings in the specified ByteMatchSet, IPSet, SqlInjectionMatchSet, XssMatchSet, or SizeConstraintSet. For example, if an IPSet includes the IP address 192.0.2.44, AWS WAF will allow or block requests based on that IP address. If set to true, AWS WAF will allow, block, or count requests based on all IP addresses except 192.0.2.44.
   *
   * @schema RateBasedRuleSpecForProviderPredicate#negated
   */
  readonly negated: boolean;

  /**
   * The type of predicate in a rule. Valid values: ByteMatch, GeoMatch, IPMatch, RegexMatch, SizeConstraint, SqlInjectionMatch, or XssMatch.
   *
   * @schema RateBasedRuleSpecForProviderPredicate#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RateBasedRuleSpecForProviderPredicate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecForProviderPredicate(obj: RateBasedRuleSpecForProviderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataId': obj.dataId,
    'dataIdRef': toJson_RateBasedRuleSpecForProviderPredicateDataIdRef(obj.dataIdRef),
    'dataIdSelector': toJson_RateBasedRuleSpecForProviderPredicateDataIdSelector(obj.dataIdSelector),
    'negated': obj.negated,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RateBasedRuleSpecProviderConfigRefPolicy
 */
export interface RateBasedRuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RateBasedRuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RateBasedRuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RateBasedRuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RateBasedRuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RateBasedRuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecProviderConfigRefPolicy(obj: RateBasedRuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RateBasedRuleSpecProviderRefPolicy
 */
export interface RateBasedRuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RateBasedRuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RateBasedRuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RateBasedRuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RateBasedRuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RateBasedRuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecProviderRefPolicy(obj: RateBasedRuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRef
 */
export interface RateBasedRuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RateBasedRuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecPublishConnectionDetailsToConfigRef(obj: RateBasedRuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RateBasedRuleSpecPublishConnectionDetailsToMetadata
 */
export interface RateBasedRuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RateBasedRuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecPublishConnectionDetailsToMetadata(obj: RateBasedRuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a IPSet in wafregional to populate dataId.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdRef
 */
export interface RateBasedRuleSpecForProviderPredicateDataIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdRef#policy
   */
  readonly policy?: RateBasedRuleSpecForProviderPredicateDataIdRefPolicy;

}

/**
 * Converts an object of type 'RateBasedRuleSpecForProviderPredicateDataIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecForProviderPredicateDataIdRef(obj: RateBasedRuleSpecForProviderPredicateDataIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RateBasedRuleSpecForProviderPredicateDataIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a IPSet in wafregional to populate dataId.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdSelector
 */
export interface RateBasedRuleSpecForProviderPredicateDataIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdSelector#policy
   */
  readonly policy?: RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy;

}

/**
 * Converts an object of type 'RateBasedRuleSpecForProviderPredicateDataIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecForProviderPredicateDataIdSelector(obj: RateBasedRuleSpecForProviderPredicateDataIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RateBasedRuleSpecProviderConfigRefPolicyResolution
 */
export enum RateBasedRuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RateBasedRuleSpecProviderConfigRefPolicyResolve
 */
export enum RateBasedRuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RateBasedRuleSpecProviderRefPolicyResolution
 */
export enum RateBasedRuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RateBasedRuleSpecProviderRefPolicyResolve
 */
export enum RateBasedRuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdRefPolicy
 */
export interface RateBasedRuleSpecForProviderPredicateDataIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdRefPolicy#resolution
   */
  readonly resolution?: RateBasedRuleSpecForProviderPredicateDataIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdRefPolicy#resolve
   */
  readonly resolve?: RateBasedRuleSpecForProviderPredicateDataIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RateBasedRuleSpecForProviderPredicateDataIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecForProviderPredicateDataIdRefPolicy(obj: RateBasedRuleSpecForProviderPredicateDataIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy
 */
export interface RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy#resolution
   */
  readonly resolution?: RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy#resolve
   */
  readonly resolve?: RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy(obj: RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RateBasedRuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdRefPolicyResolution
 */
export enum RateBasedRuleSpecForProviderPredicateDataIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdRefPolicyResolve
 */
export enum RateBasedRuleSpecForProviderPredicateDataIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicyResolution
 */
export enum RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicyResolve
 */
export enum RateBasedRuleSpecForProviderPredicateDataIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RegexMatchSet is the Schema for the RegexMatchSets API. Provides a AWS WAF Regional Regex Match Set resource.
 *
 * @schema RegexMatchSet
 */
export class RegexMatchSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RegexMatchSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'RegexMatchSet',
  }

  /**
   * Renders a Kubernetes manifest for "RegexMatchSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegexMatchSetProps): any {
    return {
      ...RegexMatchSet.GVK,
      ...toJson_RegexMatchSetProps(props),
    };
  }

  /**
   * Defines a "RegexMatchSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegexMatchSetProps) {
    super(scope, id, {
      ...RegexMatchSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RegexMatchSet.GVK,
      ...toJson_RegexMatchSetProps(resolved),
    };
  }
}

/**
 * RegexMatchSet is the Schema for the RegexMatchSets API. Provides a AWS WAF Regional Regex Match Set resource.
 *
 * @schema RegexMatchSet
 */
export interface RegexMatchSetProps {
  /**
   * @schema RegexMatchSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegexMatchSetSpec defines the desired state of RegexMatchSet
   *
   * @schema RegexMatchSet#spec
   */
  readonly spec: RegexMatchSetSpec;

}

/**
 * Converts an object of type 'RegexMatchSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetProps(obj: RegexMatchSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegexMatchSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegexMatchSetSpec defines the desired state of RegexMatchSet
 *
 * @schema RegexMatchSetSpec
 */
export interface RegexMatchSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RegexMatchSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: RegexMatchSetSpecDeletionPolicy;

  /**
   * @schema RegexMatchSetSpec#forProvider
   */
  readonly forProvider: RegexMatchSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegexMatchSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: RegexMatchSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RegexMatchSetSpec#providerRef
   */
  readonly providerRef?: RegexMatchSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegexMatchSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegexMatchSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegexMatchSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegexMatchSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegexMatchSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpec(obj: RegexMatchSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegexMatchSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RegexMatchSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RegexMatchSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RegexMatchSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegexMatchSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RegexMatchSetSpecDeletionPolicy
 */
export enum RegexMatchSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegexMatchSetSpecForProvider
 */
export interface RegexMatchSetSpecForProvider {
  /**
   * The name or description of the Regex Match Set.
   *
   * @schema RegexMatchSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * The regular expression pattern that you want AWS WAF to search for in web requests, the location in requests that you want AWS WAF to search, and other settings. See below.
   *
   * @schema RegexMatchSetSpecForProvider#regexMatchTuple
   */
  readonly regexMatchTuple?: RegexMatchSetSpecForProviderRegexMatchTuple[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RegexMatchSetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RegexMatchSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecForProvider(obj: RegexMatchSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'regexMatchTuple': obj.regexMatchTuple?.map(y => toJson_RegexMatchSetSpecForProviderRegexMatchTuple(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegexMatchSetSpecProviderConfigRef
 */
export interface RegexMatchSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegexMatchSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegexMatchSetSpecProviderConfigRef#policy
   */
  readonly policy?: RegexMatchSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegexMatchSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecProviderConfigRef(obj: RegexMatchSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegexMatchSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RegexMatchSetSpecProviderRef
 */
export interface RegexMatchSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegexMatchSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegexMatchSetSpecProviderRef#policy
   */
  readonly policy?: RegexMatchSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RegexMatchSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecProviderRef(obj: RegexMatchSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegexMatchSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegexMatchSetSpecPublishConnectionDetailsTo
 */
export interface RegexMatchSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegexMatchSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegexMatchSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegexMatchSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecPublishConnectionDetailsTo(obj: RegexMatchSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegexMatchSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegexMatchSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegexMatchSetSpecWriteConnectionSecretToRef
 */
export interface RegexMatchSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegexMatchSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegexMatchSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegexMatchSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecWriteConnectionSecretToRef(obj: RegexMatchSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RegexMatchSetSpecForProviderRegexMatchTuple
 */
export interface RegexMatchSetSpecForProviderRegexMatchTuple {
  /**
   * The part of a web request that you want to search, such as a specified header or a query string.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTuple#fieldToMatch
   */
  readonly fieldToMatch: RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch[];

  /**
   * The ID of a Regex Pattern Set.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTuple#regexPatternSetId
   */
  readonly regexPatternSetId?: string;

  /**
   * Reference to a RegexPatternSet in wafregional to populate regexPatternSetId.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTuple#regexPatternSetIdRef
   */
  readonly regexPatternSetIdRef?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef;

  /**
   * Selector for a RegexPatternSet in wafregional to populate regexPatternSetId.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTuple#regexPatternSetIdSelector
   */
  readonly regexPatternSetIdSelector?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector;

  /**
   * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. e.g., CMD_LINE, HTML_ENTITY_DECODE or NONE. See docs for all supported values.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTuple#textTransformation
   */
  readonly textTransformation: string;

}

/**
 * Converts an object of type 'RegexMatchSetSpecForProviderRegexMatchTuple' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecForProviderRegexMatchTuple(obj: RegexMatchSetSpecForProviderRegexMatchTuple | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldToMatch': obj.fieldToMatch?.map(y => toJson_RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch(y)),
    'regexPatternSetId': obj.regexPatternSetId,
    'regexPatternSetIdRef': toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef(obj.regexPatternSetIdRef),
    'regexPatternSetIdSelector': toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector(obj.regexPatternSetIdSelector),
    'textTransformation': obj.textTransformation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegexMatchSetSpecProviderConfigRefPolicy
 */
export interface RegexMatchSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexMatchSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegexMatchSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexMatchSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegexMatchSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegexMatchSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecProviderConfigRefPolicy(obj: RegexMatchSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegexMatchSetSpecProviderRefPolicy
 */
export interface RegexMatchSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexMatchSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RegexMatchSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexMatchSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RegexMatchSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RegexMatchSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecProviderRefPolicy(obj: RegexMatchSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRef
 */
export interface RegexMatchSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegexMatchSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecPublishConnectionDetailsToConfigRef(obj: RegexMatchSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegexMatchSetSpecPublishConnectionDetailsToMetadata
 */
export interface RegexMatchSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegexMatchSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecPublishConnectionDetailsToMetadata(obj: RegexMatchSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch
 */
export interface RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch {
  /**
   * When type is HEADER, enter the name of the header that you want to search, e.g., User-Agent or Referer. If type is any other value, omit this field.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch#data
   */
  readonly data?: string;

  /**
   * The part of the web request that you want AWS WAF to search for a specified string. e.g., HEADER, METHOD or BODY. See docs for all supported values.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch(obj: RegexMatchSetSpecForProviderRegexMatchTupleFieldToMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a RegexPatternSet in wafregional to populate regexPatternSetId.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef
 */
export interface RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef#policy
   */
  readonly policy?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy;

}

/**
 * Converts an object of type 'RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef(obj: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a RegexPatternSet in wafregional to populate regexPatternSetId.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector
 */
export interface RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector#policy
   */
  readonly policy?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy;

}

/**
 * Converts an object of type 'RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector(obj: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexMatchSetSpecProviderConfigRefPolicyResolution
 */
export enum RegexMatchSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexMatchSetSpecProviderConfigRefPolicyResolve
 */
export enum RegexMatchSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexMatchSetSpecProviderRefPolicyResolution
 */
export enum RegexMatchSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexMatchSetSpecProviderRefPolicyResolve
 */
export enum RegexMatchSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy
 */
export interface RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy#resolution
   */
  readonly resolution?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy#resolve
   */
  readonly resolve?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy(obj: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy
 */
export interface RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy#resolution
   */
  readonly resolution?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy#resolve
   */
  readonly resolve?: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy(obj: RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegexMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicyResolution
 */
export enum RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicyResolve
 */
export enum RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicyResolution
 */
export enum RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicyResolve
 */
export enum RegexMatchSetSpecForProviderRegexMatchTupleRegexPatternSetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RegexPatternSet is the Schema for the RegexPatternSets API. Provides a AWS WAF Regional Regex Pattern Set resource.
 *
 * @schema RegexPatternSet
 */
export class RegexPatternSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RegexPatternSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'RegexPatternSet',
  }

  /**
   * Renders a Kubernetes manifest for "RegexPatternSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RegexPatternSetProps): any {
    return {
      ...RegexPatternSet.GVK,
      ...toJson_RegexPatternSetProps(props),
    };
  }

  /**
   * Defines a "RegexPatternSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RegexPatternSetProps) {
    super(scope, id, {
      ...RegexPatternSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RegexPatternSet.GVK,
      ...toJson_RegexPatternSetProps(resolved),
    };
  }
}

/**
 * RegexPatternSet is the Schema for the RegexPatternSets API. Provides a AWS WAF Regional Regex Pattern Set resource.
 *
 * @schema RegexPatternSet
 */
export interface RegexPatternSetProps {
  /**
   * @schema RegexPatternSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RegexPatternSetSpec defines the desired state of RegexPatternSet
   *
   * @schema RegexPatternSet#spec
   */
  readonly spec: RegexPatternSetSpec;

}

/**
 * Converts an object of type 'RegexPatternSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetProps(obj: RegexPatternSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RegexPatternSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RegexPatternSetSpec defines the desired state of RegexPatternSet
 *
 * @schema RegexPatternSetSpec
 */
export interface RegexPatternSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RegexPatternSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: RegexPatternSetSpecDeletionPolicy;

  /**
   * @schema RegexPatternSetSpec#forProvider
   */
  readonly forProvider: RegexPatternSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RegexPatternSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: RegexPatternSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RegexPatternSetSpec#providerRef
   */
  readonly providerRef?: RegexPatternSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RegexPatternSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RegexPatternSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RegexPatternSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RegexPatternSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RegexPatternSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpec(obj: RegexPatternSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RegexPatternSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RegexPatternSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RegexPatternSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RegexPatternSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RegexPatternSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RegexPatternSetSpecDeletionPolicy
 */
export enum RegexPatternSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RegexPatternSetSpecForProvider
 */
export interface RegexPatternSetSpecForProvider {
  /**
   * The name or description of the Regex Pattern Set.
   *
   * @schema RegexPatternSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * A list of regular expression (regex) patterns that you want AWS WAF to search for, such as B[a@]dB[o0]t.
   *
   * @schema RegexPatternSetSpecForProvider#regexPatternStrings
   */
  readonly regexPatternStrings?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RegexPatternSetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RegexPatternSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecForProvider(obj: RegexPatternSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'regexPatternStrings': obj.regexPatternStrings?.map(y => y),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RegexPatternSetSpecProviderConfigRef
 */
export interface RegexPatternSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegexPatternSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegexPatternSetSpecProviderConfigRef#policy
   */
  readonly policy?: RegexPatternSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RegexPatternSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecProviderConfigRef(obj: RegexPatternSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegexPatternSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RegexPatternSetSpecProviderRef
 */
export interface RegexPatternSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegexPatternSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegexPatternSetSpecProviderRef#policy
   */
  readonly policy?: RegexPatternSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RegexPatternSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecProviderRef(obj: RegexPatternSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegexPatternSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RegexPatternSetSpecPublishConnectionDetailsTo
 */
export interface RegexPatternSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RegexPatternSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RegexPatternSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RegexPatternSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecPublishConnectionDetailsTo(obj: RegexPatternSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RegexPatternSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RegexPatternSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RegexPatternSetSpecWriteConnectionSecretToRef
 */
export interface RegexPatternSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RegexPatternSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RegexPatternSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RegexPatternSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecWriteConnectionSecretToRef(obj: RegexPatternSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegexPatternSetSpecProviderConfigRefPolicy
 */
export interface RegexPatternSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexPatternSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RegexPatternSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexPatternSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RegexPatternSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegexPatternSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecProviderConfigRefPolicy(obj: RegexPatternSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RegexPatternSetSpecProviderRefPolicy
 */
export interface RegexPatternSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexPatternSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RegexPatternSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexPatternSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RegexPatternSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RegexPatternSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecProviderRefPolicy(obj: RegexPatternSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRef
 */
export interface RegexPatternSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RegexPatternSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecPublishConnectionDetailsToConfigRef(obj: RegexPatternSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RegexPatternSetSpecPublishConnectionDetailsToMetadata
 */
export interface RegexPatternSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RegexPatternSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecPublishConnectionDetailsToMetadata(obj: RegexPatternSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexPatternSetSpecProviderConfigRefPolicyResolution
 */
export enum RegexPatternSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexPatternSetSpecProviderConfigRefPolicyResolve
 */
export enum RegexPatternSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexPatternSetSpecProviderRefPolicyResolution
 */
export enum RegexPatternSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexPatternSetSpecProviderRefPolicyResolve
 */
export enum RegexPatternSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RegexPatternSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Rule is the Schema for the Rules API. Provides an AWS WAF Regional rule resource for use with ALB.
 *
 * @schema Rule
 */
export class Rule extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Rule"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'Rule',
  }

  /**
   * Renders a Kubernetes manifest for "Rule".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuleProps): any {
    return {
      ...Rule.GVK,
      ...toJson_RuleProps(props),
    };
  }

  /**
   * Defines a "Rule" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuleProps) {
    super(scope, id, {
      ...Rule.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Rule.GVK,
      ...toJson_RuleProps(resolved),
    };
  }
}

/**
 * Rule is the Schema for the Rules API. Provides an AWS WAF Regional rule resource for use with ALB.
 *
 * @schema Rule
 */
export interface RuleProps {
  /**
   * @schema Rule#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuleSpec defines the desired state of Rule
   *
   * @schema Rule#spec
   */
  readonly spec: RuleSpec;

}

/**
 * Converts an object of type 'RuleProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleProps(obj: RuleProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuleSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuleSpec defines the desired state of Rule
 *
 * @schema RuleSpec
 */
export interface RuleSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RuleSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuleSpecDeletionPolicy;

  /**
   * @schema RuleSpec#forProvider
   */
  readonly forProvider: RuleSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuleSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuleSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuleSpec#providerRef
   */
  readonly providerRef?: RuleSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuleSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuleSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuleSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuleSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuleSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpec(obj: RuleSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuleSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RuleSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuleSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuleSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuleSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RuleSpecDeletionPolicy
 */
export enum RuleSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuleSpecForProvider
 */
export interface RuleSpecForProvider {
  /**
   * The name or description for the Amazon CloudWatch metric of this rule.
   *
   * @schema RuleSpecForProvider#metricName
   */
  readonly metricName: string;

  /**
   * The name or description of the rule.
   *
   * @schema RuleSpecForProvider#name
   */
  readonly name: string;

  /**
   * The objects to include in a rule (documented below).
   *
   * @schema RuleSpecForProvider#predicate
   */
  readonly predicate?: RuleSpecForProviderPredicate[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RuleSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema RuleSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'RuleSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProvider(obj: RuleSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metricName': obj.metricName,
    'name': obj.name,
    'predicate': obj.predicate?.map(y => toJson_RuleSpecForProviderPredicate(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuleSpecProviderConfigRef
 */
export interface RuleSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecProviderConfigRef#policy
   */
  readonly policy?: RuleSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderConfigRef(obj: RuleSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuleSpecProviderRef
 */
export interface RuleSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecProviderRef#policy
   */
  readonly policy?: RuleSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderRef(obj: RuleSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuleSpecPublishConnectionDetailsTo
 */
export interface RuleSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuleSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuleSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuleSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsTo(obj: RuleSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuleSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuleSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuleSpecWriteConnectionSecretToRef
 */
export interface RuleSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuleSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuleSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuleSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecWriteConnectionSecretToRef(obj: RuleSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuleSpecForProviderPredicate
 */
export interface RuleSpecForProviderPredicate {
  /**
   * The unique identifier of a predicate, such as the ID of a ByteMatchSet or IPSet.
   *
   * @schema RuleSpecForProviderPredicate#dataId
   */
  readonly dataId?: string;

  /**
   * Reference to a IPSet in wafregional to populate dataId.
   *
   * @schema RuleSpecForProviderPredicate#dataIdRef
   */
  readonly dataIdRef?: RuleSpecForProviderPredicateDataIdRef;

  /**
   * Selector for a IPSet in wafregional to populate dataId.
   *
   * @schema RuleSpecForProviderPredicate#dataIdSelector
   */
  readonly dataIdSelector?: RuleSpecForProviderPredicateDataIdSelector;

  /**
   * Whether to use the settings or the negated settings that you specified in the objects.
   *
   * @schema RuleSpecForProviderPredicate#negated
   */
  readonly negated: boolean;

  /**
   * The type of predicate in a rule. Valid values: ByteMatch, GeoMatch, IPMatch, RegexMatch, SizeConstraint, SqlInjectionMatch, or XssMatch
   *
   * @schema RuleSpecForProviderPredicate#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'RuleSpecForProviderPredicate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderPredicate(obj: RuleSpecForProviderPredicate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataId': obj.dataId,
    'dataIdRef': toJson_RuleSpecForProviderPredicateDataIdRef(obj.dataIdRef),
    'dataIdSelector': toJson_RuleSpecForProviderPredicateDataIdSelector(obj.dataIdSelector),
    'negated': obj.negated,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecProviderConfigRefPolicy
 */
export interface RuleSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuleSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuleSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderConfigRefPolicy(obj: RuleSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecProviderRefPolicy
 */
export interface RuleSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuleSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuleSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecProviderRefPolicy(obj: RuleSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRef
 */
export interface RuleSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuleSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToConfigRef(obj: RuleSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuleSpecPublishConnectionDetailsToMetadata
 */
export interface RuleSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuleSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToMetadata(obj: RuleSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a IPSet in wafregional to populate dataId.
 *
 * @schema RuleSpecForProviderPredicateDataIdRef
 */
export interface RuleSpecForProviderPredicateDataIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuleSpecForProviderPredicateDataIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuleSpecForProviderPredicateDataIdRef#policy
   */
  readonly policy?: RuleSpecForProviderPredicateDataIdRefPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderPredicateDataIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderPredicateDataIdRef(obj: RuleSpecForProviderPredicateDataIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuleSpecForProviderPredicateDataIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a IPSet in wafregional to populate dataId.
 *
 * @schema RuleSpecForProviderPredicateDataIdSelector
 */
export interface RuleSpecForProviderPredicateDataIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuleSpecForProviderPredicateDataIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuleSpecForProviderPredicateDataIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuleSpecForProviderPredicateDataIdSelector#policy
   */
  readonly policy?: RuleSpecForProviderPredicateDataIdSelectorPolicy;

}

/**
 * Converts an object of type 'RuleSpecForProviderPredicateDataIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderPredicateDataIdSelector(obj: RuleSpecForProviderPredicateDataIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuleSpecForProviderPredicateDataIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecProviderConfigRefPolicyResolution
 */
export enum RuleSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecProviderConfigRefPolicyResolve
 */
export enum RuleSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecProviderRefPolicyResolution
 */
export enum RuleSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecProviderRefPolicyResolve
 */
export enum RuleSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuleSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuleSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuleSpecForProviderPredicateDataIdRefPolicy
 */
export interface RuleSpecForProviderPredicateDataIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderPredicateDataIdRefPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderPredicateDataIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderPredicateDataIdRefPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderPredicateDataIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderPredicateDataIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderPredicateDataIdRefPolicy(obj: RuleSpecForProviderPredicateDataIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuleSpecForProviderPredicateDataIdSelectorPolicy
 */
export interface RuleSpecForProviderPredicateDataIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuleSpecForProviderPredicateDataIdSelectorPolicy#resolution
   */
  readonly resolution?: RuleSpecForProviderPredicateDataIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuleSpecForProviderPredicateDataIdSelectorPolicy#resolve
   */
  readonly resolve?: RuleSpecForProviderPredicateDataIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuleSpecForProviderPredicateDataIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuleSpecForProviderPredicateDataIdSelectorPolicy(obj: RuleSpecForProviderPredicateDataIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuleSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuleSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderPredicateDataIdRefPolicyResolution
 */
export enum RuleSpecForProviderPredicateDataIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderPredicateDataIdRefPolicyResolve
 */
export enum RuleSpecForProviderPredicateDataIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuleSpecForProviderPredicateDataIdSelectorPolicyResolution
 */
export enum RuleSpecForProviderPredicateDataIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuleSpecForProviderPredicateDataIdSelectorPolicyResolve
 */
export enum RuleSpecForProviderPredicateDataIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SizeConstraintSet is the Schema for the SizeConstraintSets API. Provides an AWS WAF Regional Size Constraint Set resource for use with ALB.
 *
 * @schema SizeConstraintSet
 */
export class SizeConstraintSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SizeConstraintSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'SizeConstraintSet',
  }

  /**
   * Renders a Kubernetes manifest for "SizeConstraintSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SizeConstraintSetProps): any {
    return {
      ...SizeConstraintSet.GVK,
      ...toJson_SizeConstraintSetProps(props),
    };
  }

  /**
   * Defines a "SizeConstraintSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SizeConstraintSetProps) {
    super(scope, id, {
      ...SizeConstraintSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SizeConstraintSet.GVK,
      ...toJson_SizeConstraintSetProps(resolved),
    };
  }
}

/**
 * SizeConstraintSet is the Schema for the SizeConstraintSets API. Provides an AWS WAF Regional Size Constraint Set resource for use with ALB.
 *
 * @schema SizeConstraintSet
 */
export interface SizeConstraintSetProps {
  /**
   * @schema SizeConstraintSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SizeConstraintSetSpec defines the desired state of SizeConstraintSet
   *
   * @schema SizeConstraintSet#spec
   */
  readonly spec: SizeConstraintSetSpec;

}

/**
 * Converts an object of type 'SizeConstraintSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetProps(obj: SizeConstraintSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SizeConstraintSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SizeConstraintSetSpec defines the desired state of SizeConstraintSet
 *
 * @schema SizeConstraintSetSpec
 */
export interface SizeConstraintSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SizeConstraintSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: SizeConstraintSetSpecDeletionPolicy;

  /**
   * @schema SizeConstraintSetSpec#forProvider
   */
  readonly forProvider: SizeConstraintSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SizeConstraintSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: SizeConstraintSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SizeConstraintSetSpec#providerRef
   */
  readonly providerRef?: SizeConstraintSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SizeConstraintSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SizeConstraintSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SizeConstraintSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SizeConstraintSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SizeConstraintSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpec(obj: SizeConstraintSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SizeConstraintSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SizeConstraintSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SizeConstraintSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SizeConstraintSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SizeConstraintSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SizeConstraintSetSpecDeletionPolicy
 */
export enum SizeConstraintSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SizeConstraintSetSpecForProvider
 */
export interface SizeConstraintSetSpecForProvider {
  /**
   * The name or description of the Size Constraint Set.
   *
   * @schema SizeConstraintSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SizeConstraintSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Specifies the parts of web requests that you want to inspect the size of.
   *
   * @schema SizeConstraintSetSpecForProvider#sizeConstraints
   */
  readonly sizeConstraints?: SizeConstraintSetSpecForProviderSizeConstraints[];

}

/**
 * Converts an object of type 'SizeConstraintSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecForProvider(obj: SizeConstraintSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'sizeConstraints': obj.sizeConstraints?.map(y => toJson_SizeConstraintSetSpecForProviderSizeConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SizeConstraintSetSpecProviderConfigRef
 */
export interface SizeConstraintSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SizeConstraintSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SizeConstraintSetSpecProviderConfigRef#policy
   */
  readonly policy?: SizeConstraintSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecProviderConfigRef(obj: SizeConstraintSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SizeConstraintSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SizeConstraintSetSpecProviderRef
 */
export interface SizeConstraintSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SizeConstraintSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SizeConstraintSetSpecProviderRef#policy
   */
  readonly policy?: SizeConstraintSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecProviderRef(obj: SizeConstraintSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SizeConstraintSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SizeConstraintSetSpecPublishConnectionDetailsTo
 */
export interface SizeConstraintSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SizeConstraintSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SizeConstraintSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecPublishConnectionDetailsTo(obj: SizeConstraintSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SizeConstraintSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SizeConstraintSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SizeConstraintSetSpecWriteConnectionSecretToRef
 */
export interface SizeConstraintSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SizeConstraintSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SizeConstraintSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecWriteConnectionSecretToRef(obj: SizeConstraintSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SizeConstraintSetSpecForProviderSizeConstraints
 */
export interface SizeConstraintSetSpecForProviderSizeConstraints {
  /**
   * The type of comparison you want to perform. e.g., EQ, NE, LT, GT. See docs for all supported values.
   *
   * @schema SizeConstraintSetSpecForProviderSizeConstraints#comparisonOperator
   */
  readonly comparisonOperator: string;

  /**
   * Specifies where in a web request to look for the size constraint.
   *
   * @schema SizeConstraintSetSpecForProviderSizeConstraints#fieldToMatch
   */
  readonly fieldToMatch: SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch[];

  /**
   * The size in bytes that you want to compare against the size of the specified field_to_match. Valid values are between 0 - 21474836480 bytes (0 - 20 GB).
   *
   * @schema SizeConstraintSetSpecForProviderSizeConstraints#size
   */
  readonly size: number;

  /**
   * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on field_to_match before inspecting a request for a match. e.g., CMD_LINE, HTML_ENTITY_DECODE or NONE. See docs for all supported values. Note: if you choose BODY as type, you must choose NONE because CloudFront forwards only the first 8192 bytes for inspection.
   *
   * @schema SizeConstraintSetSpecForProviderSizeConstraints#textTransformation
   */
  readonly textTransformation: string;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecForProviderSizeConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecForProviderSizeConstraints(obj: SizeConstraintSetSpecForProviderSizeConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comparisonOperator': obj.comparisonOperator,
    'fieldToMatch': obj.fieldToMatch?.map(y => toJson_SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch(y)),
    'size': obj.size,
    'textTransformation': obj.textTransformation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SizeConstraintSetSpecProviderConfigRefPolicy
 */
export interface SizeConstraintSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SizeConstraintSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SizeConstraintSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SizeConstraintSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SizeConstraintSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecProviderConfigRefPolicy(obj: SizeConstraintSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SizeConstraintSetSpecProviderRefPolicy
 */
export interface SizeConstraintSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SizeConstraintSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SizeConstraintSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SizeConstraintSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SizeConstraintSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecProviderRefPolicy(obj: SizeConstraintSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRef
 */
export interface SizeConstraintSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecPublishConnectionDetailsToConfigRef(obj: SizeConstraintSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SizeConstraintSetSpecPublishConnectionDetailsToMetadata
 */
export interface SizeConstraintSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecPublishConnectionDetailsToMetadata(obj: SizeConstraintSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch
 */
export interface SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch {
  /**
   * When type is HEADER, enter the name of the header that you want to search, e.g., User-Agent or Referer. If type is any other value, omit this field.
   *
   * @schema SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch#data
   */
  readonly data?: string;

  /**
   * The part of the web request that you want AWS WAF to search for a specified string. e.g., HEADER, METHOD or BODY. See docs for all supported values.
   *
   * @schema SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch(obj: SizeConstraintSetSpecForProviderSizeConstraintsFieldToMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SizeConstraintSetSpecProviderConfigRefPolicyResolution
 */
export enum SizeConstraintSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SizeConstraintSetSpecProviderConfigRefPolicyResolve
 */
export enum SizeConstraintSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SizeConstraintSetSpecProviderRefPolicyResolution
 */
export enum SizeConstraintSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SizeConstraintSetSpecProviderRefPolicyResolve
 */
export enum SizeConstraintSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SizeConstraintSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SQLInjectionMatchSet is the Schema for the SQLInjectionMatchSets API. Provides a AWS WAF Regional SqlInjectionMatchSet resource for use with ALB.
 *
 * @schema SQLInjectionMatchSet
 */
export class SqlInjectionMatchSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SQLInjectionMatchSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'SQLInjectionMatchSet',
  }

  /**
   * Renders a Kubernetes manifest for "SQLInjectionMatchSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SqlInjectionMatchSetProps): any {
    return {
      ...SqlInjectionMatchSet.GVK,
      ...toJson_SqlInjectionMatchSetProps(props),
    };
  }

  /**
   * Defines a "SQLInjectionMatchSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SqlInjectionMatchSetProps) {
    super(scope, id, {
      ...SqlInjectionMatchSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SqlInjectionMatchSet.GVK,
      ...toJson_SqlInjectionMatchSetProps(resolved),
    };
  }
}

/**
 * SQLInjectionMatchSet is the Schema for the SQLInjectionMatchSets API. Provides a AWS WAF Regional SqlInjectionMatchSet resource for use with ALB.
 *
 * @schema SQLInjectionMatchSet
 */
export interface SqlInjectionMatchSetProps {
  /**
   * @schema SQLInjectionMatchSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SQLInjectionMatchSetSpec defines the desired state of SQLInjectionMatchSet
   *
   * @schema SQLInjectionMatchSet#spec
   */
  readonly spec: SqlInjectionMatchSetSpec;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetProps(obj: SqlInjectionMatchSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SqlInjectionMatchSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SQLInjectionMatchSetSpec defines the desired state of SQLInjectionMatchSet
 *
 * @schema SqlInjectionMatchSetSpec
 */
export interface SqlInjectionMatchSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SqlInjectionMatchSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: SqlInjectionMatchSetSpecDeletionPolicy;

  /**
   * @schema SqlInjectionMatchSetSpec#forProvider
   */
  readonly forProvider: SqlInjectionMatchSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SqlInjectionMatchSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: SqlInjectionMatchSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SqlInjectionMatchSetSpec#providerRef
   */
  readonly providerRef?: SqlInjectionMatchSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SqlInjectionMatchSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SqlInjectionMatchSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SqlInjectionMatchSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SqlInjectionMatchSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpec(obj: SqlInjectionMatchSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SqlInjectionMatchSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SqlInjectionMatchSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SqlInjectionMatchSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SqlInjectionMatchSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SqlInjectionMatchSetSpecDeletionPolicy
 */
export enum SqlInjectionMatchSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SqlInjectionMatchSetSpecForProvider
 */
export interface SqlInjectionMatchSetSpecForProvider {
  /**
   * The name or description of the SizeConstraintSet.
   *
   * @schema SqlInjectionMatchSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SqlInjectionMatchSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The parts of web requests that you want AWS WAF to inspect for malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header.
   *
   * @schema SqlInjectionMatchSetSpecForProvider#sqlInjectionMatchTuple
   */
  readonly sqlInjectionMatchTuple?: SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple[];

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecForProvider(obj: SqlInjectionMatchSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'sqlInjectionMatchTuple': obj.sqlInjectionMatchTuple?.map(y => toJson_SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SqlInjectionMatchSetSpecProviderConfigRef
 */
export interface SqlInjectionMatchSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SqlInjectionMatchSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SqlInjectionMatchSetSpecProviderConfigRef#policy
   */
  readonly policy?: SqlInjectionMatchSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecProviderConfigRef(obj: SqlInjectionMatchSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SqlInjectionMatchSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SqlInjectionMatchSetSpecProviderRef
 */
export interface SqlInjectionMatchSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SqlInjectionMatchSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SqlInjectionMatchSetSpecProviderRef#policy
   */
  readonly policy?: SqlInjectionMatchSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecProviderRef(obj: SqlInjectionMatchSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SqlInjectionMatchSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsTo
 */
export interface SqlInjectionMatchSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsTo(obj: SqlInjectionMatchSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SqlInjectionMatchSetSpecWriteConnectionSecretToRef
 */
export interface SqlInjectionMatchSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SqlInjectionMatchSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SqlInjectionMatchSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecWriteConnectionSecretToRef(obj: SqlInjectionMatchSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple
 */
export interface SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple {
  /**
   * Specifies where in a web request to look for snippets of malicious SQL code.
   *
   * @schema SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple#fieldToMatch
   */
  readonly fieldToMatch: SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch[];

  /**
   * Text transformations used to eliminate unusual formatting that attackers use in web requests in an effort to bypass AWS WAF. If you specify a transformation, AWS WAF performs the transformation on field_to_match before inspecting a request for a match. e.g., CMD_LINE, HTML_ENTITY_DECODE or NONE. See docs for all supported values.
   *
   * @schema SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple#textTransformation
   */
  readonly textTransformation: string;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple(obj: SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTuple | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldToMatch': obj.fieldToMatch?.map(y => toJson_SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch(y)),
    'textTransformation': obj.textTransformation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SqlInjectionMatchSetSpecProviderConfigRefPolicy
 */
export interface SqlInjectionMatchSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SqlInjectionMatchSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SqlInjectionMatchSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SqlInjectionMatchSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SqlInjectionMatchSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecProviderConfigRefPolicy(obj: SqlInjectionMatchSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SqlInjectionMatchSetSpecProviderRefPolicy
 */
export interface SqlInjectionMatchSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SqlInjectionMatchSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SqlInjectionMatchSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SqlInjectionMatchSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SqlInjectionMatchSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecProviderRefPolicy(obj: SqlInjectionMatchSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef
 */
export interface SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef(obj: SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata
 */
export interface SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata(obj: SqlInjectionMatchSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch
 */
export interface SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch {
  /**
   * When type is HEADER, enter the name of the header that you want to search, e.g., User-Agent or Referer. If type is any other value, omit this field.
   *
   * @schema SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch#data
   */
  readonly data?: string;

  /**
   * The part of the web request that you want AWS WAF to search for a specified string. e.g., HEADER, METHOD or BODY. See docs for all supported values.
   *
   * @schema SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch(obj: SqlInjectionMatchSetSpecForProviderSqlInjectionMatchTupleFieldToMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SqlInjectionMatchSetSpecProviderConfigRefPolicyResolution
 */
export enum SqlInjectionMatchSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SqlInjectionMatchSetSpecProviderConfigRefPolicyResolve
 */
export enum SqlInjectionMatchSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SqlInjectionMatchSetSpecProviderRefPolicyResolution
 */
export enum SqlInjectionMatchSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SqlInjectionMatchSetSpecProviderRefPolicyResolve
 */
export enum SqlInjectionMatchSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SqlInjectionMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * WebACL is the Schema for the WebACLs API. Provides a AWS WAF Regional web access control group (ACL) resource for use with ALB.
 *
 * @schema WebACL
 */
export class WebAcl extends ApiObject {
  /**
   * Returns the apiVersion and kind for "WebACL"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'WebACL',
  }

  /**
   * Renders a Kubernetes manifest for "WebACL".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WebAclProps): any {
    return {
      ...WebAcl.GVK,
      ...toJson_WebAclProps(props),
    };
  }

  /**
   * Defines a "WebACL" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WebAclProps) {
    super(scope, id, {
      ...WebAcl.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...WebAcl.GVK,
      ...toJson_WebAclProps(resolved),
    };
  }
}

/**
 * WebACL is the Schema for the WebACLs API. Provides a AWS WAF Regional web access control group (ACL) resource for use with ALB.
 *
 * @schema WebACL
 */
export interface WebAclProps {
  /**
   * @schema WebACL#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * WebACLSpec defines the desired state of WebACL
   *
   * @schema WebACL#spec
   */
  readonly spec: WebAclSpec;

}

/**
 * Converts an object of type 'WebAclProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclProps(obj: WebAclProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WebAclSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WebACLSpec defines the desired state of WebACL
 *
 * @schema WebAclSpec
 */
export interface WebAclSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema WebAclSpec#deletionPolicy
   */
  readonly deletionPolicy?: WebAclSpecDeletionPolicy;

  /**
   * @schema WebAclSpec#forProvider
   */
  readonly forProvider: WebAclSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema WebAclSpec#providerConfigRef
   */
  readonly providerConfigRef?: WebAclSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema WebAclSpec#providerRef
   */
  readonly providerRef?: WebAclSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema WebAclSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: WebAclSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema WebAclSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: WebAclSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'WebAclSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpec(obj: WebAclSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_WebAclSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_WebAclSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_WebAclSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_WebAclSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_WebAclSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema WebAclSpecDeletionPolicy
 */
export enum WebAclSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema WebAclSpecForProvider
 */
export interface WebAclSpecForProvider {
  /**
   * The action that you want AWS WAF Regional to take when a request doesn't match the criteria in any of the rules that are associated with the web ACL.
   *
   * @schema WebAclSpecForProvider#defaultAction
   */
  readonly defaultAction: WebAclSpecForProviderDefaultAction[];

  /**
   * Configuration block to enable WAF logging. Detailed below.
   *
   * @schema WebAclSpecForProvider#loggingConfiguration
   */
  readonly loggingConfiguration?: WebAclSpecForProviderLoggingConfiguration[];

  /**
   * The name or description for the Amazon CloudWatch metric of this web ACL.
   *
   * @schema WebAclSpecForProvider#metricName
   */
  readonly metricName: string;

  /**
   * The name or description of the web ACL.
   *
   * @schema WebAclSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema WebAclSpecForProvider#region
   */
  readonly region: string;

  /**
   * Set of configuration blocks containing rules for the web ACL. Detailed below.
   *
   * @schema WebAclSpecForProvider#rule
   */
  readonly rule?: WebAclSpecForProviderRule[];

  /**
   * Key-value map of resource tags.
   *
   * @schema WebAclSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'WebAclSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProvider(obj: WebAclSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultAction': obj.defaultAction?.map(y => toJson_WebAclSpecForProviderDefaultAction(y)),
    'loggingConfiguration': obj.loggingConfiguration?.map(y => toJson_WebAclSpecForProviderLoggingConfiguration(y)),
    'metricName': obj.metricName,
    'name': obj.name,
    'region': obj.region,
    'rule': obj.rule?.map(y => toJson_WebAclSpecForProviderRule(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema WebAclSpecProviderConfigRef
 */
export interface WebAclSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebAclSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebAclSpecProviderConfigRef#policy
   */
  readonly policy?: WebAclSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'WebAclSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecProviderConfigRef(obj: WebAclSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebAclSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema WebAclSpecProviderRef
 */
export interface WebAclSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebAclSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebAclSpecProviderRef#policy
   */
  readonly policy?: WebAclSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'WebAclSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecProviderRef(obj: WebAclSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebAclSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema WebAclSpecPublishConnectionDetailsTo
 */
export interface WebAclSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema WebAclSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: WebAclSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema WebAclSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: WebAclSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema WebAclSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'WebAclSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecPublishConnectionDetailsTo(obj: WebAclSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_WebAclSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_WebAclSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema WebAclSpecWriteConnectionSecretToRef
 */
export interface WebAclSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema WebAclSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema WebAclSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'WebAclSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecWriteConnectionSecretToRef(obj: WebAclSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebAclSpecForProviderDefaultAction
 */
export interface WebAclSpecForProviderDefaultAction {
  /**
   * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a ruleE.g., ALLOW, BLOCK or COUNT
   *
   * @schema WebAclSpecForProviderDefaultAction#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'WebAclSpecForProviderDefaultAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderDefaultAction(obj: WebAclSpecForProviderDefaultAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebAclSpecForProviderLoggingConfiguration
 */
export interface WebAclSpecForProviderLoggingConfiguration {
  /**
   * Amazon Resource Name (ARN) of Kinesis Firehose Delivery Stream
   *
   * @schema WebAclSpecForProviderLoggingConfiguration#logDestination
   */
  readonly logDestination?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate logDestination.
   *
   * @schema WebAclSpecForProviderLoggingConfiguration#logDestinationRef
   */
  readonly logDestinationRef?: WebAclSpecForProviderLoggingConfigurationLogDestinationRef;

  /**
   * Selector for a DeliveryStream in firehose to populate logDestination.
   *
   * @schema WebAclSpecForProviderLoggingConfiguration#logDestinationSelector
   */
  readonly logDestinationSelector?: WebAclSpecForProviderLoggingConfigurationLogDestinationSelector;

  /**
   * Configuration block containing parts of the request that you want redacted from the logs. Detailed below.
   *
   * @schema WebAclSpecForProviderLoggingConfiguration#redactedFields
   */
  readonly redactedFields?: WebAclSpecForProviderLoggingConfigurationRedactedFields[];

}

/**
 * Converts an object of type 'WebAclSpecForProviderLoggingConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderLoggingConfiguration(obj: WebAclSpecForProviderLoggingConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDestination': obj.logDestination,
    'logDestinationRef': toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationRef(obj.logDestinationRef),
    'logDestinationSelector': toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationSelector(obj.logDestinationSelector),
    'redactedFields': obj.redactedFields?.map(y => toJson_WebAclSpecForProviderLoggingConfigurationRedactedFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebAclSpecForProviderRule
 */
export interface WebAclSpecForProviderRule {
  /**
   * Configuration block of the action that CloudFront or AWS WAF takes when a web request matches the conditions in the rule.  Not used if type is GROUP. Detailed below.
   *
   * @schema WebAclSpecForProviderRule#action
   */
  readonly action?: WebAclSpecForProviderRuleAction[];

  /**
   * Configuration block of the override the action that a group requests CloudFront or AWS WAF takes when a web request matches the conditions in the rule.  Only used if type is GROUP. Detailed below.
   *
   * @schema WebAclSpecForProviderRule#overrideAction
   */
  readonly overrideAction?: WebAclSpecForProviderRuleOverrideAction[];

  /**
   * Specifies the order in which the rules in a WebACL are evaluated. Rules with a lower value are evaluated before rules with a higher value.
   *
   * @schema WebAclSpecForProviderRule#priority
   */
  readonly priority: number;

  /**
   * ID of the associated WAF (Regional) rule (e.g., aws_wafregional_rule). WAF (Global) rules cannot be used.
   *
   * @schema WebAclSpecForProviderRule#ruleId
   */
  readonly ruleId?: string;

  /**
   * Reference to a Rule in wafregional to populate ruleId.
   *
   * @schema WebAclSpecForProviderRule#ruleIdRef
   */
  readonly ruleIdRef?: WebAclSpecForProviderRuleRuleIdRef;

  /**
   * Selector for a Rule in wafregional to populate ruleId.
   *
   * @schema WebAclSpecForProviderRule#ruleIdSelector
   */
  readonly ruleIdSelector?: WebAclSpecForProviderRuleRuleIdSelector;

  /**
   * The rule type, either REGULAR, as defined by Rule, RATE_BASED, as defined by RateBasedRule, or GROUP, as defined by RuleGroup. The default is REGULAR. If you add a RATE_BASED rule, you need to set type as RATE_BASED. If you add a GROUP rule, you need to set type as GROUP.
   *
   * @schema WebAclSpecForProviderRule#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebAclSpecForProviderRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderRule(obj: WebAclSpecForProviderRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action?.map(y => toJson_WebAclSpecForProviderRuleAction(y)),
    'overrideAction': obj.overrideAction?.map(y => toJson_WebAclSpecForProviderRuleOverrideAction(y)),
    'priority': obj.priority,
    'ruleId': obj.ruleId,
    'ruleIdRef': toJson_WebAclSpecForProviderRuleRuleIdRef(obj.ruleIdRef),
    'ruleIdSelector': toJson_WebAclSpecForProviderRuleRuleIdSelector(obj.ruleIdSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebAclSpecProviderConfigRefPolicy
 */
export interface WebAclSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebAclSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: WebAclSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebAclSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: WebAclSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebAclSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecProviderConfigRefPolicy(obj: WebAclSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebAclSpecProviderRefPolicy
 */
export interface WebAclSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebAclSpecProviderRefPolicy#resolution
   */
  readonly resolution?: WebAclSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebAclSpecProviderRefPolicy#resolve
   */
  readonly resolve?: WebAclSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'WebAclSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecProviderRefPolicy(obj: WebAclSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema WebAclSpecPublishConnectionDetailsToConfigRef
 */
export interface WebAclSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebAclSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebAclSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: WebAclSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'WebAclSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecPublishConnectionDetailsToConfigRef(obj: WebAclSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebAclSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema WebAclSpecPublishConnectionDetailsToMetadata
 */
export interface WebAclSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebAclSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema WebAclSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema WebAclSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'WebAclSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecPublishConnectionDetailsToMetadata(obj: WebAclSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeliveryStream in firehose to populate logDestination.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRef
 */
export interface WebAclSpecForProviderLoggingConfigurationLogDestinationRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRef#policy
   */
  readonly policy?: WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy;

}

/**
 * Converts an object of type 'WebAclSpecForProviderLoggingConfigurationLogDestinationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationRef(obj: WebAclSpecForProviderLoggingConfigurationLogDestinationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate logDestination.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelector
 */
export interface WebAclSpecForProviderLoggingConfigurationLogDestinationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelector#policy
   */
  readonly policy?: WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy;

}

/**
 * Converts an object of type 'WebAclSpecForProviderLoggingConfigurationLogDestinationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationSelector(obj: WebAclSpecForProviderLoggingConfigurationLogDestinationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebAclSpecForProviderLoggingConfigurationRedactedFields
 */
export interface WebAclSpecForProviderLoggingConfigurationRedactedFields {
  /**
   * Set of configuration blocks for fields to redact. Detailed below.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationRedactedFields#fieldToMatch
   */
  readonly fieldToMatch: WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch[];

}

/**
 * Converts an object of type 'WebAclSpecForProviderLoggingConfigurationRedactedFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderLoggingConfigurationRedactedFields(obj: WebAclSpecForProviderLoggingConfigurationRedactedFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldToMatch': obj.fieldToMatch?.map(y => toJson_WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebAclSpecForProviderRuleAction
 */
export interface WebAclSpecForProviderRuleAction {
  /**
   * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a rule. Valid values for action are ALLOW, BLOCK or COUNT. Valid values for override_action are COUNT and NONE.
   *
   * @schema WebAclSpecForProviderRuleAction#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'WebAclSpecForProviderRuleAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderRuleAction(obj: WebAclSpecForProviderRuleAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebAclSpecForProviderRuleOverrideAction
 */
export interface WebAclSpecForProviderRuleOverrideAction {
  /**
   * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a rule. Valid values for action are ALLOW, BLOCK or COUNT. Valid values for override_action are COUNT and NONE.
   *
   * @schema WebAclSpecForProviderRuleOverrideAction#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'WebAclSpecForProviderRuleOverrideAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderRuleOverrideAction(obj: WebAclSpecForProviderRuleOverrideAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Rule in wafregional to populate ruleId.
 *
 * @schema WebAclSpecForProviderRuleRuleIdRef
 */
export interface WebAclSpecForProviderRuleRuleIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema WebAclSpecForProviderRuleRuleIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema WebAclSpecForProviderRuleRuleIdRef#policy
   */
  readonly policy?: WebAclSpecForProviderRuleRuleIdRefPolicy;

}

/**
 * Converts an object of type 'WebAclSpecForProviderRuleRuleIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderRuleRuleIdRef(obj: WebAclSpecForProviderRuleRuleIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_WebAclSpecForProviderRuleRuleIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Rule in wafregional to populate ruleId.
 *
 * @schema WebAclSpecForProviderRuleRuleIdSelector
 */
export interface WebAclSpecForProviderRuleRuleIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema WebAclSpecForProviderRuleRuleIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema WebAclSpecForProviderRuleRuleIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema WebAclSpecForProviderRuleRuleIdSelector#policy
   */
  readonly policy?: WebAclSpecForProviderRuleRuleIdSelectorPolicy;

}

/**
 * Converts an object of type 'WebAclSpecForProviderRuleRuleIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderRuleRuleIdSelector(obj: WebAclSpecForProviderRuleRuleIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_WebAclSpecForProviderRuleRuleIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebAclSpecProviderConfigRefPolicyResolution
 */
export enum WebAclSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebAclSpecProviderConfigRefPolicyResolve
 */
export enum WebAclSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebAclSpecProviderRefPolicyResolution
 */
export enum WebAclSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebAclSpecProviderRefPolicyResolve
 */
export enum WebAclSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema WebAclSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface WebAclSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebAclSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: WebAclSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebAclSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: WebAclSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'WebAclSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecPublishConnectionDetailsToConfigRefPolicy(obj: WebAclSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy
 */
export interface WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy#resolution
   */
  readonly resolution?: WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy#resolve
   */
  readonly resolve?: WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicyResolve;

}

/**
 * Converts an object of type 'WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy(obj: WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy
 */
export interface WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy#resolution
   */
  readonly resolution?: WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy#resolve
   */
  readonly resolve?: WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy(obj: WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch
 */
export interface WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch {
  /**
   * When the value of type is HEADER, enter the name of the header that you want the WAF to search, for example, User-Agent or Referer. If the value of type is any other value, omit data.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch#data
   */
  readonly data?: string;

  /**
   * Specifies how you want AWS WAF Regional to respond to requests that match the settings in a rule. Valid values for action are ALLOW, BLOCK or COUNT. Valid values for override_action are COUNT and NONE.
   *
   * @schema WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch(obj: WebAclSpecForProviderLoggingConfigurationRedactedFieldsFieldToMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema WebAclSpecForProviderRuleRuleIdRefPolicy
 */
export interface WebAclSpecForProviderRuleRuleIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebAclSpecForProviderRuleRuleIdRefPolicy#resolution
   */
  readonly resolution?: WebAclSpecForProviderRuleRuleIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebAclSpecForProviderRuleRuleIdRefPolicy#resolve
   */
  readonly resolve?: WebAclSpecForProviderRuleRuleIdRefPolicyResolve;

}

/**
 * Converts an object of type 'WebAclSpecForProviderRuleRuleIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderRuleRuleIdRefPolicy(obj: WebAclSpecForProviderRuleRuleIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema WebAclSpecForProviderRuleRuleIdSelectorPolicy
 */
export interface WebAclSpecForProviderRuleRuleIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema WebAclSpecForProviderRuleRuleIdSelectorPolicy#resolution
   */
  readonly resolution?: WebAclSpecForProviderRuleRuleIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema WebAclSpecForProviderRuleRuleIdSelectorPolicy#resolve
   */
  readonly resolve?: WebAclSpecForProviderRuleRuleIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'WebAclSpecForProviderRuleRuleIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_WebAclSpecForProviderRuleRuleIdSelectorPolicy(obj: WebAclSpecForProviderRuleRuleIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebAclSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum WebAclSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebAclSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum WebAclSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicyResolution
 */
export enum WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicyResolve
 */
export enum WebAclSpecForProviderLoggingConfigurationLogDestinationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicyResolution
 */
export enum WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicyResolve
 */
export enum WebAclSpecForProviderLoggingConfigurationLogDestinationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebAclSpecForProviderRuleRuleIdRefPolicyResolution
 */
export enum WebAclSpecForProviderRuleRuleIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebAclSpecForProviderRuleRuleIdRefPolicyResolve
 */
export enum WebAclSpecForProviderRuleRuleIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema WebAclSpecForProviderRuleRuleIdSelectorPolicyResolution
 */
export enum WebAclSpecForProviderRuleRuleIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema WebAclSpecForProviderRuleRuleIdSelectorPolicyResolve
 */
export enum WebAclSpecForProviderRuleRuleIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * XSSMatchSet is the Schema for the XSSMatchSets API. Provides an AWS WAF Regional XSS Match Set resource for use with ALB.
 *
 * @schema XSSMatchSet
 */
export class XssMatchSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "XSSMatchSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'wafregional.aws.upbound.io/v1beta1',
    kind: 'XSSMatchSet',
  }

  /**
   * Renders a Kubernetes manifest for "XSSMatchSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: XssMatchSetProps): any {
    return {
      ...XssMatchSet.GVK,
      ...toJson_XssMatchSetProps(props),
    };
  }

  /**
   * Defines a "XSSMatchSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: XssMatchSetProps) {
    super(scope, id, {
      ...XssMatchSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...XssMatchSet.GVK,
      ...toJson_XssMatchSetProps(resolved),
    };
  }
}

/**
 * XSSMatchSet is the Schema for the XSSMatchSets API. Provides an AWS WAF Regional XSS Match Set resource for use with ALB.
 *
 * @schema XSSMatchSet
 */
export interface XssMatchSetProps {
  /**
   * @schema XSSMatchSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * XSSMatchSetSpec defines the desired state of XSSMatchSet
   *
   * @schema XSSMatchSet#spec
   */
  readonly spec: XssMatchSetSpec;

}

/**
 * Converts an object of type 'XssMatchSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetProps(obj: XssMatchSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_XssMatchSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * XSSMatchSetSpec defines the desired state of XSSMatchSet
 *
 * @schema XssMatchSetSpec
 */
export interface XssMatchSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema XssMatchSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: XssMatchSetSpecDeletionPolicy;

  /**
   * @schema XssMatchSetSpec#forProvider
   */
  readonly forProvider: XssMatchSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema XssMatchSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: XssMatchSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema XssMatchSetSpec#providerRef
   */
  readonly providerRef?: XssMatchSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema XssMatchSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: XssMatchSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema XssMatchSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: XssMatchSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'XssMatchSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpec(obj: XssMatchSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_XssMatchSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_XssMatchSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_XssMatchSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_XssMatchSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_XssMatchSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema XssMatchSetSpecDeletionPolicy
 */
export enum XssMatchSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema XssMatchSetSpecForProvider
 */
export interface XssMatchSetSpecForProvider {
  /**
   * The name of the set
   *
   * @schema XssMatchSetSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema XssMatchSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The parts of web requests that you want to inspect for cross-site scripting attacks.
   *
   * @schema XssMatchSetSpecForProvider#xssMatchTuple
   */
  readonly xssMatchTuple?: XssMatchSetSpecForProviderXssMatchTuple[];

}

/**
 * Converts an object of type 'XssMatchSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecForProvider(obj: XssMatchSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'xssMatchTuple': obj.xssMatchTuple?.map(y => toJson_XssMatchSetSpecForProviderXssMatchTuple(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema XssMatchSetSpecProviderConfigRef
 */
export interface XssMatchSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema XssMatchSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema XssMatchSetSpecProviderConfigRef#policy
   */
  readonly policy?: XssMatchSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'XssMatchSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecProviderConfigRef(obj: XssMatchSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_XssMatchSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema XssMatchSetSpecProviderRef
 */
export interface XssMatchSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema XssMatchSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema XssMatchSetSpecProviderRef#policy
   */
  readonly policy?: XssMatchSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'XssMatchSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecProviderRef(obj: XssMatchSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_XssMatchSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema XssMatchSetSpecPublishConnectionDetailsTo
 */
export interface XssMatchSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: XssMatchSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: XssMatchSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'XssMatchSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecPublishConnectionDetailsTo(obj: XssMatchSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_XssMatchSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_XssMatchSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema XssMatchSetSpecWriteConnectionSecretToRef
 */
export interface XssMatchSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema XssMatchSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema XssMatchSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'XssMatchSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecWriteConnectionSecretToRef(obj: XssMatchSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema XssMatchSetSpecForProviderXssMatchTuple
 */
export interface XssMatchSetSpecForProviderXssMatchTuple {
  /**
   * Specifies where in a web request to look for cross-site scripting attacks.
   *
   * @schema XssMatchSetSpecForProviderXssMatchTuple#fieldToMatch
   */
  readonly fieldToMatch: XssMatchSetSpecForProviderXssMatchTupleFieldToMatch[];

  /**
   * Which text transformation, if any, to perform on the web request before inspecting the request for cross-site scripting attacks.
   *
   * @schema XssMatchSetSpecForProviderXssMatchTuple#textTransformation
   */
  readonly textTransformation: string;

}

/**
 * Converts an object of type 'XssMatchSetSpecForProviderXssMatchTuple' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecForProviderXssMatchTuple(obj: XssMatchSetSpecForProviderXssMatchTuple | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fieldToMatch': obj.fieldToMatch?.map(y => toJson_XssMatchSetSpecForProviderXssMatchTupleFieldToMatch(y)),
    'textTransformation': obj.textTransformation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema XssMatchSetSpecProviderConfigRefPolicy
 */
export interface XssMatchSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema XssMatchSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: XssMatchSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema XssMatchSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: XssMatchSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'XssMatchSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecProviderConfigRefPolicy(obj: XssMatchSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema XssMatchSetSpecProviderRefPolicy
 */
export interface XssMatchSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema XssMatchSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: XssMatchSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema XssMatchSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: XssMatchSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'XssMatchSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecProviderRefPolicy(obj: XssMatchSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRef
 */
export interface XssMatchSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'XssMatchSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecPublishConnectionDetailsToConfigRef(obj: XssMatchSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema XssMatchSetSpecPublishConnectionDetailsToMetadata
 */
export interface XssMatchSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'XssMatchSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecPublishConnectionDetailsToMetadata(obj: XssMatchSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema XssMatchSetSpecForProviderXssMatchTupleFieldToMatch
 */
export interface XssMatchSetSpecForProviderXssMatchTupleFieldToMatch {
  /**
   * When the value of type is HEADER, enter the name of the header that you want the WAF to search, for example, User-Agent or Referer. If the value of type is any other value, omit data.
   *
   * @schema XssMatchSetSpecForProviderXssMatchTupleFieldToMatch#data
   */
  readonly data?: string;

  /**
   * The part of the web request that you want AWS WAF to search for a specified stringE.g., HEADER or METHOD
   *
   * @schema XssMatchSetSpecForProviderXssMatchTupleFieldToMatch#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'XssMatchSetSpecForProviderXssMatchTupleFieldToMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecForProviderXssMatchTupleFieldToMatch(obj: XssMatchSetSpecForProviderXssMatchTupleFieldToMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema XssMatchSetSpecProviderConfigRefPolicyResolution
 */
export enum XssMatchSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema XssMatchSetSpecProviderConfigRefPolicyResolve
 */
export enum XssMatchSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema XssMatchSetSpecProviderRefPolicyResolution
 */
export enum XssMatchSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema XssMatchSetSpecProviderRefPolicyResolve
 */
export enum XssMatchSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum XssMatchSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

