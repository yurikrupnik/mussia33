// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccountSettingDefault is the Schema for the AccountSettingDefaults API. Provides an ECS Default account setting.
 *
 * @schema AccountSettingDefault
 */
export class AccountSettingDefault extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccountSettingDefault"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.upbound.io/v1beta1',
    kind: 'AccountSettingDefault',
  }

  /**
   * Renders a Kubernetes manifest for "AccountSettingDefault".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountSettingDefaultProps): any {
    return {
      ...AccountSettingDefault.GVK,
      ...toJson_AccountSettingDefaultProps(props),
    };
  }

  /**
   * Defines a "AccountSettingDefault" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountSettingDefaultProps) {
    super(scope, id, {
      ...AccountSettingDefault.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccountSettingDefault.GVK,
      ...toJson_AccountSettingDefaultProps(resolved),
    };
  }
}

/**
 * AccountSettingDefault is the Schema for the AccountSettingDefaults API. Provides an ECS Default account setting.
 *
 * @default the Schema for the AccountSettingDefaults API. Provides an ECS Default account setting.
 * @schema AccountSettingDefault
 */
export interface AccountSettingDefaultProps {
  /**
   * @schema AccountSettingDefault#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountSettingDefaultSpec defines the desired state of AccountSettingDefault
   *
   * @schema AccountSettingDefault#spec
   */
  readonly spec: AccountSettingDefaultSpec;

}

/**
 * Converts an object of type 'AccountSettingDefaultProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultProps(obj: AccountSettingDefaultProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountSettingDefaultSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountSettingDefaultSpec defines the desired state of AccountSettingDefault
 *
 * @schema AccountSettingDefaultSpec
 */
export interface AccountSettingDefaultSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountSettingDefaultSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountSettingDefaultSpecDeletionPolicy;

  /**
   * @schema AccountSettingDefaultSpec#forProvider
   */
  readonly forProvider: AccountSettingDefaultSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AccountSettingDefaultSpec#initProvider
   */
  readonly initProvider?: AccountSettingDefaultSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccountSettingDefaultSpec#managementPolicies
   */
  readonly managementPolicies?: AccountSettingDefaultSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountSettingDefaultSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountSettingDefaultSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountSettingDefaultSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountSettingDefaultSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountSettingDefaultSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountSettingDefaultSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpec(obj: AccountSettingDefaultSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountSettingDefaultSpecForProvider(obj.forProvider),
    'initProvider': toJson_AccountSettingDefaultSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccountSettingDefaultSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccountSettingDefaultSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountSettingDefaultSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountSettingDefaultSpecDeletionPolicy
 */
export enum AccountSettingDefaultSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountSettingDefaultSpecForProvider
 */
export interface AccountSettingDefaultSpecForProvider {
  /**
   * Name of the account setting to set. Valid values are serviceLongArnFormat, taskLongArnFormat, containerInstanceLongArnFormat, awsvpcTrunking and containerInsights.
   *
   * @schema AccountSettingDefaultSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountSettingDefaultSpecForProvider#region
   */
  readonly region: string;

  /**
   * State of the setting. Valid values are enabled and disabled.
   *
   * @schema AccountSettingDefaultSpecForProvider#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecForProvider(obj: AccountSettingDefaultSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'region': obj.region,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AccountSettingDefaultSpecInitProvider
 */
export interface AccountSettingDefaultSpecInitProvider {
  /**
   * Name of the account setting to set. Valid values are serviceLongArnFormat, taskLongArnFormat, containerInstanceLongArnFormat, awsvpcTrunking and containerInsights.
   *
   * @schema AccountSettingDefaultSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * State of the setting. Valid values are enabled and disabled.
   *
   * @schema AccountSettingDefaultSpecInitProvider#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecInitProvider(obj: AccountSettingDefaultSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AccountSettingDefaultSpecManagementPolicies
 */
export enum AccountSettingDefaultSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountSettingDefaultSpecProviderConfigRef
 */
export interface AccountSettingDefaultSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSettingDefaultSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSettingDefaultSpecProviderConfigRef#policy
   */
  readonly policy?: AccountSettingDefaultSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecProviderConfigRef(obj: AccountSettingDefaultSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSettingDefaultSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountSettingDefaultSpecPublishConnectionDetailsTo
 */
export interface AccountSettingDefaultSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountSettingDefaultSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecPublishConnectionDetailsTo(obj: AccountSettingDefaultSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountSettingDefaultSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountSettingDefaultSpecWriteConnectionSecretToRef
 */
export interface AccountSettingDefaultSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountSettingDefaultSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountSettingDefaultSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecWriteConnectionSecretToRef(obj: AccountSettingDefaultSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountSettingDefaultSpecProviderConfigRefPolicy
 */
export interface AccountSettingDefaultSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSettingDefaultSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSettingDefaultSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSettingDefaultSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSettingDefaultSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecProviderConfigRefPolicy(obj: AccountSettingDefaultSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef(obj: AccountSettingDefaultSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountSettingDefaultSpecPublishConnectionDetailsToMetadata
 */
export interface AccountSettingDefaultSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecPublishConnectionDetailsToMetadata(obj: AccountSettingDefaultSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSettingDefaultSpecProviderConfigRefPolicyResolution
 */
export enum AccountSettingDefaultSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSettingDefaultSpecProviderConfigRefPolicyResolve
 */
export enum AccountSettingDefaultSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountSettingDefaultSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CapacityProvider is the Schema for the CapacityProviders API. Provides an ECS cluster capacity provider.
 *
 * @schema CapacityProvider
 */
export class CapacityProvider extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CapacityProvider"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.upbound.io/v1beta1',
    kind: 'CapacityProvider',
  }

  /**
   * Renders a Kubernetes manifest for "CapacityProvider".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CapacityProviderProps): any {
    return {
      ...CapacityProvider.GVK,
      ...toJson_CapacityProviderProps(props),
    };
  }

  /**
   * Defines a "CapacityProvider" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CapacityProviderProps) {
    super(scope, id, {
      ...CapacityProvider.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CapacityProvider.GVK,
      ...toJson_CapacityProviderProps(resolved),
    };
  }
}

/**
 * CapacityProvider is the Schema for the CapacityProviders API. Provides an ECS cluster capacity provider.
 *
 * @schema CapacityProvider
 */
export interface CapacityProviderProps {
  /**
   * @schema CapacityProvider#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CapacityProviderSpec defines the desired state of CapacityProvider
   *
   * @schema CapacityProvider#spec
   */
  readonly spec: CapacityProviderSpec;

}

/**
 * Converts an object of type 'CapacityProviderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderProps(obj: CapacityProviderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CapacityProviderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CapacityProviderSpec defines the desired state of CapacityProvider
 *
 * @schema CapacityProviderSpec
 */
export interface CapacityProviderSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CapacityProviderSpec#deletionPolicy
   */
  readonly deletionPolicy?: CapacityProviderSpecDeletionPolicy;

  /**
   * @schema CapacityProviderSpec#forProvider
   */
  readonly forProvider: CapacityProviderSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CapacityProviderSpec#initProvider
   */
  readonly initProvider?: CapacityProviderSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CapacityProviderSpec#managementPolicies
   */
  readonly managementPolicies?: CapacityProviderSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CapacityProviderSpec#providerConfigRef
   */
  readonly providerConfigRef?: CapacityProviderSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CapacityProviderSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CapacityProviderSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CapacityProviderSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CapacityProviderSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CapacityProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpec(obj: CapacityProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CapacityProviderSpecForProvider(obj.forProvider),
    'initProvider': toJson_CapacityProviderSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CapacityProviderSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CapacityProviderSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CapacityProviderSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CapacityProviderSpecDeletionPolicy
 */
export enum CapacityProviderSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CapacityProviderSpecForProvider
 */
export interface CapacityProviderSpecForProvider {
  /**
   * Configuration block for the provider for the ECS auto scaling group. Detailed below.
   *
   * @schema CapacityProviderSpecForProvider#autoScalingGroupProvider
   */
  readonly autoScalingGroupProvider?: CapacityProviderSpecForProviderAutoScalingGroupProvider[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CapacityProviderSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CapacityProviderSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CapacityProviderSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecForProvider(obj: CapacityProviderSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoScalingGroupProvider': obj.autoScalingGroupProvider?.map(y => toJson_CapacityProviderSpecForProviderAutoScalingGroupProvider(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CapacityProviderSpecInitProvider
 */
export interface CapacityProviderSpecInitProvider {
  /**
   * Configuration block for the provider for the ECS auto scaling group. Detailed below.
   *
   * @schema CapacityProviderSpecInitProvider#autoScalingGroupProvider
   */
  readonly autoScalingGroupProvider?: CapacityProviderSpecInitProviderAutoScalingGroupProvider[];

  /**
   * Key-value map of resource tags.
   *
   * @schema CapacityProviderSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CapacityProviderSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecInitProvider(obj: CapacityProviderSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoScalingGroupProvider': obj.autoScalingGroupProvider?.map(y => toJson_CapacityProviderSpecInitProviderAutoScalingGroupProvider(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CapacityProviderSpecManagementPolicies
 */
export enum CapacityProviderSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CapacityProviderSpecProviderConfigRef
 */
export interface CapacityProviderSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CapacityProviderSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CapacityProviderSpecProviderConfigRef#policy
   */
  readonly policy?: CapacityProviderSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CapacityProviderSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecProviderConfigRef(obj: CapacityProviderSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CapacityProviderSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CapacityProviderSpecPublishConnectionDetailsTo
 */
export interface CapacityProviderSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CapacityProviderSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CapacityProviderSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CapacityProviderSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecPublishConnectionDetailsTo(obj: CapacityProviderSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CapacityProviderSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CapacityProviderSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CapacityProviderSpecWriteConnectionSecretToRef
 */
export interface CapacityProviderSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CapacityProviderSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CapacityProviderSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CapacityProviderSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecWriteConnectionSecretToRef(obj: CapacityProviderSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProvider
 */
export interface CapacityProviderSpecForProviderAutoScalingGroupProvider {
  /**
   * - ARN of the associated auto scaling group.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProvider#autoScalingGroupArn
   */
  readonly autoScalingGroupArn?: string;

  /**
   * Reference to a AutoscalingGroup in autoscaling to populate autoScalingGroupArn.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProvider#autoScalingGroupArnRef
   */
  readonly autoScalingGroupArnRef?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef;

  /**
   * Selector for a AutoscalingGroup in autoscaling to populate autoScalingGroupArn.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProvider#autoScalingGroupArnSelector
   */
  readonly autoScalingGroupArnSelector?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector;

  /**
   * - Configuration block defining the parameters of the auto scaling. Detailed below.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProvider#managedScaling
   */
  readonly managedScaling?: CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling[];

  /**
   * - Enables or disables container-aware termination of instances in the auto scaling group when scale-in happens. Valid values are ENABLED and DISABLED.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProvider#managedTerminationProtection
   */
  readonly managedTerminationProtection?: string;

}

/**
 * Converts an object of type 'CapacityProviderSpecForProviderAutoScalingGroupProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecForProviderAutoScalingGroupProvider(obj: CapacityProviderSpecForProviderAutoScalingGroupProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoScalingGroupArn': obj.autoScalingGroupArn,
    'autoScalingGroupArnRef': toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef(obj.autoScalingGroupArnRef),
    'autoScalingGroupArnSelector': toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector(obj.autoScalingGroupArnSelector),
    'managedScaling': obj.managedScaling?.map(y => toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling(y)),
    'managedTerminationProtection': obj.managedTerminationProtection,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CapacityProviderSpecInitProviderAutoScalingGroupProvider
 */
export interface CapacityProviderSpecInitProviderAutoScalingGroupProvider {
  /**
   * - Configuration block defining the parameters of the auto scaling. Detailed below.
   *
   * @schema CapacityProviderSpecInitProviderAutoScalingGroupProvider#managedScaling
   */
  readonly managedScaling?: CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling[];

  /**
   * - Enables or disables container-aware termination of instances in the auto scaling group when scale-in happens. Valid values are ENABLED and DISABLED.
   *
   * @schema CapacityProviderSpecInitProviderAutoScalingGroupProvider#managedTerminationProtection
   */
  readonly managedTerminationProtection?: string;

}

/**
 * Converts an object of type 'CapacityProviderSpecInitProviderAutoScalingGroupProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecInitProviderAutoScalingGroupProvider(obj: CapacityProviderSpecInitProviderAutoScalingGroupProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedScaling': obj.managedScaling?.map(y => toJson_CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling(y)),
    'managedTerminationProtection': obj.managedTerminationProtection,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CapacityProviderSpecProviderConfigRefPolicy
 */
export interface CapacityProviderSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CapacityProviderSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CapacityProviderSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CapacityProviderSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CapacityProviderSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CapacityProviderSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecProviderConfigRefPolicy(obj: CapacityProviderSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRef
 */
export interface CapacityProviderSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CapacityProviderSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecPublishConnectionDetailsToConfigRef(obj: CapacityProviderSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CapacityProviderSpecPublishConnectionDetailsToMetadata
 */
export interface CapacityProviderSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CapacityProviderSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecPublishConnectionDetailsToMetadata(obj: CapacityProviderSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AutoscalingGroup in autoscaling to populate autoScalingGroupArn.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef
 */
export interface CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef#policy
   */
  readonly policy?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy;

}

/**
 * Converts an object of type 'CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef(obj: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AutoscalingGroup in autoscaling to populate autoScalingGroupArn.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector
 */
export interface CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector#policy
   */
  readonly policy?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector(obj: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling
 */
export interface CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling {
  /**
   * Period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of 300 seconds is used.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling#instanceWarmupPeriod
   */
  readonly instanceWarmupPeriod?: number;

  /**
   * Maximum step adjustment size. A number between 1 and 10,000.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling#maximumScalingStepSize
   */
  readonly maximumScalingStepSize?: number;

  /**
   * Minimum step adjustment size. A number between 1 and 10,000.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling#minimumScalingStepSize
   */
  readonly minimumScalingStepSize?: number;

  /**
   * Whether auto scaling is managed by ECS. Valid values are ENABLED and DISABLED.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling#status
   */
  readonly status?: string;

  /**
   * Target utilization for the capacity provider. A number between 1 and 100.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling#targetCapacity
   */
  readonly targetCapacity?: number;

}

/**
 * Converts an object of type 'CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling(obj: CapacityProviderSpecForProviderAutoScalingGroupProviderManagedScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceWarmupPeriod': obj.instanceWarmupPeriod,
    'maximumScalingStepSize': obj.maximumScalingStepSize,
    'minimumScalingStepSize': obj.minimumScalingStepSize,
    'status': obj.status,
    'targetCapacity': obj.targetCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling
 */
export interface CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling {
  /**
   * Period of time, in seconds, after a newly launched Amazon EC2 instance can contribute to CloudWatch metrics for Auto Scaling group. If this parameter is omitted, the default value of 300 seconds is used.
   *
   * @schema CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling#instanceWarmupPeriod
   */
  readonly instanceWarmupPeriod?: number;

  /**
   * Maximum step adjustment size. A number between 1 and 10,000.
   *
   * @schema CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling#maximumScalingStepSize
   */
  readonly maximumScalingStepSize?: number;

  /**
   * Minimum step adjustment size. A number between 1 and 10,000.
   *
   * @schema CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling#minimumScalingStepSize
   */
  readonly minimumScalingStepSize?: number;

  /**
   * Whether auto scaling is managed by ECS. Valid values are ENABLED and DISABLED.
   *
   * @schema CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling#status
   */
  readonly status?: string;

  /**
   * Target utilization for the capacity provider. A number between 1 and 100.
   *
   * @schema CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling#targetCapacity
   */
  readonly targetCapacity?: number;

}

/**
 * Converts an object of type 'CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling(obj: CapacityProviderSpecInitProviderAutoScalingGroupProviderManagedScaling | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceWarmupPeriod': obj.instanceWarmupPeriod,
    'maximumScalingStepSize': obj.maximumScalingStepSize,
    'minimumScalingStepSize': obj.minimumScalingStepSize,
    'status': obj.status,
    'targetCapacity': obj.targetCapacity,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CapacityProviderSpecProviderConfigRefPolicyResolution
 */
export enum CapacityProviderSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CapacityProviderSpecProviderConfigRefPolicyResolve
 */
export enum CapacityProviderSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy(obj: CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy
 */
export interface CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy#resolution
   */
  readonly resolution?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy#resolve
   */
  readonly resolve?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy(obj: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy
 */
export interface CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy(obj: CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CapacityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicyResolution
 */
export enum CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicyResolve
 */
export enum CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicyResolution
 */
export enum CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicyResolve
 */
export enum CapacityProviderSpecForProviderAutoScalingGroupProviderAutoScalingGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Cluster is the Schema for the Clusters API. Provides an ECS cluster.
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Provides an ECS cluster.
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterSpec#initProvider
   */
  readonly initProvider?: ClusterSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * The execute command configuration for the cluster. Detailed below.
   *
   * @schema ClusterSpecForProvider#configuration
   */
  readonly configuration?: ClusterSpecForProviderConfiguration[];

  /**
   * Configuration block for capacity provider strategy to use by default for the cluster. Can be one or more. Detailed below.
   *
   * @schema ClusterSpecForProvider#defaultCapacityProviderStrategy
   */
  readonly defaultCapacityProviderStrategy?: ClusterSpecForProviderDefaultCapacityProviderStrategy[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configures a default Service Connect namespace. Detailed below.
   *
   * @schema ClusterSpecForProvider#serviceConnectDefaults
   */
  readonly serviceConnectDefaults?: ClusterSpecForProviderServiceConnectDefaults[];

  /**
   * Configuration block(s) with cluster settings. For example, this can be used to enable CloudWatch Container Insights for a cluster. Detailed below.
   *
   * @schema ClusterSpecForProvider#setting
   */
  readonly setting?: ClusterSpecForProviderSetting[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration?.map(y => toJson_ClusterSpecForProviderConfiguration(y)),
    'defaultCapacityProviderStrategy': obj.defaultCapacityProviderStrategy?.map(y => toJson_ClusterSpecForProviderDefaultCapacityProviderStrategy(y)),
    'region': obj.region,
    'serviceConnectDefaults': obj.serviceConnectDefaults?.map(y => toJson_ClusterSpecForProviderServiceConnectDefaults(y)),
    'setting': obj.setting?.map(y => toJson_ClusterSpecForProviderSetting(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterSpecInitProvider
 */
export interface ClusterSpecInitProvider {
  /**
   * The execute command configuration for the cluster. Detailed below.
   *
   * @schema ClusterSpecInitProvider#configuration
   */
  readonly configuration?: ClusterSpecInitProviderConfiguration[];

  /**
   * Configuration block for capacity provider strategy to use by default for the cluster. Can be one or more. Detailed below.
   *
   * @schema ClusterSpecInitProvider#defaultCapacityProviderStrategy
   */
  readonly defaultCapacityProviderStrategy?: ClusterSpecInitProviderDefaultCapacityProviderStrategy[];

  /**
   * Configures a default Service Connect namespace. Detailed below.
   *
   * @schema ClusterSpecInitProvider#serviceConnectDefaults
   */
  readonly serviceConnectDefaults?: ClusterSpecInitProviderServiceConnectDefaults[];

  /**
   * Configuration block(s) with cluster settings. For example, this can be used to enable CloudWatch Container Insights for a cluster. Detailed below.
   *
   * @schema ClusterSpecInitProvider#setting
   */
  readonly setting?: ClusterSpecInitProviderSetting[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProvider(obj: ClusterSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration?.map(y => toJson_ClusterSpecInitProviderConfiguration(y)),
    'defaultCapacityProviderStrategy': obj.defaultCapacityProviderStrategy?.map(y => toJson_ClusterSpecInitProviderDefaultCapacityProviderStrategy(y)),
    'serviceConnectDefaults': obj.serviceConnectDefaults?.map(y => toJson_ClusterSpecInitProviderServiceConnectDefaults(y)),
    'setting': obj.setting?.map(y => toJson_ClusterSpecInitProviderSetting(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterSpecManagementPolicies
 */
export enum ClusterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderConfiguration
 */
export interface ClusterSpecForProviderConfiguration {
  /**
   * The details of the execute command configuration. Detailed below.
   *
   * @schema ClusterSpecForProviderConfiguration#executeCommandConfiguration
   */
  readonly executeCommandConfiguration?: ClusterSpecForProviderConfigurationExecuteCommandConfiguration[];

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfiguration(obj: ClusterSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executeCommandConfiguration': obj.executeCommandConfiguration?.map(y => toJson_ClusterSpecForProviderConfigurationExecuteCommandConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy
 */
export interface ClusterSpecForProviderDefaultCapacityProviderStrategy {
  /**
   * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
   *
   * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * The short name of the capacity provider.
   *
   * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * The relative percentage of the total number of launched tasks that should use the specified capacity provider.
   *
   * @schema ClusterSpecForProviderDefaultCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProviderDefaultCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderDefaultCapacityProviderStrategy(obj: ClusterSpecForProviderDefaultCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderServiceConnectDefaults
 */
export interface ClusterSpecForProviderServiceConnectDefaults {
  /**
   * The ARN of the aws_service_discovery_http_namespace that's used when you create a service and don't specify a Service Connect configuration.
   *
   * @schema ClusterSpecForProviderServiceConnectDefaults#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderServiceConnectDefaults' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderServiceConnectDefaults(obj: ClusterSpecForProviderServiceConnectDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderSetting
 */
export interface ClusterSpecForProviderSetting {
  /**
   * Name of the setting to manage. Valid values: containerInsights.
   *
   * @schema ClusterSpecForProviderSetting#name
   */
  readonly name?: string;

  /**
   * The value to assign to the setting. Valid values are enabled and disabled.
   *
   * @schema ClusterSpecForProviderSetting#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderSetting(obj: ClusterSpecForProviderSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderConfiguration
 */
export interface ClusterSpecInitProviderConfiguration {
  /**
   * The details of the execute command configuration. Detailed below.
   *
   * @schema ClusterSpecInitProviderConfiguration#executeCommandConfiguration
   */
  readonly executeCommandConfiguration?: ClusterSpecInitProviderConfigurationExecuteCommandConfiguration[];

}

/**
 * Converts an object of type 'ClusterSpecInitProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderConfiguration(obj: ClusterSpecInitProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'executeCommandConfiguration': obj.executeCommandConfiguration?.map(y => toJson_ClusterSpecInitProviderConfigurationExecuteCommandConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderDefaultCapacityProviderStrategy
 */
export interface ClusterSpecInitProviderDefaultCapacityProviderStrategy {
  /**
   * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
   *
   * @schema ClusterSpecInitProviderDefaultCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * The short name of the capacity provider.
   *
   * @schema ClusterSpecInitProviderDefaultCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * The relative percentage of the total number of launched tasks that should use the specified capacity provider.
   *
   * @schema ClusterSpecInitProviderDefaultCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderDefaultCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderDefaultCapacityProviderStrategy(obj: ClusterSpecInitProviderDefaultCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderServiceConnectDefaults
 */
export interface ClusterSpecInitProviderServiceConnectDefaults {
  /**
   * The ARN of the aws_service_discovery_http_namespace that's used when you create a service and don't specify a Service Connect configuration.
   *
   * @schema ClusterSpecInitProviderServiceConnectDefaults#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderServiceConnectDefaults' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderServiceConnectDefaults(obj: ClusterSpecInitProviderServiceConnectDefaults | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderSetting
 */
export interface ClusterSpecInitProviderSetting {
  /**
   * Name of the setting to manage. Valid values: containerInsights.
   *
   * @schema ClusterSpecInitProviderSetting#name
   */
  readonly name?: string;

  /**
   * The value to assign to the setting. Valid values are enabled and disabled.
   *
   * @schema ClusterSpecInitProviderSetting#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderSetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderSetting(obj: ClusterSpecInitProviderSetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration
 */
export interface ClusterSpecForProviderConfigurationExecuteCommandConfiguration {
  /**
   * The AWS Key Management Service key ID to encrypt the data between the local client and the container.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * The log configuration for the results of the execute command actions Required when logging is OVERRIDE. Detailed below.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration#logConfiguration
   */
  readonly logConfiguration?: ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration[];

  /**
   * The log setting to use for redirecting logs for your execute command results. Valid values are NONE, DEFAULT, and OVERRIDE.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfiguration#logging
   */
  readonly logging?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationExecuteCommandConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationExecuteCommandConfiguration(obj: ClusterSpecForProviderConfigurationExecuteCommandConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'logConfiguration': obj.logConfiguration?.map(y => toJson_ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration(y)),
    'logging': obj.logging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfiguration
 */
export interface ClusterSpecInitProviderConfigurationExecuteCommandConfiguration {
  /**
   * The AWS Key Management Service key ID to encrypt the data between the local client and the container.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfiguration#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * The log configuration for the results of the execute command actions Required when logging is OVERRIDE. Detailed below.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfiguration#logConfiguration
   */
  readonly logConfiguration?: ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration[];

  /**
   * The log setting to use for redirecting logs for your execute command results. Valid values are NONE, DEFAULT, and OVERRIDE.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfiguration#logging
   */
  readonly logging?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderConfigurationExecuteCommandConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderConfigurationExecuteCommandConfiguration(obj: ClusterSpecInitProviderConfigurationExecuteCommandConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKeyId': obj.kmsKeyId,
    'logConfiguration': obj.logConfiguration?.map(y => toJson_ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration(y)),
    'logging': obj.logging,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration
 */
export interface ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration {
  /**
   * Whether or not to enable encryption on the CloudWatch logs. If not specified, encryption will be disabled.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#cloudWatchEncryptionEnabled
   */
  readonly cloudWatchEncryptionEnabled?: boolean;

  /**
   * The name of the CloudWatch log group to send logs to.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#cloudWatchLogGroupName
   */
  readonly cloudWatchLogGroupName?: string;

  /**
   * Whether or not to enable encryption on the logs sent to S3. If not specified, encryption will be disabled.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3BucketEncryptionEnabled
   */
  readonly s3BucketEncryptionEnabled?: boolean;

  /**
   * The name of the S3 bucket to send logs to.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * An optional folder in the S3 bucket to place logs in.
   *
   * @schema ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration(obj: ClusterSpecForProviderConfigurationExecuteCommandConfigurationLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchEncryptionEnabled': obj.cloudWatchEncryptionEnabled,
    'cloudWatchLogGroupName': obj.cloudWatchLogGroupName,
    's3BucketEncryptionEnabled': obj.s3BucketEncryptionEnabled,
    's3BucketName': obj.s3BucketName,
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration
 */
export interface ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration {
  /**
   * Whether or not to enable encryption on the CloudWatch logs. If not specified, encryption will be disabled.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration#cloudWatchEncryptionEnabled
   */
  readonly cloudWatchEncryptionEnabled?: boolean;

  /**
   * The name of the CloudWatch log group to send logs to.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration#cloudWatchLogGroupName
   */
  readonly cloudWatchLogGroupName?: string;

  /**
   * Whether or not to enable encryption on the logs sent to S3. If not specified, encryption will be disabled.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3BucketEncryptionEnabled
   */
  readonly s3BucketEncryptionEnabled?: boolean;

  /**
   * The name of the S3 bucket to send logs to.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3BucketName
   */
  readonly s3BucketName?: string;

  /**
   * An optional folder in the S3 bucket to place logs in.
   *
   * @schema ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

}

/**
 * Converts an object of type 'ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration(obj: ClusterSpecInitProviderConfigurationExecuteCommandConfigurationLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchEncryptionEnabled': obj.cloudWatchEncryptionEnabled,
    'cloudWatchLogGroupName': obj.cloudWatchLogGroupName,
    's3BucketEncryptionEnabled': obj.s3BucketEncryptionEnabled,
    's3BucketName': obj.s3BucketName,
    's3KeyPrefix': obj.s3KeyPrefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterCapacityProviders is the Schema for the ClusterCapacityProviderss API. Provides an ECS cluster capacity providers resource.
 *
 * @schema ClusterCapacityProviders
 */
export class ClusterCapacityProviders extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterCapacityProviders"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.upbound.io/v1beta1',
    kind: 'ClusterCapacityProviders',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterCapacityProviders".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterCapacityProvidersProps): any {
    return {
      ...ClusterCapacityProviders.GVK,
      ...toJson_ClusterCapacityProvidersProps(props),
    };
  }

  /**
   * Defines a "ClusterCapacityProviders" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterCapacityProvidersProps) {
    super(scope, id, {
      ...ClusterCapacityProviders.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterCapacityProviders.GVK,
      ...toJson_ClusterCapacityProvidersProps(resolved),
    };
  }
}

/**
 * ClusterCapacityProviders is the Schema for the ClusterCapacityProviderss API. Provides an ECS cluster capacity providers resource.
 *
 * @schema ClusterCapacityProviders
 */
export interface ClusterCapacityProvidersProps {
  /**
   * @schema ClusterCapacityProviders#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterCapacityProvidersSpec defines the desired state of ClusterCapacityProviders
   *
   * @schema ClusterCapacityProviders#spec
   */
  readonly spec: ClusterCapacityProvidersSpec;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersProps(obj: ClusterCapacityProvidersProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterCapacityProvidersSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterCapacityProvidersSpec defines the desired state of ClusterCapacityProviders
 *
 * @schema ClusterCapacityProvidersSpec
 */
export interface ClusterCapacityProvidersSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ClusterCapacityProvidersSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterCapacityProvidersSpecDeletionPolicy;

  /**
   * @schema ClusterCapacityProvidersSpec#forProvider
   */
  readonly forProvider: ClusterCapacityProvidersSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ClusterCapacityProvidersSpec#initProvider
   */
  readonly initProvider?: ClusterCapacityProvidersSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ClusterCapacityProvidersSpec#managementPolicies
   */
  readonly managementPolicies?: ClusterCapacityProvidersSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterCapacityProvidersSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterCapacityProvidersSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterCapacityProvidersSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterCapacityProvidersSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterCapacityProvidersSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterCapacityProvidersSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpec(obj: ClusterCapacityProvidersSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterCapacityProvidersSpecForProvider(obj.forProvider),
    'initProvider': toJson_ClusterCapacityProvidersSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ClusterCapacityProvidersSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterCapacityProvidersSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ClusterCapacityProvidersSpecDeletionPolicy
 */
export enum ClusterCapacityProvidersSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterCapacityProvidersSpecForProvider
 */
export interface ClusterCapacityProvidersSpecForProvider {
  /**
   * Set of names of one or more capacity providers to associate with the cluster. Valid values also include FARGATE and FARGATE_SPOT.
   *
   * @schema ClusterCapacityProvidersSpecForProvider#capacityProviders
   */
  readonly capacityProviders?: string[];

  /**
   * Name of the ECS cluster to manage capacity providers for.
   *
   * @schema ClusterCapacityProvidersSpecForProvider#clusterName
   */
  readonly clusterName?: string;

  /**
   * Reference to a Cluster in ecs to populate clusterName.
   *
   * @schema ClusterCapacityProvidersSpecForProvider#clusterNameRef
   */
  readonly clusterNameRef?: ClusterCapacityProvidersSpecForProviderClusterNameRef;

  /**
   * Selector for a Cluster in ecs to populate clusterName.
   *
   * @schema ClusterCapacityProvidersSpecForProvider#clusterNameSelector
   */
  readonly clusterNameSelector?: ClusterCapacityProvidersSpecForProviderClusterNameSelector;

  /**
   * Set of capacity provider strategies to use by default for the cluster. Detailed below.
   *
   * @schema ClusterCapacityProvidersSpecForProvider#defaultCapacityProviderStrategy
   */
  readonly defaultCapacityProviderStrategy?: ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterCapacityProvidersSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecForProvider(obj: ClusterCapacityProvidersSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityProviders': obj.capacityProviders?.map(y => y),
    'clusterName': obj.clusterName,
    'clusterNameRef': toJson_ClusterCapacityProvidersSpecForProviderClusterNameRef(obj.clusterNameRef),
    'clusterNameSelector': toJson_ClusterCapacityProvidersSpecForProviderClusterNameSelector(obj.clusterNameSelector),
    'defaultCapacityProviderStrategy': obj.defaultCapacityProviderStrategy?.map(y => toJson_ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ClusterCapacityProvidersSpecInitProvider
 */
export interface ClusterCapacityProvidersSpecInitProvider {
  /**
   * Set of names of one or more capacity providers to associate with the cluster. Valid values also include FARGATE and FARGATE_SPOT.
   *
   * @schema ClusterCapacityProvidersSpecInitProvider#capacityProviders
   */
  readonly capacityProviders?: string[];

  /**
   * Set of capacity provider strategies to use by default for the cluster. Detailed below.
   *
   * @schema ClusterCapacityProvidersSpecInitProvider#defaultCapacityProviderStrategy
   */
  readonly defaultCapacityProviderStrategy?: ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy[];

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecInitProvider(obj: ClusterCapacityProvidersSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capacityProviders': obj.capacityProviders?.map(y => y),
    'defaultCapacityProviderStrategy': obj.defaultCapacityProviderStrategy?.map(y => toJson_ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ClusterCapacityProvidersSpecManagementPolicies
 */
export enum ClusterCapacityProvidersSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterCapacityProvidersSpecProviderConfigRef
 */
export interface ClusterCapacityProvidersSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterCapacityProvidersSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterCapacityProvidersSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterCapacityProvidersSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecProviderConfigRef(obj: ClusterCapacityProvidersSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterCapacityProvidersSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsTo
 */
export interface ClusterCapacityProvidersSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsTo(obj: ClusterCapacityProvidersSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterCapacityProvidersSpecWriteConnectionSecretToRef
 */
export interface ClusterCapacityProvidersSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterCapacityProvidersSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterCapacityProvidersSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecWriteConnectionSecretToRef(obj: ClusterCapacityProvidersSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in ecs to populate clusterName.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameRef
 */
export interface ClusterCapacityProvidersSpecForProviderClusterNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameRef#policy
   */
  readonly policy?: ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecForProviderClusterNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecForProviderClusterNameRef(obj: ClusterCapacityProvidersSpecForProviderClusterNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in ecs to populate clusterName.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelector
 */
export interface ClusterCapacityProvidersSpecForProviderClusterNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelector#policy
   */
  readonly policy?: ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecForProviderClusterNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecForProviderClusterNameSelector(obj: ClusterCapacityProvidersSpecForProviderClusterNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy
 */
export interface ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy {
  /**
   * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * Name of the capacity provider.
   *
   * @schema ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * The relative percentage of the total number of launched tasks that should use the specified capacity provider. The weight value is taken into consideration after the base count of tasks has been satisfied. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy(obj: ClusterCapacityProvidersSpecForProviderDefaultCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy
 */
export interface ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy {
  /**
   * The number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * Name of the capacity provider.
   *
   * @schema ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * The relative percentage of the total number of launched tasks that should use the specified capacity provider. The weight value is taken into consideration after the base count of tasks has been satisfied. Defaults to 0.
   *
   * @default 0.
   * @schema ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy(obj: ClusterCapacityProvidersSpecInitProviderDefaultCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterCapacityProvidersSpecProviderConfigRefPolicy
 */
export interface ClusterCapacityProvidersSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterCapacityProvidersSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterCapacityProvidersSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterCapacityProvidersSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterCapacityProvidersSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecProviderConfigRefPolicy(obj: ClusterCapacityProvidersSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef(obj: ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata(obj: ClusterCapacityProvidersSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy
 */
export interface ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy#resolution
   */
  readonly resolution?: ClusterCapacityProvidersSpecForProviderClusterNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy#resolve
   */
  readonly resolve?: ClusterCapacityProvidersSpecForProviderClusterNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy(obj: ClusterCapacityProvidersSpecForProviderClusterNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy
 */
export interface ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy#resolution
   */
  readonly resolution?: ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy#resolve
   */
  readonly resolve?: ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy(obj: ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterCapacityProvidersSpecProviderConfigRefPolicyResolution
 */
export enum ClusterCapacityProvidersSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterCapacityProvidersSpecProviderConfigRefPolicyResolve
 */
export enum ClusterCapacityProvidersSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameRefPolicyResolution
 */
export enum ClusterCapacityProvidersSpecForProviderClusterNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameRefPolicyResolve
 */
export enum ClusterCapacityProvidersSpecForProviderClusterNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicyResolution
 */
export enum ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicyResolve
 */
export enum ClusterCapacityProvidersSpecForProviderClusterNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterCapacityProvidersSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Service is the Schema for the Services API. Provides an ECS service.
 *
 * @schema Service
 */
export class Service extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Service"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.upbound.io/v1beta1',
    kind: 'Service',
  }

  /**
   * Renders a Kubernetes manifest for "Service".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceProps): any {
    return {
      ...Service.GVK,
      ...toJson_ServiceProps(props),
    };
  }

  /**
   * Defines a "Service" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceProps) {
    super(scope, id, {
      ...Service.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Service.GVK,
      ...toJson_ServiceProps(resolved),
    };
  }
}

/**
 * Service is the Schema for the Services API. Provides an ECS service.
 *
 * @schema Service
 */
export interface ServiceProps {
  /**
   * @schema Service#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSpec defines the desired state of Service
   *
   * @schema Service#spec
   */
  readonly spec: ServiceSpec;

}

/**
 * Converts an object of type 'ServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceProps(obj: ServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSpec defines the desired state of Service
 *
 * @schema ServiceSpec
 */
export interface ServiceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSpecDeletionPolicy;

  /**
   * @schema ServiceSpec#forProvider
   */
  readonly forProvider: ServiceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ServiceSpec#initProvider
   */
  readonly initProvider?: ServiceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ServiceSpec#managementPolicies
   */
  readonly managementPolicies?: ServiceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpec(obj: ServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSpecForProvider(obj.forProvider),
    'initProvider': toJson_ServiceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ServiceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ServiceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSpecDeletionPolicy
 */
export enum ServiceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceSpecForProvider
 */
export interface ServiceSpecForProvider {
  /**
   * Information about the CloudWatch alarms. See below.
   *
   * @schema ServiceSpecForProvider#alarms
   */
  readonly alarms?: ServiceSpecForProviderAlarms[];

  /**
   * Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below.
   *
   * @schema ServiceSpecForProvider#capacityProviderStrategy
   */
  readonly capacityProviderStrategy?: ServiceSpecForProviderCapacityProviderStrategy[];

  /**
   * Name of an ECS cluster.
   *
   * @schema ServiceSpecForProvider#cluster
   */
  readonly cluster?: string;

  /**
   * Reference to a Cluster to populate cluster.
   *
   * @schema ServiceSpecForProvider#clusterRef
   */
  readonly clusterRef?: ServiceSpecForProviderClusterRef;

  /**
   * Selector for a Cluster to populate cluster.
   *
   * @schema ServiceSpecForProvider#clusterSelector
   */
  readonly clusterSelector?: ServiceSpecForProviderClusterSelector;

  /**
   * Configuration block for deployment circuit breaker. See below.
   *
   * @schema ServiceSpecForProvider#deploymentCircuitBreaker
   */
  readonly deploymentCircuitBreaker?: ServiceSpecForProviderDeploymentCircuitBreaker[];

  /**
   * Configuration block for deployment controller configuration. See below.
   *
   * @schema ServiceSpecForProvider#deploymentController
   */
  readonly deploymentController?: ServiceSpecForProviderDeploymentController[];

  /**
   * Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
   *
   * @schema ServiceSpecForProvider#deploymentMaximumPercent
   */
  readonly deploymentMaximumPercent?: number;

  /**
   * Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
   *
   * @schema ServiceSpecForProvider#deploymentMinimumHealthyPercent
   */
  readonly deploymentMinimumHealthyPercent?: number;

  /**
   * Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
   *
   * @default 0. Do not specify if using the DAEMON scheduling strategy.
   * @schema ServiceSpecForProvider#desiredCount
   */
  readonly desiredCount?: number;

  /**
   * Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
   *
   * @schema ServiceSpecForProvider#enableEcsManagedTags
   */
  readonly enableEcsManagedTags?: boolean;

  /**
   * Specifies whether to enable Amazon ECS Exec for the tasks within the service.
   *
   * @schema ServiceSpecForProvider#enableExecuteCommand
   */
  readonly enableExecuteCommand?: boolean;

  /**
   * Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
   *
   * @schema ServiceSpecForProvider#forceNewDeployment
   */
  readonly forceNewDeployment?: boolean;

  /**
   * Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
   *
   * @schema ServiceSpecForProvider#healthCheckGracePeriodSeconds
   */
  readonly healthCheckGracePeriodSeconds?: number;

  /**
   * ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the awsvpc network mode. If using awsvpc network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
   *
   * @schema ServiceSpecForProvider#iamRole
   */
  readonly iamRole?: string;

  /**
   * Reference to a Role in iam to populate iamRole.
   *
   * @schema ServiceSpecForProvider#iamRoleRef
   */
  readonly iamRoleRef?: ServiceSpecForProviderIamRoleRef;

  /**
   * Selector for a Role in iam to populate iamRole.
   *
   * @schema ServiceSpecForProvider#iamRoleSelector
   */
  readonly iamRoleSelector?: ServiceSpecForProviderIamRoleSelector;

  /**
   * Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2.
   *
   * @default EC2.
   * @schema ServiceSpecForProvider#launchType
   */
  readonly launchType?: string;

  /**
   * Configuration block for load balancers. See below.
   *
   * @schema ServiceSpecForProvider#loadBalancer
   */
  readonly loadBalancer?: ServiceSpecForProviderLoadBalancer[];

  /**
   * Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
   *
   * @schema ServiceSpecForProvider#networkConfiguration
   */
  readonly networkConfiguration?: ServiceSpecForProviderNetworkConfiguration[];

  /**
   * Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
   *
   * @schema ServiceSpecForProvider#orderedPlacementStrategy
   */
  readonly orderedPlacementStrategy?: ServiceSpecForProviderOrderedPlacementStrategy[];

  /**
   * Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
   *
   * @schema ServiceSpecForProvider#placementConstraints
   */
  readonly placementConstraints?: ServiceSpecForProviderPlacementConstraints[];

  /**
   * Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
   *
   * @default LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
   * @schema ServiceSpecForProvider#platformVersion
   */
  readonly platformVersion?: string;

  /**
   * Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
   *
   * @schema ServiceSpecForProvider#propagateTags
   */
  readonly propagateTags?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ServiceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
   *
   * @default REPLICA. Note that Tasks using the Fargate launch type or the .
   * @schema ServiceSpecForProvider#schedulingStrategy
   */
  readonly schedulingStrategy?: string;

  /**
   * The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
   *
   * @schema ServiceSpecForProvider#serviceConnectConfiguration
   */
  readonly serviceConnectConfiguration?: ServiceSpecForProviderServiceConnectConfiguration[];

  /**
   * Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
   *
   * @schema ServiceSpecForProvider#serviceRegistries
   */
  readonly serviceRegistries?: ServiceSpecForProviderServiceRegistries[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ServiceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Family and revision (family:revision) or full ARN of the task definition that you want to run in your service. Required unless using the EXTERNAL deployment controller. If a revision is not specified, the latest ACTIVE revision is used.
   *
   * @schema ServiceSpecForProvider#taskDefinition
   */
  readonly taskDefinition?: string;

  /**
   * Reference to a TaskDefinition to populate taskDefinition.
   *
   * @schema ServiceSpecForProvider#taskDefinitionRef
   */
  readonly taskDefinitionRef?: ServiceSpecForProviderTaskDefinitionRef;

  /**
   * Selector for a TaskDefinition to populate taskDefinition.
   *
   * @schema ServiceSpecForProvider#taskDefinitionSelector
   */
  readonly taskDefinitionSelector?: ServiceSpecForProviderTaskDefinitionSelector;

  /**
   * Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with timestamp(). See example above.
   *
   * @schema ServiceSpecForProvider#triggers
   */
  readonly triggers?: { [key: string]: string };

  /**
   * Default false.
   *
   * @schema ServiceSpecForProvider#waitForSteadyState
   */
  readonly waitForSteadyState?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProvider(obj: ServiceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => toJson_ServiceSpecForProviderAlarms(y)),
    'capacityProviderStrategy': obj.capacityProviderStrategy?.map(y => toJson_ServiceSpecForProviderCapacityProviderStrategy(y)),
    'cluster': obj.cluster,
    'clusterRef': toJson_ServiceSpecForProviderClusterRef(obj.clusterRef),
    'clusterSelector': toJson_ServiceSpecForProviderClusterSelector(obj.clusterSelector),
    'deploymentCircuitBreaker': obj.deploymentCircuitBreaker?.map(y => toJson_ServiceSpecForProviderDeploymentCircuitBreaker(y)),
    'deploymentController': obj.deploymentController?.map(y => toJson_ServiceSpecForProviderDeploymentController(y)),
    'deploymentMaximumPercent': obj.deploymentMaximumPercent,
    'deploymentMinimumHealthyPercent': obj.deploymentMinimumHealthyPercent,
    'desiredCount': obj.desiredCount,
    'enableEcsManagedTags': obj.enableEcsManagedTags,
    'enableExecuteCommand': obj.enableExecuteCommand,
    'forceNewDeployment': obj.forceNewDeployment,
    'healthCheckGracePeriodSeconds': obj.healthCheckGracePeriodSeconds,
    'iamRole': obj.iamRole,
    'iamRoleRef': toJson_ServiceSpecForProviderIamRoleRef(obj.iamRoleRef),
    'iamRoleSelector': toJson_ServiceSpecForProviderIamRoleSelector(obj.iamRoleSelector),
    'launchType': obj.launchType,
    'loadBalancer': obj.loadBalancer?.map(y => toJson_ServiceSpecForProviderLoadBalancer(y)),
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_ServiceSpecForProviderNetworkConfiguration(y)),
    'orderedPlacementStrategy': obj.orderedPlacementStrategy?.map(y => toJson_ServiceSpecForProviderOrderedPlacementStrategy(y)),
    'placementConstraints': obj.placementConstraints?.map(y => toJson_ServiceSpecForProviderPlacementConstraints(y)),
    'platformVersion': obj.platformVersion,
    'propagateTags': obj.propagateTags,
    'region': obj.region,
    'schedulingStrategy': obj.schedulingStrategy,
    'serviceConnectConfiguration': obj.serviceConnectConfiguration?.map(y => toJson_ServiceSpecForProviderServiceConnectConfiguration(y)),
    'serviceRegistries': obj.serviceRegistries?.map(y => toJson_ServiceSpecForProviderServiceRegistries(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taskDefinition': obj.taskDefinition,
    'taskDefinitionRef': toJson_ServiceSpecForProviderTaskDefinitionRef(obj.taskDefinitionRef),
    'taskDefinitionSelector': toJson_ServiceSpecForProviderTaskDefinitionSelector(obj.taskDefinitionSelector),
    'triggers': ((obj.triggers) === undefined) ? undefined : (Object.entries(obj.triggers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'waitForSteadyState': obj.waitForSteadyState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ServiceSpecInitProvider
 */
export interface ServiceSpecInitProvider {
  /**
   * Information about the CloudWatch alarms. See below.
   *
   * @schema ServiceSpecInitProvider#alarms
   */
  readonly alarms?: ServiceSpecInitProviderAlarms[];

  /**
   * Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if force_new_deployment = true and not changing from 0 capacity_provider_strategy blocks to greater than 0, or vice versa. See below.
   *
   * @schema ServiceSpecInitProvider#capacityProviderStrategy
   */
  readonly capacityProviderStrategy?: ServiceSpecInitProviderCapacityProviderStrategy[];

  /**
   * Configuration block for deployment circuit breaker. See below.
   *
   * @schema ServiceSpecInitProvider#deploymentCircuitBreaker
   */
  readonly deploymentCircuitBreaker?: ServiceSpecInitProviderDeploymentCircuitBreaker[];

  /**
   * Configuration block for deployment controller configuration. See below.
   *
   * @schema ServiceSpecInitProvider#deploymentController
   */
  readonly deploymentController?: ServiceSpecInitProviderDeploymentController[];

  /**
   * Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the DAEMON scheduling strategy.
   *
   * @schema ServiceSpecInitProvider#deploymentMaximumPercent
   */
  readonly deploymentMaximumPercent?: number;

  /**
   * Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
   *
   * @schema ServiceSpecInitProvider#deploymentMinimumHealthyPercent
   */
  readonly deploymentMinimumHealthyPercent?: number;

  /**
   * Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the DAEMON scheduling strategy.
   *
   * @default 0. Do not specify if using the DAEMON scheduling strategy.
   * @schema ServiceSpecInitProvider#desiredCount
   */
  readonly desiredCount?: number;

  /**
   * Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
   *
   * @schema ServiceSpecInitProvider#enableEcsManagedTags
   */
  readonly enableEcsManagedTags?: boolean;

  /**
   * Specifies whether to enable Amazon ECS Exec for the tasks within the service.
   *
   * @schema ServiceSpecInitProvider#enableExecuteCommand
   */
  readonly enableExecuteCommand?: boolean;

  /**
   * Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., myimage:latest), roll Fargate tasks onto a newer platform version, or immediately deploy ordered_placement_strategy and placement_constraints updates.
   *
   * @schema ServiceSpecInitProvider#forceNewDeployment
   */
  readonly forceNewDeployment?: boolean;

  /**
   * Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
   *
   * @schema ServiceSpecInitProvider#healthCheckGracePeriodSeconds
   */
  readonly healthCheckGracePeriodSeconds?: number;

  /**
   * Launch type on which to run your service. The valid values are EC2, FARGATE, and EXTERNAL. Defaults to EC2.
   *
   * @default EC2.
   * @schema ServiceSpecInitProvider#launchType
   */
  readonly launchType?: string;

  /**
   * Configuration block for load balancers. See below.
   *
   * @schema ServiceSpecInitProvider#loadBalancer
   */
  readonly loadBalancer?: ServiceSpecInitProviderLoadBalancer[];

  /**
   * Network configuration for the service. This parameter is required for task definitions that use the awsvpc network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
   *
   * @schema ServiceSpecInitProvider#networkConfiguration
   */
  readonly networkConfiguration?: ServiceSpecInitProviderNetworkConfiguration[];

  /**
   * Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. The maximum number of ordered_placement_strategy blocks is 5. See below.
   *
   * @schema ServiceSpecInitProvider#orderedPlacementStrategy
   */
  readonly orderedPlacementStrategy?: ServiceSpecInitProviderOrderedPlacementStrategy[];

  /**
   * Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless force_new_deployment is enabled. Maximum number of placement_constraints is 10. See below.
   *
   * @schema ServiceSpecInitProvider#placementConstraints
   */
  readonly placementConstraints?: ServiceSpecInitProviderPlacementConstraints[];

  /**
   * Platform version on which to run your service. Only applicable for launch_type set to FARGATE. Defaults to LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
   *
   * @default LATEST. More information about Fargate platform versions can be found in the AWS ECS User Guide.
   * @schema ServiceSpecInitProvider#platformVersion
   */
  readonly platformVersion?: string;

  /**
   * Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are SERVICE and TASK_DEFINITION.
   *
   * @schema ServiceSpecInitProvider#propagateTags
   */
  readonly propagateTags?: string;

  /**
   * Scheduling strategy to use for the service. The valid values are REPLICA and DAEMON. Defaults to REPLICA. Note that Tasks using the Fargate launch type or the .
   *
   * @default REPLICA. Note that Tasks using the Fargate launch type or the .
   * @schema ServiceSpecInitProvider#schedulingStrategy
   */
  readonly schedulingStrategy?: string;

  /**
   * The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
   *
   * @schema ServiceSpecInitProvider#serviceConnectConfiguration
   */
  readonly serviceConnectConfiguration?: ServiceSpecInitProviderServiceConnectConfiguration[];

  /**
   * Service discovery registries for the service. The maximum number of service_registries blocks is 1. See below.
   *
   * @schema ServiceSpecInitProvider#serviceRegistries
   */
  readonly serviceRegistries?: ServiceSpecInitProviderServiceRegistries[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ServiceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with timestamp(). See example above.
   *
   * @schema ServiceSpecInitProvider#triggers
   */
  readonly triggers?: { [key: string]: string };

  /**
   * Default false.
   *
   * @schema ServiceSpecInitProvider#waitForSteadyState
   */
  readonly waitForSteadyState?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProvider(obj: ServiceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarms': obj.alarms?.map(y => toJson_ServiceSpecInitProviderAlarms(y)),
    'capacityProviderStrategy': obj.capacityProviderStrategy?.map(y => toJson_ServiceSpecInitProviderCapacityProviderStrategy(y)),
    'deploymentCircuitBreaker': obj.deploymentCircuitBreaker?.map(y => toJson_ServiceSpecInitProviderDeploymentCircuitBreaker(y)),
    'deploymentController': obj.deploymentController?.map(y => toJson_ServiceSpecInitProviderDeploymentController(y)),
    'deploymentMaximumPercent': obj.deploymentMaximumPercent,
    'deploymentMinimumHealthyPercent': obj.deploymentMinimumHealthyPercent,
    'desiredCount': obj.desiredCount,
    'enableEcsManagedTags': obj.enableEcsManagedTags,
    'enableExecuteCommand': obj.enableExecuteCommand,
    'forceNewDeployment': obj.forceNewDeployment,
    'healthCheckGracePeriodSeconds': obj.healthCheckGracePeriodSeconds,
    'launchType': obj.launchType,
    'loadBalancer': obj.loadBalancer?.map(y => toJson_ServiceSpecInitProviderLoadBalancer(y)),
    'networkConfiguration': obj.networkConfiguration?.map(y => toJson_ServiceSpecInitProviderNetworkConfiguration(y)),
    'orderedPlacementStrategy': obj.orderedPlacementStrategy?.map(y => toJson_ServiceSpecInitProviderOrderedPlacementStrategy(y)),
    'placementConstraints': obj.placementConstraints?.map(y => toJson_ServiceSpecInitProviderPlacementConstraints(y)),
    'platformVersion': obj.platformVersion,
    'propagateTags': obj.propagateTags,
    'schedulingStrategy': obj.schedulingStrategy,
    'serviceConnectConfiguration': obj.serviceConnectConfiguration?.map(y => toJson_ServiceSpecInitProviderServiceConnectConfiguration(y)),
    'serviceRegistries': obj.serviceRegistries?.map(y => toJson_ServiceSpecInitProviderServiceRegistries(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'triggers': ((obj.triggers) === undefined) ? undefined : (Object.entries(obj.triggers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'waitForSteadyState': obj.waitForSteadyState,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ServiceSpecManagementPolicies
 */
export enum ServiceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSpecProviderConfigRef
 */
export interface ServiceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRef(obj: ServiceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSpecPublishConnectionDetailsTo
 */
export interface ServiceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsTo(obj: ServiceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSpecWriteConnectionSecretToRef
 */
export interface ServiceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecWriteConnectionSecretToRef(obj: ServiceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderAlarms
 */
export interface ServiceSpecForProviderAlarms {
  /**
   * One or more CloudWatch alarm names.
   *
   * @schema ServiceSpecForProviderAlarms#alarmNames
   */
  readonly alarmNames?: string[];

  /**
   * Determines whether to use the CloudWatch alarm option in the service deployment process.
   *
   * @schema ServiceSpecForProviderAlarms#enable
   */
  readonly enable?: boolean;

  /**
   * Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
   *
   * @schema ServiceSpecForProviderAlarms#rollback
   */
  readonly rollback?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderAlarms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderAlarms(obj: ServiceSpecForProviderAlarms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmNames': obj.alarmNames?.map(y => y),
    'enable': obj.enable,
    'rollback': obj.rollback,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderCapacityProviderStrategy
 */
export interface ServiceSpecForProviderCapacityProviderStrategy {
  /**
   * Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
   *
   * @schema ServiceSpecForProviderCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * Short name of the capacity provider.
   *
   * @schema ServiceSpecForProviderCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * Relative percentage of the total number of launched tasks that should use the specified capacity provider.
   *
   * @schema ServiceSpecForProviderCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderCapacityProviderStrategy(obj: ServiceSpecForProviderCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate cluster.
 *
 * @schema ServiceSpecForProviderClusterRef
 */
export interface ServiceSpecForProviderClusterRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderClusterRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderClusterRef#policy
   */
  readonly policy?: ServiceSpecForProviderClusterRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterRef(obj: ServiceSpecForProviderClusterRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderClusterRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate cluster.
 *
 * @schema ServiceSpecForProviderClusterSelector
 */
export interface ServiceSpecForProviderClusterSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderClusterSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderClusterSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderClusterSelector#policy
   */
  readonly policy?: ServiceSpecForProviderClusterSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterSelector(obj: ServiceSpecForProviderClusterSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderClusterSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderDeploymentCircuitBreaker
 */
export interface ServiceSpecForProviderDeploymentCircuitBreaker {
  /**
   * Whether to enable the deployment circuit breaker logic for the service.
   *
   * @schema ServiceSpecForProviderDeploymentCircuitBreaker#enable
   */
  readonly enable?: boolean;

  /**
   * Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
   *
   * @schema ServiceSpecForProviderDeploymentCircuitBreaker#rollback
   */
  readonly rollback?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDeploymentCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDeploymentCircuitBreaker(obj: ServiceSpecForProviderDeploymentCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'rollback': obj.rollback,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderDeploymentController
 */
export interface ServiceSpecForProviderDeploymentController {
  /**
   * Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
   *
   * @schema ServiceSpecForProviderDeploymentController#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderDeploymentController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderDeploymentController(obj: ServiceSpecForProviderDeploymentController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRole.
 *
 * @schema ServiceSpecForProviderIamRoleRef
 */
export interface ServiceSpecForProviderIamRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderIamRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderIamRoleRef#policy
   */
  readonly policy?: ServiceSpecForProviderIamRoleRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderIamRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderIamRoleRef(obj: ServiceSpecForProviderIamRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderIamRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRole.
 *
 * @schema ServiceSpecForProviderIamRoleSelector
 */
export interface ServiceSpecForProviderIamRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderIamRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderIamRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderIamRoleSelector#policy
   */
  readonly policy?: ServiceSpecForProviderIamRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderIamRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderIamRoleSelector(obj: ServiceSpecForProviderIamRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderIamRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderLoadBalancer
 */
export interface ServiceSpecForProviderLoadBalancer {
  /**
   * Name of the container to associate with the load balancer (as it appears in a container definition).
   *
   * @schema ServiceSpecForProviderLoadBalancer#containerName
   */
  readonly containerName?: string;

  /**
   * Port on the container to associate with the load balancer.
   *
   * @schema ServiceSpecForProviderLoadBalancer#containerPort
   */
  readonly containerPort?: number;

  /**
   * Name of the ELB (Classic) to associate with the service.
   *
   * @schema ServiceSpecForProviderLoadBalancer#elbName
   */
  readonly elbName?: string;

  /**
   * ARN of the Load Balancer target group to associate with the service.
   *
   * @schema ServiceSpecForProviderLoadBalancer#targetGroupArn
   */
  readonly targetGroupArn?: string;

  /**
   * Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
   *
   * @schema ServiceSpecForProviderLoadBalancer#targetGroupArnRef
   */
  readonly targetGroupArnRef?: ServiceSpecForProviderLoadBalancerTargetGroupArnRef;

  /**
   * Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
   *
   * @schema ServiceSpecForProviderLoadBalancer#targetGroupArnSelector
   */
  readonly targetGroupArnSelector?: ServiceSpecForProviderLoadBalancerTargetGroupArnSelector;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancer(obj: ServiceSpecForProviderLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'containerPort': obj.containerPort,
    'elbName': obj.elbName,
    'targetGroupArn': obj.targetGroupArn,
    'targetGroupArnRef': toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnRef(obj.targetGroupArnRef),
    'targetGroupArnSelector': toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnSelector(obj.targetGroupArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderNetworkConfiguration
 */
export interface ServiceSpecForProviderNetworkConfiguration {
  /**
   * Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#assignPublicIp
   */
  readonly assignPublicIp?: boolean;

  /**
   * References to SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#securityGroupRefs
   */
  readonly securityGroupRefs?: ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#securityGroupSelector
   */
  readonly securityGroupSelector?: ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector;

  /**
   * Security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#securityGroups
   */
  readonly securityGroups?: string[];

  /**
   * References to Subnet in ec2 to populate subnets.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#subnetRefs
   */
  readonly subnetRefs?: ServiceSpecForProviderNetworkConfigurationSubnetRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnets.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#subnetSelector
   */
  readonly subnetSelector?: ServiceSpecForProviderNetworkConfigurationSubnetSelector;

  /**
   * Subnets associated with the task or service.
   *
   * @schema ServiceSpecForProviderNetworkConfiguration#subnets
   */
  readonly subnets?: string[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfiguration(obj: ServiceSpecForProviderNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignPublicIp': obj.assignPublicIp,
    'securityGroupRefs': obj.securityGroupRefs?.map(y => toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs(y)),
    'securityGroupSelector': toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector(obj.securityGroupSelector),
    'securityGroups': obj.securityGroups?.map(y => y),
    'subnetRefs': obj.subnetRefs?.map(y => toJson_ServiceSpecForProviderNetworkConfigurationSubnetRefs(y)),
    'subnetSelector': toJson_ServiceSpecForProviderNetworkConfigurationSubnetSelector(obj.subnetSelector),
    'subnets': obj.subnets?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderOrderedPlacementStrategy
 */
export interface ServiceSpecForProviderOrderedPlacementStrategy {
  /**
   * For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see Placement Strategy.
   *
   * @schema ServiceSpecForProviderOrderedPlacementStrategy#field
   */
  readonly field?: string;

  /**
   * Type of placement strategy. Must be one of: binpack, random, or spread
   *
   * @schema ServiceSpecForProviderOrderedPlacementStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderOrderedPlacementStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderOrderedPlacementStrategy(obj: ServiceSpecForProviderOrderedPlacementStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderPlacementConstraints
 */
export interface ServiceSpecForProviderPlacementConstraints {
  /**
   * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
   *
   * @schema ServiceSpecForProviderPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * Type of constraint. The only valid values at this time are memberOf and distinctInstance.
   *
   * @schema ServiceSpecForProviderPlacementConstraints#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderPlacementConstraints(obj: ServiceSpecForProviderPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfiguration
 */
export interface ServiceSpecForProviderServiceConnectConfiguration {
  /**
   * Specifies whether to use Service Connect with this service.
   *
   * @schema ServiceSpecForProviderServiceConnectConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The log configuration for the container. See below.
   *
   * @schema ServiceSpecForProviderServiceConnectConfiguration#logConfiguration
   */
  readonly logConfiguration?: ServiceSpecForProviderServiceConnectConfigurationLogConfiguration[];

  /**
   * The namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
   *
   * @schema ServiceSpecForProviderServiceConnectConfiguration#namespace
   */
  readonly namespace?: string;

  /**
   * The list of Service Connect service objects. See below.
   *
   * @schema ServiceSpecForProviderServiceConnectConfiguration#service
   */
  readonly service?: ServiceSpecForProviderServiceConnectConfigurationService[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfiguration(obj: ServiceSpecForProviderServiceConnectConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logConfiguration': obj.logConfiguration?.map(y => toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfiguration(y)),
    'namespace': obj.namespace,
    'service': obj.service?.map(y => toJson_ServiceSpecForProviderServiceConnectConfigurationService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceRegistries
 */
export interface ServiceSpecForProviderServiceRegistries {
  /**
   * Container name value, already specified in the task definition, to be used for your service discovery service.
   *
   * @schema ServiceSpecForProviderServiceRegistries#containerName
   */
  readonly containerName?: string;

  /**
   * Port value, already specified in the task definition, to be used for your service discovery service.
   *
   * @schema ServiceSpecForProviderServiceRegistries#containerPort
   */
  readonly containerPort?: number;

  /**
   * Port value used if your Service Discovery service specified an SRV record.
   *
   * @schema ServiceSpecForProviderServiceRegistries#port
   */
  readonly port?: number;

  /**
   * ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
   *
   * @schema ServiceSpecForProviderServiceRegistries#registryArn
   */
  readonly registryArn?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceRegistries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceRegistries(obj: ServiceSpecForProviderServiceRegistries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'containerPort': obj.containerPort,
    'port': obj.port,
    'registryArn': obj.registryArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TaskDefinition to populate taskDefinition.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRef
 */
export interface ServiceSpecForProviderTaskDefinitionRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRef#policy
   */
  readonly policy?: ServiceSpecForProviderTaskDefinitionRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionRef(obj: ServiceSpecForProviderTaskDefinitionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderTaskDefinitionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TaskDefinition to populate taskDefinition.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelector
 */
export interface ServiceSpecForProviderTaskDefinitionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelector#policy
   */
  readonly policy?: ServiceSpecForProviderTaskDefinitionSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionSelector(obj: ServiceSpecForProviderTaskDefinitionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderTaskDefinitionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderAlarms
 */
export interface ServiceSpecInitProviderAlarms {
  /**
   * One or more CloudWatch alarm names.
   *
   * @schema ServiceSpecInitProviderAlarms#alarmNames
   */
  readonly alarmNames?: string[];

  /**
   * Determines whether to use the CloudWatch alarm option in the service deployment process.
   *
   * @schema ServiceSpecInitProviderAlarms#enable
   */
  readonly enable?: boolean;

  /**
   * Determines whether to configure Amazon ECS to roll back the service if a service deployment fails. If rollback is used, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
   *
   * @schema ServiceSpecInitProviderAlarms#rollback
   */
  readonly rollback?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderAlarms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderAlarms(obj: ServiceSpecInitProviderAlarms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alarmNames': obj.alarmNames?.map(y => y),
    'enable': obj.enable,
    'rollback': obj.rollback,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderCapacityProviderStrategy
 */
export interface ServiceSpecInitProviderCapacityProviderStrategy {
  /**
   * Number of tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined.
   *
   * @schema ServiceSpecInitProviderCapacityProviderStrategy#base
   */
  readonly base?: number;

  /**
   * Short name of the capacity provider.
   *
   * @schema ServiceSpecInitProviderCapacityProviderStrategy#capacityProvider
   */
  readonly capacityProvider?: string;

  /**
   * Relative percentage of the total number of launched tasks that should use the specified capacity provider.
   *
   * @schema ServiceSpecInitProviderCapacityProviderStrategy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderCapacityProviderStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderCapacityProviderStrategy(obj: ServiceSpecInitProviderCapacityProviderStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'base': obj.base,
    'capacityProvider': obj.capacityProvider,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderDeploymentCircuitBreaker
 */
export interface ServiceSpecInitProviderDeploymentCircuitBreaker {
  /**
   * Whether to enable the deployment circuit breaker logic for the service.
   *
   * @schema ServiceSpecInitProviderDeploymentCircuitBreaker#enable
   */
  readonly enable?: boolean;

  /**
   * Whether to enable Amazon ECS to roll back the service if a service deployment fails. If rollback is enabled, when a service deployment fails, the service is rolled back to the last deployment that completed successfully.
   *
   * @schema ServiceSpecInitProviderDeploymentCircuitBreaker#rollback
   */
  readonly rollback?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderDeploymentCircuitBreaker' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderDeploymentCircuitBreaker(obj: ServiceSpecInitProviderDeploymentCircuitBreaker | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'rollback': obj.rollback,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderDeploymentController
 */
export interface ServiceSpecInitProviderDeploymentController {
  /**
   * Type of deployment controller. Valid values: CODE_DEPLOY, ECS, EXTERNAL. Default: ECS.
   *
   * @schema ServiceSpecInitProviderDeploymentController#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderDeploymentController' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderDeploymentController(obj: ServiceSpecInitProviderDeploymentController | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderLoadBalancer
 */
export interface ServiceSpecInitProviderLoadBalancer {
  /**
   * Name of the container to associate with the load balancer (as it appears in a container definition).
   *
   * @schema ServiceSpecInitProviderLoadBalancer#containerName
   */
  readonly containerName?: string;

  /**
   * Port on the container to associate with the load balancer.
   *
   * @schema ServiceSpecInitProviderLoadBalancer#containerPort
   */
  readonly containerPort?: number;

  /**
   * Name of the ELB (Classic) to associate with the service.
   *
   * @schema ServiceSpecInitProviderLoadBalancer#elbName
   */
  readonly elbName?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderLoadBalancer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderLoadBalancer(obj: ServiceSpecInitProviderLoadBalancer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'containerPort': obj.containerPort,
    'elbName': obj.elbName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderNetworkConfiguration
 */
export interface ServiceSpecInitProviderNetworkConfiguration {
  /**
   * Assign a public IP address to the ENI (Fargate launch type only). Valid values are true or false. Default false.
   *
   * @schema ServiceSpecInitProviderNetworkConfiguration#assignPublicIp
   */
  readonly assignPublicIp?: boolean;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderNetworkConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderNetworkConfiguration(obj: ServiceSpecInitProviderNetworkConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'assignPublicIp': obj.assignPublicIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderOrderedPlacementStrategy
 */
export interface ServiceSpecInitProviderOrderedPlacementStrategy {
  /**
   * For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance. For the binpack type, valid values are memory and cpu. For the random type, this attribute is not needed. For more information, see Placement Strategy.
   *
   * @schema ServiceSpecInitProviderOrderedPlacementStrategy#field
   */
  readonly field?: string;

  /**
   * Type of placement strategy. Must be one of: binpack, random, or spread
   *
   * @schema ServiceSpecInitProviderOrderedPlacementStrategy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderOrderedPlacementStrategy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderOrderedPlacementStrategy(obj: ServiceSpecInitProviderOrderedPlacementStrategy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderPlacementConstraints
 */
export interface ServiceSpecInitProviderPlacementConstraints {
  /**
   * Cluster Query Language expression to apply to the constraint. Does not need to be specified for the distinctInstance type. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
   *
   * @schema ServiceSpecInitProviderPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * Type of constraint. The only valid values at this time are memberOf and distinctInstance.
   *
   * @schema ServiceSpecInitProviderPlacementConstraints#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderPlacementConstraints(obj: ServiceSpecInitProviderPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderServiceConnectConfiguration
 */
export interface ServiceSpecInitProviderServiceConnectConfiguration {
  /**
   * Specifies whether to use Service Connect with this service.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfiguration#enabled
   */
  readonly enabled?: boolean;

  /**
   * The log configuration for the container. See below.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfiguration#logConfiguration
   */
  readonly logConfiguration?: ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration[];

  /**
   * The namespace name or ARN of the aws_service_discovery_http_namespace for use with Service Connect.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfiguration#namespace
   */
  readonly namespace?: string;

  /**
   * The list of Service Connect service objects. See below.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfiguration#service
   */
  readonly service?: ServiceSpecInitProviderServiceConnectConfigurationService[];

}

/**
 * Converts an object of type 'ServiceSpecInitProviderServiceConnectConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderServiceConnectConfiguration(obj: ServiceSpecInitProviderServiceConnectConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'logConfiguration': obj.logConfiguration?.map(y => toJson_ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration(y)),
    'namespace': obj.namespace,
    'service': obj.service?.map(y => toJson_ServiceSpecInitProviderServiceConnectConfigurationService(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderServiceRegistries
 */
export interface ServiceSpecInitProviderServiceRegistries {
  /**
   * Container name value, already specified in the task definition, to be used for your service discovery service.
   *
   * @schema ServiceSpecInitProviderServiceRegistries#containerName
   */
  readonly containerName?: string;

  /**
   * Port value, already specified in the task definition, to be used for your service discovery service.
   *
   * @schema ServiceSpecInitProviderServiceRegistries#containerPort
   */
  readonly containerPort?: number;

  /**
   * Port value used if your Service Discovery service specified an SRV record.
   *
   * @schema ServiceSpecInitProviderServiceRegistries#port
   */
  readonly port?: number;

  /**
   * ARN of the Service Registry. The currently supported service registry is Amazon Route 53 Auto Naming Service(aws_service_discovery_service). For more information, see Service
   *
   * @schema ServiceSpecInitProviderServiceRegistries#registryArn
   */
  readonly registryArn?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderServiceRegistries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderServiceRegistries(obj: ServiceSpecInitProviderServiceRegistries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'containerPort': obj.containerPort,
    'port': obj.port,
    'registryArn': obj.registryArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecProviderConfigRefPolicy
 */
export interface ServiceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecProviderConfigRefPolicy(obj: ServiceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRef(obj: ServiceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToMetadata(obj: ServiceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderClusterRefPolicy
 */
export interface ServiceSpecForProviderClusterRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderClusterRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderClusterRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderClusterRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderClusterRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterRefPolicy(obj: ServiceSpecForProviderClusterRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderClusterSelectorPolicy
 */
export interface ServiceSpecForProviderClusterSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderClusterSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderClusterSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderClusterSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderClusterSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderClusterSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderClusterSelectorPolicy(obj: ServiceSpecForProviderClusterSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderIamRoleRefPolicy
 */
export interface ServiceSpecForProviderIamRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderIamRoleRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderIamRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderIamRoleRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderIamRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderIamRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderIamRoleRefPolicy(obj: ServiceSpecForProviderIamRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderIamRoleSelectorPolicy
 */
export interface ServiceSpecForProviderIamRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderIamRoleSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderIamRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderIamRoleSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderIamRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderIamRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderIamRoleSelectorPolicy(obj: ServiceSpecForProviderIamRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a LBTargetGroup in elbv2 to populate targetGroupArn.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRef
 */
export interface ServiceSpecForProviderLoadBalancerTargetGroupArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRef#policy
   */
  readonly policy?: ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancerTargetGroupArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnRef(obj: ServiceSpecForProviderLoadBalancerTargetGroupArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a LBTargetGroup in elbv2 to populate targetGroupArn.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelector
 */
export interface ServiceSpecForProviderLoadBalancerTargetGroupArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelector#policy
   */
  readonly policy?: ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancerTargetGroupArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnSelector(obj: ServiceSpecForProviderLoadBalancerTargetGroupArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs
 */
export interface ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs(obj: ServiceSpecForProviderNetworkConfigurationSecurityGroupRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate securityGroups.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector
 */
export interface ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector(obj: ServiceSpecForProviderNetworkConfigurationSecurityGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefs
 */
export interface ServiceSpecForProviderNetworkConfigurationSubnetRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefs#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSubnetRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSubnetRefs(obj: ServiceSpecForProviderNetworkConfigurationSubnetRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnets.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelector
 */
export interface ServiceSpecForProviderNetworkConfigurationSubnetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelector#policy
   */
  readonly policy?: ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSubnetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSubnetSelector(obj: ServiceSpecForProviderNetworkConfigurationSubnetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration
 */
export interface ServiceSpecForProviderServiceConnectConfigurationLogConfiguration {
  /**
   * The log driver to use for the container.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration#logDriver
   */
  readonly logDriver?: string;

  /**
   * The configuration options to send to the log driver.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration#options
   */
  readonly options?: { [key: string]: string };

  /**
   * The secrets to pass to the log configuration. See below.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfiguration#secretOption
   */
  readonly secretOption?: ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption[];

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfiguration(obj: ServiceSpecForProviderServiceConnectConfigurationLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDriver': obj.logDriver,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secretOption': obj.secretOption?.map(y => toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfigurationService
 */
export interface ServiceSpecForProviderServiceConnectConfigurationService {
  /**
   * The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationService#clientAlias
   */
  readonly clientAlias?: ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias[];

  /**
   * The name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationService#discoveryName
   */
  readonly discoveryName?: string;

  /**
   * The port number for the Service Connect proxy to listen on.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationService#ingressPortOverride
   */
  readonly ingressPortOverride?: number;

  /**
   * The name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationService#portName
   */
  readonly portName?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationService(obj: ServiceSpecForProviderServiceConnectConfigurationService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAlias': obj.clientAlias?.map(y => toJson_ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias(y)),
    'discoveryName': obj.discoveryName,
    'ingressPortOverride': obj.ingressPortOverride,
    'portName': obj.portName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRefPolicy
 */
export interface ServiceSpecForProviderTaskDefinitionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTaskDefinitionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTaskDefinitionRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTaskDefinitionRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionRefPolicy(obj: ServiceSpecForProviderTaskDefinitionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicy
 */
export interface ServiceSpecForProviderTaskDefinitionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderTaskDefinitionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderTaskDefinitionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderTaskDefinitionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderTaskDefinitionSelectorPolicy(obj: ServiceSpecForProviderTaskDefinitionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration
 */
export interface ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration {
  /**
   * The log driver to use for the container.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration#logDriver
   */
  readonly logDriver?: string;

  /**
   * The configuration options to send to the log driver.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration#options
   */
  readonly options?: { [key: string]: string };

  /**
   * The secrets to pass to the log configuration. See below.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration#secretOption
   */
  readonly secretOption?: ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption[];

}

/**
 * Converts an object of type 'ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration(obj: ServiceSpecInitProviderServiceConnectConfigurationLogConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'logDriver': obj.logDriver,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'secretOption': obj.secretOption?.map(y => toJson_ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderServiceConnectConfigurationService
 */
export interface ServiceSpecInitProviderServiceConnectConfigurationService {
  /**
   * The list of client aliases for this Service Connect service. You use these to assign names that can be used by client applications. The maximum number of client aliases that you can have in this list is 1. See below.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationService#clientAlias
   */
  readonly clientAlias?: ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias[];

  /**
   * The name of the new AWS Cloud Map service that Amazon ECS creates for this Amazon ECS service.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationService#discoveryName
   */
  readonly discoveryName?: string;

  /**
   * The port number for the Service Connect proxy to listen on.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationService#ingressPortOverride
   */
  readonly ingressPortOverride?: number;

  /**
   * The name of one of the portMappings from all the containers in the task definition of this Amazon ECS service.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationService#portName
   */
  readonly portName?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderServiceConnectConfigurationService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderServiceConnectConfigurationService(obj: ServiceSpecInitProviderServiceConnectConfigurationService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientAlias': obj.clientAlias?.map(y => toJson_ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias(y)),
    'discoveryName': obj.discoveryName,
    'ingressPortOverride': obj.ingressPortOverride,
    'portName': obj.portName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderClusterRefPolicyResolution
 */
export enum ServiceSpecForProviderClusterRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderClusterRefPolicyResolve
 */
export enum ServiceSpecForProviderClusterRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderClusterSelectorPolicyResolution
 */
export enum ServiceSpecForProviderClusterSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderClusterSelectorPolicyResolve
 */
export enum ServiceSpecForProviderClusterSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderIamRoleRefPolicyResolution
 */
export enum ServiceSpecForProviderIamRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderIamRoleRefPolicyResolve
 */
export enum ServiceSpecForProviderIamRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderIamRoleSelectorPolicyResolution
 */
export enum ServiceSpecForProviderIamRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderIamRoleSelectorPolicyResolve
 */
export enum ServiceSpecForProviderIamRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy
 */
export interface ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy(obj: ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy
 */
export interface ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy(obj: ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy(obj: ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy(obj: ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy(obj: ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy
 */
export interface ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy#resolution
   */
  readonly resolution?: ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy#resolve
   */
  readonly resolve?: ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy(obj: ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption
 */
export interface ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption {
  /**
   * The name of the secret.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption#name
   */
  readonly name?: string;

  /**
   * The secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption(obj: ServiceSpecForProviderServiceConnectConfigurationLogConfigurationSecretOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias
 */
export interface ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias {
  /**
   * The name that you use in the applications of client tasks to connect to this service.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias#dnsName
   */
  readonly dnsName?: string;

  /**
   * The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
   *
   * @schema ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias(obj: ServiceSpecForProviderServiceConnectConfigurationServiceClientAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsName': obj.dnsName,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRefPolicyResolution
 */
export enum ServiceSpecForProviderTaskDefinitionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTaskDefinitionRefPolicyResolve
 */
export enum ServiceSpecForProviderTaskDefinitionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicyResolution
 */
export enum ServiceSpecForProviderTaskDefinitionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderTaskDefinitionSelectorPolicyResolve
 */
export enum ServiceSpecForProviderTaskDefinitionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption
 */
export interface ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption {
  /**
   * The name of the secret.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption#name
   */
  readonly name?: string;

  /**
   * The secret to expose to the container. The supported values are either the full ARN of the AWS Secrets Manager secret or the full ARN of the parameter in the SSM Parameter Store.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption#valueFrom
   */
  readonly valueFrom?: string;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption(obj: ServiceSpecInitProviderServiceConnectConfigurationLogConfigurationSecretOption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': obj.valueFrom,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias
 */
export interface ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias {
  /**
   * The name that you use in the applications of client tasks to connect to this service.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias#dnsName
   */
  readonly dnsName?: string;

  /**
   * The listening port number for the Service Connect proxy. This port is available inside of all of the tasks within the same namespace.
   *
   * @schema ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias#port
   */
  readonly port?: number;

}

/**
 * Converts an object of type 'ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias(obj: ServiceSpecInitProviderServiceConnectConfigurationServiceClientAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsName': obj.dnsName,
    'port': obj.port,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicyResolution
 */
export enum ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicyResolve
 */
export enum ServiceSpecForProviderLoadBalancerTargetGroupArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicyResolution
 */
export enum ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicyResolve
 */
export enum ServiceSpecForProviderLoadBalancerTargetGroupArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationSecurityGroupRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationSecurityGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationSubnetRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicyResolution
 */
export enum ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicyResolve
 */
export enum ServiceSpecForProviderNetworkConfigurationSubnetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TaskDefinition is the Schema for the TaskDefinitions API. Manages a revision of an ECS task definition.
 *
 * @schema TaskDefinition
 */
export class TaskDefinition extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TaskDefinition"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ecs.aws.upbound.io/v1beta1',
    kind: 'TaskDefinition',
  }

  /**
   * Renders a Kubernetes manifest for "TaskDefinition".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TaskDefinitionProps): any {
    return {
      ...TaskDefinition.GVK,
      ...toJson_TaskDefinitionProps(props),
    };
  }

  /**
   * Defines a "TaskDefinition" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TaskDefinitionProps) {
    super(scope, id, {
      ...TaskDefinition.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TaskDefinition.GVK,
      ...toJson_TaskDefinitionProps(resolved),
    };
  }
}

/**
 * TaskDefinition is the Schema for the TaskDefinitions API. Manages a revision of an ECS task definition.
 *
 * @schema TaskDefinition
 */
export interface TaskDefinitionProps {
  /**
   * @schema TaskDefinition#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TaskDefinitionSpec defines the desired state of TaskDefinition
   *
   * @schema TaskDefinition#spec
   */
  readonly spec: TaskDefinitionSpec;

}

/**
 * Converts an object of type 'TaskDefinitionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionProps(obj: TaskDefinitionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TaskDefinitionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TaskDefinitionSpec defines the desired state of TaskDefinition
 *
 * @schema TaskDefinitionSpec
 */
export interface TaskDefinitionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TaskDefinitionSpec#deletionPolicy
   */
  readonly deletionPolicy?: TaskDefinitionSpecDeletionPolicy;

  /**
   * @schema TaskDefinitionSpec#forProvider
   */
  readonly forProvider: TaskDefinitionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TaskDefinitionSpec#initProvider
   */
  readonly initProvider?: TaskDefinitionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TaskDefinitionSpec#managementPolicies
   */
  readonly managementPolicies?: TaskDefinitionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TaskDefinitionSpec#providerConfigRef
   */
  readonly providerConfigRef?: TaskDefinitionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TaskDefinitionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TaskDefinitionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TaskDefinitionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TaskDefinitionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TaskDefinitionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpec(obj: TaskDefinitionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TaskDefinitionSpecForProvider(obj.forProvider),
    'initProvider': toJson_TaskDefinitionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TaskDefinitionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TaskDefinitionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TaskDefinitionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TaskDefinitionSpecDeletionPolicy
 */
export enum TaskDefinitionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TaskDefinitionSpecForProvider
 */
export interface TaskDefinitionSpecForProvider {
  /**
   * A list of valid container definitions provided as a single valid JSON document. Please note that you should only provide values that are part of the container definition document. For a detailed description of what parameters are available, see the Task Definition Parameters section from the official Developer Guide.
   *
   * @schema TaskDefinitionSpecForProvider#containerDefinitions
   */
  readonly containerDefinitions?: string;

  /**
   * Number of cpu units used by the task. If the requires_compatibilities is FARGATE this field is required.
   *
   * @schema TaskDefinitionSpecForProvider#cpu
   */
  readonly cpu?: string;

  /**
   * The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on AWS Fargate. See Ephemeral Storage.
   *
   * @schema TaskDefinitionSpecForProvider#ephemeralStorage
   */
  readonly ephemeralStorage?: TaskDefinitionSpecForProviderEphemeralStorage[];

  /**
   * ARN of the task execution role that the Amazon ECS container agent and the Docker daemon can assume.
   *
   * @schema TaskDefinitionSpecForProvider#executionRoleArn
   */
  readonly executionRoleArn?: string;

  /**
   * Reference to a Role in iam to populate executionRoleArn.
   *
   * @schema TaskDefinitionSpecForProvider#executionRoleArnRef
   */
  readonly executionRoleArnRef?: TaskDefinitionSpecForProviderExecutionRoleArnRef;

  /**
   * Selector for a Role in iam to populate executionRoleArn.
   *
   * @schema TaskDefinitionSpecForProvider#executionRoleArnSelector
   */
  readonly executionRoleArnSelector?: TaskDefinitionSpecForProviderExecutionRoleArnSelector;

  /**
   * A unique name for your task definition.
   *
   * @schema TaskDefinitionSpecForProvider#family
   */
  readonly family?: string;

  /**
   * Configuration block(s) with Inference Accelerators settings. Detailed below.
   *
   * @schema TaskDefinitionSpecForProvider#inferenceAccelerator
   */
  readonly inferenceAccelerator?: TaskDefinitionSpecForProviderInferenceAccelerator[];

  /**
   * IPC resource namespace to be used for the containers in the task The valid values are host, task, and none.
   *
   * @schema TaskDefinitionSpecForProvider#ipcMode
   */
  readonly ipcMode?: string;

  /**
   * Amount (in MiB) of memory used by the task. If the requires_compatibilities is FARGATE this field is required.
   *
   * @schema TaskDefinitionSpecForProvider#memory
   */
  readonly memory?: string;

  /**
   * Docker networking mode to use for the containers in the task. Valid values are none, bridge, awsvpc, and host.
   *
   * @schema TaskDefinitionSpecForProvider#networkMode
   */
  readonly networkMode?: string;

  /**
   * Process namespace to use for the containers in the task. The valid values are host and task.
   *
   * @schema TaskDefinitionSpecForProvider#pidMode
   */
  readonly pidMode?: string;

  /**
   * Configuration block for rules that are taken into consideration during task placement. Maximum number of placement_constraints is 10. Detailed below.
   *
   * @schema TaskDefinitionSpecForProvider#placementConstraints
   */
  readonly placementConstraints?: TaskDefinitionSpecForProviderPlacementConstraints[];

  /**
   * Configuration block for the App Mesh proxy. Detailed below.
   *
   * @schema TaskDefinitionSpecForProvider#proxyConfiguration
   */
  readonly proxyConfiguration?: TaskDefinitionSpecForProviderProxyConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TaskDefinitionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Set of launch types required by the task. The valid values are EC2 and FARGATE.
   *
   * @schema TaskDefinitionSpecForProvider#requiresCompatibilities
   */
  readonly requiresCompatibilities?: string[];

  /**
   * Configuration block for runtime_platform that containers in your task may use.
   *
   * @schema TaskDefinitionSpecForProvider#runtimePlatform
   */
  readonly runtimePlatform?: TaskDefinitionSpecForProviderRuntimePlatform[];

  /**
   * Whether to retain the old revision when the resource is destroyed or replacement is necessary. Default is false.
   *
   * @default false.
   * @schema TaskDefinitionSpecForProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema TaskDefinitionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * ARN of IAM role that allows your Amazon ECS container task to make calls to other AWS services.
   *
   * @schema TaskDefinitionSpecForProvider#taskRoleArn
   */
  readonly taskRoleArn?: string;

  /**
   * Configuration block for volumes that containers in your task may use. Detailed below.
   *
   * @schema TaskDefinitionSpecForProvider#volume
   */
  readonly volume?: TaskDefinitionSpecForProviderVolume[];

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProvider(obj: TaskDefinitionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerDefinitions': obj.containerDefinitions,
    'cpu': obj.cpu,
    'ephemeralStorage': obj.ephemeralStorage?.map(y => toJson_TaskDefinitionSpecForProviderEphemeralStorage(y)),
    'executionRoleArn': obj.executionRoleArn,
    'executionRoleArnRef': toJson_TaskDefinitionSpecForProviderExecutionRoleArnRef(obj.executionRoleArnRef),
    'executionRoleArnSelector': toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelector(obj.executionRoleArnSelector),
    'family': obj.family,
    'inferenceAccelerator': obj.inferenceAccelerator?.map(y => toJson_TaskDefinitionSpecForProviderInferenceAccelerator(y)),
    'ipcMode': obj.ipcMode,
    'memory': obj.memory,
    'networkMode': obj.networkMode,
    'pidMode': obj.pidMode,
    'placementConstraints': obj.placementConstraints?.map(y => toJson_TaskDefinitionSpecForProviderPlacementConstraints(y)),
    'proxyConfiguration': obj.proxyConfiguration?.map(y => toJson_TaskDefinitionSpecForProviderProxyConfiguration(y)),
    'region': obj.region,
    'requiresCompatibilities': obj.requiresCompatibilities?.map(y => y),
    'runtimePlatform': obj.runtimePlatform?.map(y => toJson_TaskDefinitionSpecForProviderRuntimePlatform(y)),
    'skipDestroy': obj.skipDestroy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taskRoleArn': obj.taskRoleArn,
    'volume': obj.volume?.map(y => toJson_TaskDefinitionSpecForProviderVolume(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TaskDefinitionSpecInitProvider
 */
export interface TaskDefinitionSpecInitProvider {
  /**
   * A list of valid container definitions provided as a single valid JSON document. Please note that you should only provide values that are part of the container definition document. For a detailed description of what parameters are available, see the Task Definition Parameters section from the official Developer Guide.
   *
   * @schema TaskDefinitionSpecInitProvider#containerDefinitions
   */
  readonly containerDefinitions?: string;

  /**
   * Number of cpu units used by the task. If the requires_compatibilities is FARGATE this field is required.
   *
   * @schema TaskDefinitionSpecInitProvider#cpu
   */
  readonly cpu?: string;

  /**
   * The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on AWS Fargate. See Ephemeral Storage.
   *
   * @schema TaskDefinitionSpecInitProvider#ephemeralStorage
   */
  readonly ephemeralStorage?: TaskDefinitionSpecInitProviderEphemeralStorage[];

  /**
   * A unique name for your task definition.
   *
   * @schema TaskDefinitionSpecInitProvider#family
   */
  readonly family?: string;

  /**
   * Configuration block(s) with Inference Accelerators settings. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProvider#inferenceAccelerator
   */
  readonly inferenceAccelerator?: TaskDefinitionSpecInitProviderInferenceAccelerator[];

  /**
   * IPC resource namespace to be used for the containers in the task The valid values are host, task, and none.
   *
   * @schema TaskDefinitionSpecInitProvider#ipcMode
   */
  readonly ipcMode?: string;

  /**
   * Amount (in MiB) of memory used by the task. If the requires_compatibilities is FARGATE this field is required.
   *
   * @schema TaskDefinitionSpecInitProvider#memory
   */
  readonly memory?: string;

  /**
   * Docker networking mode to use for the containers in the task. Valid values are none, bridge, awsvpc, and host.
   *
   * @schema TaskDefinitionSpecInitProvider#networkMode
   */
  readonly networkMode?: string;

  /**
   * Process namespace to use for the containers in the task. The valid values are host and task.
   *
   * @schema TaskDefinitionSpecInitProvider#pidMode
   */
  readonly pidMode?: string;

  /**
   * Configuration block for rules that are taken into consideration during task placement. Maximum number of placement_constraints is 10. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProvider#placementConstraints
   */
  readonly placementConstraints?: TaskDefinitionSpecInitProviderPlacementConstraints[];

  /**
   * Configuration block for the App Mesh proxy. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProvider#proxyConfiguration
   */
  readonly proxyConfiguration?: TaskDefinitionSpecInitProviderProxyConfiguration[];

  /**
   * Set of launch types required by the task. The valid values are EC2 and FARGATE.
   *
   * @schema TaskDefinitionSpecInitProvider#requiresCompatibilities
   */
  readonly requiresCompatibilities?: string[];

  /**
   * Configuration block for runtime_platform that containers in your task may use.
   *
   * @schema TaskDefinitionSpecInitProvider#runtimePlatform
   */
  readonly runtimePlatform?: TaskDefinitionSpecInitProviderRuntimePlatform[];

  /**
   * Whether to retain the old revision when the resource is destroyed or replacement is necessary. Default is false.
   *
   * @default false.
   * @schema TaskDefinitionSpecInitProvider#skipDestroy
   */
  readonly skipDestroy?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema TaskDefinitionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * ARN of IAM role that allows your Amazon ECS container task to make calls to other AWS services.
   *
   * @schema TaskDefinitionSpecInitProvider#taskRoleArn
   */
  readonly taskRoleArn?: string;

  /**
   * Configuration block for volumes that containers in your task may use. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProvider#volume
   */
  readonly volume?: TaskDefinitionSpecInitProviderVolume[];

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProvider(obj: TaskDefinitionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerDefinitions': obj.containerDefinitions,
    'cpu': obj.cpu,
    'ephemeralStorage': obj.ephemeralStorage?.map(y => toJson_TaskDefinitionSpecInitProviderEphemeralStorage(y)),
    'family': obj.family,
    'inferenceAccelerator': obj.inferenceAccelerator?.map(y => toJson_TaskDefinitionSpecInitProviderInferenceAccelerator(y)),
    'ipcMode': obj.ipcMode,
    'memory': obj.memory,
    'networkMode': obj.networkMode,
    'pidMode': obj.pidMode,
    'placementConstraints': obj.placementConstraints?.map(y => toJson_TaskDefinitionSpecInitProviderPlacementConstraints(y)),
    'proxyConfiguration': obj.proxyConfiguration?.map(y => toJson_TaskDefinitionSpecInitProviderProxyConfiguration(y)),
    'requiresCompatibilities': obj.requiresCompatibilities?.map(y => y),
    'runtimePlatform': obj.runtimePlatform?.map(y => toJson_TaskDefinitionSpecInitProviderRuntimePlatform(y)),
    'skipDestroy': obj.skipDestroy,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'taskRoleArn': obj.taskRoleArn,
    'volume': obj.volume?.map(y => toJson_TaskDefinitionSpecInitProviderVolume(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TaskDefinitionSpecManagementPolicies
 */
export enum TaskDefinitionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TaskDefinitionSpecProviderConfigRef
 */
export interface TaskDefinitionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecProviderConfigRef#policy
   */
  readonly policy?: TaskDefinitionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecProviderConfigRef(obj: TaskDefinitionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsTo
 */
export interface TaskDefinitionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TaskDefinitionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TaskDefinitionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsTo(obj: TaskDefinitionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TaskDefinitionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TaskDefinitionSpecWriteConnectionSecretToRef
 */
export interface TaskDefinitionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TaskDefinitionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TaskDefinitionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecWriteConnectionSecretToRef(obj: TaskDefinitionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderEphemeralStorage
 */
export interface TaskDefinitionSpecForProviderEphemeralStorage {
  /**
   * The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is 21 GiB and the maximum supported value is 200 GiB.
   *
   * @schema TaskDefinitionSpecForProviderEphemeralStorage#sizeInGib
   */
  readonly sizeInGib?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderEphemeralStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderEphemeralStorage(obj: TaskDefinitionSpecForProviderEphemeralStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sizeInGib': obj.sizeInGib,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate executionRoleArn.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRef
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRef#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnRef(obj: TaskDefinitionSpecForProviderExecutionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate executionRoleArn.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelector#policy
   */
  readonly policy?: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelector(obj: TaskDefinitionSpecForProviderExecutionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderInferenceAccelerator
 */
export interface TaskDefinitionSpecForProviderInferenceAccelerator {
  /**
   * Elastic Inference accelerator device name. The deviceName must also be referenced in a container definition as a ResourceRequirement.
   *
   * @schema TaskDefinitionSpecForProviderInferenceAccelerator#deviceName
   */
  readonly deviceName?: string;

  /**
   * Elastic Inference accelerator type to use.
   *
   * @schema TaskDefinitionSpecForProviderInferenceAccelerator#deviceType
   */
  readonly deviceType?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderInferenceAccelerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderInferenceAccelerator(obj: TaskDefinitionSpecForProviderInferenceAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'deviceType': obj.deviceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderPlacementConstraints
 */
export interface TaskDefinitionSpecForProviderPlacementConstraints {
  /**
   * Cluster Query Language expression to apply to the constraint. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecForProviderPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * Type of constraint. Use memberOf to restrict selection to a group of valid candidates. Note that distinctInstance is not supported in task definitions.
   *
   * @schema TaskDefinitionSpecForProviderPlacementConstraints#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderPlacementConstraints(obj: TaskDefinitionSpecForProviderPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderProxyConfiguration
 */
export interface TaskDefinitionSpecForProviderProxyConfiguration {
  /**
   * Name of the container that will serve as the App Mesh proxy.
   *
   * @schema TaskDefinitionSpecForProviderProxyConfiguration#containerName
   */
  readonly containerName?: string;

  /**
   * Set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified a key-value mapping.
   *
   * @schema TaskDefinitionSpecForProviderProxyConfiguration#properties
   */
  readonly properties?: { [key: string]: string };

  /**
   * Proxy type. The default value is APPMESH. The only supported value is APPMESH.
   *
   * @schema TaskDefinitionSpecForProviderProxyConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderProxyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderProxyConfiguration(obj: TaskDefinitionSpecForProviderProxyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'properties': ((obj.properties) === undefined) ? undefined : (Object.entries(obj.properties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderRuntimePlatform
 */
export interface TaskDefinitionSpecForProviderRuntimePlatform {
  /**
   * Must be set to either X86_64 or ARM64; see cpu architecture
   *
   * @schema TaskDefinitionSpecForProviderRuntimePlatform#cpuArchitecture
   */
  readonly cpuArchitecture?: string;

  /**
   * If the requires_compatibilities is FARGATE this field is required; must be set to a valid option from the operating system family in the runtime platform setting
   *
   * @schema TaskDefinitionSpecForProviderRuntimePlatform#operatingSystemFamily
   */
  readonly operatingSystemFamily?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderRuntimePlatform' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderRuntimePlatform(obj: TaskDefinitionSpecForProviderRuntimePlatform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuArchitecture': obj.cpuArchitecture,
    'operatingSystemFamily': obj.operatingSystemFamily,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderVolume
 */
export interface TaskDefinitionSpecForProviderVolume {
  /**
   * Configuration block to configure a docker volume. Detailed below.
   *
   * @schema TaskDefinitionSpecForProviderVolume#dockerVolumeConfiguration
   */
  readonly dockerVolumeConfiguration?: TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration[];

  /**
   * Configuration block for an EFS volume. Detailed below.
   *
   * @schema TaskDefinitionSpecForProviderVolume#efsVolumeConfiguration
   */
  readonly efsVolumeConfiguration?: TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration[];

  /**
   * Configuration block for an FSX Windows File Server volume. Detailed below.
   *
   * @schema TaskDefinitionSpecForProviderVolume#fsxWindowsFileServerVolumeConfiguration
   */
  readonly fsxWindowsFileServerVolumeConfiguration?: TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration[];

  /**
   * Path on the host container instance that is presented to the container. If not set, ECS will create a nonpersistent data volume that starts empty and is deleted after the task has finished.
   *
   * @schema TaskDefinitionSpecForProviderVolume#hostPath
   */
  readonly hostPath?: string;

  /**
   * Name of the volume. This name is referenced in the sourceVolume parameter of container definition in the mountPoints section.
   *
   * @schema TaskDefinitionSpecForProviderVolume#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolume(obj: TaskDefinitionSpecForProviderVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dockerVolumeConfiguration': obj.dockerVolumeConfiguration?.map(y => toJson_TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration(y)),
    'efsVolumeConfiguration': obj.efsVolumeConfiguration?.map(y => toJson_TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration(y)),
    'fsxWindowsFileServerVolumeConfiguration': obj.fsxWindowsFileServerVolumeConfiguration?.map(y => toJson_TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration(y)),
    'hostPath': obj.hostPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderEphemeralStorage
 */
export interface TaskDefinitionSpecInitProviderEphemeralStorage {
  /**
   * The total amount, in GiB, of ephemeral storage to set for the task. The minimum supported value is 21 GiB and the maximum supported value is 200 GiB.
   *
   * @schema TaskDefinitionSpecInitProviderEphemeralStorage#sizeInGib
   */
  readonly sizeInGib?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderEphemeralStorage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderEphemeralStorage(obj: TaskDefinitionSpecInitProviderEphemeralStorage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sizeInGib': obj.sizeInGib,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderInferenceAccelerator
 */
export interface TaskDefinitionSpecInitProviderInferenceAccelerator {
  /**
   * Elastic Inference accelerator device name. The deviceName must also be referenced in a container definition as a ResourceRequirement.
   *
   * @schema TaskDefinitionSpecInitProviderInferenceAccelerator#deviceName
   */
  readonly deviceName?: string;

  /**
   * Elastic Inference accelerator type to use.
   *
   * @schema TaskDefinitionSpecInitProviderInferenceAccelerator#deviceType
   */
  readonly deviceType?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderInferenceAccelerator' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderInferenceAccelerator(obj: TaskDefinitionSpecInitProviderInferenceAccelerator | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceName': obj.deviceName,
    'deviceType': obj.deviceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderPlacementConstraints
 */
export interface TaskDefinitionSpecInitProviderPlacementConstraints {
  /**
   * Cluster Query Language expression to apply to the constraint. For more information, see Cluster Query Language in the Amazon EC2 Container Service Developer Guide.
   *
   * @schema TaskDefinitionSpecInitProviderPlacementConstraints#expression
   */
  readonly expression?: string;

  /**
   * Type of constraint. Use memberOf to restrict selection to a group of valid candidates. Note that distinctInstance is not supported in task definitions.
   *
   * @schema TaskDefinitionSpecInitProviderPlacementConstraints#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderPlacementConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderPlacementConstraints(obj: TaskDefinitionSpecInitProviderPlacementConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expression': obj.expression,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderProxyConfiguration
 */
export interface TaskDefinitionSpecInitProviderProxyConfiguration {
  /**
   * Name of the container that will serve as the App Mesh proxy.
   *
   * @schema TaskDefinitionSpecInitProviderProxyConfiguration#containerName
   */
  readonly containerName?: string;

  /**
   * Set of network configuration parameters to provide the Container Network Interface (CNI) plugin, specified a key-value mapping.
   *
   * @schema TaskDefinitionSpecInitProviderProxyConfiguration#properties
   */
  readonly properties?: { [key: string]: string };

  /**
   * Proxy type. The default value is APPMESH. The only supported value is APPMESH.
   *
   * @schema TaskDefinitionSpecInitProviderProxyConfiguration#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderProxyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderProxyConfiguration(obj: TaskDefinitionSpecInitProviderProxyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerName': obj.containerName,
    'properties': ((obj.properties) === undefined) ? undefined : (Object.entries(obj.properties).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderRuntimePlatform
 */
export interface TaskDefinitionSpecInitProviderRuntimePlatform {
  /**
   * Must be set to either X86_64 or ARM64; see cpu architecture
   *
   * @schema TaskDefinitionSpecInitProviderRuntimePlatform#cpuArchitecture
   */
  readonly cpuArchitecture?: string;

  /**
   * If the requires_compatibilities is FARGATE this field is required; must be set to a valid option from the operating system family in the runtime platform setting
   *
   * @schema TaskDefinitionSpecInitProviderRuntimePlatform#operatingSystemFamily
   */
  readonly operatingSystemFamily?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderRuntimePlatform' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderRuntimePlatform(obj: TaskDefinitionSpecInitProviderRuntimePlatform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cpuArchitecture': obj.cpuArchitecture,
    'operatingSystemFamily': obj.operatingSystemFamily,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderVolume
 */
export interface TaskDefinitionSpecInitProviderVolume {
  /**
   * Configuration block to configure a docker volume. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProviderVolume#dockerVolumeConfiguration
   */
  readonly dockerVolumeConfiguration?: TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration[];

  /**
   * Configuration block for an EFS volume. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProviderVolume#efsVolumeConfiguration
   */
  readonly efsVolumeConfiguration?: TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration[];

  /**
   * Configuration block for an FSX Windows File Server volume. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProviderVolume#fsxWindowsFileServerVolumeConfiguration
   */
  readonly fsxWindowsFileServerVolumeConfiguration?: TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration[];

  /**
   * Path on the host container instance that is presented to the container. If not set, ECS will create a nonpersistent data volume that starts empty and is deleted after the task has finished.
   *
   * @schema TaskDefinitionSpecInitProviderVolume#hostPath
   */
  readonly hostPath?: string;

  /**
   * Name of the volume. This name is referenced in the sourceVolume parameter of container definition in the mountPoints section.
   *
   * @schema TaskDefinitionSpecInitProviderVolume#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderVolume' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderVolume(obj: TaskDefinitionSpecInitProviderVolume | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dockerVolumeConfiguration': obj.dockerVolumeConfiguration?.map(y => toJson_TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration(y)),
    'efsVolumeConfiguration': obj.efsVolumeConfiguration?.map(y => toJson_TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration(y)),
    'fsxWindowsFileServerVolumeConfiguration': obj.fsxWindowsFileServerVolumeConfiguration?.map(y => toJson_TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration(y)),
    'hostPath': obj.hostPath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecProviderConfigRefPolicy
 */
export interface TaskDefinitionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecProviderConfigRefPolicy(obj: TaskDefinitionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRef
 */
export interface TaskDefinitionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRef(obj: TaskDefinitionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata
 */
export interface TaskDefinitionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsToMetadata(obj: TaskDefinitionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy(obj: TaskDefinitionSpecForProviderExecutionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy
 */
export interface TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy(obj: TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration
 */
export interface TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration {
  /**
   * If this value is true, the Docker volume is created if it does not already exist. Note: This field is only used if the scope is shared.
   *
   * @schema TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration#autoprovision
   */
  readonly autoprovision?: boolean;

  /**
   * Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement.
   *
   * @schema TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration#driver
   */
  readonly driver?: string;

  /**
   * Map of Docker driver specific options.
   *
   * @schema TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration#driverOpts
   */
  readonly driverOpts?: { [key: string]: string };

  /**
   * Map of custom metadata to add to your Docker volume.
   *
   * @schema TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Scope for the Docker volume, which determines its lifecycle, either task or shared.  Docker volumes that are scoped to a task are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as shared persist after the task stops.
   *
   * @schema TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration#scope
   */
  readonly scope?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration(obj: TaskDefinitionSpecForProviderVolumeDockerVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoprovision': obj.autoprovision,
    'driver': obj.driver,
    'driverOpts': ((obj.driverOpts) === undefined) ? undefined : (Object.entries(obj.driverOpts).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration
 */
export interface TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration {
  /**
   * Configuration block for authorization for the Amazon EFS file system. Detailed below.
   *
   * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration#authorizationConfig
   */
  readonly authorizationConfig?: TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig[];

  /**
   * ID of the EFS File System.
   *
   * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying / will have the same effect as omitting this parameter. This argument is ignored when using authorization_config.
   *
   * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration#rootDirectory
   */
  readonly rootDirectory?: string;

  /**
   * Whether or not to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be enabled if Amazon EFS IAM authorization is used. Valid values: ENABLED, DISABLED. If this parameter is omitted, the default value of DISABLED is used.
   *
   * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration#transitEncryption
   */
  readonly transitEncryption?: string;

  /**
   * Port to use for transit encryption. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses.
   *
   * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration#transitEncryptionPort
   */
  readonly transitEncryptionPort?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration(obj: TaskDefinitionSpecForProviderVolumeEfsVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationConfig': obj.authorizationConfig?.map(y => toJson_TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig(y)),
    'fileSystemId': obj.fileSystemId,
    'rootDirectory': obj.rootDirectory,
    'transitEncryption': obj.transitEncryption,
    'transitEncryptionPort': obj.transitEncryptionPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration
 */
export interface TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration {
  /**
   * Configuration block for authorization for the Amazon FSx for Windows File Server file system detailed below.
   *
   * @schema TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration#authorizationConfig
   */
  readonly authorizationConfig?: TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig[];

  /**
   * The Amazon FSx for Windows File Server file system ID to use.
   *
   * @schema TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
   *
   * @schema TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration#rootDirectory
   */
  readonly rootDirectory?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration(obj: TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationConfig': obj.authorizationConfig?.map(y => toJson_TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig(y)),
    'fileSystemId': obj.fileSystemId,
    'rootDirectory': obj.rootDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration
 */
export interface TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration {
  /**
   * If this value is true, the Docker volume is created if it does not already exist. Note: This field is only used if the scope is shared.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration#autoprovision
   */
  readonly autoprovision?: boolean;

  /**
   * Docker volume driver to use. The driver value must match the driver name provided by Docker because it is used for task placement.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration#driver
   */
  readonly driver?: string;

  /**
   * Map of Docker driver specific options.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration#driverOpts
   */
  readonly driverOpts?: { [key: string]: string };

  /**
   * Map of custom metadata to add to your Docker volume.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Scope for the Docker volume, which determines its lifecycle, either task or shared.  Docker volumes that are scoped to a task are automatically provisioned when the task starts and destroyed when the task stops. Docker volumes that are scoped as shared persist after the task stops.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration#scope
   */
  readonly scope?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration(obj: TaskDefinitionSpecInitProviderVolumeDockerVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoprovision': obj.autoprovision,
    'driver': obj.driver,
    'driverOpts': ((obj.driverOpts) === undefined) ? undefined : (Object.entries(obj.driverOpts).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'scope': obj.scope,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration
 */
export interface TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration {
  /**
   * Configuration block for authorization for the Amazon EFS file system. Detailed below.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration#authorizationConfig
   */
  readonly authorizationConfig?: TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig[];

  /**
   * ID of the EFS File System.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * Directory within the Amazon EFS file system to mount as the root directory inside the host. If this parameter is omitted, the root of the Amazon EFS volume will be used. Specifying / will have the same effect as omitting this parameter. This argument is ignored when using authorization_config.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration#rootDirectory
   */
  readonly rootDirectory?: string;

  /**
   * Whether or not to enable encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be enabled if Amazon EFS IAM authorization is used. Valid values: ENABLED, DISABLED. If this parameter is omitted, the default value of DISABLED is used.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration#transitEncryption
   */
  readonly transitEncryption?: string;

  /**
   * Port to use for transit encryption. If you do not specify a transit encryption port, it will use the port selection strategy that the Amazon EFS mount helper uses.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration#transitEncryptionPort
   */
  readonly transitEncryptionPort?: number;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration(obj: TaskDefinitionSpecInitProviderVolumeEfsVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationConfig': obj.authorizationConfig?.map(y => toJson_TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig(y)),
    'fileSystemId': obj.fileSystemId,
    'rootDirectory': obj.rootDirectory,
    'transitEncryption': obj.transitEncryption,
    'transitEncryptionPort': obj.transitEncryptionPort,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration
 */
export interface TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration {
  /**
   * Configuration block for authorization for the Amazon FSx for Windows File Server file system detailed below.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration#authorizationConfig
   */
  readonly authorizationConfig?: TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig[];

  /**
   * The Amazon FSx for Windows File Server file system ID to use.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration#fileSystemId
   */
  readonly fileSystemId?: string;

  /**
   * The directory within the Amazon FSx for Windows File Server file system to mount as the root directory inside the host.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration#rootDirectory
   */
  readonly rootDirectory?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration(obj: TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationConfig': obj.authorizationConfig?.map(y => toJson_TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig(y)),
    'fileSystemId': obj.fileSystemId,
    'rootDirectory': obj.rootDirectory,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecProviderConfigRefPolicyResolution
 */
export enum TaskDefinitionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecProviderConfigRefPolicyResolve
 */
export enum TaskDefinitionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy(obj: TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolution
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolve
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolution
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolve
 */
export enum TaskDefinitionSpecForProviderExecutionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig
 */
export interface TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig {
  /**
   * Access point ID to use. If an access point is specified, the root directory value will be relative to the directory set for the access point. If specified, transit encryption must be enabled in the EFSVolumeConfiguration.
   *
   * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig#accessPointId
   */
  readonly accessPointId?: string;

  /**
   * Whether or not to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. Valid values: ENABLED, DISABLED. If this parameter is omitted, the default value of DISABLED is used.
   *
   * @schema TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig#iam
   */
  readonly iam?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig(obj: TaskDefinitionSpecForProviderVolumeEfsVolumeConfigurationAuthorizationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPointId': obj.accessPointId,
    'iam': obj.iam,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig
 */
export interface TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig {
  /**
   * The authorization credential option to use. The authorization credential options can be provided using either the Amazon Resource Name (ARN) of an AWS Secrets Manager secret or AWS Systems Manager Parameter Store parameter. The ARNs refer to the stored credentials.
   *
   * @schema TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig#credentialsParameter
   */
  readonly credentialsParameter?: string;

  /**
   * A fully qualified domain name hosted by an AWS Directory Service Managed Microsoft AD (Active Directory) or self-hosted AD on Amazon EC2.
   *
   * @schema TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig#domain
   */
  readonly domain?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig(obj: TaskDefinitionSpecForProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialsParameter': obj.credentialsParameter,
    'domain': obj.domain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig
 */
export interface TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig {
  /**
   * Access point ID to use. If an access point is specified, the root directory value will be relative to the directory set for the access point. If specified, transit encryption must be enabled in the EFSVolumeConfiguration.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig#accessPointId
   */
  readonly accessPointId?: string;

  /**
   * Whether or not to use the Amazon ECS task IAM role defined in a task definition when mounting the Amazon EFS file system. If enabled, transit encryption must be enabled in the EFSVolumeConfiguration. Valid values: ENABLED, DISABLED. If this parameter is omitted, the default value of DISABLED is used.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig#iam
   */
  readonly iam?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig(obj: TaskDefinitionSpecInitProviderVolumeEfsVolumeConfigurationAuthorizationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPointId': obj.accessPointId,
    'iam': obj.iam,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig
 */
export interface TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig {
  /**
   * The authorization credential option to use. The authorization credential options can be provided using either the Amazon Resource Name (ARN) of an AWS Secrets Manager secret or AWS Systems Manager Parameter Store parameter. The ARNs refer to the stored credentials.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig#credentialsParameter
   */
  readonly credentialsParameter?: string;

  /**
   * A fully qualified domain name hosted by an AWS Directory Service Managed Microsoft AD (Active Directory) or self-hosted AD on Amazon EC2.
   *
   * @schema TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig#domain
   */
  readonly domain?: string;

}

/**
 * Converts an object of type 'TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig(obj: TaskDefinitionSpecInitProviderVolumeFsxWindowsFileServerVolumeConfigurationAuthorizationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'credentialsParameter': obj.credentialsParameter,
    'domain': obj.domain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TaskDefinitionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

