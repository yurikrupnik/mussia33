// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Activation is the Schema for the Activations API. Registers an on-premises server or virtual machine with Amazon EC2 so that it can be managed using Run Command.
 *
 * @schema Activation
 */
export class Activation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Activation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'Activation',
  }

  /**
   * Renders a Kubernetes manifest for "Activation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ActivationProps): any {
    return {
      ...Activation.GVK,
      ...toJson_ActivationProps(props),
    };
  }

  /**
   * Defines a "Activation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ActivationProps) {
    super(scope, id, {
      ...Activation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Activation.GVK,
      ...toJson_ActivationProps(resolved),
    };
  }
}

/**
 * Activation is the Schema for the Activations API. Registers an on-premises server or virtual machine with Amazon EC2 so that it can be managed using Run Command.
 *
 * @schema Activation
 */
export interface ActivationProps {
  /**
   * @schema Activation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ActivationSpec defines the desired state of Activation
   *
   * @schema Activation#spec
   */
  readonly spec: ActivationSpec;

}

/**
 * Converts an object of type 'ActivationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationProps(obj: ActivationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ActivationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActivationSpec defines the desired state of Activation
 *
 * @schema ActivationSpec
 */
export interface ActivationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ActivationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ActivationSpecDeletionPolicy;

  /**
   * @schema ActivationSpec#forProvider
   */
  readonly forProvider: ActivationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ActivationSpec#managementPolicy
   */
  readonly managementPolicy?: ActivationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ActivationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ActivationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ActivationSpec#providerRef
   */
  readonly providerRef?: ActivationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ActivationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ActivationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ActivationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ActivationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ActivationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpec(obj: ActivationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ActivationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ActivationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ActivationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ActivationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ActivationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ActivationSpecDeletionPolicy
 */
export enum ActivationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ActivationSpecForProvider
 */
export interface ActivationSpecForProvider {
  /**
   * The description of the resource that you want to register.
   *
   * @schema ActivationSpecForProvider#description
   */
  readonly description?: string;

  /**
   * UTC timestamp in RFC3339 format by which this activation request should expire. The default value is 24 hours from resource creation time.
   *
   * @schema ActivationSpecForProvider#expirationDate
   */
  readonly expirationDate?: string;

  /**
   * The IAM Role to attach to the managed instance.
   *
   * @schema ActivationSpecForProvider#iamRole
   */
  readonly iamRole?: string;

  /**
   * Reference to a Role in iam to populate iamRole.
   *
   * @schema ActivationSpecForProvider#iamRoleRef
   */
  readonly iamRoleRef?: ActivationSpecForProviderIamRoleRef;

  /**
   * Selector for a Role in iam to populate iamRole.
   *
   * @schema ActivationSpecForProvider#iamRoleSelector
   */
  readonly iamRoleSelector?: ActivationSpecForProviderIamRoleSelector;

  /**
   * The default name of the registered managed instance.
   *
   * @schema ActivationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ActivationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The maximum number of managed instances you want to register. The default value is 1 instance.
   *
   * @schema ActivationSpecForProvider#registrationLimit
   */
  readonly registrationLimit?: number;

  /**
   * Key-value map of resource tags.
   *
   * @schema ActivationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ActivationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecForProvider(obj: ActivationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expirationDate': obj.expirationDate,
    'iamRole': obj.iamRole,
    'iamRoleRef': toJson_ActivationSpecForProviderIamRoleRef(obj.iamRoleRef),
    'iamRoleSelector': toJson_ActivationSpecForProviderIamRoleSelector(obj.iamRoleSelector),
    'name': obj.name,
    'region': obj.region,
    'registrationLimit': obj.registrationLimit,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ActivationSpecManagementPolicy
 */
export enum ActivationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ActivationSpecProviderConfigRef
 */
export interface ActivationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActivationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActivationSpecProviderConfigRef#policy
   */
  readonly policy?: ActivationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ActivationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecProviderConfigRef(obj: ActivationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActivationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ActivationSpecProviderRef
 */
export interface ActivationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActivationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActivationSpecProviderRef#policy
   */
  readonly policy?: ActivationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ActivationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecProviderRef(obj: ActivationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActivationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ActivationSpecPublishConnectionDetailsTo
 */
export interface ActivationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ActivationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ActivationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ActivationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ActivationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ActivationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ActivationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecPublishConnectionDetailsTo(obj: ActivationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ActivationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ActivationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ActivationSpecWriteConnectionSecretToRef
 */
export interface ActivationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ActivationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ActivationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ActivationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecWriteConnectionSecretToRef(obj: ActivationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRole.
 *
 * @schema ActivationSpecForProviderIamRoleRef
 */
export interface ActivationSpecForProviderIamRoleRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActivationSpecForProviderIamRoleRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActivationSpecForProviderIamRoleRef#policy
   */
  readonly policy?: ActivationSpecForProviderIamRoleRefPolicy;

}

/**
 * Converts an object of type 'ActivationSpecForProviderIamRoleRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecForProviderIamRoleRef(obj: ActivationSpecForProviderIamRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActivationSpecForProviderIamRoleRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRole.
 *
 * @schema ActivationSpecForProviderIamRoleSelector
 */
export interface ActivationSpecForProviderIamRoleSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ActivationSpecForProviderIamRoleSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ActivationSpecForProviderIamRoleSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ActivationSpecForProviderIamRoleSelector#policy
   */
  readonly policy?: ActivationSpecForProviderIamRoleSelectorPolicy;

}

/**
 * Converts an object of type 'ActivationSpecForProviderIamRoleSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecForProviderIamRoleSelector(obj: ActivationSpecForProviderIamRoleSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ActivationSpecForProviderIamRoleSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActivationSpecProviderConfigRefPolicy
 */
export interface ActivationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActivationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ActivationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActivationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ActivationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActivationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecProviderConfigRefPolicy(obj: ActivationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActivationSpecProviderRefPolicy
 */
export interface ActivationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActivationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ActivationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActivationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ActivationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ActivationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecProviderRefPolicy(obj: ActivationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ActivationSpecPublishConnectionDetailsToConfigRef
 */
export interface ActivationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ActivationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ActivationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ActivationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ActivationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecPublishConnectionDetailsToConfigRef(obj: ActivationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ActivationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ActivationSpecPublishConnectionDetailsToMetadata
 */
export interface ActivationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActivationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ActivationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ActivationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ActivationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecPublishConnectionDetailsToMetadata(obj: ActivationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ActivationSpecForProviderIamRoleRefPolicy
 */
export interface ActivationSpecForProviderIamRoleRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActivationSpecForProviderIamRoleRefPolicy#resolution
   */
  readonly resolution?: ActivationSpecForProviderIamRoleRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActivationSpecForProviderIamRoleRefPolicy#resolve
   */
  readonly resolve?: ActivationSpecForProviderIamRoleRefPolicyResolve;

}

/**
 * Converts an object of type 'ActivationSpecForProviderIamRoleRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecForProviderIamRoleRefPolicy(obj: ActivationSpecForProviderIamRoleRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ActivationSpecForProviderIamRoleSelectorPolicy
 */
export interface ActivationSpecForProviderIamRoleSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActivationSpecForProviderIamRoleSelectorPolicy#resolution
   */
  readonly resolution?: ActivationSpecForProviderIamRoleSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActivationSpecForProviderIamRoleSelectorPolicy#resolve
   */
  readonly resolve?: ActivationSpecForProviderIamRoleSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ActivationSpecForProviderIamRoleSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecForProviderIamRoleSelectorPolicy(obj: ActivationSpecForProviderIamRoleSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActivationSpecProviderConfigRefPolicyResolution
 */
export enum ActivationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActivationSpecProviderConfigRefPolicyResolve
 */
export enum ActivationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActivationSpecProviderRefPolicyResolution
 */
export enum ActivationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActivationSpecProviderRefPolicyResolve
 */
export enum ActivationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ActivationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ActivationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ActivationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ActivationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ActivationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ActivationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ActivationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ActivationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ActivationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActivationSpecForProviderIamRoleRefPolicyResolution
 */
export enum ActivationSpecForProviderIamRoleRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActivationSpecForProviderIamRoleRefPolicyResolve
 */
export enum ActivationSpecForProviderIamRoleRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActivationSpecForProviderIamRoleSelectorPolicyResolution
 */
export enum ActivationSpecForProviderIamRoleSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActivationSpecForProviderIamRoleSelectorPolicyResolve
 */
export enum ActivationSpecForProviderIamRoleSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ActivationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ActivationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ActivationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ActivationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Association is the Schema for the Associations API. Associates an SSM Document to an instance or EC2 tag.
 *
 * @schema Association
 */
export class Association extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Association"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'Association',
  }

  /**
   * Renders a Kubernetes manifest for "Association".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AssociationProps): any {
    return {
      ...Association.GVK,
      ...toJson_AssociationProps(props),
    };
  }

  /**
   * Defines a "Association" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AssociationProps) {
    super(scope, id, {
      ...Association.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Association.GVK,
      ...toJson_AssociationProps(resolved),
    };
  }
}

/**
 * Association is the Schema for the Associations API. Associates an SSM Document to an instance or EC2 tag.
 *
 * @schema Association
 */
export interface AssociationProps {
  /**
   * @schema Association#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AssociationSpec defines the desired state of Association
   *
   * @schema Association#spec
   */
  readonly spec: AssociationSpec;

}

/**
 * Converts an object of type 'AssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationProps(obj: AssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AssociationSpec defines the desired state of Association
 *
 * @schema AssociationSpec
 */
export interface AssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: AssociationSpecDeletionPolicy;

  /**
   * @schema AssociationSpec#forProvider
   */
  readonly forProvider: AssociationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AssociationSpec#managementPolicy
   */
  readonly managementPolicy?: AssociationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: AssociationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AssociationSpec#providerRef
   */
  readonly providerRef?: AssociationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpec(obj: AssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AssociationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AssociationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AssociationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AssociationSpecDeletionPolicy
 */
export enum AssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AssociationSpecForProvider
 */
export interface AssociationSpecForProvider {
  /**
   * By default, when you create a new or update associations, the system runs it immediately and then according to the schedule you specified. Enable this option if you do not want an association to run immediately after you create or update it. This parameter is not supported for rate expressions. Default: false.
   *
   * @schema AssociationSpecForProvider#applyOnlyAtCronInterval
   */
  readonly applyOnlyAtCronInterval?: boolean;

  /**
   * The descriptive name for the association.
   *
   * @schema AssociationSpecForProvider#associationName
   */
  readonly associationName?: string;

  /**
   * Specify the target for the association. This target is required for associations that use an Automation document and target resources by using rate controls. This should be set to the SSM document parameter that will define how your automation will branch out.
   *
   * @schema AssociationSpecForProvider#automationTargetParameterName
   */
  readonly automationTargetParameterName?: string;

  /**
   * The compliance severity for the association. Can be one of the following: UNSPECIFIED, LOW, MEDIUM, HIGH or CRITICAL
   *
   * @schema AssociationSpecForProvider#complianceSeverity
   */
  readonly complianceSeverity?: string;

  /**
   * The document version you want to associate with the target(s). Can be a specific version or the default version.
   *
   * @schema AssociationSpecForProvider#documentVersion
   */
  readonly documentVersion?: string;

  /**
   * The instance ID to apply an SSM document to. Use targets with key InstanceIds for document schema versions 2.0 and above.
   *
   * @schema AssociationSpecForProvider#instanceId
   */
  readonly instanceId?: string;

  /**
   * The maximum number of targets allowed to run the association at the same time. You can specify a number, for example 10, or a percentage of the target set, for example 10%.
   *
   * @schema AssociationSpecForProvider#maxConcurrency
   */
  readonly maxConcurrency?: string;

  /**
   * The number of errors that are allowed before the system stops sending requests to run the association on additional targets. You can specify a number, for example 10, or a percentage of the target set, for example 10%.
   *
   * @schema AssociationSpecForProvider#maxErrors
   */
  readonly maxErrors?: string;

  /**
   * The name of the SSM document to apply.
   *
   * @schema AssociationSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Reference to a Document in ssm to populate name.
   *
   * @schema AssociationSpecForProvider#nameRef
   */
  readonly nameRef?: AssociationSpecForProviderNameRef;

  /**
   * Selector for a Document in ssm to populate name.
   *
   * @schema AssociationSpecForProvider#nameSelector
   */
  readonly nameSelector?: AssociationSpecForProviderNameSelector;

  /**
   * An output location block. Output Location is documented below.
   *
   * @schema AssociationSpecForProvider#outputLocation
   */
  readonly outputLocation?: AssociationSpecForProviderOutputLocation[];

  /**
   * A block of arbitrary string parameters to pass to the SSM document.
   *
   * @schema AssociationSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * A cron or rate expression that specifies when the association runs.
   *
   * @schema AssociationSpecForProvider#scheduleExpression
   */
  readonly scheduleExpression?: string;

  /**
   * A block containing the targets of the SSM association. Targets are documented below. AWS currently supports a maximum of 5 targets.
   *
   * @schema AssociationSpecForProvider#targets
   */
  readonly targets?: AssociationSpecForProviderTargets[];

  /**
   * The number of seconds to wait for the association status to be Success. If Success status is not reached within the given time, create opration will fail.
   *
   * @schema AssociationSpecForProvider#waitForSuccessTimeoutSeconds
   */
  readonly waitForSuccessTimeoutSeconds?: number;

}

/**
 * Converts an object of type 'AssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProvider(obj: AssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyOnlyAtCronInterval': obj.applyOnlyAtCronInterval,
    'associationName': obj.associationName,
    'automationTargetParameterName': obj.automationTargetParameterName,
    'complianceSeverity': obj.complianceSeverity,
    'documentVersion': obj.documentVersion,
    'instanceId': obj.instanceId,
    'maxConcurrency': obj.maxConcurrency,
    'maxErrors': obj.maxErrors,
    'name': obj.name,
    'nameRef': toJson_AssociationSpecForProviderNameRef(obj.nameRef),
    'nameSelector': toJson_AssociationSpecForProviderNameSelector(obj.nameSelector),
    'outputLocation': obj.outputLocation?.map(y => toJson_AssociationSpecForProviderOutputLocation(y)),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'scheduleExpression': obj.scheduleExpression,
    'targets': obj.targets?.map(y => toJson_AssociationSpecForProviderTargets(y)),
    'waitForSuccessTimeoutSeconds': obj.waitForSuccessTimeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AssociationSpecManagementPolicy
 */
export enum AssociationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AssociationSpecProviderConfigRef
 */
export interface AssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecProviderConfigRef#policy
   */
  readonly policy?: AssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderConfigRef(obj: AssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AssociationSpecProviderRef
 */
export interface AssociationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecProviderRef#policy
   */
  readonly policy?: AssociationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderRef(obj: AssociationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AssociationSpecPublishConnectionDetailsTo
 */
export interface AssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsTo(obj: AssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AssociationSpecWriteConnectionSecretToRef
 */
export interface AssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecWriteConnectionSecretToRef(obj: AssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Document in ssm to populate name.
 *
 * @schema AssociationSpecForProviderNameRef
 */
export interface AssociationSpecForProviderNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecForProviderNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecForProviderNameRef#policy
   */
  readonly policy?: AssociationSpecForProviderNameRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecForProviderNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderNameRef(obj: AssociationSpecForProviderNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecForProviderNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Document in ssm to populate name.
 *
 * @schema AssociationSpecForProviderNameSelector
 */
export interface AssociationSpecForProviderNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AssociationSpecForProviderNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AssociationSpecForProviderNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AssociationSpecForProviderNameSelector#policy
   */
  readonly policy?: AssociationSpecForProviderNameSelectorPolicy;

}

/**
 * Converts an object of type 'AssociationSpecForProviderNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderNameSelector(obj: AssociationSpecForProviderNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AssociationSpecForProviderNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AssociationSpecForProviderOutputLocation
 */
export interface AssociationSpecForProviderOutputLocation {
  /**
   * The S3 bucket name.
   *
   * @schema AssociationSpecForProviderOutputLocation#s3BucketName
   */
  readonly s3BucketName: string;

  /**
   * The S3 bucket prefix. Results stored in the root if not configured.
   *
   * @schema AssociationSpecForProviderOutputLocation#s3KeyPrefix
   */
  readonly s3KeyPrefix?: string;

  /**
   * The S3 bucket region.
   *
   * @schema AssociationSpecForProviderOutputLocation#s3Region
   */
  readonly s3Region?: string;

}

/**
 * Converts an object of type 'AssociationSpecForProviderOutputLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderOutputLocation(obj: AssociationSpecForProviderOutputLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    's3BucketName': obj.s3BucketName,
    's3KeyPrefix': obj.s3KeyPrefix,
    's3Region': obj.s3Region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AssociationSpecForProviderTargets
 */
export interface AssociationSpecForProviderTargets {
  /**
   * Either InstanceIds or tag:Tag Name to specify an EC2 tag.
   *
   * @schema AssociationSpecForProviderTargets#key
   */
  readonly key: string;

  /**
   * A list of instance IDs or tag values. AWS currently limits this list size to one value.
   *
   * @schema AssociationSpecForProviderTargets#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'AssociationSpecForProviderTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderTargets(obj: AssociationSpecForProviderTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecProviderConfigRefPolicy
 */
export interface AssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderConfigRefPolicy(obj: AssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecProviderRefPolicy
 */
export interface AssociationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecProviderRefPolicy(obj: AssociationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface AssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsToConfigRef(obj: AssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AssociationSpecPublishConnectionDetailsToMetadata
 */
export interface AssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsToMetadata(obj: AssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecForProviderNameRefPolicy
 */
export interface AssociationSpecForProviderNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecForProviderNameRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecForProviderNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecForProviderNameRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecForProviderNameRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecForProviderNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderNameRefPolicy(obj: AssociationSpecForProviderNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AssociationSpecForProviderNameSelectorPolicy
 */
export interface AssociationSpecForProviderNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecForProviderNameSelectorPolicy#resolution
   */
  readonly resolution?: AssociationSpecForProviderNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecForProviderNameSelectorPolicy#resolve
   */
  readonly resolve?: AssociationSpecForProviderNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecForProviderNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecForProviderNameSelectorPolicy(obj: AssociationSpecForProviderNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecProviderConfigRefPolicyResolution
 */
export enum AssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecProviderConfigRefPolicyResolve
 */
export enum AssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecProviderRefPolicyResolution
 */
export enum AssociationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecProviderRefPolicyResolve
 */
export enum AssociationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: AssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecForProviderNameRefPolicyResolution
 */
export enum AssociationSpecForProviderNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecForProviderNameRefPolicyResolve
 */
export enum AssociationSpecForProviderNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecForProviderNameSelectorPolicyResolution
 */
export enum AssociationSpecForProviderNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecForProviderNameSelectorPolicyResolve
 */
export enum AssociationSpecForProviderNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DefaultPatchBaseline is the Schema for the DefaultPatchBaselines API.
 *
 * @schema DefaultPatchBaseline
 */
export class DefaultPatchBaseline extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DefaultPatchBaseline"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'DefaultPatchBaseline',
  }

  /**
   * Renders a Kubernetes manifest for "DefaultPatchBaseline".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DefaultPatchBaselineProps): any {
    return {
      ...DefaultPatchBaseline.GVK,
      ...toJson_DefaultPatchBaselineProps(props),
    };
  }

  /**
   * Defines a "DefaultPatchBaseline" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DefaultPatchBaselineProps) {
    super(scope, id, {
      ...DefaultPatchBaseline.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DefaultPatchBaseline.GVK,
      ...toJson_DefaultPatchBaselineProps(resolved),
    };
  }
}

/**
 * DefaultPatchBaseline is the Schema for the DefaultPatchBaselines API.
 *
 * @schema DefaultPatchBaseline
 */
export interface DefaultPatchBaselineProps {
  /**
   * @schema DefaultPatchBaseline#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DefaultPatchBaselineSpec defines the desired state of DefaultPatchBaseline
   *
   * @schema DefaultPatchBaseline#spec
   */
  readonly spec: DefaultPatchBaselineSpec;

}

/**
 * Converts an object of type 'DefaultPatchBaselineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineProps(obj: DefaultPatchBaselineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DefaultPatchBaselineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DefaultPatchBaselineSpec defines the desired state of DefaultPatchBaseline
 *
 * @schema DefaultPatchBaselineSpec
 */
export interface DefaultPatchBaselineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DefaultPatchBaselineSpec#deletionPolicy
   */
  readonly deletionPolicy?: DefaultPatchBaselineSpecDeletionPolicy;

  /**
   * @schema DefaultPatchBaselineSpec#forProvider
   */
  readonly forProvider: DefaultPatchBaselineSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DefaultPatchBaselineSpec#managementPolicy
   */
  readonly managementPolicy?: DefaultPatchBaselineSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DefaultPatchBaselineSpec#providerConfigRef
   */
  readonly providerConfigRef?: DefaultPatchBaselineSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DefaultPatchBaselineSpec#providerRef
   */
  readonly providerRef?: DefaultPatchBaselineSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DefaultPatchBaselineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DefaultPatchBaselineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DefaultPatchBaselineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DefaultPatchBaselineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpec(obj: DefaultPatchBaselineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DefaultPatchBaselineSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DefaultPatchBaselineSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DefaultPatchBaselineSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DefaultPatchBaselineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DefaultPatchBaselineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DefaultPatchBaselineSpecDeletionPolicy
 */
export enum DefaultPatchBaselineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DefaultPatchBaselineSpecForProvider
 */
export interface DefaultPatchBaselineSpecForProvider {
  /**
   * ID of the patch baseline. Can be an ID or an ARN. When specifying an AWS-provided patch baseline, must be the ARN.
   *
   * @schema DefaultPatchBaselineSpecForProvider#baselineId
   */
  readonly baselineId?: string;

  /**
   * Reference to a PatchBaseline in ssm to populate baselineId.
   *
   * @schema DefaultPatchBaselineSpecForProvider#baselineIdRef
   */
  readonly baselineIdRef?: DefaultPatchBaselineSpecForProviderBaselineIdRef;

  /**
   * Selector for a PatchBaseline in ssm to populate baselineId.
   *
   * @schema DefaultPatchBaselineSpecForProvider#baselineIdSelector
   */
  readonly baselineIdSelector?: DefaultPatchBaselineSpecForProviderBaselineIdSelector;

  /**
   * The operating system the patch baseline applies to. Valid values are AMAZON_LINUX, AMAZON_LINUX_2, AMAZON_LINUX_2022, CENTOS, DEBIAN, MACOS, ORACLE_LINUX, RASPBIAN, REDHAT_ENTERPRISE_LINUX, ROCKY_LINUX, SUSE, UBUNTU, and WINDOWS.
   *
   * @schema DefaultPatchBaselineSpecForProvider#operatingSystem
   */
  readonly operatingSystem?: string;

  /**
   * Reference to a PatchBaseline in ssm to populate operatingSystem.
   *
   * @schema DefaultPatchBaselineSpecForProvider#operatingSystemRef
   */
  readonly operatingSystemRef?: DefaultPatchBaselineSpecForProviderOperatingSystemRef;

  /**
   * Selector for a PatchBaseline in ssm to populate operatingSystem.
   *
   * @schema DefaultPatchBaselineSpecForProvider#operatingSystemSelector
   */
  readonly operatingSystemSelector?: DefaultPatchBaselineSpecForProviderOperatingSystemSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DefaultPatchBaselineSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProvider(obj: DefaultPatchBaselineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baselineId': obj.baselineId,
    'baselineIdRef': toJson_DefaultPatchBaselineSpecForProviderBaselineIdRef(obj.baselineIdRef),
    'baselineIdSelector': toJson_DefaultPatchBaselineSpecForProviderBaselineIdSelector(obj.baselineIdSelector),
    'operatingSystem': obj.operatingSystem,
    'operatingSystemRef': toJson_DefaultPatchBaselineSpecForProviderOperatingSystemRef(obj.operatingSystemRef),
    'operatingSystemSelector': toJson_DefaultPatchBaselineSpecForProviderOperatingSystemSelector(obj.operatingSystemSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DefaultPatchBaselineSpecManagementPolicy
 */
export enum DefaultPatchBaselineSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DefaultPatchBaselineSpecProviderConfigRef
 */
export interface DefaultPatchBaselineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultPatchBaselineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultPatchBaselineSpecProviderConfigRef#policy
   */
  readonly policy?: DefaultPatchBaselineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecProviderConfigRef(obj: DefaultPatchBaselineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultPatchBaselineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DefaultPatchBaselineSpecProviderRef
 */
export interface DefaultPatchBaselineSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultPatchBaselineSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultPatchBaselineSpecProviderRef#policy
   */
  readonly policy?: DefaultPatchBaselineSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecProviderRef(obj: DefaultPatchBaselineSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultPatchBaselineSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DefaultPatchBaselineSpecPublishConnectionDetailsTo
 */
export interface DefaultPatchBaselineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecPublishConnectionDetailsTo(obj: DefaultPatchBaselineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DefaultPatchBaselineSpecWriteConnectionSecretToRef
 */
export interface DefaultPatchBaselineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DefaultPatchBaselineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DefaultPatchBaselineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecWriteConnectionSecretToRef(obj: DefaultPatchBaselineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PatchBaseline in ssm to populate baselineId.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdRef
 */
export interface DefaultPatchBaselineSpecForProviderBaselineIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdRef#policy
   */
  readonly policy?: DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderBaselineIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderBaselineIdRef(obj: DefaultPatchBaselineSpecForProviderBaselineIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PatchBaseline in ssm to populate baselineId.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelector
 */
export interface DefaultPatchBaselineSpecForProviderBaselineIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelector#policy
   */
  readonly policy?: DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderBaselineIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderBaselineIdSelector(obj: DefaultPatchBaselineSpecForProviderBaselineIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PatchBaseline in ssm to populate operatingSystem.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRef
 */
export interface DefaultPatchBaselineSpecForProviderOperatingSystemRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRef#policy
   */
  readonly policy?: DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderOperatingSystemRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderOperatingSystemRef(obj: DefaultPatchBaselineSpecForProviderOperatingSystemRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PatchBaseline in ssm to populate operatingSystem.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelector
 */
export interface DefaultPatchBaselineSpecForProviderOperatingSystemSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelector#policy
   */
  readonly policy?: DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderOperatingSystemSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderOperatingSystemSelector(obj: DefaultPatchBaselineSpecForProviderOperatingSystemSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultPatchBaselineSpecProviderConfigRefPolicy
 */
export interface DefaultPatchBaselineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultPatchBaselineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultPatchBaselineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultPatchBaselineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultPatchBaselineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecProviderConfigRefPolicy(obj: DefaultPatchBaselineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultPatchBaselineSpecProviderRefPolicy
 */
export interface DefaultPatchBaselineSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultPatchBaselineSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DefaultPatchBaselineSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultPatchBaselineSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DefaultPatchBaselineSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecProviderRefPolicy(obj: DefaultPatchBaselineSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef
 */
export interface DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef(obj: DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata
 */
export interface DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata(obj: DefaultPatchBaselineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy
 */
export interface DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy#resolution
   */
  readonly resolution?: DefaultPatchBaselineSpecForProviderBaselineIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy#resolve
   */
  readonly resolve?: DefaultPatchBaselineSpecForProviderBaselineIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy(obj: DefaultPatchBaselineSpecForProviderBaselineIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy
 */
export interface DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy#resolution
   */
  readonly resolution?: DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy#resolve
   */
  readonly resolve?: DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy(obj: DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy
 */
export interface DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy#resolution
   */
  readonly resolution?: DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy#resolve
   */
  readonly resolve?: DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy(obj: DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy
 */
export interface DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy#resolution
   */
  readonly resolution?: DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy#resolve
   */
  readonly resolve?: DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy(obj: DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultPatchBaselineSpecProviderConfigRefPolicyResolution
 */
export enum DefaultPatchBaselineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultPatchBaselineSpecProviderConfigRefPolicyResolve
 */
export enum DefaultPatchBaselineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultPatchBaselineSpecProviderRefPolicyResolution
 */
export enum DefaultPatchBaselineSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultPatchBaselineSpecProviderRefPolicyResolve
 */
export enum DefaultPatchBaselineSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy(obj: DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdRefPolicyResolution
 */
export enum DefaultPatchBaselineSpecForProviderBaselineIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdRefPolicyResolve
 */
export enum DefaultPatchBaselineSpecForProviderBaselineIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicyResolution
 */
export enum DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicyResolve
 */
export enum DefaultPatchBaselineSpecForProviderBaselineIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicyResolution
 */
export enum DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicyResolve
 */
export enum DefaultPatchBaselineSpecForProviderOperatingSystemRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicyResolution
 */
export enum DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicyResolve
 */
export enum DefaultPatchBaselineSpecForProviderOperatingSystemSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DefaultPatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Document is the Schema for the Documents API. Provides an SSM Document resource
 *
 * @schema Document
 */
export class Document extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Document"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'Document',
  }

  /**
   * Renders a Kubernetes manifest for "Document".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DocumentProps): any {
    return {
      ...Document.GVK,
      ...toJson_DocumentProps(props),
    };
  }

  /**
   * Defines a "Document" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DocumentProps) {
    super(scope, id, {
      ...Document.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Document.GVK,
      ...toJson_DocumentProps(resolved),
    };
  }
}

/**
 * Document is the Schema for the Documents API. Provides an SSM Document resource
 *
 * @schema Document
 */
export interface DocumentProps {
  /**
   * @schema Document#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DocumentSpec defines the desired state of Document
   *
   * @schema Document#spec
   */
  readonly spec: DocumentSpec;

}

/**
 * Converts an object of type 'DocumentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentProps(obj: DocumentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DocumentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DocumentSpec defines the desired state of Document
 *
 * @schema DocumentSpec
 */
export interface DocumentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentSpec#deletionPolicy
   */
  readonly deletionPolicy?: DocumentSpecDeletionPolicy;

  /**
   * @schema DocumentSpec#forProvider
   */
  readonly forProvider: DocumentSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DocumentSpec#managementPolicy
   */
  readonly managementPolicy?: DocumentSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DocumentSpec#providerConfigRef
   */
  readonly providerConfigRef?: DocumentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DocumentSpec#providerRef
   */
  readonly providerRef?: DocumentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DocumentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DocumentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DocumentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DocumentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DocumentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpec(obj: DocumentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DocumentSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_DocumentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DocumentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DocumentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DocumentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentSpecDeletionPolicy
 */
export enum DocumentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DocumentSpecForProvider
 */
export interface DocumentSpecForProvider {
  /**
   * One or more configuration blocks describing attachments sources to a version of a document. Defined below.
   *
   * @schema DocumentSpecForProvider#attachmentsSource
   */
  readonly attachmentsSource?: DocumentSpecForProviderAttachmentsSource[];

  /**
   * The JSON or YAML content of the document.
   *
   * @schema DocumentSpecForProvider#content
   */
  readonly content?: string;

  /**
   * The format of the document. Valid document types include: JSON and YAML
   *
   * @schema DocumentSpecForProvider#documentFormat
   */
  readonly documentFormat?: string;

  /**
   * The type of the document. Valid document types include: Automation, Command, Package, Policy, and Session
   *
   * @schema DocumentSpecForProvider#documentType
   */
  readonly documentType?: string;

  /**
   * Additional Permissions to attach to the document. See Permissions below for details.
   *
   * @schema DocumentSpecForProvider#permissions
   */
  readonly permissions?: { [key: string]: string };

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DocumentSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DocumentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The target type which defines the kinds of resources the document can run on. For example, /AWS::EC2::Instance. For a list of valid resource types, see AWS Resource Types Reference (http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)
   *
   * @schema DocumentSpecForProvider#targetType
   */
  readonly targetType?: string;

  /**
   * A field specifying the version of the artifact you are creating with the document. For example, "Release 12, Update 6". This value is unique across all versions of a document and cannot be changed for an existing document version.
   *
   * @schema DocumentSpecForProvider#versionName
   */
  readonly versionName?: string;

}

/**
 * Converts an object of type 'DocumentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecForProvider(obj: DocumentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attachmentsSource': obj.attachmentsSource?.map(y => toJson_DocumentSpecForProviderAttachmentsSource(y)),
    'content': obj.content,
    'documentFormat': obj.documentFormat,
    'documentType': obj.documentType,
    'permissions': ((obj.permissions) === undefined) ? undefined : (Object.entries(obj.permissions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'targetType': obj.targetType,
    'versionName': obj.versionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DocumentSpecManagementPolicy
 */
export enum DocumentSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DocumentSpecProviderConfigRef
 */
export interface DocumentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentSpecProviderConfigRef#policy
   */
  readonly policy?: DocumentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecProviderConfigRef(obj: DocumentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DocumentSpecProviderRef
 */
export interface DocumentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentSpecProviderRef#policy
   */
  readonly policy?: DocumentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DocumentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecProviderRef(obj: DocumentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DocumentSpecPublishConnectionDetailsTo
 */
export interface DocumentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DocumentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DocumentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DocumentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DocumentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DocumentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DocumentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecPublishConnectionDetailsTo(obj: DocumentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DocumentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DocumentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DocumentSpecWriteConnectionSecretToRef
 */
export interface DocumentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DocumentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DocumentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DocumentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecWriteConnectionSecretToRef(obj: DocumentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DocumentSpecForProviderAttachmentsSource
 */
export interface DocumentSpecForProviderAttachmentsSource {
  /**
   * The key describing the location of an attachment to a document. Valid key types include: SourceUrl and S3FileUrl
   *
   * @schema DocumentSpecForProviderAttachmentsSource#key
   */
  readonly key: string;

  /**
   * The name of the document attachment file
   *
   * @schema DocumentSpecForProviderAttachmentsSource#name
   */
  readonly name?: string;

  /**
   * The value describing the location of an attachment to a document
   *
   * @schema DocumentSpecForProviderAttachmentsSource#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'DocumentSpecForProviderAttachmentsSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecForProviderAttachmentsSource(obj: DocumentSpecForProviderAttachmentsSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentSpecProviderConfigRefPolicy
 */
export interface DocumentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecProviderConfigRefPolicy(obj: DocumentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DocumentSpecProviderRefPolicy
 */
export interface DocumentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DocumentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DocumentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecProviderRefPolicy(obj: DocumentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DocumentSpecPublishConnectionDetailsToConfigRef
 */
export interface DocumentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DocumentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DocumentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DocumentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DocumentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecPublishConnectionDetailsToConfigRef(obj: DocumentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DocumentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DocumentSpecPublishConnectionDetailsToMetadata
 */
export interface DocumentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DocumentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DocumentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DocumentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecPublishConnectionDetailsToMetadata(obj: DocumentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentSpecProviderConfigRefPolicyResolution
 */
export enum DocumentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentSpecProviderConfigRefPolicyResolve
 */
export enum DocumentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentSpecProviderRefPolicyResolution
 */
export enum DocumentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentSpecProviderRefPolicyResolve
 */
export enum DocumentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DocumentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DocumentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DocumentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DocumentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DocumentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DocumentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DocumentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DocumentSpecPublishConnectionDetailsToConfigRefPolicy(obj: DocumentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DocumentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DocumentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DocumentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DocumentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MaintenanceWindow is the Schema for the MaintenanceWindows API. Provides an SSM Maintenance Window resource
 *
 * @schema MaintenanceWindow
 */
export class MaintenanceWindow extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MaintenanceWindow"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'MaintenanceWindow',
  }

  /**
   * Renders a Kubernetes manifest for "MaintenanceWindow".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MaintenanceWindowProps): any {
    return {
      ...MaintenanceWindow.GVK,
      ...toJson_MaintenanceWindowProps(props),
    };
  }

  /**
   * Defines a "MaintenanceWindow" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MaintenanceWindowProps) {
    super(scope, id, {
      ...MaintenanceWindow.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MaintenanceWindow.GVK,
      ...toJson_MaintenanceWindowProps(resolved),
    };
  }
}

/**
 * MaintenanceWindow is the Schema for the MaintenanceWindows API. Provides an SSM Maintenance Window resource
 *
 * @schema MaintenanceWindow
 */
export interface MaintenanceWindowProps {
  /**
   * @schema MaintenanceWindow#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MaintenanceWindowSpec defines the desired state of MaintenanceWindow
   *
   * @schema MaintenanceWindow#spec
   */
  readonly spec: MaintenanceWindowSpec;

}

/**
 * Converts an object of type 'MaintenanceWindowProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowProps(obj: MaintenanceWindowProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MaintenanceWindowSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MaintenanceWindowSpec defines the desired state of MaintenanceWindow
 *
 * @schema MaintenanceWindowSpec
 */
export interface MaintenanceWindowSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MaintenanceWindowSpec#deletionPolicy
   */
  readonly deletionPolicy?: MaintenanceWindowSpecDeletionPolicy;

  /**
   * @schema MaintenanceWindowSpec#forProvider
   */
  readonly forProvider: MaintenanceWindowSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MaintenanceWindowSpec#managementPolicy
   */
  readonly managementPolicy?: MaintenanceWindowSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MaintenanceWindowSpec#providerConfigRef
   */
  readonly providerConfigRef?: MaintenanceWindowSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MaintenanceWindowSpec#providerRef
   */
  readonly providerRef?: MaintenanceWindowSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MaintenanceWindowSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MaintenanceWindowSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MaintenanceWindowSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MaintenanceWindowSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MaintenanceWindowSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpec(obj: MaintenanceWindowSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MaintenanceWindowSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MaintenanceWindowSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MaintenanceWindowSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MaintenanceWindowSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MaintenanceWindowSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MaintenanceWindowSpecDeletionPolicy
 */
export enum MaintenanceWindowSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MaintenanceWindowSpecForProvider
 */
export interface MaintenanceWindowSpecForProvider {
  /**
   * Whether targets must be registered with the Maintenance Window before tasks can be defined for those targets.
   *
   * @schema MaintenanceWindowSpecForProvider#allowUnassociatedTargets
   */
  readonly allowUnassociatedTargets?: boolean;

  /**
   * The number of hours before the end of the Maintenance Window that Systems Manager stops scheduling new tasks for execution.
   *
   * @schema MaintenanceWindowSpecForProvider#cutoff
   */
  readonly cutoff?: number;

  /**
   * A description for the maintenance window.
   *
   * @schema MaintenanceWindowSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The duration of the Maintenance Window in hours.
   *
   * @schema MaintenanceWindowSpecForProvider#duration
   */
  readonly duration?: number;

  /**
   * Whether the maintenance window is enabled. Default: true.
   *
   * @schema MaintenanceWindowSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * Timestamp in ISO-8601 extended format when to no longer run the maintenance window.
   *
   * @schema MaintenanceWindowSpecForProvider#endDate
   */
  readonly endDate?: string;

  /**
   * The name of the maintenance window.
   *
   * @schema MaintenanceWindowSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MaintenanceWindowSpecForProvider#region
   */
  readonly region: string;

  /**
   * The schedule of the Maintenance Window in the form of a cron or rate expression.
   *
   * @schema MaintenanceWindowSpecForProvider#schedule
   */
  readonly schedule?: string;

  /**
   * The number of days to wait after the date and time specified by a CRON expression before running the maintenance window.
   *
   * @schema MaintenanceWindowSpecForProvider#scheduleOffset
   */
  readonly scheduleOffset?: number;

  /**
   * Timezone for schedule in Internet Assigned Numbers Authority (IANA) Time Zone Database format. For example: America/Los_Angeles, etc/UTC, or Asia/Seoul.
   *
   * @schema MaintenanceWindowSpecForProvider#scheduleTimezone
   */
  readonly scheduleTimezone?: string;

  /**
   * Timestamp in ISO-8601 extended format when to begin the maintenance window.
   *
   * @schema MaintenanceWindowSpecForProvider#startDate
   */
  readonly startDate?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema MaintenanceWindowSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'MaintenanceWindowSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecForProvider(obj: MaintenanceWindowSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowUnassociatedTargets': obj.allowUnassociatedTargets,
    'cutoff': obj.cutoff,
    'description': obj.description,
    'duration': obj.duration,
    'enabled': obj.enabled,
    'endDate': obj.endDate,
    'name': obj.name,
    'region': obj.region,
    'schedule': obj.schedule,
    'scheduleOffset': obj.scheduleOffset,
    'scheduleTimezone': obj.scheduleTimezone,
    'startDate': obj.startDate,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MaintenanceWindowSpecManagementPolicy
 */
export enum MaintenanceWindowSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MaintenanceWindowSpecProviderConfigRef
 */
export interface MaintenanceWindowSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowSpecProviderConfigRef#policy
   */
  readonly policy?: MaintenanceWindowSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecProviderConfigRef(obj: MaintenanceWindowSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MaintenanceWindowSpecProviderRef
 */
export interface MaintenanceWindowSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowSpecProviderRef#policy
   */
  readonly policy?: MaintenanceWindowSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecProviderRef(obj: MaintenanceWindowSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MaintenanceWindowSpecPublishConnectionDetailsTo
 */
export interface MaintenanceWindowSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MaintenanceWindowSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MaintenanceWindowSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecPublishConnectionDetailsTo(obj: MaintenanceWindowSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MaintenanceWindowSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MaintenanceWindowSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MaintenanceWindowSpecWriteConnectionSecretToRef
 */
export interface MaintenanceWindowSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MaintenanceWindowSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MaintenanceWindowSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecWriteConnectionSecretToRef(obj: MaintenanceWindowSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowSpecProviderConfigRefPolicy
 */
export interface MaintenanceWindowSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecProviderConfigRefPolicy(obj: MaintenanceWindowSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowSpecProviderRefPolicy
 */
export interface MaintenanceWindowSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecProviderRefPolicy(obj: MaintenanceWindowSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRef
 */
export interface MaintenanceWindowSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecPublishConnectionDetailsToConfigRef(obj: MaintenanceWindowSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MaintenanceWindowSpecPublishConnectionDetailsToMetadata
 */
export interface MaintenanceWindowSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecPublishConnectionDetailsToMetadata(obj: MaintenanceWindowSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowSpecProviderConfigRefPolicyResolution
 */
export enum MaintenanceWindowSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowSpecProviderConfigRefPolicyResolve
 */
export enum MaintenanceWindowSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowSpecProviderRefPolicyResolution
 */
export enum MaintenanceWindowSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowSpecProviderRefPolicyResolve
 */
export enum MaintenanceWindowSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy(obj: MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MaintenanceWindowSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MaintenanceWindowTarget is the Schema for the MaintenanceWindowTargets API. Provides an SSM Maintenance Window Target resource
 *
 * @schema MaintenanceWindowTarget
 */
export class MaintenanceWindowTarget extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MaintenanceWindowTarget"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'MaintenanceWindowTarget',
  }

  /**
   * Renders a Kubernetes manifest for "MaintenanceWindowTarget".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MaintenanceWindowTargetProps): any {
    return {
      ...MaintenanceWindowTarget.GVK,
      ...toJson_MaintenanceWindowTargetProps(props),
    };
  }

  /**
   * Defines a "MaintenanceWindowTarget" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MaintenanceWindowTargetProps) {
    super(scope, id, {
      ...MaintenanceWindowTarget.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MaintenanceWindowTarget.GVK,
      ...toJson_MaintenanceWindowTargetProps(resolved),
    };
  }
}

/**
 * MaintenanceWindowTarget is the Schema for the MaintenanceWindowTargets API. Provides an SSM Maintenance Window Target resource
 *
 * @schema MaintenanceWindowTarget
 */
export interface MaintenanceWindowTargetProps {
  /**
   * @schema MaintenanceWindowTarget#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MaintenanceWindowTargetSpec defines the desired state of MaintenanceWindowTarget
   *
   * @schema MaintenanceWindowTarget#spec
   */
  readonly spec: MaintenanceWindowTargetSpec;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetProps(obj: MaintenanceWindowTargetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MaintenanceWindowTargetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MaintenanceWindowTargetSpec defines the desired state of MaintenanceWindowTarget
 *
 * @schema MaintenanceWindowTargetSpec
 */
export interface MaintenanceWindowTargetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MaintenanceWindowTargetSpec#deletionPolicy
   */
  readonly deletionPolicy?: MaintenanceWindowTargetSpecDeletionPolicy;

  /**
   * @schema MaintenanceWindowTargetSpec#forProvider
   */
  readonly forProvider: MaintenanceWindowTargetSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MaintenanceWindowTargetSpec#managementPolicy
   */
  readonly managementPolicy?: MaintenanceWindowTargetSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MaintenanceWindowTargetSpec#providerConfigRef
   */
  readonly providerConfigRef?: MaintenanceWindowTargetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MaintenanceWindowTargetSpec#providerRef
   */
  readonly providerRef?: MaintenanceWindowTargetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MaintenanceWindowTargetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MaintenanceWindowTargetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MaintenanceWindowTargetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MaintenanceWindowTargetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpec(obj: MaintenanceWindowTargetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MaintenanceWindowTargetSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MaintenanceWindowTargetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MaintenanceWindowTargetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MaintenanceWindowTargetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MaintenanceWindowTargetSpecDeletionPolicy
 */
export enum MaintenanceWindowTargetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MaintenanceWindowTargetSpecForProvider
 */
export interface MaintenanceWindowTargetSpecForProvider {
  /**
   * The description of the maintenance window target.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the maintenance window target.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * User-provided value that will be included in any CloudWatch events raised while running tasks for these targets in this Maintenance Window.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#ownerInformation
   */
  readonly ownerInformation?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The type of target being registered with the Maintenance Window. Possible values are INSTANCE and RESOURCE_GROUP.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#resourceType
   */
  readonly resourceType?: string;

  /**
   * The targets to register with the maintenance window. In other words, the instances to run commands on when the maintenance window runs. You can specify targets using instance IDs, resource group names, or tags that have been applied to instances. For more information about these examples formats see (https://docs.aws.amazon.com/systems-manager/latest/userguide/mw-cli-tutorial-targets-examples.html)
   *
   * @schema MaintenanceWindowTargetSpecForProvider#targets
   */
  readonly targets?: MaintenanceWindowTargetSpecForProviderTargets[];

  /**
   * The Id of the maintenance window to register the target with.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#windowId
   */
  readonly windowId?: string;

  /**
   * Reference to a MaintenanceWindow in ssm to populate windowId.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#windowIdRef
   */
  readonly windowIdRef?: MaintenanceWindowTargetSpecForProviderWindowIdRef;

  /**
   * Selector for a MaintenanceWindow in ssm to populate windowId.
   *
   * @schema MaintenanceWindowTargetSpecForProvider#windowIdSelector
   */
  readonly windowIdSelector?: MaintenanceWindowTargetSpecForProviderWindowIdSelector;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecForProvider(obj: MaintenanceWindowTargetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'ownerInformation': obj.ownerInformation,
    'region': obj.region,
    'resourceType': obj.resourceType,
    'targets': obj.targets?.map(y => toJson_MaintenanceWindowTargetSpecForProviderTargets(y)),
    'windowId': obj.windowId,
    'windowIdRef': toJson_MaintenanceWindowTargetSpecForProviderWindowIdRef(obj.windowIdRef),
    'windowIdSelector': toJson_MaintenanceWindowTargetSpecForProviderWindowIdSelector(obj.windowIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MaintenanceWindowTargetSpecManagementPolicy
 */
export enum MaintenanceWindowTargetSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MaintenanceWindowTargetSpecProviderConfigRef
 */
export interface MaintenanceWindowTargetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTargetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTargetSpecProviderConfigRef#policy
   */
  readonly policy?: MaintenanceWindowTargetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecProviderConfigRef(obj: MaintenanceWindowTargetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTargetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MaintenanceWindowTargetSpecProviderRef
 */
export interface MaintenanceWindowTargetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTargetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTargetSpecProviderRef#policy
   */
  readonly policy?: MaintenanceWindowTargetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecProviderRef(obj: MaintenanceWindowTargetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTargetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsTo
 */
export interface MaintenanceWindowTargetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsTo(obj: MaintenanceWindowTargetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MaintenanceWindowTargetSpecWriteConnectionSecretToRef
 */
export interface MaintenanceWindowTargetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MaintenanceWindowTargetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MaintenanceWindowTargetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecWriteConnectionSecretToRef(obj: MaintenanceWindowTargetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTargetSpecForProviderTargets
 */
export interface MaintenanceWindowTargetSpecForProviderTargets {
  /**
   * @schema MaintenanceWindowTargetSpecForProviderTargets#key
   */
  readonly key: string;

  /**
   * @schema MaintenanceWindowTargetSpecForProviderTargets#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecForProviderTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecForProviderTargets(obj: MaintenanceWindowTargetSpecForProviderTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a MaintenanceWindow in ssm to populate windowId.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdRef
 */
export interface MaintenanceWindowTargetSpecForProviderWindowIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdRef#policy
   */
  readonly policy?: MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecForProviderWindowIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecForProviderWindowIdRef(obj: MaintenanceWindowTargetSpecForProviderWindowIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a MaintenanceWindow in ssm to populate windowId.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelector
 */
export interface MaintenanceWindowTargetSpecForProviderWindowIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelector#policy
   */
  readonly policy?: MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecForProviderWindowIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecForProviderWindowIdSelector(obj: MaintenanceWindowTargetSpecForProviderWindowIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTargetSpecProviderConfigRefPolicy
 */
export interface MaintenanceWindowTargetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTargetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTargetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTargetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTargetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecProviderConfigRefPolicy(obj: MaintenanceWindowTargetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTargetSpecProviderRefPolicy
 */
export interface MaintenanceWindowTargetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTargetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTargetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTargetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTargetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecProviderRefPolicy(obj: MaintenanceWindowTargetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef
 */
export interface MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef(obj: MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata
 */
export interface MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata(obj: MaintenanceWindowTargetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy
 */
export interface MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTargetSpecForProviderWindowIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTargetSpecForProviderWindowIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy(obj: MaintenanceWindowTargetSpecForProviderWindowIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy
 */
export interface MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy(obj: MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTargetSpecProviderConfigRefPolicyResolution
 */
export enum MaintenanceWindowTargetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTargetSpecProviderConfigRefPolicyResolve
 */
export enum MaintenanceWindowTargetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTargetSpecProviderRefPolicyResolution
 */
export enum MaintenanceWindowTargetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTargetSpecProviderRefPolicyResolve
 */
export enum MaintenanceWindowTargetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy(obj: MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdRefPolicyResolution
 */
export enum MaintenanceWindowTargetSpecForProviderWindowIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdRefPolicyResolve
 */
export enum MaintenanceWindowTargetSpecForProviderWindowIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicyResolution
 */
export enum MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicyResolve
 */
export enum MaintenanceWindowTargetSpecForProviderWindowIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MaintenanceWindowTargetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MaintenanceWindowTask is the Schema for the MaintenanceWindowTasks API. Provides an SSM Maintenance Window Task resource
 *
 * @schema MaintenanceWindowTask
 */
export class MaintenanceWindowTask extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MaintenanceWindowTask"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'MaintenanceWindowTask',
  }

  /**
   * Renders a Kubernetes manifest for "MaintenanceWindowTask".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MaintenanceWindowTaskProps): any {
    return {
      ...MaintenanceWindowTask.GVK,
      ...toJson_MaintenanceWindowTaskProps(props),
    };
  }

  /**
   * Defines a "MaintenanceWindowTask" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MaintenanceWindowTaskProps) {
    super(scope, id, {
      ...MaintenanceWindowTask.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MaintenanceWindowTask.GVK,
      ...toJson_MaintenanceWindowTaskProps(resolved),
    };
  }
}

/**
 * MaintenanceWindowTask is the Schema for the MaintenanceWindowTasks API. Provides an SSM Maintenance Window Task resource
 *
 * @schema MaintenanceWindowTask
 */
export interface MaintenanceWindowTaskProps {
  /**
   * @schema MaintenanceWindowTask#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MaintenanceWindowTaskSpec defines the desired state of MaintenanceWindowTask
   *
   * @schema MaintenanceWindowTask#spec
   */
  readonly spec: MaintenanceWindowTaskSpec;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskProps(obj: MaintenanceWindowTaskProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MaintenanceWindowTaskSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MaintenanceWindowTaskSpec defines the desired state of MaintenanceWindowTask
 *
 * @schema MaintenanceWindowTaskSpec
 */
export interface MaintenanceWindowTaskSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MaintenanceWindowTaskSpec#deletionPolicy
   */
  readonly deletionPolicy?: MaintenanceWindowTaskSpecDeletionPolicy;

  /**
   * @schema MaintenanceWindowTaskSpec#forProvider
   */
  readonly forProvider: MaintenanceWindowTaskSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MaintenanceWindowTaskSpec#managementPolicy
   */
  readonly managementPolicy?: MaintenanceWindowTaskSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MaintenanceWindowTaskSpec#providerConfigRef
   */
  readonly providerConfigRef?: MaintenanceWindowTaskSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MaintenanceWindowTaskSpec#providerRef
   */
  readonly providerRef?: MaintenanceWindowTaskSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MaintenanceWindowTaskSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MaintenanceWindowTaskSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MaintenanceWindowTaskSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MaintenanceWindowTaskSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpec(obj: MaintenanceWindowTaskSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MaintenanceWindowTaskSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MaintenanceWindowTaskSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MaintenanceWindowTaskSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MaintenanceWindowTaskSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MaintenanceWindowTaskSpecDeletionPolicy
 */
export enum MaintenanceWindowTaskSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MaintenanceWindowTaskSpecForProvider
 */
export interface MaintenanceWindowTaskSpecForProvider {
  /**
   * Indicates whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached. Valid values are CONTINUE_TASK and CANCEL_TASK.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#cutoffBehavior
   */
  readonly cutoffBehavior?: string;

  /**
   * The description of the maintenance window task.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The maximum number of targets this task can be run for in parallel.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#maxConcurrency
   */
  readonly maxConcurrency?: string;

  /**
   * The maximum number of errors allowed before this task stops being scheduled.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#maxErrors
   */
  readonly maxErrors?: string;

  /**
   * The name of the maintenance window task.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The priority of the task in the Maintenance Window, the lower the number the higher the priority. Tasks in a Maintenance Window are scheduled in priority order with tasks that have the same priority scheduled in parallel.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#priority
   */
  readonly priority?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#region
   */
  readonly region: string;

  /**
   * The role that should be assumed when executing the task. If a role is not provided, Systems Manager uses your account's service-linked role. If no service-linked role for Systems Manager exists in your account, it is created for you.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#serviceRoleArn
   */
  readonly serviceRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceRoleArn.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#serviceRoleArnRef
   */
  readonly serviceRoleArnRef?: MaintenanceWindowTaskSpecForProviderServiceRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceRoleArn.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#serviceRoleArnSelector
   */
  readonly serviceRoleArnSelector?: MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector;

  /**
   * The targets (either instances or window target ids). Instances are specified using Key=InstanceIds,Values=instanceid1,instanceid2. Window target ids are specified using Key=WindowTargetIds,Values=window target id1, window target id2.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#targets
   */
  readonly targets?: MaintenanceWindowTaskSpecForProviderTargets[];

  /**
   * The ARN of the task to execute.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#taskArn
   */
  readonly taskArn?: string;

  /**
   * Reference to a Function in lambda to populate taskArn.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#taskArnRef
   */
  readonly taskArnRef?: MaintenanceWindowTaskSpecForProviderTaskArnRef;

  /**
   * Selector for a Function in lambda to populate taskArn.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#taskArnSelector
   */
  readonly taskArnSelector?: MaintenanceWindowTaskSpecForProviderTaskArnSelector;

  /**
   * Configuration block with parameters for task execution.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#taskInvocationParameters
   */
  readonly taskInvocationParameters?: MaintenanceWindowTaskSpecForProviderTaskInvocationParameters[];

  /**
   * The type of task being registered. Valid values: AUTOMATION, LAMBDA, RUN_COMMAND or STEP_FUNCTIONS.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#taskType
   */
  readonly taskType?: string;

  /**
   * The Id of the maintenance window to register the task with.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#windowId
   */
  readonly windowId?: string;

  /**
   * Reference to a MaintenanceWindow in ssm to populate windowId.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#windowIdRef
   */
  readonly windowIdRef?: MaintenanceWindowTaskSpecForProviderWindowIdRef;

  /**
   * Selector for a MaintenanceWindow in ssm to populate windowId.
   *
   * @schema MaintenanceWindowTaskSpecForProvider#windowIdSelector
   */
  readonly windowIdSelector?: MaintenanceWindowTaskSpecForProviderWindowIdSelector;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProvider(obj: MaintenanceWindowTaskSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cutoffBehavior': obj.cutoffBehavior,
    'description': obj.description,
    'maxConcurrency': obj.maxConcurrency,
    'maxErrors': obj.maxErrors,
    'name': obj.name,
    'priority': obj.priority,
    'region': obj.region,
    'serviceRoleArn': obj.serviceRoleArn,
    'serviceRoleArnRef': toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnRef(obj.serviceRoleArnRef),
    'serviceRoleArnSelector': toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector(obj.serviceRoleArnSelector),
    'targets': obj.targets?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTargets(y)),
    'taskArn': obj.taskArn,
    'taskArnRef': toJson_MaintenanceWindowTaskSpecForProviderTaskArnRef(obj.taskArnRef),
    'taskArnSelector': toJson_MaintenanceWindowTaskSpecForProviderTaskArnSelector(obj.taskArnSelector),
    'taskInvocationParameters': obj.taskInvocationParameters?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParameters(y)),
    'taskType': obj.taskType,
    'windowId': obj.windowId,
    'windowIdRef': toJson_MaintenanceWindowTaskSpecForProviderWindowIdRef(obj.windowIdRef),
    'windowIdSelector': toJson_MaintenanceWindowTaskSpecForProviderWindowIdSelector(obj.windowIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MaintenanceWindowTaskSpecManagementPolicy
 */
export enum MaintenanceWindowTaskSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MaintenanceWindowTaskSpecProviderConfigRef
 */
export interface MaintenanceWindowTaskSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecProviderConfigRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecProviderConfigRef(obj: MaintenanceWindowTaskSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MaintenanceWindowTaskSpecProviderRef
 */
export interface MaintenanceWindowTaskSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecProviderRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecProviderRef(obj: MaintenanceWindowTaskSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsTo
 */
export interface MaintenanceWindowTaskSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsTo(obj: MaintenanceWindowTaskSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MaintenanceWindowTaskSpecWriteConnectionSecretToRef
 */
export interface MaintenanceWindowTaskSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MaintenanceWindowTaskSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MaintenanceWindowTaskSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecWriteConnectionSecretToRef(obj: MaintenanceWindowTaskSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceRoleArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRef
 */
export interface MaintenanceWindowTaskSpecForProviderServiceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderServiceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnRef(obj: MaintenanceWindowTaskSpecForProviderServiceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceRoleArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector
 */
export interface MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector(obj: MaintenanceWindowTaskSpecForProviderServiceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTargets
 */
export interface MaintenanceWindowTaskSpecForProviderTargets {
  /**
   * @schema MaintenanceWindowTaskSpecForProviderTargets#key
   */
  readonly key: string;

  /**
   * The array of strings.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTargets#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTargets(obj: MaintenanceWindowTaskSpecForProviderTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate taskArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnRef
 */
export interface MaintenanceWindowTaskSpecForProviderTaskArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskArnRef(obj: MaintenanceWindowTaskSpecForProviderTaskArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate taskArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelector
 */
export interface MaintenanceWindowTaskSpecForProviderTaskArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelector#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskArnSelector(obj: MaintenanceWindowTaskSpecForProviderTaskArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParameters
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParameters {
  /**
   * The parameters for an AUTOMATION task type. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParameters#automationParameters
   */
  readonly automationParameters?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters[];

  /**
   * The parameters for a LAMBDA task type. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParameters#lambdaParameters
   */
  readonly lambdaParameters?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters[];

  /**
   * The parameters for a RUN_COMMAND task type. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParameters#runCommandParameters
   */
  readonly runCommandParameters?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters[];

  /**
   * The parameters for a STEP_FUNCTIONS task type. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParameters#stepFunctionsParameters
   */
  readonly stepFunctionsParameters?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters[];

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParameters(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'automationParameters': obj.automationParameters?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters(y)),
    'lambdaParameters': obj.lambdaParameters?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters(y)),
    'runCommandParameters': obj.runCommandParameters?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters(y)),
    'stepFunctionsParameters': obj.stepFunctionsParameters?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a MaintenanceWindow in ssm to populate windowId.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdRef
 */
export interface MaintenanceWindowTaskSpecForProviderWindowIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderWindowIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderWindowIdRef(obj: MaintenanceWindowTaskSpecForProviderWindowIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a MaintenanceWindow in ssm to populate windowId.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelector
 */
export interface MaintenanceWindowTaskSpecForProviderWindowIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelector#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderWindowIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderWindowIdSelector(obj: MaintenanceWindowTaskSpecForProviderWindowIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecProviderConfigRefPolicy
 */
export interface MaintenanceWindowTaskSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecProviderConfigRefPolicy(obj: MaintenanceWindowTaskSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecProviderRefPolicy
 */
export interface MaintenanceWindowTaskSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecProviderRefPolicy(obj: MaintenanceWindowTaskSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef
 */
export interface MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef(obj: MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata
 */
export interface MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata(obj: MaintenanceWindowTaskSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy(obj: MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy(obj: MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters {
  /**
   * The version of an Automation document to use during task execution.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters#documentVersion
   */
  readonly documentVersion?: string;

  /**
   * The parameters for the RUN_COMMAND task execution. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters#parameter
   */
  readonly parameter?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter[];

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'documentVersion': obj.documentVersion,
    'parameter': obj.parameter?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters {
  /**
   * Pass client-specific information to the Lambda function that you are invoking.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters#clientContext
   */
  readonly clientContext?: string;

  /**
   * JSON to provide to your Lambda function as input.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters#payloadSecretRef
   */
  readonly payloadSecretRef?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef;

  /**
   * Specify a Lambda function version or alias name.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters#qualifier
   */
  readonly qualifier?: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientContext': obj.clientContext,
    'payloadSecretRef': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef(obj.payloadSecretRef),
    'qualifier': obj.qualifier,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters {
  /**
   * Configuration options for sending command output to CloudWatch Logs. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#cloudwatchConfig
   */
  readonly cloudwatchConfig?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig[];

  /**
   * Information about the command(s) to execute.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#comment
   */
  readonly comment?: string;

  /**
   * The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#documentHash
   */
  readonly documentHash?: string;

  /**
   * SHA-256 or SHA-1. SHA-1 hashes have been deprecated. Valid values: Sha256 and Sha1
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#documentHashType
   */
  readonly documentHashType?: string;

  /**
   * The version of an Automation document to use during task execution.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#documentVersion
   */
  readonly documentVersion?: string;

  /**
   * Configurations for sending notifications about command status changes on a per-instance basis. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#notificationConfig
   */
  readonly notificationConfig?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig[];

  /**
   * The name of the Amazon S3 bucket.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#outputS3Bucket
   */
  readonly outputS3Bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate outputS3Bucket.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#outputS3BucketRef
   */
  readonly outputS3BucketRef?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef;

  /**
   * Selector for a Bucket in s3 to populate outputS3Bucket.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#outputS3BucketSelector
   */
  readonly outputS3BucketSelector?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector;

  /**
   * The Amazon S3 bucket subfolder.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#outputS3KeyPrefix
   */
  readonly outputS3KeyPrefix?: string;

  /**
   * The parameters for the RUN_COMMAND task execution. Documented below.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#parameter
   */
  readonly parameter?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter[];

  /**
   * The role that should be assumed when executing the task. If a role is not provided, Systems Manager uses your account's service-linked role. If no service-linked role for Systems Manager exists in your account, it is created for you.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#serviceRoleArn
   */
  readonly serviceRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceRoleArn.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#serviceRoleArnRef
   */
  readonly serviceRoleArnRef?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceRoleArn.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#serviceRoleArnSelector
   */
  readonly serviceRoleArnSelector?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector;

  /**
   * If this time is reached and the command has not already started executing, it doesn't run.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchConfig': obj.cloudwatchConfig?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig(y)),
    'comment': obj.comment,
    'documentHash': obj.documentHash,
    'documentHashType': obj.documentHashType,
    'documentVersion': obj.documentVersion,
    'notificationConfig': obj.notificationConfig?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig(y)),
    'outputS3Bucket': obj.outputS3Bucket,
    'outputS3BucketRef': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef(obj.outputS3BucketRef),
    'outputS3BucketSelector': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector(obj.outputS3BucketSelector),
    'outputS3KeyPrefix': obj.outputS3KeyPrefix,
    'parameter': obj.parameter?.map(y => toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter(y)),
    'serviceRoleArn': obj.serviceRoleArn,
    'serviceRoleArnRef': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef(obj.serviceRoleArnRef),
    'serviceRoleArnSelector': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector(obj.serviceRoleArnSelector),
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters {
  /**
   * The inputs for the STEP_FUNCTION task.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters#inputSecretRef
   */
  readonly inputSecretRef?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef;

  /**
   * The name of the maintenance window task.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inputSecretRef': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef(obj.inputSecretRef),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderWindowIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderWindowIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy(obj: MaintenanceWindowTaskSpecForProviderWindowIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy(obj: MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecProviderConfigRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecProviderConfigRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecProviderRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecProviderRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy(obj: MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderServiceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderServiceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter {
  /**
   * The name of the maintenance window task.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter#name
   */
  readonly name: string;

  /**
   * The array of strings.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersAutomationParametersParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JSON to provide to your Lambda function as input.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef {
  /**
   * The key to select.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersLambdaParametersPayloadSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig {
  /**
   * The name of the CloudWatch log group where you want to send command output. If you don't specify a group name, Systems Manager automatically creates a log group for you. The log group uses the following naming format: aws/ssm/SystemsManagerDocumentName.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig#cloudwatchLogGroupName
   */
  readonly cloudwatchLogGroupName?: string;

  /**
   * Enables Systems Manager to send command output to CloudWatch Logs.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig#cloudwatchOutputEnabled
   */
  readonly cloudwatchOutputEnabled?: boolean;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersCloudwatchConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLogGroupName': obj.cloudwatchLogGroupName,
    'cloudwatchOutputEnabled': obj.cloudwatchOutputEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig {
  /**
   * An Amazon Resource Name (ARN) for a Simple Notification Service (SNS) topic. Run Command pushes notifications about command status changes to this topic.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig#notificationArn
   */
  readonly notificationArn?: string;

  /**
   * Reference to a Topic in sns to populate notificationArn.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig#notificationArnRef
   */
  readonly notificationArnRef?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef;

  /**
   * Selector for a Topic in sns to populate notificationArn.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig#notificationArnSelector
   */
  readonly notificationArnSelector?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector;

  /**
   * The different events for which you can receive notifications. Valid values: All, InProgress, Success, TimedOut, Cancelled, and Failed
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig#notificationEvents
   */
  readonly notificationEvents?: string[];

  /**
   * When specified with Command, receive notification when the status of a command changes. When specified with Invocation, for commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes. Valid values: Command and Invocation
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig#notificationType
   */
  readonly notificationType?: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'notificationArn': obj.notificationArn,
    'notificationArnRef': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef(obj.notificationArnRef),
    'notificationArnSelector': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector(obj.notificationArnSelector),
    'notificationEvents': obj.notificationEvents?.map(y => y),
    'notificationType': obj.notificationType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate outputS3Bucket.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate outputS3Bucket.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter {
  /**
   * The name of the maintenance window task.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter#name
   */
  readonly name: string;

  /**
   * The array of strings.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceRoleArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceRoleArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The inputs for the STEP_FUNCTION task.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef {
  /**
   * The key to select.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersStepFunctionsParametersInputSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderWindowIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderWindowIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderWindowIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Topic in sns to populate notificationArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate notificationArn.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector#policy
   */
  readonly policy?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy
 */
export interface MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy#resolution
   */
  readonly resolution?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy#resolve
   */
  readonly resolve?: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy(obj: MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersOutputS3BucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersServiceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicyResolution
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicyResolve
 */
export enum MaintenanceWindowTaskSpecForProviderTaskInvocationParametersRunCommandParametersNotificationConfigNotificationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Parameter is the Schema for the Parameters API. Provides a SSM Parameter resource
 *
 * @schema Parameter
 */
export class Parameter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Parameter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'Parameter',
  }

  /**
   * Renders a Kubernetes manifest for "Parameter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ParameterProps): any {
    return {
      ...Parameter.GVK,
      ...toJson_ParameterProps(props),
    };
  }

  /**
   * Defines a "Parameter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ParameterProps) {
    super(scope, id, {
      ...Parameter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Parameter.GVK,
      ...toJson_ParameterProps(resolved),
    };
  }
}

/**
 * Parameter is the Schema for the Parameters API. Provides a SSM Parameter resource
 *
 * @schema Parameter
 */
export interface ParameterProps {
  /**
   * @schema Parameter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ParameterSpec defines the desired state of Parameter
   *
   * @schema Parameter#spec
   */
  readonly spec: ParameterSpec;

}

/**
 * Converts an object of type 'ParameterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterProps(obj: ParameterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ParameterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ParameterSpec defines the desired state of Parameter
 *
 * @schema ParameterSpec
 */
export interface ParameterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ParameterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ParameterSpecDeletionPolicy;

  /**
   * @schema ParameterSpec#forProvider
   */
  readonly forProvider: ParameterSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ParameterSpec#managementPolicy
   */
  readonly managementPolicy?: ParameterSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ParameterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ParameterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ParameterSpec#providerRef
   */
  readonly providerRef?: ParameterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ParameterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ParameterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ParameterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ParameterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ParameterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpec(obj: ParameterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ParameterSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ParameterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ParameterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ParameterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ParameterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ParameterSpecDeletionPolicy
 */
export enum ParameterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ParameterSpecForProvider
 */
export interface ParameterSpecForProvider {
  /**
   * Regular expression used to validate the parameter value.
   *
   * @schema ParameterSpecForProvider#allowedPattern
   */
  readonly allowedPattern?: string;

  /**
   * ARN of the parameter.
   *
   * @schema ParameterSpecForProvider#arn
   */
  readonly arn?: string;

  /**
   * Data type of the parameter. Valid values: text, aws:ssm:integration and aws:ec2:image for AMI format, see the Native parameter support for Amazon Machine Image IDs.
   *
   * @schema ParameterSpecForProvider#dataType
   */
  readonly dataType?: string;

  /**
   * Description of the parameter.
   *
   * @schema ParameterSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Value of the parameter. This argument is not valid with a type of SecureString.
   *
   * @schema ParameterSpecForProvider#insecureValue
   */
  readonly insecureValue?: string;

  /**
   * KMS key ID or ARN for encrypting a SecureString.
   *
   * @schema ParameterSpecForProvider#keyId
   */
  readonly keyId?: string;

  /**
   * Overwrite an existing parameter.
   *
   * @schema ParameterSpecForProvider#overwrite
   */
  readonly overwrite?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ParameterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ParameterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Parameter tier to assign to the parameter. If not specified, will use the default parameter tier for the region. Valid tiers are Standard, Advanced, and Intelligent-Tiering. Downgrading an Advanced tier parameter to Standard will recreate the resource. For more information on parameter tiers, see the AWS SSM Parameter tier comparison and guide.
   *
   * @schema ParameterSpecForProvider#tier
   */
  readonly tier?: string;

  /**
   * Type of the parameter. Valid types are String, StringList and SecureString.
   *
   * @schema ParameterSpecForProvider#type
   */
  readonly type?: string;

  /**
   * Value of the parameter.15 and later, this may require additional configuration handling for certain scenarios.15 Upgrade Guide.
   *
   * @schema ParameterSpecForProvider#valueSecretRef
   */
  readonly valueSecretRef?: ParameterSpecForProviderValueSecretRef;

}

/**
 * Converts an object of type 'ParameterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecForProvider(obj: ParameterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedPattern': obj.allowedPattern,
    'arn': obj.arn,
    'dataType': obj.dataType,
    'description': obj.description,
    'insecureValue': obj.insecureValue,
    'keyId': obj.keyId,
    'overwrite': obj.overwrite,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tier': obj.tier,
    'type': obj.type,
    'valueSecretRef': toJson_ParameterSpecForProviderValueSecretRef(obj.valueSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ParameterSpecManagementPolicy
 */
export enum ParameterSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ParameterSpecProviderConfigRef
 */
export interface ParameterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterSpecProviderConfigRef#policy
   */
  readonly policy?: ParameterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecProviderConfigRef(obj: ParameterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ParameterSpecProviderRef
 */
export interface ParameterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterSpecProviderRef#policy
   */
  readonly policy?: ParameterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ParameterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecProviderRef(obj: ParameterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ParameterSpecPublishConnectionDetailsTo
 */
export interface ParameterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ParameterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ParameterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ParameterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ParameterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ParameterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ParameterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecPublishConnectionDetailsTo(obj: ParameterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ParameterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ParameterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ParameterSpecWriteConnectionSecretToRef
 */
export interface ParameterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ParameterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ParameterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ParameterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecWriteConnectionSecretToRef(obj: ParameterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value of the parameter.15 and later, this may require additional configuration handling for certain scenarios.15 Upgrade Guide.
 *
 * @schema ParameterSpecForProviderValueSecretRef
 */
export interface ParameterSpecForProviderValueSecretRef {
  /**
   * The key to select.
   *
   * @schema ParameterSpecForProviderValueSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ParameterSpecForProviderValueSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ParameterSpecForProviderValueSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ParameterSpecForProviderValueSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecForProviderValueSecretRef(obj: ParameterSpecForProviderValueSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ParameterSpecProviderConfigRefPolicy
 */
export interface ParameterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecProviderConfigRefPolicy(obj: ParameterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ParameterSpecProviderRefPolicy
 */
export interface ParameterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ParameterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ParameterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecProviderRefPolicy(obj: ParameterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ParameterSpecPublishConnectionDetailsToConfigRef
 */
export interface ParameterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ParameterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ParameterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ParameterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ParameterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecPublishConnectionDetailsToConfigRef(obj: ParameterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ParameterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ParameterSpecPublishConnectionDetailsToMetadata
 */
export interface ParameterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ParameterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ParameterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ParameterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecPublishConnectionDetailsToMetadata(obj: ParameterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterSpecProviderConfigRefPolicyResolution
 */
export enum ParameterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterSpecProviderConfigRefPolicyResolve
 */
export enum ParameterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterSpecProviderRefPolicyResolution
 */
export enum ParameterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterSpecProviderRefPolicyResolve
 */
export enum ParameterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ParameterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ParameterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ParameterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ParameterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ParameterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ParameterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ParameterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ParameterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ParameterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ParameterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ParameterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ParameterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ParameterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PatchBaseline is the Schema for the PatchBaselines API. Provides an SSM Patch Baseline resource
 *
 * @schema PatchBaseline
 */
export class PatchBaseline extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PatchBaseline"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'PatchBaseline',
  }

  /**
   * Renders a Kubernetes manifest for "PatchBaseline".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PatchBaselineProps): any {
    return {
      ...PatchBaseline.GVK,
      ...toJson_PatchBaselineProps(props),
    };
  }

  /**
   * Defines a "PatchBaseline" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PatchBaselineProps) {
    super(scope, id, {
      ...PatchBaseline.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PatchBaseline.GVK,
      ...toJson_PatchBaselineProps(resolved),
    };
  }
}

/**
 * PatchBaseline is the Schema for the PatchBaselines API. Provides an SSM Patch Baseline resource
 *
 * @schema PatchBaseline
 */
export interface PatchBaselineProps {
  /**
   * @schema PatchBaseline#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PatchBaselineSpec defines the desired state of PatchBaseline
   *
   * @schema PatchBaseline#spec
   */
  readonly spec: PatchBaselineSpec;

}

/**
 * Converts an object of type 'PatchBaselineProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineProps(obj: PatchBaselineProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PatchBaselineSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PatchBaselineSpec defines the desired state of PatchBaseline
 *
 * @schema PatchBaselineSpec
 */
export interface PatchBaselineSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PatchBaselineSpec#deletionPolicy
   */
  readonly deletionPolicy?: PatchBaselineSpecDeletionPolicy;

  /**
   * @schema PatchBaselineSpec#forProvider
   */
  readonly forProvider: PatchBaselineSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PatchBaselineSpec#managementPolicy
   */
  readonly managementPolicy?: PatchBaselineSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PatchBaselineSpec#providerConfigRef
   */
  readonly providerConfigRef?: PatchBaselineSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PatchBaselineSpec#providerRef
   */
  readonly providerRef?: PatchBaselineSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PatchBaselineSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PatchBaselineSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PatchBaselineSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PatchBaselineSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PatchBaselineSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpec(obj: PatchBaselineSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PatchBaselineSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PatchBaselineSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PatchBaselineSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PatchBaselineSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PatchBaselineSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PatchBaselineSpecDeletionPolicy
 */
export enum PatchBaselineSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PatchBaselineSpecForProvider
 */
export interface PatchBaselineSpecForProvider {
  /**
   * A set of rules used to include patches in the baseline. Up to 10 approval rules can be specified. See approval_rule below.
   *
   * @schema PatchBaselineSpecForProvider#approvalRule
   */
  readonly approvalRule?: PatchBaselineSpecForProviderApprovalRule[];

  /**
   * A list of explicitly approved patches for the baseline. Cannot be specified with approval_rule.
   *
   * @schema PatchBaselineSpecForProvider#approvedPatches
   */
  readonly approvedPatches?: string[];

  /**
   * The compliance level for approved patches. This means that if an approved patch is reported as missing, this is the severity of the compliance violation. Valid values are CRITICAL, HIGH, MEDIUM, LOW, INFORMATIONAL, UNSPECIFIED. The default value is UNSPECIFIED.
   *
   * @schema PatchBaselineSpecForProvider#approvedPatchesComplianceLevel
   */
  readonly approvedPatchesComplianceLevel?: string;

  /**
   * Indicates whether the list of approved patches includes non-security updates that should be applied to the instances. Applies to Linux instances only.
   *
   * @schema PatchBaselineSpecForProvider#approvedPatchesEnableNonSecurity
   */
  readonly approvedPatchesEnableNonSecurity?: boolean;

  /**
   * The description of the patch baseline.
   *
   * @schema PatchBaselineSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A set of global filters used to exclude patches from the baseline. Up to 4 global filters can be specified using Key/Value pairs. Valid Keys are PRODUCT, CLASSIFICATION, MSRC_SEVERITY, and PATCH_ID.
   *
   * @schema PatchBaselineSpecForProvider#globalFilter
   */
  readonly globalFilter?: PatchBaselineSpecForProviderGlobalFilter[];

  /**
   * The name of the patch baseline.
   *
   * @schema PatchBaselineSpecForProvider#name
   */
  readonly name?: string;

  /**
   * The operating system the patch baseline applies to. Valid values are AMAZON_LINUX, AMAZON_LINUX_2, AMAZON_LINUX_2022, CENTOS, DEBIAN, MACOS, ORACLE_LINUX, RASPBIAN, REDHAT_ENTERPRISE_LINUX, ROCKY_LINUX, SUSE, UBUNTU, and WINDOWS. The default value is WINDOWS.
   *
   * @schema PatchBaselineSpecForProvider#operatingSystem
   */
  readonly operatingSystem?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PatchBaselineSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of rejected patches.
   *
   * @schema PatchBaselineSpecForProvider#rejectedPatches
   */
  readonly rejectedPatches?: string[];

  /**
   * The action for Patch Manager to take on patches included in the rejected_patches list. Valid values are ALLOW_AS_DEPENDENCY and BLOCK.
   *
   * @schema PatchBaselineSpecForProvider#rejectedPatchesAction
   */
  readonly rejectedPatchesAction?: string;

  /**
   * Configuration block with alternate sources for patches. Applies to Linux instances only. See source below.
   *
   * @schema PatchBaselineSpecForProvider#source
   */
  readonly source?: PatchBaselineSpecForProviderSource[];

  /**
   * Key-value map of resource tags.
   *
   * @schema PatchBaselineSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PatchBaselineSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecForProvider(obj: PatchBaselineSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'approvalRule': obj.approvalRule?.map(y => toJson_PatchBaselineSpecForProviderApprovalRule(y)),
    'approvedPatches': obj.approvedPatches?.map(y => y),
    'approvedPatchesComplianceLevel': obj.approvedPatchesComplianceLevel,
    'approvedPatchesEnableNonSecurity': obj.approvedPatchesEnableNonSecurity,
    'description': obj.description,
    'globalFilter': obj.globalFilter?.map(y => toJson_PatchBaselineSpecForProviderGlobalFilter(y)),
    'name': obj.name,
    'operatingSystem': obj.operatingSystem,
    'region': obj.region,
    'rejectedPatches': obj.rejectedPatches?.map(y => y),
    'rejectedPatchesAction': obj.rejectedPatchesAction,
    'source': obj.source?.map(y => toJson_PatchBaselineSpecForProviderSource(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PatchBaselineSpecManagementPolicy
 */
export enum PatchBaselineSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PatchBaselineSpecProviderConfigRef
 */
export interface PatchBaselineSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchBaselineSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchBaselineSpecProviderConfigRef#policy
   */
  readonly policy?: PatchBaselineSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchBaselineSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecProviderConfigRef(obj: PatchBaselineSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchBaselineSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PatchBaselineSpecProviderRef
 */
export interface PatchBaselineSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchBaselineSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchBaselineSpecProviderRef#policy
   */
  readonly policy?: PatchBaselineSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PatchBaselineSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecProviderRef(obj: PatchBaselineSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchBaselineSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PatchBaselineSpecPublishConnectionDetailsTo
 */
export interface PatchBaselineSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PatchBaselineSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PatchBaselineSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PatchBaselineSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecPublishConnectionDetailsTo(obj: PatchBaselineSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PatchBaselineSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PatchBaselineSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PatchBaselineSpecWriteConnectionSecretToRef
 */
export interface PatchBaselineSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PatchBaselineSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PatchBaselineSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PatchBaselineSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecWriteConnectionSecretToRef(obj: PatchBaselineSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchBaselineSpecForProviderApprovalRule
 */
export interface PatchBaselineSpecForProviderApprovalRule {
  /**
   * The number of days after the release date of each patch matched by the rule the patch is marked as approved in the patch baseline. Valid Range: 0 to 100. Conflicts with approve_until_date.
   *
   * @schema PatchBaselineSpecForProviderApprovalRule#approveAfterDays
   */
  readonly approveAfterDays?: number;

  /**
   * The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically. Date is formatted as YYYY-MM-DD. Conflicts with approve_after_days
   *
   * @schema PatchBaselineSpecForProviderApprovalRule#approveUntilDate
   */
  readonly approveUntilDate?: string;

  /**
   * The compliance level for patches approved by this rule. Valid values are CRITICAL, HIGH, MEDIUM, LOW, INFORMATIONAL, and UNSPECIFIED. The default value is UNSPECIFIED.
   *
   * @schema PatchBaselineSpecForProviderApprovalRule#complianceLevel
   */
  readonly complianceLevel?: string;

  /**
   * Boolean enabling the application of non-security updates. The default value is false. Valid for Linux instances only.
   *
   * @schema PatchBaselineSpecForProviderApprovalRule#enableNonSecurity
   */
  readonly enableNonSecurity?: boolean;

  /**
   * The patch filter group that defines the criteria for the rule. Up to 5 patch filters can be specified per approval rule using Key/Value pairs. Valid combinations of these Keys and the operating_system value can be found in the SSM DescribePatchProperties API Reference. Valid Values are exact values for the patch property given as the key, or a wildcard *, which matches all values.
   *
   * @schema PatchBaselineSpecForProviderApprovalRule#patchFilter
   */
  readonly patchFilter: PatchBaselineSpecForProviderApprovalRulePatchFilter[];

}

/**
 * Converts an object of type 'PatchBaselineSpecForProviderApprovalRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecForProviderApprovalRule(obj: PatchBaselineSpecForProviderApprovalRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'approveAfterDays': obj.approveAfterDays,
    'approveUntilDate': obj.approveUntilDate,
    'complianceLevel': obj.complianceLevel,
    'enableNonSecurity': obj.enableNonSecurity,
    'patchFilter': obj.patchFilter?.map(y => toJson_PatchBaselineSpecForProviderApprovalRulePatchFilter(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchBaselineSpecForProviderGlobalFilter
 */
export interface PatchBaselineSpecForProviderGlobalFilter {
  /**
   * @schema PatchBaselineSpecForProviderGlobalFilter#key
   */
  readonly key: string;

  /**
   * @schema PatchBaselineSpecForProviderGlobalFilter#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'PatchBaselineSpecForProviderGlobalFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecForProviderGlobalFilter(obj: PatchBaselineSpecForProviderGlobalFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchBaselineSpecForProviderSource
 */
export interface PatchBaselineSpecForProviderSource {
  /**
   * The value of the yum repo configuration. For information about other options available for your yum repository configuration, see the dnf.conf documentation
   *
   * @schema PatchBaselineSpecForProviderSource#configuration
   */
  readonly configuration: string;

  /**
   * The name specified to identify the patch source.
   *
   * @schema PatchBaselineSpecForProviderSource#name
   */
  readonly name: string;

  /**
   * The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "AmazonLinux2016.09", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see PatchFilter.
   *
   * @schema PatchBaselineSpecForProviderSource#products
   */
  readonly products: string[];

}

/**
 * Converts an object of type 'PatchBaselineSpecForProviderSource' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecForProviderSource(obj: PatchBaselineSpecForProviderSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configuration': obj.configuration,
    'name': obj.name,
    'products': obj.products?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchBaselineSpecProviderConfigRefPolicy
 */
export interface PatchBaselineSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchBaselineSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PatchBaselineSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchBaselineSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PatchBaselineSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchBaselineSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecProviderConfigRefPolicy(obj: PatchBaselineSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchBaselineSpecProviderRefPolicy
 */
export interface PatchBaselineSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchBaselineSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PatchBaselineSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchBaselineSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PatchBaselineSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchBaselineSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecProviderRefPolicy(obj: PatchBaselineSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRef
 */
export interface PatchBaselineSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchBaselineSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecPublishConnectionDetailsToConfigRef(obj: PatchBaselineSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PatchBaselineSpecPublishConnectionDetailsToMetadata
 */
export interface PatchBaselineSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PatchBaselineSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecPublishConnectionDetailsToMetadata(obj: PatchBaselineSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PatchBaselineSpecForProviderApprovalRulePatchFilter
 */
export interface PatchBaselineSpecForProviderApprovalRulePatchFilter {
  /**
   * @schema PatchBaselineSpecForProviderApprovalRulePatchFilter#key
   */
  readonly key: string;

  /**
   * @schema PatchBaselineSpecForProviderApprovalRulePatchFilter#values
   */
  readonly values: string[];

}

/**
 * Converts an object of type 'PatchBaselineSpecForProviderApprovalRulePatchFilter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecForProviderApprovalRulePatchFilter(obj: PatchBaselineSpecForProviderApprovalRulePatchFilter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchBaselineSpecProviderConfigRefPolicyResolution
 */
export enum PatchBaselineSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchBaselineSpecProviderConfigRefPolicyResolve
 */
export enum PatchBaselineSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchBaselineSpecProviderRefPolicyResolution
 */
export enum PatchBaselineSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchBaselineSpecProviderRefPolicyResolve
 */
export enum PatchBaselineSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy(obj: PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PatchBaselineSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PatchGroup is the Schema for the PatchGroups API. Provides an SSM Patch Group resource
 *
 * @schema PatchGroup
 */
export class PatchGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PatchGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'PatchGroup',
  }

  /**
   * Renders a Kubernetes manifest for "PatchGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PatchGroupProps): any {
    return {
      ...PatchGroup.GVK,
      ...toJson_PatchGroupProps(props),
    };
  }

  /**
   * Defines a "PatchGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PatchGroupProps) {
    super(scope, id, {
      ...PatchGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PatchGroup.GVK,
      ...toJson_PatchGroupProps(resolved),
    };
  }
}

/**
 * PatchGroup is the Schema for the PatchGroups API. Provides an SSM Patch Group resource
 *
 * @schema PatchGroup
 */
export interface PatchGroupProps {
  /**
   * @schema PatchGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PatchGroupSpec defines the desired state of PatchGroup
   *
   * @schema PatchGroup#spec
   */
  readonly spec: PatchGroupSpec;

}

/**
 * Converts an object of type 'PatchGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupProps(obj: PatchGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PatchGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PatchGroupSpec defines the desired state of PatchGroup
 *
 * @schema PatchGroupSpec
 */
export interface PatchGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PatchGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: PatchGroupSpecDeletionPolicy;

  /**
   * @schema PatchGroupSpec#forProvider
   */
  readonly forProvider: PatchGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PatchGroupSpec#managementPolicy
   */
  readonly managementPolicy?: PatchGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PatchGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: PatchGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema PatchGroupSpec#providerRef
   */
  readonly providerRef?: PatchGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PatchGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PatchGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PatchGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PatchGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PatchGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpec(obj: PatchGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PatchGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_PatchGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_PatchGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_PatchGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PatchGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PatchGroupSpecDeletionPolicy
 */
export enum PatchGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PatchGroupSpecForProvider
 */
export interface PatchGroupSpecForProvider {
  /**
   * The ID of the patch baseline to register the patch group with.
   *
   * @schema PatchGroupSpecForProvider#baselineId
   */
  readonly baselineId?: string;

  /**
   * Reference to a PatchBaseline in ssm to populate baselineId.
   *
   * @schema PatchGroupSpecForProvider#baselineIdRef
   */
  readonly baselineIdRef?: PatchGroupSpecForProviderBaselineIdRef;

  /**
   * Selector for a PatchBaseline in ssm to populate baselineId.
   *
   * @schema PatchGroupSpecForProvider#baselineIdSelector
   */
  readonly baselineIdSelector?: PatchGroupSpecForProviderBaselineIdSelector;

  /**
   * The name of the patch group that should be registered with the patch baseline.
   *
   * @schema PatchGroupSpecForProvider#patchGroup
   */
  readonly patchGroup?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PatchGroupSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PatchGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecForProvider(obj: PatchGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baselineId': obj.baselineId,
    'baselineIdRef': toJson_PatchGroupSpecForProviderBaselineIdRef(obj.baselineIdRef),
    'baselineIdSelector': toJson_PatchGroupSpecForProviderBaselineIdSelector(obj.baselineIdSelector),
    'patchGroup': obj.patchGroup,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PatchGroupSpecManagementPolicy
 */
export enum PatchGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PatchGroupSpecProviderConfigRef
 */
export interface PatchGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchGroupSpecProviderConfigRef#policy
   */
  readonly policy?: PatchGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecProviderConfigRef(obj: PatchGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema PatchGroupSpecProviderRef
 */
export interface PatchGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchGroupSpecProviderRef#policy
   */
  readonly policy?: PatchGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'PatchGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecProviderRef(obj: PatchGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PatchGroupSpecPublishConnectionDetailsTo
 */
export interface PatchGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PatchGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PatchGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PatchGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecPublishConnectionDetailsTo(obj: PatchGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PatchGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PatchGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PatchGroupSpecWriteConnectionSecretToRef
 */
export interface PatchGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PatchGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PatchGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PatchGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecWriteConnectionSecretToRef(obj: PatchGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PatchBaseline in ssm to populate baselineId.
 *
 * @schema PatchGroupSpecForProviderBaselineIdRef
 */
export interface PatchGroupSpecForProviderBaselineIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchGroupSpecForProviderBaselineIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchGroupSpecForProviderBaselineIdRef#policy
   */
  readonly policy?: PatchGroupSpecForProviderBaselineIdRefPolicy;

}

/**
 * Converts an object of type 'PatchGroupSpecForProviderBaselineIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecForProviderBaselineIdRef(obj: PatchGroupSpecForProviderBaselineIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchGroupSpecForProviderBaselineIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PatchBaseline in ssm to populate baselineId.
 *
 * @schema PatchGroupSpecForProviderBaselineIdSelector
 */
export interface PatchGroupSpecForProviderBaselineIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PatchGroupSpecForProviderBaselineIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PatchGroupSpecForProviderBaselineIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PatchGroupSpecForProviderBaselineIdSelector#policy
   */
  readonly policy?: PatchGroupSpecForProviderBaselineIdSelectorPolicy;

}

/**
 * Converts an object of type 'PatchGroupSpecForProviderBaselineIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecForProviderBaselineIdSelector(obj: PatchGroupSpecForProviderBaselineIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PatchGroupSpecForProviderBaselineIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchGroupSpecProviderConfigRefPolicy
 */
export interface PatchGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PatchGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PatchGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecProviderConfigRefPolicy(obj: PatchGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchGroupSpecProviderRefPolicy
 */
export interface PatchGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: PatchGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: PatchGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecProviderRefPolicy(obj: PatchGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PatchGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface PatchGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PatchGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecPublishConnectionDetailsToConfigRef(obj: PatchGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PatchGroupSpecPublishConnectionDetailsToMetadata
 */
export interface PatchGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PatchGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecPublishConnectionDetailsToMetadata(obj: PatchGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PatchGroupSpecForProviderBaselineIdRefPolicy
 */
export interface PatchGroupSpecForProviderBaselineIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchGroupSpecForProviderBaselineIdRefPolicy#resolution
   */
  readonly resolution?: PatchGroupSpecForProviderBaselineIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchGroupSpecForProviderBaselineIdRefPolicy#resolve
   */
  readonly resolve?: PatchGroupSpecForProviderBaselineIdRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchGroupSpecForProviderBaselineIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecForProviderBaselineIdRefPolicy(obj: PatchGroupSpecForProviderBaselineIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PatchGroupSpecForProviderBaselineIdSelectorPolicy
 */
export interface PatchGroupSpecForProviderBaselineIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchGroupSpecForProviderBaselineIdSelectorPolicy#resolution
   */
  readonly resolution?: PatchGroupSpecForProviderBaselineIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchGroupSpecForProviderBaselineIdSelectorPolicy#resolve
   */
  readonly resolve?: PatchGroupSpecForProviderBaselineIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PatchGroupSpecForProviderBaselineIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecForProviderBaselineIdSelectorPolicy(obj: PatchGroupSpecForProviderBaselineIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchGroupSpecProviderConfigRefPolicyResolution
 */
export enum PatchGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchGroupSpecProviderConfigRefPolicyResolve
 */
export enum PatchGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchGroupSpecProviderRefPolicyResolution
 */
export enum PatchGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchGroupSpecProviderRefPolicyResolve
 */
export enum PatchGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PatchGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PatchGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: PatchGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchGroupSpecForProviderBaselineIdRefPolicyResolution
 */
export enum PatchGroupSpecForProviderBaselineIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchGroupSpecForProviderBaselineIdRefPolicyResolve
 */
export enum PatchGroupSpecForProviderBaselineIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchGroupSpecForProviderBaselineIdSelectorPolicyResolution
 */
export enum PatchGroupSpecForProviderBaselineIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchGroupSpecForProviderBaselineIdSelectorPolicyResolve
 */
export enum PatchGroupSpecForProviderBaselineIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PatchGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PatchGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PatchGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PatchGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResourceDataSync is the Schema for the ResourceDataSyncs API. Provides a SSM resource data sync.
 *
 * @schema ResourceDataSync
 */
export class ResourceDataSync extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResourceDataSync"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'ResourceDataSync',
  }

  /**
   * Renders a Kubernetes manifest for "ResourceDataSync".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceDataSyncProps): any {
    return {
      ...ResourceDataSync.GVK,
      ...toJson_ResourceDataSyncProps(props),
    };
  }

  /**
   * Defines a "ResourceDataSync" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceDataSyncProps) {
    super(scope, id, {
      ...ResourceDataSync.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResourceDataSync.GVK,
      ...toJson_ResourceDataSyncProps(resolved),
    };
  }
}

/**
 * ResourceDataSync is the Schema for the ResourceDataSyncs API. Provides a SSM resource data sync.
 *
 * @schema ResourceDataSync
 */
export interface ResourceDataSyncProps {
  /**
   * @schema ResourceDataSync#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourceDataSyncSpec defines the desired state of ResourceDataSync
   *
   * @schema ResourceDataSync#spec
   */
  readonly spec: ResourceDataSyncSpec;

}

/**
 * Converts an object of type 'ResourceDataSyncProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncProps(obj: ResourceDataSyncProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceDataSyncSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDataSyncSpec defines the desired state of ResourceDataSync
 *
 * @schema ResourceDataSyncSpec
 */
export interface ResourceDataSyncSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourceDataSyncSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourceDataSyncSpecDeletionPolicy;

  /**
   * @schema ResourceDataSyncSpec#forProvider
   */
  readonly forProvider: ResourceDataSyncSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResourceDataSyncSpec#managementPolicy
   */
  readonly managementPolicy?: ResourceDataSyncSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourceDataSyncSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourceDataSyncSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ResourceDataSyncSpec#providerRef
   */
  readonly providerRef?: ResourceDataSyncSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourceDataSyncSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourceDataSyncSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourceDataSyncSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourceDataSyncSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourceDataSyncSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpec(obj: ResourceDataSyncSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourceDataSyncSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ResourceDataSyncSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ResourceDataSyncSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ResourceDataSyncSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourceDataSyncSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourceDataSyncSpecDeletionPolicy
 */
export enum ResourceDataSyncSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResourceDataSyncSpecForProvider
 */
export interface ResourceDataSyncSpecForProvider {
  /**
   * Region with the bucket targeted by the Resource Data Sync. Region is the region you'd like your resource to be created in.
   *
   * @schema ResourceDataSyncSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon S3 configuration details for the sync.
   *
   * @schema ResourceDataSyncSpecForProvider#s3Destination
   */
  readonly s3Destination?: ResourceDataSyncSpecForProviderS3Destination[];

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProvider(obj: ResourceDataSyncSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    's3Destination': obj.s3Destination?.map(y => toJson_ResourceDataSyncSpecForProviderS3Destination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResourceDataSyncSpecManagementPolicy
 */
export enum ResourceDataSyncSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourceDataSyncSpecProviderConfigRef
 */
export interface ResourceDataSyncSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceDataSyncSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceDataSyncSpecProviderConfigRef#policy
   */
  readonly policy?: ResourceDataSyncSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecProviderConfigRef(obj: ResourceDataSyncSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceDataSyncSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ResourceDataSyncSpecProviderRef
 */
export interface ResourceDataSyncSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceDataSyncSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceDataSyncSpecProviderRef#policy
   */
  readonly policy?: ResourceDataSyncSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecProviderRef(obj: ResourceDataSyncSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceDataSyncSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourceDataSyncSpecPublishConnectionDetailsTo
 */
export interface ResourceDataSyncSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourceDataSyncSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourceDataSyncSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecPublishConnectionDetailsTo(obj: ResourceDataSyncSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourceDataSyncSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourceDataSyncSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourceDataSyncSpecWriteConnectionSecretToRef
 */
export interface ResourceDataSyncSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourceDataSyncSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceDataSyncSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecWriteConnectionSecretToRef(obj: ResourceDataSyncSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResourceDataSyncSpecForProviderS3Destination
 */
export interface ResourceDataSyncSpecForProviderS3Destination {
  /**
   * Name of S3 bucket where the aggregated data is stored.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#bucketName
   */
  readonly bucketName?: string;

  /**
   * Reference to a Bucket in s3 to populate bucketName.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#bucketNameRef
   */
  readonly bucketNameRef?: ResourceDataSyncSpecForProviderS3DestinationBucketNameRef;

  /**
   * Selector for a Bucket in s3 to populate bucketName.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#bucketNameSelector
   */
  readonly bucketNameSelector?: ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector;

  /**
   * ARN of an encryption key for a destination in Amazon S3.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#kmsKeyArn
   */
  readonly kmsKeyArn?: string;

  /**
   * Prefix for the bucket.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#prefix
   */
  readonly prefix?: string;

  /**
   * Region with the bucket targeted by the Resource Data Sync.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#region
   */
  readonly region?: string;

  /**
   * Reference to a Bucket in s3 to populate region.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#regionRef
   */
  readonly regionRef?: ResourceDataSyncSpecForProviderS3DestinationRegionRef;

  /**
   * Selector for a Bucket in s3 to populate region.
   *
   * @schema ResourceDataSyncSpecForProviderS3Destination#regionSelector
   */
  readonly regionSelector?: ResourceDataSyncSpecForProviderS3DestinationRegionSelector;

  /**
   * A supported sync format. Only JsonSerDe is currently supported. Defaults to JsonSerDe.
   *
   * @default JsonSerDe.
   * @schema ResourceDataSyncSpecForProviderS3Destination#syncFormat
   */
  readonly syncFormat?: string;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3Destination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3Destination(obj: ResourceDataSyncSpecForProviderS3Destination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucketName': obj.bucketName,
    'bucketNameRef': toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameRef(obj.bucketNameRef),
    'bucketNameSelector': toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector(obj.bucketNameSelector),
    'kmsKeyArn': obj.kmsKeyArn,
    'prefix': obj.prefix,
    'region': obj.region,
    'regionRef': toJson_ResourceDataSyncSpecForProviderS3DestinationRegionRef(obj.regionRef),
    'regionSelector': toJson_ResourceDataSyncSpecForProviderS3DestinationRegionSelector(obj.regionSelector),
    'syncFormat': obj.syncFormat,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceDataSyncSpecProviderConfigRefPolicy
 */
export interface ResourceDataSyncSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceDataSyncSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceDataSyncSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceDataSyncSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceDataSyncSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecProviderConfigRefPolicy(obj: ResourceDataSyncSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceDataSyncSpecProviderRefPolicy
 */
export interface ResourceDataSyncSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceDataSyncSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ResourceDataSyncSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceDataSyncSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ResourceDataSyncSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecProviderRefPolicy(obj: ResourceDataSyncSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRef
 */
export interface ResourceDataSyncSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecPublishConnectionDetailsToConfigRef(obj: ResourceDataSyncSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourceDataSyncSpecPublishConnectionDetailsToMetadata
 */
export interface ResourceDataSyncSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecPublishConnectionDetailsToMetadata(obj: ResourceDataSyncSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucketName.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRef
 */
export interface ResourceDataSyncSpecForProviderS3DestinationBucketNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRef#policy
   */
  readonly policy?: ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationBucketNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameRef(obj: ResourceDataSyncSpecForProviderS3DestinationBucketNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucketName.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector
 */
export interface ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector#policy
   */
  readonly policy?: ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector(obj: ResourceDataSyncSpecForProviderS3DestinationBucketNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate region.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRef
 */
export interface ResourceDataSyncSpecForProviderS3DestinationRegionRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRef#policy
   */
  readonly policy?: ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationRegionRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationRegionRef(obj: ResourceDataSyncSpecForProviderS3DestinationRegionRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate region.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelector
 */
export interface ResourceDataSyncSpecForProviderS3DestinationRegionSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelector#policy
   */
  readonly policy?: ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationRegionSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationRegionSelector(obj: ResourceDataSyncSpecForProviderS3DestinationRegionSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceDataSyncSpecProviderConfigRefPolicyResolution
 */
export enum ResourceDataSyncSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceDataSyncSpecProviderConfigRefPolicyResolve
 */
export enum ResourceDataSyncSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceDataSyncSpecProviderRefPolicyResolution
 */
export enum ResourceDataSyncSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceDataSyncSpecProviderRefPolicyResolve
 */
export enum ResourceDataSyncSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy
 */
export interface ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy#resolution
   */
  readonly resolution?: ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy#resolve
   */
  readonly resolve?: ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy(obj: ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy
 */
export interface ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy#resolution
   */
  readonly resolution?: ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy#resolve
   */
  readonly resolve?: ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy(obj: ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy
 */
export interface ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy#resolution
   */
  readonly resolution?: ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy#resolve
   */
  readonly resolve?: ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy(obj: ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy
 */
export interface ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy#resolution
   */
  readonly resolution?: ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy#resolve
   */
  readonly resolve?: ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy(obj: ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourceDataSyncSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicyResolution
 */
export enum ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicyResolve
 */
export enum ResourceDataSyncSpecForProviderS3DestinationBucketNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicyResolution
 */
export enum ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicyResolve
 */
export enum ResourceDataSyncSpecForProviderS3DestinationBucketNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicyResolution
 */
export enum ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicyResolve
 */
export enum ResourceDataSyncSpecForProviderS3DestinationRegionRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicyResolution
 */
export enum ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicyResolve
 */
export enum ResourceDataSyncSpecForProviderS3DestinationRegionSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ServiceSetting is the Schema for the ServiceSettings API. Defines how a user interacts with or uses a service or a feature of a service.
 *
 * @schema ServiceSetting
 */
export class ServiceSetting extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ServiceSetting"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssm.aws.upbound.io/v1beta1',
    kind: 'ServiceSetting',
  }

  /**
   * Renders a Kubernetes manifest for "ServiceSetting".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ServiceSettingProps): any {
    return {
      ...ServiceSetting.GVK,
      ...toJson_ServiceSettingProps(props),
    };
  }

  /**
   * Defines a "ServiceSetting" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ServiceSettingProps) {
    super(scope, id, {
      ...ServiceSetting.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ServiceSetting.GVK,
      ...toJson_ServiceSettingProps(resolved),
    };
  }
}

/**
 * ServiceSetting is the Schema for the ServiceSettings API. Defines how a user interacts with or uses a service or a feature of a service.
 *
 * @schema ServiceSetting
 */
export interface ServiceSettingProps {
  /**
   * @schema ServiceSetting#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ServiceSettingSpec defines the desired state of ServiceSetting
   *
   * @schema ServiceSetting#spec
   */
  readonly spec: ServiceSettingSpec;

}

/**
 * Converts an object of type 'ServiceSettingProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingProps(obj: ServiceSettingProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ServiceSettingSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceSettingSpec defines the desired state of ServiceSetting
 *
 * @schema ServiceSettingSpec
 */
export interface ServiceSettingSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSettingSpec#deletionPolicy
   */
  readonly deletionPolicy?: ServiceSettingSpecDeletionPolicy;

  /**
   * @schema ServiceSettingSpec#forProvider
   */
  readonly forProvider: ServiceSettingSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ServiceSettingSpec#managementPolicy
   */
  readonly managementPolicy?: ServiceSettingSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ServiceSettingSpec#providerConfigRef
   */
  readonly providerConfigRef?: ServiceSettingSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ServiceSettingSpec#providerRef
   */
  readonly providerRef?: ServiceSettingSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ServiceSettingSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ServiceSettingSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ServiceSettingSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ServiceSettingSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ServiceSettingSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpec(obj: ServiceSettingSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ServiceSettingSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ServiceSettingSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ServiceSettingSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ServiceSettingSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ServiceSettingSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSettingSpecDeletionPolicy
 */
export enum ServiceSettingSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ServiceSettingSpecForProvider
 */
export interface ServiceSettingSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ServiceSettingSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the service setting.
   *
   * @schema ServiceSettingSpecForProvider#settingId
   */
  readonly settingId?: string;

  /**
   * Value of the service setting.
   *
   * @schema ServiceSettingSpecForProvider#settingValue
   */
  readonly settingValue?: string;

}

/**
 * Converts an object of type 'ServiceSettingSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecForProvider(obj: ServiceSettingSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'settingId': obj.settingId,
    'settingValue': obj.settingValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ServiceSettingSpecManagementPolicy
 */
export enum ServiceSettingSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ServiceSettingSpecProviderConfigRef
 */
export interface ServiceSettingSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSettingSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSettingSpecProviderConfigRef#policy
   */
  readonly policy?: ServiceSettingSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSettingSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecProviderConfigRef(obj: ServiceSettingSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSettingSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ServiceSettingSpecProviderRef
 */
export interface ServiceSettingSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSettingSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSettingSpecProviderRef#policy
   */
  readonly policy?: ServiceSettingSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ServiceSettingSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecProviderRef(obj: ServiceSettingSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSettingSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ServiceSettingSpecPublishConnectionDetailsTo
 */
export interface ServiceSettingSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ServiceSettingSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ServiceSettingSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ServiceSettingSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecPublishConnectionDetailsTo(obj: ServiceSettingSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ServiceSettingSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ServiceSettingSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ServiceSettingSpecWriteConnectionSecretToRef
 */
export interface ServiceSettingSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ServiceSettingSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ServiceSettingSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ServiceSettingSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecWriteConnectionSecretToRef(obj: ServiceSettingSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSettingSpecProviderConfigRefPolicy
 */
export interface ServiceSettingSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSettingSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSettingSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSettingSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSettingSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSettingSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecProviderConfigRefPolicy(obj: ServiceSettingSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ServiceSettingSpecProviderRefPolicy
 */
export interface ServiceSettingSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSettingSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ServiceSettingSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSettingSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ServiceSettingSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSettingSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecProviderRefPolicy(obj: ServiceSettingSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRef
 */
export interface ServiceSettingSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ServiceSettingSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecPublishConnectionDetailsToConfigRef(obj: ServiceSettingSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ServiceSettingSpecPublishConnectionDetailsToMetadata
 */
export interface ServiceSettingSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ServiceSettingSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecPublishConnectionDetailsToMetadata(obj: ServiceSettingSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSettingSpecProviderConfigRefPolicyResolution
 */
export enum ServiceSettingSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSettingSpecProviderConfigRefPolicyResolve
 */
export enum ServiceSettingSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSettingSpecProviderRefPolicyResolution
 */
export enum ServiceSettingSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSettingSpecProviderRefPolicyResolve
 */
export enum ServiceSettingSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy(obj: ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ServiceSettingSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

