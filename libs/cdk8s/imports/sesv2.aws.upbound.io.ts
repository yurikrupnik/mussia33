// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ConfigurationSet is the Schema for the ConfigurationSets API.
 *
 * @schema ConfigurationSet
 */
export class ConfigurationSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.upbound.io/v1beta1',
    kind: 'ConfigurationSet',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationSetProps): any {
    return {
      ...ConfigurationSet.GVK,
      ...toJson_ConfigurationSetProps(props),
    };
  }

  /**
   * Defines a "ConfigurationSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationSetProps) {
    super(scope, id, {
      ...ConfigurationSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationSet.GVK,
      ...toJson_ConfigurationSetProps(resolved),
    };
  }
}

/**
 * ConfigurationSet is the Schema for the ConfigurationSets API.
 *
 * @schema ConfigurationSet
 */
export interface ConfigurationSetProps {
  /**
   * @schema ConfigurationSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSetSpec defines the desired state of ConfigurationSet
   *
   * @schema ConfigurationSet#spec
   */
  readonly spec: ConfigurationSetSpec;

}

/**
 * Converts an object of type 'ConfigurationSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetProps(obj: ConfigurationSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSetSpec defines the desired state of ConfigurationSet
 *
 * @schema ConfigurationSetSpec
 */
export interface ConfigurationSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConfigurationSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationSetSpecDeletionPolicy;

  /**
   * @schema ConfigurationSetSpec#forProvider
   */
  readonly forProvider: ConfigurationSetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationSetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigurationSetSpec#providerRef
   */
  readonly providerRef?: ConfigurationSetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpec(obj: ConfigurationSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationSetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConfigurationSetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigurationSetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigurationSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConfigurationSetSpecDeletionPolicy
 */
export enum ConfigurationSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationSetSpecForProvider
 */
export interface ConfigurationSetSpecForProvider {
  /**
   * An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#deliveryOptions
   */
  readonly deliveryOptions?: ConfigurationSetSpecForProviderDeliveryOptions[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#reputationOptions
   */
  readonly reputationOptions?: ConfigurationSetSpecForProviderReputationOptions[];

  /**
   * An object that defines whether or not Amazon SES can send email that you send using the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#sendingOptions
   */
  readonly sendingOptions?: ConfigurationSetSpecForProviderSendingOptions[];

  /**
   * An object that contains information about the suppression list preferences for your account.
   *
   * @schema ConfigurationSetSpecForProvider#suppressionOptions
   */
  readonly suppressionOptions?: ConfigurationSetSpecForProviderSuppressionOptions[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ConfigurationSetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * An object that defines the open and click tracking options for emails that you send using the configuration set.
   *
   * @schema ConfigurationSetSpecForProvider#trackingOptions
   */
  readonly trackingOptions?: ConfigurationSetSpecForProviderTrackingOptions[];

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProvider(obj: ConfigurationSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryOptions': obj.deliveryOptions?.map(y => toJson_ConfigurationSetSpecForProviderDeliveryOptions(y)),
    'region': obj.region,
    'reputationOptions': obj.reputationOptions?.map(y => toJson_ConfigurationSetSpecForProviderReputationOptions(y)),
    'sendingOptions': obj.sendingOptions?.map(y => toJson_ConfigurationSetSpecForProviderSendingOptions(y)),
    'suppressionOptions': obj.suppressionOptions?.map(y => toJson_ConfigurationSetSpecForProviderSuppressionOptions(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'trackingOptions': obj.trackingOptions?.map(y => toJson_ConfigurationSetSpecForProviderTrackingOptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationSetSpecProviderConfigRef
 */
export interface ConfigurationSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderConfigRef(obj: ConfigurationSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigurationSetSpecProviderRef
 */
export interface ConfigurationSetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecProviderRef#policy
   */
  readonly policy?: ConfigurationSetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderRef(obj: ConfigurationSetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsTo
 */
export interface ConfigurationSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsTo(obj: ConfigurationSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationSetSpecWriteConnectionSecretToRef
 */
export interface ConfigurationSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecWriteConnectionSecretToRef(obj: ConfigurationSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderDeliveryOptions
 */
export interface ConfigurationSetSpecForProviderDeliveryOptions {
  /**
   * The name of the dedicated IP pool to associate with the configuration set.
   *
   * @schema ConfigurationSetSpecForProviderDeliveryOptions#sendingPoolName
   */
  readonly sendingPoolName?: string;

  /**
   * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). Valid values: REQUIRE, OPTIONAL.
   *
   * @schema ConfigurationSetSpecForProviderDeliveryOptions#tlsPolicy
   */
  readonly tlsPolicy?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderDeliveryOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderDeliveryOptions(obj: ConfigurationSetSpecForProviderDeliveryOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sendingPoolName': obj.sendingPoolName,
    'tlsPolicy': obj.tlsPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderReputationOptions
 */
export interface ConfigurationSetSpecForProviderReputationOptions {
  /**
   * If true, tracking of reputation metrics is enabled for the configuration set. If false, tracking of reputation metrics is disabled for the configuration set.
   *
   * @schema ConfigurationSetSpecForProviderReputationOptions#reputationMetricsEnabled
   */
  readonly reputationMetricsEnabled?: boolean;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderReputationOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderReputationOptions(obj: ConfigurationSetSpecForProviderReputationOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'reputationMetricsEnabled': obj.reputationMetricsEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderSendingOptions
 */
export interface ConfigurationSetSpecForProviderSendingOptions {
  /**
   * If true, email sending is enabled for the configuration set. If false, email sending is disabled for the configuration set.
   *
   * @schema ConfigurationSetSpecForProviderSendingOptions#sendingEnabled
   */
  readonly sendingEnabled?: boolean;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderSendingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderSendingOptions(obj: ConfigurationSetSpecForProviderSendingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sendingEnabled': obj.sendingEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderSuppressionOptions
 */
export interface ConfigurationSetSpecForProviderSuppressionOptions {
  /**
   * A list that contains the reasons that email addresses are automatically added to the suppression list for your account. Valid values: BOUNCE, COMPLAINT.
   *
   * @schema ConfigurationSetSpecForProviderSuppressionOptions#suppressedReasons
   */
  readonly suppressedReasons?: string[];

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderSuppressionOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderSuppressionOptions(obj: ConfigurationSetSpecForProviderSuppressionOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'suppressedReasons': obj.suppressedReasons?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetSpecForProviderTrackingOptions
 */
export interface ConfigurationSetSpecForProviderTrackingOptions {
  /**
   * The domain to use for tracking open and click events.
   *
   * @schema ConfigurationSetSpecForProviderTrackingOptions#customRedirectDomain
   */
  readonly customRedirectDomain: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecForProviderTrackingOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecForProviderTrackingOptions(obj: ConfigurationSetSpecForProviderTrackingOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customRedirectDomain': obj.customRedirectDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicy
 */
export interface ConfigurationSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderConfigRefPolicy(obj: ConfigurationSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecProviderRefPolicy
 */
export interface ConfigurationSetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecProviderRefPolicy(obj: ConfigurationSetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToMetadata(obj: ConfigurationSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecProviderRefPolicyResolution
 */
export enum ConfigurationSetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecProviderRefPolicyResolve
 */
export enum ConfigurationSetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConfigurationSetEventDestination is the Schema for the ConfigurationSetEventDestinations API.
 *
 * @schema ConfigurationSetEventDestination
 */
export class ConfigurationSetEventDestination extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConfigurationSetEventDestination"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.upbound.io/v1beta1',
    kind: 'ConfigurationSetEventDestination',
  }

  /**
   * Renders a Kubernetes manifest for "ConfigurationSetEventDestination".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationSetEventDestinationProps): any {
    return {
      ...ConfigurationSetEventDestination.GVK,
      ...toJson_ConfigurationSetEventDestinationProps(props),
    };
  }

  /**
   * Defines a "ConfigurationSetEventDestination" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationSetEventDestinationProps) {
    super(scope, id, {
      ...ConfigurationSetEventDestination.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConfigurationSetEventDestination.GVK,
      ...toJson_ConfigurationSetEventDestinationProps(resolved),
    };
  }
}

/**
 * ConfigurationSetEventDestination is the Schema for the ConfigurationSetEventDestinations API.
 *
 * @schema ConfigurationSetEventDestination
 */
export interface ConfigurationSetEventDestinationProps {
  /**
   * @schema ConfigurationSetEventDestination#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSetEventDestinationSpec defines the desired state of ConfigurationSetEventDestination
   *
   * @schema ConfigurationSetEventDestination#spec
   */
  readonly spec: ConfigurationSetEventDestinationSpec;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationProps(obj: ConfigurationSetEventDestinationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSetEventDestinationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSetEventDestinationSpec defines the desired state of ConfigurationSetEventDestination
 *
 * @schema ConfigurationSetEventDestinationSpec
 */
export interface ConfigurationSetEventDestinationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConfigurationSetEventDestinationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConfigurationSetEventDestinationSpecDeletionPolicy;

  /**
   * @schema ConfigurationSetEventDestinationSpec#forProvider
   */
  readonly forProvider: ConfigurationSetEventDestinationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConfigurationSetEventDestinationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConfigurationSetEventDestinationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConfigurationSetEventDestinationSpec#providerRef
   */
  readonly providerRef?: ConfigurationSetEventDestinationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConfigurationSetEventDestinationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConfigurationSetEventDestinationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpec(obj: ConfigurationSetEventDestinationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConfigurationSetEventDestinationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConfigurationSetEventDestinationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConfigurationSetEventDestinationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConfigurationSetEventDestinationSpecDeletionPolicy
 */
export enum ConfigurationSetEventDestinationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConfigurationSetEventDestinationSpecForProvider
 */
export interface ConfigurationSetEventDestinationSpecForProvider {
  /**
   * The name of the configuration set.
   *
   * @schema ConfigurationSetEventDestinationSpecForProvider#configurationSetName
   */
  readonly configurationSetName?: string;

  /**
   * Reference to a ConfigurationSet in sesv2 to populate configurationSetName.
   *
   * @schema ConfigurationSetEventDestinationSpecForProvider#configurationSetNameRef
   */
  readonly configurationSetNameRef?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef;

  /**
   * Selector for a ConfigurationSet in sesv2 to populate configurationSetName.
   *
   * @schema ConfigurationSetEventDestinationSpecForProvider#configurationSetNameSelector
   */
  readonly configurationSetNameSelector?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector;

  /**
   * A name that identifies the event destination within the configuration set.
   *
   * @schema ConfigurationSetEventDestinationSpecForProvider#eventDestination
   */
  readonly eventDestination: ConfigurationSetEventDestinationSpecForProviderEventDestination[];

  /**
   * An object that defines the event destination. See event_destination below.
   *
   * @schema ConfigurationSetEventDestinationSpecForProvider#eventDestinationName
   */
  readonly eventDestinationName: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConfigurationSetEventDestinationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProvider(obj: ConfigurationSetEventDestinationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configurationSetName': obj.configurationSetName,
    'configurationSetNameRef': toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef(obj.configurationSetNameRef),
    'configurationSetNameSelector': toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector(obj.configurationSetNameSelector),
    'eventDestination': obj.eventDestination?.map(y => toJson_ConfigurationSetEventDestinationSpecForProviderEventDestination(y)),
    'eventDestinationName': obj.eventDestinationName,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConfigurationSetEventDestinationSpecProviderConfigRef
 */
export interface ConfigurationSetEventDestinationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderConfigRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecProviderConfigRef(obj: ConfigurationSetEventDestinationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConfigurationSetEventDestinationSpecProviderRef
 */
export interface ConfigurationSetEventDestinationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecProviderRef(obj: ConfigurationSetEventDestinationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo
 */
export interface ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo(obj: ConfigurationSetEventDestinationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef
 */
export interface ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef(obj: ConfigurationSetEventDestinationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ConfigurationSet in sesv2 to populate configurationSetName.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef
 */
export interface ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef(obj: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ConfigurationSet in sesv2 to populate configurationSetName.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector
 */
export interface ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector(obj: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestination
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestination {
  /**
   * An object that defines an Amazon CloudWatch destination for email events. See cloud_watch_destination below
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestination#cloudWatchDestination
   */
  readonly cloudWatchDestination?: ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination[];

  /**
   * When the event destination is enabled, the specified event types are sent to the destinations. Default: false.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestination#enabled
   */
  readonly enabled?: boolean;

  /**
   * An object that defines an Amazon Kinesis Data Firehose destination for email events. See kinesis_firehose_destination below.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestination#kinesisFirehoseDestination
   */
  readonly kinesisFirehoseDestination?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination[];

  /**
   * - An array that specifies which events the Amazon SES API v2 should send to the destinations. Valid values: SEND, REJECT, BOUNCE, COMPLAINT, DELIVERY, OPEN, CLICK, RENDERING_FAILURE, DELIVERY_DELAY, SUBSCRIPTION.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestination#matchingEventTypes
   */
  readonly matchingEventTypes: string[];

  /**
   * An object that defines an Amazon Pinpoint project destination for email events. See pinpoint_destination below.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestination#pinpointDestination
   */
  readonly pinpointDestination?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination[];

  /**
   * An object that defines an Amazon SNS destination for email events. See sns_destination below.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestination#snsDestination
   */
  readonly snsDestination?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination[];

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestination(obj: ConfigurationSetEventDestinationSpecForProviderEventDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchDestination': obj.cloudWatchDestination?.map(y => toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination(y)),
    'enabled': obj.enabled,
    'kinesisFirehoseDestination': obj.kinesisFirehoseDestination?.map(y => toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination(y)),
    'matchingEventTypes': obj.matchingEventTypes?.map(y => y),
    'pinpointDestination': obj.pinpointDestination?.map(y => toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination(y)),
    'snsDestination': obj.snsDestination?.map(y => toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecProviderConfigRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecProviderConfigRefPolicy(obj: ConfigurationSetEventDestinationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecProviderRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecProviderRefPolicy(obj: ConfigurationSetEventDestinationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef
 */
export interface ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef(obj: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata
 */
export interface ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata(obj: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy(obj: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy(obj: ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination {
  /**
   * An array of objects that define the dimensions to use when you send email events to Amazon CloudWatch. See dimension_configuration below.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination#dimensionConfiguration
   */
  readonly dimensionConfiguration: ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration[];

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dimensionConfiguration': obj.dimensionConfiguration?.map(y => toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination {
  /**
   * The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose stream that the Amazon SES API v2 sends email events to.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination#deliveryStreamArn
   */
  readonly deliveryStreamArn?: string;

  /**
   * Reference to a DeliveryStream in firehose to populate deliveryStreamArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination#deliveryStreamArnRef
   */
  readonly deliveryStreamArnRef?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef;

  /**
   * Selector for a DeliveryStream in firehose to populate deliveryStreamArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination#deliveryStreamArnSelector
   */
  readonly deliveryStreamArnSelector?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector;

  /**
   * The Amazon Resource Name (ARN) of the IAM role that the Amazon SES API v2 uses to send email events to the Amazon Kinesis Data Firehose stream.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination#iamRoleArnRef
   */
  readonly iamRoleArnRef?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deliveryStreamArn': obj.deliveryStreamArn,
    'deliveryStreamArnRef': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef(obj.deliveryStreamArnRef),
    'deliveryStreamArnSelector': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector(obj.deliveryStreamArnSelector),
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector(obj.iamRoleArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination {
  /**
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination#applicationArn
   */
  readonly applicationArn?: string;

  /**
   * Reference to a App in pinpoint to populate applicationArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination#applicationArnRef
   */
  readonly applicationArnRef?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef;

  /**
   * Selector for a App in pinpoint to populate applicationArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination#applicationArnSelector
   */
  readonly applicationArnSelector?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationArn': obj.applicationArn,
    'applicationArnRef': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef(obj.applicationArnRef),
    'applicationArnSelector': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector(obj.applicationArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination {
  /**
   * The Amazon Resource Name (ARN) of the Amazon SNS topic to publish email events to.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination#topicArn
   */
  readonly topicArn?: string;

  /**
   * Reference to a Topic in sns to populate topicArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination#topicArnRef
   */
  readonly topicArnRef?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef;

  /**
   * Selector for a Topic in sns to populate topicArn.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination#topicArnSelector
   */
  readonly topicArnSelector?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topicArn': obj.topicArn,
    'topicArnRef': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef(obj.topicArnRef),
    'topicArnSelector': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector(obj.topicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecProviderConfigRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecProviderConfigRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecProviderRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecProviderRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderConfigurationSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration {
  /**
   * The default value of the dimension that is published to Amazon CloudWatch if you don't provide the value of the dimension when you send an email. ( dimension_name -  The name of an Amazon CloudWatch dimension associated with an email sending metric.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration#defaultDimensionValue
   */
  readonly defaultDimensionValue: string;

  /**
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration#dimensionName
   */
  readonly dimensionName: string;

  /**
   * The location where the Amazon SES API v2 finds the value of a dimension to publish to Amazon CloudWatch. Valid values: MESSAGE_TAG, EMAIL_HEADER, LINK_TAG.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration#dimensionValueSource
   */
  readonly dimensionValueSource: string;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationCloudWatchDestinationDimensionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultDimensionValue': obj.defaultDimensionValue,
    'dimensionName': obj.dimensionName,
    'dimensionValueSource': obj.dimensionValueSource,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DeliveryStream in firehose to populate deliveryStreamArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DeliveryStream in firehose to populate deliveryStreamArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in pinpoint to populate applicationArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in pinpoint to populate applicationArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate topicArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate topicArn.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector#policy
   */
  readonly policy?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy
 */
export interface ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy(obj: ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationDeliveryStreamArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationKinesisFirehoseDestinationIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationPinpointDestinationApplicationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicyResolution
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicyResolve
 */
export enum ConfigurationSetEventDestinationSpecForProviderEventDestinationSnsDestinationTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DedicatedIPPool is the Schema for the DedicatedIPPools API.
 *
 * @schema DedicatedIPPool
 */
export class DedicatedIpPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DedicatedIPPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.upbound.io/v1beta1',
    kind: 'DedicatedIPPool',
  }

  /**
   * Renders a Kubernetes manifest for "DedicatedIPPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DedicatedIpPoolProps): any {
    return {
      ...DedicatedIpPool.GVK,
      ...toJson_DedicatedIpPoolProps(props),
    };
  }

  /**
   * Defines a "DedicatedIPPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DedicatedIpPoolProps) {
    super(scope, id, {
      ...DedicatedIpPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DedicatedIpPool.GVK,
      ...toJson_DedicatedIpPoolProps(resolved),
    };
  }
}

/**
 * DedicatedIPPool is the Schema for the DedicatedIPPools API.
 *
 * @schema DedicatedIPPool
 */
export interface DedicatedIpPoolProps {
  /**
   * @schema DedicatedIPPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DedicatedIPPoolSpec defines the desired state of DedicatedIPPool
   *
   * @schema DedicatedIPPool#spec
   */
  readonly spec: DedicatedIpPoolSpec;

}

/**
 * Converts an object of type 'DedicatedIpPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolProps(obj: DedicatedIpPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DedicatedIpPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DedicatedIPPoolSpec defines the desired state of DedicatedIPPool
 *
 * @schema DedicatedIpPoolSpec
 */
export interface DedicatedIpPoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DedicatedIpPoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: DedicatedIpPoolSpecDeletionPolicy;

  /**
   * @schema DedicatedIpPoolSpec#forProvider
   */
  readonly forProvider: DedicatedIpPoolSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DedicatedIpPoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: DedicatedIpPoolSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DedicatedIpPoolSpec#providerRef
   */
  readonly providerRef?: DedicatedIpPoolSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DedicatedIpPoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DedicatedIpPoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DedicatedIpPoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DedicatedIpPoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpec(obj: DedicatedIpPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DedicatedIpPoolSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DedicatedIpPoolSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DedicatedIpPoolSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DedicatedIpPoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DedicatedIpPoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DedicatedIpPoolSpecDeletionPolicy
 */
export enum DedicatedIpPoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DedicatedIpPoolSpecForProvider
 */
export interface DedicatedIpPoolSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DedicatedIpPoolSpecForProvider#region
   */
  readonly region: string;

  /**
   * IP pool scaling mode. Valid values: STANDARD, MANAGED. If omitted, the AWS API will default to a standard pool.
   *
   * @schema DedicatedIpPoolSpecForProvider#scalingMode
   */
  readonly scalingMode?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DedicatedIpPoolSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecForProvider(obj: DedicatedIpPoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'scalingMode': obj.scalingMode,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DedicatedIpPoolSpecProviderConfigRef
 */
export interface DedicatedIpPoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DedicatedIpPoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DedicatedIpPoolSpecProviderConfigRef#policy
   */
  readonly policy?: DedicatedIpPoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecProviderConfigRef(obj: DedicatedIpPoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DedicatedIpPoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DedicatedIpPoolSpecProviderRef
 */
export interface DedicatedIpPoolSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DedicatedIpPoolSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DedicatedIpPoolSpecProviderRef#policy
   */
  readonly policy?: DedicatedIpPoolSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecProviderRef(obj: DedicatedIpPoolSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DedicatedIpPoolSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DedicatedIpPoolSpecPublishConnectionDetailsTo
 */
export interface DedicatedIpPoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DedicatedIpPoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecPublishConnectionDetailsTo(obj: DedicatedIpPoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DedicatedIpPoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DedicatedIpPoolSpecWriteConnectionSecretToRef
 */
export interface DedicatedIpPoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DedicatedIpPoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DedicatedIpPoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecWriteConnectionSecretToRef(obj: DedicatedIpPoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DedicatedIpPoolSpecProviderConfigRefPolicy
 */
export interface DedicatedIpPoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DedicatedIpPoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DedicatedIpPoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DedicatedIpPoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DedicatedIpPoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecProviderConfigRefPolicy(obj: DedicatedIpPoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DedicatedIpPoolSpecProviderRefPolicy
 */
export interface DedicatedIpPoolSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DedicatedIpPoolSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DedicatedIpPoolSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DedicatedIpPoolSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DedicatedIpPoolSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecProviderRefPolicy(obj: DedicatedIpPoolSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef
 */
export interface DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef(obj: DedicatedIpPoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DedicatedIpPoolSpecPublishConnectionDetailsToMetadata
 */
export interface DedicatedIpPoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecPublishConnectionDetailsToMetadata(obj: DedicatedIpPoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DedicatedIpPoolSpecProviderConfigRefPolicyResolution
 */
export enum DedicatedIpPoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DedicatedIpPoolSpecProviderConfigRefPolicyResolve
 */
export enum DedicatedIpPoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DedicatedIpPoolSpecProviderRefPolicyResolution
 */
export enum DedicatedIpPoolSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DedicatedIpPoolSpecProviderRefPolicyResolve
 */
export enum DedicatedIpPoolSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DedicatedIpPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EmailIdentity is the Schema for the EmailIdentitys API.
 *
 * @schema EmailIdentity
 */
export class EmailIdentity extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EmailIdentity"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.upbound.io/v1beta1',
    kind: 'EmailIdentity',
  }

  /**
   * Renders a Kubernetes manifest for "EmailIdentity".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EmailIdentityProps): any {
    return {
      ...EmailIdentity.GVK,
      ...toJson_EmailIdentityProps(props),
    };
  }

  /**
   * Defines a "EmailIdentity" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EmailIdentityProps) {
    super(scope, id, {
      ...EmailIdentity.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EmailIdentity.GVK,
      ...toJson_EmailIdentityProps(resolved),
    };
  }
}

/**
 * EmailIdentity is the Schema for the EmailIdentitys API.
 *
 * @schema EmailIdentity
 */
export interface EmailIdentityProps {
  /**
   * @schema EmailIdentity#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EmailIdentitySpec defines the desired state of EmailIdentity
   *
   * @schema EmailIdentity#spec
   */
  readonly spec: EmailIdentitySpec;

}

/**
 * Converts an object of type 'EmailIdentityProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityProps(obj: EmailIdentityProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EmailIdentitySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmailIdentitySpec defines the desired state of EmailIdentity
 *
 * @schema EmailIdentitySpec
 */
export interface EmailIdentitySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EmailIdentitySpec#deletionPolicy
   */
  readonly deletionPolicy?: EmailIdentitySpecDeletionPolicy;

  /**
   * @schema EmailIdentitySpec#forProvider
   */
  readonly forProvider: EmailIdentitySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EmailIdentitySpec#providerConfigRef
   */
  readonly providerConfigRef?: EmailIdentitySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EmailIdentitySpec#providerRef
   */
  readonly providerRef?: EmailIdentitySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EmailIdentitySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EmailIdentitySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EmailIdentitySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EmailIdentitySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EmailIdentitySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpec(obj: EmailIdentitySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EmailIdentitySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EmailIdentitySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EmailIdentitySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EmailIdentitySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EmailIdentitySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EmailIdentitySpecDeletionPolicy
 */
export enum EmailIdentitySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EmailIdentitySpecForProvider
 */
export interface EmailIdentitySpecForProvider {
  /**
   * The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
   *
   * @schema EmailIdentitySpecForProvider#configurationSetName
   */
  readonly configurationSetName?: string;

  /**
   * Reference to a ConfigurationSet in sesv2 to populate configurationSetName.
   *
   * @schema EmailIdentitySpecForProvider#configurationSetNameRef
   */
  readonly configurationSetNameRef?: EmailIdentitySpecForProviderConfigurationSetNameRef;

  /**
   * Selector for a ConfigurationSet in sesv2 to populate configurationSetName.
   *
   * @schema EmailIdentitySpecForProvider#configurationSetNameSelector
   */
  readonly configurationSetNameSelector?: EmailIdentitySpecForProviderConfigurationSetNameSelector;

  /**
   * The configuration of the DKIM authentication settings for an email domain identity.
   *
   * @schema EmailIdentitySpecForProvider#dkimSigningAttributes
   */
  readonly dkimSigningAttributes?: EmailIdentitySpecForProviderDkimSigningAttributes[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EmailIdentitySpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EmailIdentitySpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EmailIdentitySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProvider(obj: EmailIdentitySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configurationSetName': obj.configurationSetName,
    'configurationSetNameRef': toJson_EmailIdentitySpecForProviderConfigurationSetNameRef(obj.configurationSetNameRef),
    'configurationSetNameSelector': toJson_EmailIdentitySpecForProviderConfigurationSetNameSelector(obj.configurationSetNameSelector),
    'dkimSigningAttributes': obj.dkimSigningAttributes?.map(y => toJson_EmailIdentitySpecForProviderDkimSigningAttributes(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EmailIdentitySpecProviderConfigRef
 */
export interface EmailIdentitySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecProviderConfigRef#policy
   */
  readonly policy?: EmailIdentitySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderConfigRef(obj: EmailIdentitySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EmailIdentitySpecProviderRef
 */
export interface EmailIdentitySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecProviderRef#policy
   */
  readonly policy?: EmailIdentitySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderRef(obj: EmailIdentitySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsTo
 */
export interface EmailIdentitySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EmailIdentitySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EmailIdentitySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsTo(obj: EmailIdentitySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EmailIdentitySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EmailIdentitySpecWriteConnectionSecretToRef
 */
export interface EmailIdentitySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EmailIdentitySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EmailIdentitySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecWriteConnectionSecretToRef(obj: EmailIdentitySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ConfigurationSet in sesv2 to populate configurationSetName.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRef
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRef#policy
   */
  readonly policy?: EmailIdentitySpecForProviderConfigurationSetNameRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameRef(obj: EmailIdentitySpecForProviderConfigurationSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecForProviderConfigurationSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ConfigurationSet in sesv2 to populate configurationSetName.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelector#policy
   */
  readonly policy?: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameSelector(obj: EmailIdentitySpecForProviderConfigurationSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EmailIdentitySpecForProviderDkimSigningAttributes
 */
export interface EmailIdentitySpecForProviderDkimSigningAttributes {
  /**
   * [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
   *
   * @schema EmailIdentitySpecForProviderDkimSigningAttributes#domainSigningPrivateKey
   */
  readonly domainSigningPrivateKey?: string;

  /**
   * [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
   *
   * @schema EmailIdentitySpecForProviderDkimSigningAttributes#domainSigningSelector
   */
  readonly domainSigningSelector?: string;

  /**
   * [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day. Valid values: RSA_1024_BIT, RSA_2048_BIT.
   *
   * @schema EmailIdentitySpecForProviderDkimSigningAttributes#nextSigningKeyLength
   */
  readonly nextSigningKeyLength?: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderDkimSigningAttributes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderDkimSigningAttributes(obj: EmailIdentitySpecForProviderDkimSigningAttributes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domainSigningPrivateKey': obj.domainSigningPrivateKey,
    'domainSigningSelector': obj.domainSigningSelector,
    'nextSigningKeyLength': obj.nextSigningKeyLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicy
 */
export interface EmailIdentitySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderConfigRefPolicy(obj: EmailIdentitySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecProviderRefPolicy
 */
export interface EmailIdentitySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecProviderRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecProviderRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecProviderRefPolicy(obj: EmailIdentitySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef
 */
export interface EmailIdentitySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRef(obj: EmailIdentitySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata
 */
export interface EmailIdentitySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToMetadata(obj: EmailIdentitySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicy
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameRefPolicy(obj: EmailIdentitySpecForProviderConfigurationSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy
 */
export interface EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy(obj: EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicyResolution
 */
export enum EmailIdentitySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecProviderConfigRefPolicyResolve
 */
export enum EmailIdentitySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecProviderRefPolicyResolution
 */
export enum EmailIdentitySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecProviderRefPolicyResolve
 */
export enum EmailIdentitySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy(obj: EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolution
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolve
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolution
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolve
 */
export enum EmailIdentitySpecForProviderConfigurationSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EmailIdentitySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EmailIdentityFeedbackAttributes is the Schema for the EmailIdentityFeedbackAttributess API.
 *
 * @schema EmailIdentityFeedbackAttributes
 */
export class EmailIdentityFeedbackAttributes extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EmailIdentityFeedbackAttributes"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.upbound.io/v1beta1',
    kind: 'EmailIdentityFeedbackAttributes',
  }

  /**
   * Renders a Kubernetes manifest for "EmailIdentityFeedbackAttributes".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EmailIdentityFeedbackAttributesProps): any {
    return {
      ...EmailIdentityFeedbackAttributes.GVK,
      ...toJson_EmailIdentityFeedbackAttributesProps(props),
    };
  }

  /**
   * Defines a "EmailIdentityFeedbackAttributes" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EmailIdentityFeedbackAttributesProps) {
    super(scope, id, {
      ...EmailIdentityFeedbackAttributes.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EmailIdentityFeedbackAttributes.GVK,
      ...toJson_EmailIdentityFeedbackAttributesProps(resolved),
    };
  }
}

/**
 * EmailIdentityFeedbackAttributes is the Schema for the EmailIdentityFeedbackAttributess API.
 *
 * @schema EmailIdentityFeedbackAttributes
 */
export interface EmailIdentityFeedbackAttributesProps {
  /**
   * @schema EmailIdentityFeedbackAttributes#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EmailIdentityFeedbackAttributesSpec defines the desired state of EmailIdentityFeedbackAttributes
   *
   * @schema EmailIdentityFeedbackAttributes#spec
   */
  readonly spec: EmailIdentityFeedbackAttributesSpec;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesProps(obj: EmailIdentityFeedbackAttributesProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EmailIdentityFeedbackAttributesSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmailIdentityFeedbackAttributesSpec defines the desired state of EmailIdentityFeedbackAttributes
 *
 * @schema EmailIdentityFeedbackAttributesSpec
 */
export interface EmailIdentityFeedbackAttributesSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EmailIdentityFeedbackAttributesSpec#deletionPolicy
   */
  readonly deletionPolicy?: EmailIdentityFeedbackAttributesSpecDeletionPolicy;

  /**
   * @schema EmailIdentityFeedbackAttributesSpec#forProvider
   */
  readonly forProvider: EmailIdentityFeedbackAttributesSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EmailIdentityFeedbackAttributesSpec#providerConfigRef
   */
  readonly providerConfigRef?: EmailIdentityFeedbackAttributesSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EmailIdentityFeedbackAttributesSpec#providerRef
   */
  readonly providerRef?: EmailIdentityFeedbackAttributesSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EmailIdentityFeedbackAttributesSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EmailIdentityFeedbackAttributesSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpec(obj: EmailIdentityFeedbackAttributesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EmailIdentityFeedbackAttributesSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EmailIdentityFeedbackAttributesSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EmailIdentityFeedbackAttributesSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EmailIdentityFeedbackAttributesSpecDeletionPolicy
 */
export enum EmailIdentityFeedbackAttributesSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EmailIdentityFeedbackAttributesSpecForProvider
 */
export interface EmailIdentityFeedbackAttributesSpecForProvider {
  /**
   * Sets the feedback forwarding configuration for the identity.
   *
   * @schema EmailIdentityFeedbackAttributesSpecForProvider#emailForwardingEnabled
   */
  readonly emailForwardingEnabled?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EmailIdentityFeedbackAttributesSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecForProvider(obj: EmailIdentityFeedbackAttributesSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'emailForwardingEnabled': obj.emailForwardingEnabled,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRef
 */
export interface EmailIdentityFeedbackAttributesSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRef#policy
   */
  readonly policy?: EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecProviderConfigRef(obj: EmailIdentityFeedbackAttributesSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderRef
 */
export interface EmailIdentityFeedbackAttributesSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderRef#policy
   */
  readonly policy?: EmailIdentityFeedbackAttributesSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecProviderRef(obj: EmailIdentityFeedbackAttributesSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentityFeedbackAttributesSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo
 */
export interface EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo(obj: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef
 */
export interface EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef(obj: EmailIdentityFeedbackAttributesSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy
 */
export interface EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy(obj: EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderRefPolicy
 */
export interface EmailIdentityFeedbackAttributesSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EmailIdentityFeedbackAttributesSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentityFeedbackAttributesSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EmailIdentityFeedbackAttributesSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecProviderRefPolicy(obj: EmailIdentityFeedbackAttributesSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef
 */
export interface EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef(obj: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata
 */
export interface EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata(obj: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicyResolution
 */
export enum EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicyResolve
 */
export enum EmailIdentityFeedbackAttributesSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderRefPolicyResolution
 */
export enum EmailIdentityFeedbackAttributesSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentityFeedbackAttributesSpecProviderRefPolicyResolve
 */
export enum EmailIdentityFeedbackAttributesSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy(obj: EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EmailIdentityFeedbackAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EmailIdentityMailFromAttributes is the Schema for the EmailIdentityMailFromAttributess API.
 *
 * @schema EmailIdentityMailFromAttributes
 */
export class EmailIdentityMailFromAttributes extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EmailIdentityMailFromAttributes"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sesv2.aws.upbound.io/v1beta1',
    kind: 'EmailIdentityMailFromAttributes',
  }

  /**
   * Renders a Kubernetes manifest for "EmailIdentityMailFromAttributes".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EmailIdentityMailFromAttributesProps): any {
    return {
      ...EmailIdentityMailFromAttributes.GVK,
      ...toJson_EmailIdentityMailFromAttributesProps(props),
    };
  }

  /**
   * Defines a "EmailIdentityMailFromAttributes" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EmailIdentityMailFromAttributesProps) {
    super(scope, id, {
      ...EmailIdentityMailFromAttributes.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EmailIdentityMailFromAttributes.GVK,
      ...toJson_EmailIdentityMailFromAttributesProps(resolved),
    };
  }
}

/**
 * EmailIdentityMailFromAttributes is the Schema for the EmailIdentityMailFromAttributess API.
 *
 * @schema EmailIdentityMailFromAttributes
 */
export interface EmailIdentityMailFromAttributesProps {
  /**
   * @schema EmailIdentityMailFromAttributes#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EmailIdentityMailFromAttributesSpec defines the desired state of EmailIdentityMailFromAttributes
   *
   * @schema EmailIdentityMailFromAttributes#spec
   */
  readonly spec: EmailIdentityMailFromAttributesSpec;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesProps(obj: EmailIdentityMailFromAttributesProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EmailIdentityMailFromAttributesSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EmailIdentityMailFromAttributesSpec defines the desired state of EmailIdentityMailFromAttributes
 *
 * @schema EmailIdentityMailFromAttributesSpec
 */
export interface EmailIdentityMailFromAttributesSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EmailIdentityMailFromAttributesSpec#deletionPolicy
   */
  readonly deletionPolicy?: EmailIdentityMailFromAttributesSpecDeletionPolicy;

  /**
   * @schema EmailIdentityMailFromAttributesSpec#forProvider
   */
  readonly forProvider: EmailIdentityMailFromAttributesSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EmailIdentityMailFromAttributesSpec#providerConfigRef
   */
  readonly providerConfigRef?: EmailIdentityMailFromAttributesSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EmailIdentityMailFromAttributesSpec#providerRef
   */
  readonly providerRef?: EmailIdentityMailFromAttributesSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EmailIdentityMailFromAttributesSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EmailIdentityMailFromAttributesSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpec(obj: EmailIdentityMailFromAttributesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EmailIdentityMailFromAttributesSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EmailIdentityMailFromAttributesSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EmailIdentityMailFromAttributesSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EmailIdentityMailFromAttributesSpecDeletionPolicy
 */
export enum EmailIdentityMailFromAttributesSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EmailIdentityMailFromAttributesSpecForProvider
 */
export interface EmailIdentityMailFromAttributesSpecForProvider {
  /**
   * The action to take if the required MX record isn't found when you send an email. Valid values: USE_DEFAULT_VALUE, REJECT_MESSAGE.
   *
   * @schema EmailIdentityMailFromAttributesSpecForProvider#behaviorOnMxFailure
   */
  readonly behaviorOnMxFailure?: string;

  /**
   * The custom MAIL FROM domain that you want the verified identity to use. Required if behavior_on_mx_failure is REJECT_MESSAGE.
   *
   * @schema EmailIdentityMailFromAttributesSpecForProvider#mailFromDomain
   */
  readonly mailFromDomain?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EmailIdentityMailFromAttributesSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecForProvider(obj: EmailIdentityMailFromAttributesSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'behaviorOnMxFailure': obj.behaviorOnMxFailure,
    'mailFromDomain': obj.mailFromDomain,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderConfigRef
 */
export interface EmailIdentityMailFromAttributesSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderConfigRef#policy
   */
  readonly policy?: EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecProviderConfigRef(obj: EmailIdentityMailFromAttributesSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderRef
 */
export interface EmailIdentityMailFromAttributesSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderRef#policy
   */
  readonly policy?: EmailIdentityMailFromAttributesSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecProviderRef(obj: EmailIdentityMailFromAttributesSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentityMailFromAttributesSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo
 */
export interface EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo(obj: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef
 */
export interface EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef(obj: EmailIdentityMailFromAttributesSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy
 */
export interface EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentityMailFromAttributesSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentityMailFromAttributesSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy(obj: EmailIdentityMailFromAttributesSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderRefPolicy
 */
export interface EmailIdentityMailFromAttributesSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EmailIdentityMailFromAttributesSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentityMailFromAttributesSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EmailIdentityMailFromAttributesSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecProviderRefPolicy(obj: EmailIdentityMailFromAttributesSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef
 */
export interface EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef(obj: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata
 */
export interface EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata(obj: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderConfigRefPolicyResolution
 */
export enum EmailIdentityMailFromAttributesSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderConfigRefPolicyResolve
 */
export enum EmailIdentityMailFromAttributesSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderRefPolicyResolution
 */
export enum EmailIdentityMailFromAttributesSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentityMailFromAttributesSpecProviderRefPolicyResolve
 */
export enum EmailIdentityMailFromAttributesSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy(obj: EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EmailIdentityMailFromAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

