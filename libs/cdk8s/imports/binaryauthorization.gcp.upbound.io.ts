// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Attestor is the Schema for the Attestors API. An attestor that attests to container image artifacts.
 *
 * @schema Attestor
 */
export class Attestor extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Attestor"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'binaryauthorization.gcp.upbound.io/v1beta1',
    kind: 'Attestor',
  }

  /**
   * Renders a Kubernetes manifest for "Attestor".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AttestorProps): any {
    return {
      ...Attestor.GVK,
      ...toJson_AttestorProps(props),
    };
  }

  /**
   * Defines a "Attestor" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AttestorProps) {
    super(scope, id, {
      ...Attestor.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Attestor.GVK,
      ...toJson_AttestorProps(resolved),
    };
  }
}

/**
 * Attestor is the Schema for the Attestors API. An attestor that attests to container image artifacts.
 *
 * @schema Attestor
 */
export interface AttestorProps {
  /**
   * @schema Attestor#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AttestorSpec defines the desired state of Attestor
   *
   * @schema Attestor#spec
   */
  readonly spec: AttestorSpec;

}

/**
 * Converts an object of type 'AttestorProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorProps(obj: AttestorProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AttestorSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AttestorSpec defines the desired state of Attestor
 *
 * @schema AttestorSpec
 */
export interface AttestorSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AttestorSpec#deletionPolicy
   */
  readonly deletionPolicy?: AttestorSpecDeletionPolicy;

  /**
   * @schema AttestorSpec#forProvider
   */
  readonly forProvider: AttestorSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AttestorSpec#initProvider
   */
  readonly initProvider?: AttestorSpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AttestorSpec#managementPolicies
   */
  readonly managementPolicies?: AttestorSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AttestorSpec#providerConfigRef
   */
  readonly providerConfigRef?: AttestorSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AttestorSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AttestorSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AttestorSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AttestorSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AttestorSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpec(obj: AttestorSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AttestorSpecForProvider(obj.forProvider),
    'initProvider': toJson_AttestorSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AttestorSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AttestorSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AttestorSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AttestorSpecDeletionPolicy
 */
export enum AttestorSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AttestorSpecForProvider
 */
export interface AttestorSpecForProvider {
  /**
   * A Container Analysis ATTESTATION_AUTHORITY Note, created by the user. Structure is documented below.
   *
   * @schema AttestorSpecForProvider#attestationAuthorityNote
   */
  readonly attestationAuthorityNote?: AttestorSpecForProviderAttestationAuthorityNote[];

  /**
   * A descriptive comment. This field may be updated. The field may be displayed in chooser dialogs.
   *
   * @schema AttestorSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AttestorSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'AttestorSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProvider(obj: AttestorSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attestationAuthorityNote': obj.attestationAuthorityNote?.map(y => toJson_AttestorSpecForProviderAttestationAuthorityNote(y)),
    'description': obj.description,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema AttestorSpecInitProvider
 */
export interface AttestorSpecInitProvider {
  /**
   * A Container Analysis ATTESTATION_AUTHORITY Note, created by the user. Structure is documented below.
   *
   * @schema AttestorSpecInitProvider#attestationAuthorityNote
   */
  readonly attestationAuthorityNote?: AttestorSpecInitProviderAttestationAuthorityNote[];

  /**
   * A descriptive comment. This field may be updated. The field may be displayed in chooser dialogs.
   *
   * @schema AttestorSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema AttestorSpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'AttestorSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecInitProvider(obj: AttestorSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attestationAuthorityNote': obj.attestationAuthorityNote?.map(y => toJson_AttestorSpecInitProviderAttestationAuthorityNote(y)),
    'description': obj.description,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AttestorSpecManagementPolicies
 */
export enum AttestorSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AttestorSpecProviderConfigRef
 */
export interface AttestorSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttestorSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttestorSpecProviderConfigRef#policy
   */
  readonly policy?: AttestorSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AttestorSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecProviderConfigRef(obj: AttestorSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttestorSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AttestorSpecPublishConnectionDetailsTo
 */
export interface AttestorSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AttestorSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AttestorSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AttestorSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AttestorSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AttestorSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AttestorSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecPublishConnectionDetailsTo(obj: AttestorSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AttestorSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AttestorSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AttestorSpecWriteConnectionSecretToRef
 */
export interface AttestorSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AttestorSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AttestorSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AttestorSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecWriteConnectionSecretToRef(obj: AttestorSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AttestorSpecForProviderAttestationAuthorityNote
 */
export interface AttestorSpecForProviderAttestationAuthorityNote {
  /**
   * The resource name of a ATTESTATION_AUTHORITY Note, created by the user. If the Note is in a different project from the Attestor, it should be specified in the format projects/_/notes/* (or the legacy providers/_/notes/*). This field may not be updated. An attestation by this attestor is stored as a Container Analysis ATTESTATION_AUTHORITY Occurrence that names a container image and that links to this Note.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNote#noteReference
   */
  readonly noteReference?: string;

  /**
   * Reference to a Note in containeranalysis to populate noteReference.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNote#noteReferenceRef
   */
  readonly noteReferenceRef?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef;

  /**
   * Selector for a Note in containeranalysis to populate noteReference.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNote#noteReferenceSelector
   */
  readonly noteReferenceSelector?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector;

  /**
   * Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist. Structure is documented below.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNote#publicKeys
   */
  readonly publicKeys?: AttestorSpecForProviderAttestationAuthorityNotePublicKeys[];

}

/**
 * Converts an object of type 'AttestorSpecForProviderAttestationAuthorityNote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProviderAttestationAuthorityNote(obj: AttestorSpecForProviderAttestationAuthorityNote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'noteReference': obj.noteReference,
    'noteReferenceRef': toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef(obj.noteReferenceRef),
    'noteReferenceSelector': toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector(obj.noteReferenceSelector),
    'publicKeys': obj.publicKeys?.map(y => toJson_AttestorSpecForProviderAttestationAuthorityNotePublicKeys(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AttestorSpecInitProviderAttestationAuthorityNote
 */
export interface AttestorSpecInitProviderAttestationAuthorityNote {
  /**
   * Public keys that verify attestations signed by this attestor. This field may be updated. If this field is non-empty, one of the specified public keys must verify that an attestation was signed by this attestor for the image specified in the admission request. If this field is empty, this attestor always returns that no valid attestations exist. Structure is documented below.
   *
   * @schema AttestorSpecInitProviderAttestationAuthorityNote#publicKeys
   */
  readonly publicKeys?: AttestorSpecInitProviderAttestationAuthorityNotePublicKeys[];

}

/**
 * Converts an object of type 'AttestorSpecInitProviderAttestationAuthorityNote' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecInitProviderAttestationAuthorityNote(obj: AttestorSpecInitProviderAttestationAuthorityNote | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKeys': obj.publicKeys?.map(y => toJson_AttestorSpecInitProviderAttestationAuthorityNotePublicKeys(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttestorSpecProviderConfigRefPolicy
 */
export interface AttestorSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttestorSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AttestorSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttestorSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AttestorSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttestorSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecProviderConfigRefPolicy(obj: AttestorSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AttestorSpecPublishConnectionDetailsToConfigRef
 */
export interface AttestorSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttestorSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttestorSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AttestorSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AttestorSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecPublishConnectionDetailsToConfigRef(obj: AttestorSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttestorSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AttestorSpecPublishConnectionDetailsToMetadata
 */
export interface AttestorSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttestorSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttestorSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AttestorSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AttestorSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecPublishConnectionDetailsToMetadata(obj: AttestorSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Note in containeranalysis to populate noteReference.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef
 */
export interface AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef#policy
   */
  readonly policy?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy;

}

/**
 * Converts an object of type 'AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef(obj: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Note in containeranalysis to populate noteReference.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector
 */
export interface AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector#policy
   */
  readonly policy?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy;

}

/**
 * Converts an object of type 'AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector(obj: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeys
 */
export interface AttestorSpecForProviderAttestationAuthorityNotePublicKeys {
  /**
   * ASCII-armored representation of a PGP public key, as the entire output by the command gpg --export --armor foo@example.com (either LF or CRLF line endings). When using this field, id should be left blank. The BinAuthz API handlers will calculate the ID and fill it in automatically. BinAuthz computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If id is provided by the caller, it will be overwritten by the API-calculated ID.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeys#asciiArmoredPgpPublicKey
   */
  readonly asciiArmoredPgpPublicKey?: string;

  /**
   * A descriptive comment. This field may be updated.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeys#comment
   */
  readonly comment?: string;

  /**
   * The ID of this public key. Signatures verified by BinAuthz must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on publicKey cases below for details.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeys#id
   */
  readonly id?: string;

  /**
   * A raw PKIX SubjectPublicKeyInfo format public key. NOTE: id may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If id is left blank, a default one will be computed based on the digest of the DER encoding of the public key. Structure is documented below.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeys#pkixPublicKey
   */
  readonly pkixPublicKey?: AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey[];

}

/**
 * Converts an object of type 'AttestorSpecForProviderAttestationAuthorityNotePublicKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProviderAttestationAuthorityNotePublicKeys(obj: AttestorSpecForProviderAttestationAuthorityNotePublicKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'asciiArmoredPgpPublicKey': obj.asciiArmoredPgpPublicKey,
    'comment': obj.comment,
    'id': obj.id,
    'pkixPublicKey': obj.pkixPublicKey?.map(y => toJson_AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeys
 */
export interface AttestorSpecInitProviderAttestationAuthorityNotePublicKeys {
  /**
   * ASCII-armored representation of a PGP public key, as the entire output by the command gpg --export --armor foo@example.com (either LF or CRLF line endings). When using this field, id should be left blank. The BinAuthz API handlers will calculate the ID and fill it in automatically. BinAuthz computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as upper-case hex. If id is provided by the caller, it will be overwritten by the API-calculated ID.
   *
   * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeys#asciiArmoredPgpPublicKey
   */
  readonly asciiArmoredPgpPublicKey?: string;

  /**
   * A descriptive comment. This field may be updated.
   *
   * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeys#comment
   */
  readonly comment?: string;

  /**
   * The ID of this public key. Signatures verified by BinAuthz must include the ID of the public key that can be used to verify them, and that ID must match the contents of this field exactly. Additional restrictions on this field can be imposed based on which public key type is encapsulated. See the documentation on publicKey cases below for details.
   *
   * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeys#id
   */
  readonly id?: string;

  /**
   * A raw PKIX SubjectPublicKeyInfo format public key. NOTE: id may be explicitly provided by the caller when using this type of public key, but it MUST be a valid RFC3986 URI. If id is left blank, a default one will be computed based on the digest of the DER encoding of the public key. Structure is documented below.
   *
   * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeys#pkixPublicKey
   */
  readonly pkixPublicKey?: AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey[];

}

/**
 * Converts an object of type 'AttestorSpecInitProviderAttestationAuthorityNotePublicKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecInitProviderAttestationAuthorityNotePublicKeys(obj: AttestorSpecInitProviderAttestationAuthorityNotePublicKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'asciiArmoredPgpPublicKey': obj.asciiArmoredPgpPublicKey,
    'comment': obj.comment,
    'id': obj.id,
    'pkixPublicKey': obj.pkixPublicKey?.map(y => toJson_AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttestorSpecProviderConfigRefPolicyResolution
 */
export enum AttestorSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttestorSpecProviderConfigRefPolicyResolve
 */
export enum AttestorSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AttestorSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AttestorSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttestorSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AttestorSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttestorSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AttestorSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttestorSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecPublishConnectionDetailsToConfigRefPolicy(obj: AttestorSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy
 */
export interface AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy#resolution
   */
  readonly resolution?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy#resolve
   */
  readonly resolve?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicyResolve;

}

/**
 * Converts an object of type 'AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy(obj: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy
 */
export interface AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy#resolution
   */
  readonly resolution?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy#resolve
   */
  readonly resolve?: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy(obj: AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey
 */
export interface AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey {
  /**
   * A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey#publicKeyPem
   */
  readonly publicKeyPem?: string;

  /**
   * The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in publicKeyPem (i.e. this algorithm must match that of the public key).
   *
   * @schema AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey(obj: AttestorSpecForProviderAttestationAuthorityNotePublicKeysPkixPublicKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKeyPem': obj.publicKeyPem,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey
 */
export interface AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey {
  /**
   * A PEM-encoded public key, as described in https://tools.ietf.org/html/rfc7468#section-13
   *
   * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey#publicKeyPem
   */
  readonly publicKeyPem?: string;

  /**
   * The signature algorithm used to verify a message against a signature using this key. These signature algorithm must match the structure and any object identifiers encoded in publicKeyPem (i.e. this algorithm must match that of the public key).
   *
   * @schema AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey#signatureAlgorithm
   */
  readonly signatureAlgorithm?: string;

}

/**
 * Converts an object of type 'AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey(obj: AttestorSpecInitProviderAttestationAuthorityNotePublicKeysPkixPublicKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKeyPem': obj.publicKeyPem,
    'signatureAlgorithm': obj.signatureAlgorithm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttestorSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AttestorSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttestorSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AttestorSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicyResolution
 */
export enum AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicyResolve
 */
export enum AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicyResolution
 */
export enum AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicyResolve
 */
export enum AttestorSpecForProviderAttestationAuthorityNoteNoteReferenceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Policy is the Schema for the Policys API. A policy for container image binary authorization.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'binaryauthorization.gcp.upbound.io/v1beta1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy is the Schema for the Policys API. A policy for container image binary authorization.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec defines the desired state of Policy
   *
   * @schema Policy#spec
   */
  readonly spec: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec defines the desired state of Policy
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PolicySpecDeletionPolicy;

  /**
   * @schema PolicySpec#forProvider
   */
  readonly forProvider: PolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PolicySpec#initProvider
   */
  readonly initProvider?: PolicySpecInitProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PolicySpec#managementPolicies
   */
  readonly managementPolicies?: PolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_PolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PolicySpecDeletionPolicy
 */
export enum PolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PolicySpecForProvider
 */
export interface PolicySpecForProvider {
  /**
   * A whitelist of image patterns to exclude from admission rules. If an image's name matches a whitelist pattern, the image's admission requests will always be permitted regardless of your admission rules. Structure is documented below.
   *
   * @schema PolicySpecForProvider#admissionWhitelistPatterns
   */
  readonly admissionWhitelistPatterns?: PolicySpecForProviderAdmissionWhitelistPatterns[];

  /**
   * Per-cluster admission rules. An admission rule specifies either that all container images used in a pod creation request must be attested to by one or more attestors, that all pod creations will be allowed, or that all pod creations will be denied. There can be at most one admission rule per cluster spec.
   *
   * @schema PolicySpecForProvider#clusterAdmissionRules
   */
  readonly clusterAdmissionRules?: PolicySpecForProviderClusterAdmissionRules[];

  /**
   * Default admission rule for a cluster without a per-cluster admission rule. Structure is documented below.
   *
   * @schema PolicySpecForProvider#defaultAdmissionRule
   */
  readonly defaultAdmissionRule?: PolicySpecForProviderDefaultAdmissionRule[];

  /**
   * A descriptive comment.
   *
   * @schema PolicySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Controls the evaluation of a Google-maintained global admission policy for common system-level images. Images not covered by the global policy will be subject to the project admission policy. Possible values are: ENABLE, DISABLE.
   *
   * @schema PolicySpecForProvider#globalPolicyEvaluationMode
   */
  readonly globalPolicyEvaluationMode?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema PolicySpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'PolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProvider(obj: PolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admissionWhitelistPatterns': obj.admissionWhitelistPatterns?.map(y => toJson_PolicySpecForProviderAdmissionWhitelistPatterns(y)),
    'clusterAdmissionRules': obj.clusterAdmissionRules?.map(y => toJson_PolicySpecForProviderClusterAdmissionRules(y)),
    'defaultAdmissionRule': obj.defaultAdmissionRule?.map(y => toJson_PolicySpecForProviderDefaultAdmissionRule(y)),
    'description': obj.description,
    'globalPolicyEvaluationMode': obj.globalPolicyEvaluationMode,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PolicySpecInitProvider
 */
export interface PolicySpecInitProvider {
  /**
   * A whitelist of image patterns to exclude from admission rules. If an image's name matches a whitelist pattern, the image's admission requests will always be permitted regardless of your admission rules. Structure is documented below.
   *
   * @schema PolicySpecInitProvider#admissionWhitelistPatterns
   */
  readonly admissionWhitelistPatterns?: PolicySpecInitProviderAdmissionWhitelistPatterns[];

  /**
   * Per-cluster admission rules. An admission rule specifies either that all container images used in a pod creation request must be attested to by one or more attestors, that all pod creations will be allowed, or that all pod creations will be denied. There can be at most one admission rule per cluster spec.
   *
   * @schema PolicySpecInitProvider#clusterAdmissionRules
   */
  readonly clusterAdmissionRules?: PolicySpecInitProviderClusterAdmissionRules[];

  /**
   * Default admission rule for a cluster without a per-cluster admission rule. Structure is documented below.
   *
   * @schema PolicySpecInitProvider#defaultAdmissionRule
   */
  readonly defaultAdmissionRule?: PolicySpecInitProviderDefaultAdmissionRule[];

  /**
   * A descriptive comment.
   *
   * @schema PolicySpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Controls the evaluation of a Google-maintained global admission policy for common system-level images. Images not covered by the global policy will be subject to the project admission policy. Possible values are: ENABLE, DISABLE.
   *
   * @schema PolicySpecInitProvider#globalPolicyEvaluationMode
   */
  readonly globalPolicyEvaluationMode?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema PolicySpecInitProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProvider(obj: PolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'admissionWhitelistPatterns': obj.admissionWhitelistPatterns?.map(y => toJson_PolicySpecInitProviderAdmissionWhitelistPatterns(y)),
    'clusterAdmissionRules': obj.clusterAdmissionRules?.map(y => toJson_PolicySpecInitProviderClusterAdmissionRules(y)),
    'defaultAdmissionRule': obj.defaultAdmissionRule?.map(y => toJson_PolicySpecInitProviderDefaultAdmissionRule(y)),
    'description': obj.description,
    'globalPolicyEvaluationMode': obj.globalPolicyEvaluationMode,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PolicySpecManagementPolicies
 */
export enum PolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PolicySpecProviderConfigRef
 */
export interface PolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecProviderConfigRef#policy
   */
  readonly policy?: PolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRef(obj: PolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PolicySpecPublishConnectionDetailsTo
 */
export interface PolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsTo(obj: PolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PolicySpecWriteConnectionSecretToRef
 */
export interface PolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWriteConnectionSecretToRef(obj: PolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderAdmissionWhitelistPatterns
 */
export interface PolicySpecForProviderAdmissionWhitelistPatterns {
  /**
   * An image name pattern to whitelist, in the form registry/path/to/image. This supports a trailing * as a wildcard, but this is allowed only in text after the registry/ part.
   *
   * @schema PolicySpecForProviderAdmissionWhitelistPatterns#namePattern
   */
  readonly namePattern?: string;

}

/**
 * Converts an object of type 'PolicySpecForProviderAdmissionWhitelistPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderAdmissionWhitelistPatterns(obj: PolicySpecForProviderAdmissionWhitelistPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namePattern': obj.namePattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderClusterAdmissionRules
 */
export interface PolicySpecForProviderClusterAdmissionRules {
  /**
   * The identifier for this object. Format specified above.
   *
   * @schema PolicySpecForProviderClusterAdmissionRules#cluster
   */
  readonly cluster?: string;

  /**
   * The action when a pod creation is denied by the admission rule. Possible values are: ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY.
   *
   * @schema PolicySpecForProviderClusterAdmissionRules#enforcementMode
   */
  readonly enforcementMode?: string;

  /**
   * How this admission rule will be evaluated. Possible values are: ALWAYS_ALLOW, REQUIRE_ATTESTATION, ALWAYS_DENY.
   *
   * @schema PolicySpecForProviderClusterAdmissionRules#evaluationMode
   */
  readonly evaluationMode?: string;

  /**
   * The resource names of the attestors that must attest to a container image. If the attestor is in a different project from the policy, it should be specified in the format projects/_/attestors/*. Each attestor must exist before a policy can reference it. To add an attestor to a policy the principal issuing the policy change request must be able to read the attestor resource. Note: this field must be non-empty when the evaluation_mode field specifies REQUIRE_ATTESTATION, otherwise it must be empty.
   *
   * @schema PolicySpecForProviderClusterAdmissionRules#requireAttestationsBy
   */
  readonly requireAttestationsBy?: string[];

}

/**
 * Converts an object of type 'PolicySpecForProviderClusterAdmissionRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderClusterAdmissionRules(obj: PolicySpecForProviderClusterAdmissionRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cluster': obj.cluster,
    'enforcementMode': obj.enforcementMode,
    'evaluationMode': obj.evaluationMode,
    'requireAttestationsBy': obj.requireAttestationsBy?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecForProviderDefaultAdmissionRule
 */
export interface PolicySpecForProviderDefaultAdmissionRule {
  /**
   * The action when a pod creation is denied by the admission rule. Possible values are: ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY.
   *
   * @schema PolicySpecForProviderDefaultAdmissionRule#enforcementMode
   */
  readonly enforcementMode?: string;

  /**
   * How this admission rule will be evaluated. Possible values are: ALWAYS_ALLOW, REQUIRE_ATTESTATION, ALWAYS_DENY.
   *
   * @schema PolicySpecForProviderDefaultAdmissionRule#evaluationMode
   */
  readonly evaluationMode?: string;

  /**
   * The resource names of the attestors that must attest to a container image. If the attestor is in a different project from the policy, it should be specified in the format projects/_/attestors/*. Each attestor must exist before a policy can reference it. To add an attestor to a policy the principal issuing the policy change request must be able to read the attestor resource. Note: this field must be non-empty when the evaluation_mode field specifies REQUIRE_ATTESTATION, otherwise it must be empty.
   *
   * @schema PolicySpecForProviderDefaultAdmissionRule#requireAttestationsBy
   */
  readonly requireAttestationsBy?: string[];

}

/**
 * Converts an object of type 'PolicySpecForProviderDefaultAdmissionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecForProviderDefaultAdmissionRule(obj: PolicySpecForProviderDefaultAdmissionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforcementMode': obj.enforcementMode,
    'evaluationMode': obj.evaluationMode,
    'requireAttestationsBy': obj.requireAttestationsBy?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderAdmissionWhitelistPatterns
 */
export interface PolicySpecInitProviderAdmissionWhitelistPatterns {
  /**
   * An image name pattern to whitelist, in the form registry/path/to/image. This supports a trailing * as a wildcard, but this is allowed only in text after the registry/ part.
   *
   * @schema PolicySpecInitProviderAdmissionWhitelistPatterns#namePattern
   */
  readonly namePattern?: string;

}

/**
 * Converts an object of type 'PolicySpecInitProviderAdmissionWhitelistPatterns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderAdmissionWhitelistPatterns(obj: PolicySpecInitProviderAdmissionWhitelistPatterns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namePattern': obj.namePattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderClusterAdmissionRules
 */
export interface PolicySpecInitProviderClusterAdmissionRules {
  /**
   * The identifier for this object. Format specified above.
   *
   * @schema PolicySpecInitProviderClusterAdmissionRules#cluster
   */
  readonly cluster?: string;

  /**
   * The action when a pod creation is denied by the admission rule. Possible values are: ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY.
   *
   * @schema PolicySpecInitProviderClusterAdmissionRules#enforcementMode
   */
  readonly enforcementMode?: string;

  /**
   * How this admission rule will be evaluated. Possible values are: ALWAYS_ALLOW, REQUIRE_ATTESTATION, ALWAYS_DENY.
   *
   * @schema PolicySpecInitProviderClusterAdmissionRules#evaluationMode
   */
  readonly evaluationMode?: string;

  /**
   * The resource names of the attestors that must attest to a container image. If the attestor is in a different project from the policy, it should be specified in the format projects/_/attestors/*. Each attestor must exist before a policy can reference it. To add an attestor to a policy the principal issuing the policy change request must be able to read the attestor resource. Note: this field must be non-empty when the evaluation_mode field specifies REQUIRE_ATTESTATION, otherwise it must be empty.
   *
   * @schema PolicySpecInitProviderClusterAdmissionRules#requireAttestationsBy
   */
  readonly requireAttestationsBy?: string[];

}

/**
 * Converts an object of type 'PolicySpecInitProviderClusterAdmissionRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderClusterAdmissionRules(obj: PolicySpecInitProviderClusterAdmissionRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cluster': obj.cluster,
    'enforcementMode': obj.enforcementMode,
    'evaluationMode': obj.evaluationMode,
    'requireAttestationsBy': obj.requireAttestationsBy?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PolicySpecInitProviderDefaultAdmissionRule
 */
export interface PolicySpecInitProviderDefaultAdmissionRule {
  /**
   * The action when a pod creation is denied by the admission rule. Possible values are: ENFORCED_BLOCK_AND_AUDIT_LOG, DRYRUN_AUDIT_LOG_ONLY.
   *
   * @schema PolicySpecInitProviderDefaultAdmissionRule#enforcementMode
   */
  readonly enforcementMode?: string;

  /**
   * How this admission rule will be evaluated. Possible values are: ALWAYS_ALLOW, REQUIRE_ATTESTATION, ALWAYS_DENY.
   *
   * @schema PolicySpecInitProviderDefaultAdmissionRule#evaluationMode
   */
  readonly evaluationMode?: string;

  /**
   * The resource names of the attestors that must attest to a container image. If the attestor is in a different project from the policy, it should be specified in the format projects/_/attestors/*. Each attestor must exist before a policy can reference it. To add an attestor to a policy the principal issuing the policy change request must be able to read the attestor resource. Note: this field must be non-empty when the evaluation_mode field specifies REQUIRE_ATTESTATION, otherwise it must be empty.
   *
   * @schema PolicySpecInitProviderDefaultAdmissionRule#requireAttestationsBy
   */
  readonly requireAttestationsBy?: string[];

}

/**
 * Converts an object of type 'PolicySpecInitProviderDefaultAdmissionRule' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecInitProviderDefaultAdmissionRule(obj: PolicySpecInitProviderDefaultAdmissionRule | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforcementMode': obj.enforcementMode,
    'evaluationMode': obj.evaluationMode,
    'requireAttestationsBy': obj.requireAttestationsBy?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PolicySpecProviderConfigRefPolicy
 */
export interface PolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecProviderConfigRefPolicy(obj: PolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRef(obj: PolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PolicySpecPublishConnectionDetailsToMetadata
 */
export interface PolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToMetadata(obj: PolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolution
 */
export enum PolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecProviderConfigRefPolicyResolve
 */
export enum PolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

