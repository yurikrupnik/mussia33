// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Domain is the Schema for the Domains API. Provides an CloudSearch domain resource.
 *
 * @schema Domain
 */
export class Domain extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Domain"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudsearch.aws.upbound.io/v1beta1',
    kind: 'Domain',
  }

  /**
   * Renders a Kubernetes manifest for "Domain".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainProps): any {
    return {
      ...Domain.GVK,
      ...toJson_DomainProps(props),
    };
  }

  /**
   * Defines a "Domain" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainProps) {
    super(scope, id, {
      ...Domain.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Domain.GVK,
      ...toJson_DomainProps(resolved),
    };
  }
}

/**
 * Domain is the Schema for the Domains API. Provides an CloudSearch domain resource.
 *
 * @schema Domain
 */
export interface DomainProps {
  /**
   * @schema Domain#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainSpec defines the desired state of Domain
   *
   * @schema Domain#spec
   */
  readonly spec: DomainSpec;

}

/**
 * Converts an object of type 'DomainProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainProps(obj: DomainProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainSpec defines the desired state of Domain
 *
 * @schema DomainSpec
 */
export interface DomainSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainSpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainSpecDeletionPolicy;

  /**
   * @schema DomainSpec#forProvider
   */
  readonly forProvider: DomainSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DomainSpec#initProvider
   */
  readonly initProvider?: DomainSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DomainSpec#managementPolicies
   */
  readonly managementPolicies?: DomainSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainSpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpec(obj: DomainSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainSpecForProvider(obj.forProvider),
    'initProvider': toJson_DomainSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DomainSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DomainSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainSpecDeletionPolicy
 */
export enum DomainSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainSpecForProvider
 */
export interface DomainSpecForProvider {
  /**
   * Domain endpoint options. Documented below.
   *
   * @schema DomainSpecForProvider#endpointOptions
   */
  readonly endpointOptions?: DomainSpecForProviderEndpointOptions[];

  /**
   * The index fields for documents added to the domain. Documented below.
   *
   * @schema DomainSpecForProvider#indexField
   */
  readonly indexField?: DomainSpecForProviderIndexField[];

  /**
   * Whether or not to maintain extra instances for the domain in a second Availability Zone to ensure high availability.
   *
   * @schema DomainSpecForProvider#multiAz
   */
  readonly multiAz?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainSpecForProvider#region
   */
  readonly region: string;

  /**
   * Domain scaling parameters. Documented below.
   *
   * @schema DomainSpecForProvider#scalingParameters
   */
  readonly scalingParameters?: DomainSpecForProviderScalingParameters[];

}

/**
 * Converts an object of type 'DomainSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProvider(obj: DomainSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointOptions': obj.endpointOptions?.map(y => toJson_DomainSpecForProviderEndpointOptions(y)),
    'indexField': obj.indexField?.map(y => toJson_DomainSpecForProviderIndexField(y)),
    'multiAz': obj.multiAz,
    'region': obj.region,
    'scalingParameters': obj.scalingParameters?.map(y => toJson_DomainSpecForProviderScalingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DomainSpecInitProvider
 */
export interface DomainSpecInitProvider {
  /**
   * Domain endpoint options. Documented below.
   *
   * @schema DomainSpecInitProvider#endpointOptions
   */
  readonly endpointOptions?: DomainSpecInitProviderEndpointOptions[];

  /**
   * The index fields for documents added to the domain. Documented below.
   *
   * @schema DomainSpecInitProvider#indexField
   */
  readonly indexField?: DomainSpecInitProviderIndexField[];

  /**
   * Whether or not to maintain extra instances for the domain in a second Availability Zone to ensure high availability.
   *
   * @schema DomainSpecInitProvider#multiAz
   */
  readonly multiAz?: boolean;

  /**
   * Domain scaling parameters. Documented below.
   *
   * @schema DomainSpecInitProvider#scalingParameters
   */
  readonly scalingParameters?: DomainSpecInitProviderScalingParameters[];

}

/**
 * Converts an object of type 'DomainSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProvider(obj: DomainSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointOptions': obj.endpointOptions?.map(y => toJson_DomainSpecInitProviderEndpointOptions(y)),
    'indexField': obj.indexField?.map(y => toJson_DomainSpecInitProviderIndexField(y)),
    'multiAz': obj.multiAz,
    'scalingParameters': obj.scalingParameters?.map(y => toJson_DomainSpecInitProviderScalingParameters(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DomainSpecManagementPolicies
 */
export enum DomainSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainSpecProviderConfigRef
 */
export interface DomainSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecProviderConfigRef#policy
   */
  readonly policy?: DomainSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRef(obj: DomainSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainSpecPublishConnectionDetailsTo
 */
export interface DomainSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsTo(obj: DomainSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainSpecWriteConnectionSecretToRef
 */
export interface DomainSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecWriteConnectionSecretToRef(obj: DomainSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderEndpointOptions
 */
export interface DomainSpecForProviderEndpointOptions {
  /**
   * Enables or disables the requirement that all requests to the domain arrive over HTTPS.
   *
   * @schema DomainSpecForProviderEndpointOptions#enforceHttps
   */
  readonly enforceHttps?: boolean;

  /**
   * The minimum required TLS version. See the AWS documentation for valid values.
   *
   * @schema DomainSpecForProviderEndpointOptions#tlsSecurityPolicy
   */
  readonly tlsSecurityPolicy?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderEndpointOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderEndpointOptions(obj: DomainSpecForProviderEndpointOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforceHttps': obj.enforceHttps,
    'tlsSecurityPolicy': obj.tlsSecurityPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderIndexField
 */
export interface DomainSpecForProviderIndexField {
  /**
   * The analysis scheme you want to use for a text field. The analysis scheme specifies the language-specific text processing options that are used during indexing.
   *
   * @schema DomainSpecForProviderIndexField#analysisScheme
   */
  readonly analysisScheme?: string;

  /**
   * The default value for the field. This value is used when no value is specified for the field in the document data.
   *
   * @schema DomainSpecForProviderIndexField#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * You can get facet information by enabling this.
   *
   * @schema DomainSpecForProviderIndexField#facet
   */
  readonly facet?: boolean;

  /**
   * You can highlight information.
   *
   * @schema DomainSpecForProviderIndexField#highlight
   */
  readonly highlight?: boolean;

  /**
   * The name of the CloudSearch domain.
   *
   * @schema DomainSpecForProviderIndexField#name
   */
  readonly name?: string;

  /**
   * You can enable returning the value of all searchable fields.
   *
   * @schema DomainSpecForProviderIndexField#return
   */
  readonly return?: boolean;

  /**
   * You can set whether this index should be searchable or not.
   *
   * @schema DomainSpecForProviderIndexField#search
   */
  readonly search?: boolean;

  /**
   * You can enable the property to be sortable.
   *
   * @schema DomainSpecForProviderIndexField#sort
   */
  readonly sort?: boolean;

  /**
   * A comma-separated list of source fields to map to the field. Specifying a source field copies data from one field to another, enabling you to use the same source data in different ways by configuring different options for the fields.
   *
   * @schema DomainSpecForProviderIndexField#sourceFields
   */
  readonly sourceFields?: string;

  /**
   * The field type. Valid values: date, date-array, double, double-array, int, int-array, literal, literal-array, text, text-array.
   *
   * @schema DomainSpecForProviderIndexField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainSpecForProviderIndexField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderIndexField(obj: DomainSpecForProviderIndexField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'analysisScheme': obj.analysisScheme,
    'defaultValue': obj.defaultValue,
    'facet': obj.facet,
    'highlight': obj.highlight,
    'name': obj.name,
    'return': obj.return,
    'search': obj.search,
    'sort': obj.sort,
    'sourceFields': obj.sourceFields,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecForProviderScalingParameters
 */
export interface DomainSpecForProviderScalingParameters {
  /**
   * The instance type that you want to preconfigure for your domain. See the AWS documentation for valid values.
   *
   * @schema DomainSpecForProviderScalingParameters#desiredInstanceType
   */
  readonly desiredInstanceType?: string;

  /**
   * The number of partitions you want to preconfigure for your domain. Only valid when you select search.2xlarge as the instance type.
   *
   * @schema DomainSpecForProviderScalingParameters#desiredPartitionCount
   */
  readonly desiredPartitionCount?: number;

  /**
   * The number of replicas you want to preconfigure for each index partition.
   *
   * @schema DomainSpecForProviderScalingParameters#desiredReplicationCount
   */
  readonly desiredReplicationCount?: number;

}

/**
 * Converts an object of type 'DomainSpecForProviderScalingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecForProviderScalingParameters(obj: DomainSpecForProviderScalingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredInstanceType': obj.desiredInstanceType,
    'desiredPartitionCount': obj.desiredPartitionCount,
    'desiredReplicationCount': obj.desiredReplicationCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderEndpointOptions
 */
export interface DomainSpecInitProviderEndpointOptions {
  /**
   * Enables or disables the requirement that all requests to the domain arrive over HTTPS.
   *
   * @schema DomainSpecInitProviderEndpointOptions#enforceHttps
   */
  readonly enforceHttps?: boolean;

  /**
   * The minimum required TLS version. See the AWS documentation for valid values.
   *
   * @schema DomainSpecInitProviderEndpointOptions#tlsSecurityPolicy
   */
  readonly tlsSecurityPolicy?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderEndpointOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderEndpointOptions(obj: DomainSpecInitProviderEndpointOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enforceHttps': obj.enforceHttps,
    'tlsSecurityPolicy': obj.tlsSecurityPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderIndexField
 */
export interface DomainSpecInitProviderIndexField {
  /**
   * The analysis scheme you want to use for a text field. The analysis scheme specifies the language-specific text processing options that are used during indexing.
   *
   * @schema DomainSpecInitProviderIndexField#analysisScheme
   */
  readonly analysisScheme?: string;

  /**
   * The default value for the field. This value is used when no value is specified for the field in the document data.
   *
   * @schema DomainSpecInitProviderIndexField#defaultValue
   */
  readonly defaultValue?: string;

  /**
   * You can get facet information by enabling this.
   *
   * @schema DomainSpecInitProviderIndexField#facet
   */
  readonly facet?: boolean;

  /**
   * You can highlight information.
   *
   * @schema DomainSpecInitProviderIndexField#highlight
   */
  readonly highlight?: boolean;

  /**
   * The name of the CloudSearch domain.
   *
   * @schema DomainSpecInitProviderIndexField#name
   */
  readonly name?: string;

  /**
   * You can enable returning the value of all searchable fields.
   *
   * @schema DomainSpecInitProviderIndexField#return
   */
  readonly return?: boolean;

  /**
   * You can set whether this index should be searchable or not.
   *
   * @schema DomainSpecInitProviderIndexField#search
   */
  readonly search?: boolean;

  /**
   * You can enable the property to be sortable.
   *
   * @schema DomainSpecInitProviderIndexField#sort
   */
  readonly sort?: boolean;

  /**
   * A comma-separated list of source fields to map to the field. Specifying a source field copies data from one field to another, enabling you to use the same source data in different ways by configuring different options for the fields.
   *
   * @schema DomainSpecInitProviderIndexField#sourceFields
   */
  readonly sourceFields?: string;

  /**
   * The field type. Valid values: date, date-array, double, double-array, int, int-array, literal, literal-array, text, text-array.
   *
   * @schema DomainSpecInitProviderIndexField#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainSpecInitProviderIndexField' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderIndexField(obj: DomainSpecInitProviderIndexField | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'analysisScheme': obj.analysisScheme,
    'defaultValue': obj.defaultValue,
    'facet': obj.facet,
    'highlight': obj.highlight,
    'name': obj.name,
    'return': obj.return,
    'search': obj.search,
    'sort': obj.sort,
    'sourceFields': obj.sourceFields,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DomainSpecInitProviderScalingParameters
 */
export interface DomainSpecInitProviderScalingParameters {
  /**
   * The instance type that you want to preconfigure for your domain. See the AWS documentation for valid values.
   *
   * @schema DomainSpecInitProviderScalingParameters#desiredInstanceType
   */
  readonly desiredInstanceType?: string;

  /**
   * The number of partitions you want to preconfigure for your domain. Only valid when you select search.2xlarge as the instance type.
   *
   * @schema DomainSpecInitProviderScalingParameters#desiredPartitionCount
   */
  readonly desiredPartitionCount?: number;

  /**
   * The number of replicas you want to preconfigure for each index partition.
   *
   * @schema DomainSpecInitProviderScalingParameters#desiredReplicationCount
   */
  readonly desiredReplicationCount?: number;

}

/**
 * Converts an object of type 'DomainSpecInitProviderScalingParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecInitProviderScalingParameters(obj: DomainSpecInitProviderScalingParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredInstanceType': obj.desiredInstanceType,
    'desiredPartitionCount': obj.desiredPartitionCount,
    'desiredReplicationCount': obj.desiredReplicationCount,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainSpecProviderConfigRefPolicy
 */
export interface DomainSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecProviderConfigRefPolicy(obj: DomainSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRef
 */
export interface DomainSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRef(obj: DomainSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainSpecPublishConnectionDetailsToMetadata
 */
export interface DomainSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToMetadata(obj: DomainSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolution
 */
export enum DomainSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecProviderConfigRefPolicyResolve
 */
export enum DomainSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainSpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DomainServiceAccessPolicy is the Schema for the DomainServiceAccessPolicys API. Provides an CloudSearch domain service access policy resource.
 *
 * @schema DomainServiceAccessPolicy
 */
export class DomainServiceAccessPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DomainServiceAccessPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudsearch.aws.upbound.io/v1beta1',
    kind: 'DomainServiceAccessPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "DomainServiceAccessPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DomainServiceAccessPolicyProps): any {
    return {
      ...DomainServiceAccessPolicy.GVK,
      ...toJson_DomainServiceAccessPolicyProps(props),
    };
  }

  /**
   * Defines a "DomainServiceAccessPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DomainServiceAccessPolicyProps) {
    super(scope, id, {
      ...DomainServiceAccessPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DomainServiceAccessPolicy.GVK,
      ...toJson_DomainServiceAccessPolicyProps(resolved),
    };
  }
}

/**
 * DomainServiceAccessPolicy is the Schema for the DomainServiceAccessPolicys API. Provides an CloudSearch domain service access policy resource.
 *
 * @schema DomainServiceAccessPolicy
 */
export interface DomainServiceAccessPolicyProps {
  /**
   * @schema DomainServiceAccessPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DomainServiceAccessPolicySpec defines the desired state of DomainServiceAccessPolicy
   *
   * @schema DomainServiceAccessPolicy#spec
   */
  readonly spec: DomainServiceAccessPolicySpec;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicyProps(obj: DomainServiceAccessPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DomainServiceAccessPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DomainServiceAccessPolicySpec defines the desired state of DomainServiceAccessPolicy
 *
 * @schema DomainServiceAccessPolicySpec
 */
export interface DomainServiceAccessPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DomainServiceAccessPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: DomainServiceAccessPolicySpecDeletionPolicy;

  /**
   * @schema DomainServiceAccessPolicySpec#forProvider
   */
  readonly forProvider: DomainServiceAccessPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DomainServiceAccessPolicySpec#initProvider
   */
  readonly initProvider?: DomainServiceAccessPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DomainServiceAccessPolicySpec#managementPolicies
   */
  readonly managementPolicies?: DomainServiceAccessPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DomainServiceAccessPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: DomainServiceAccessPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DomainServiceAccessPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DomainServiceAccessPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DomainServiceAccessPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DomainServiceAccessPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpec(obj: DomainServiceAccessPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DomainServiceAccessPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_DomainServiceAccessPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DomainServiceAccessPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DomainServiceAccessPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DomainServiceAccessPolicySpecDeletionPolicy
 */
export enum DomainServiceAccessPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DomainServiceAccessPolicySpecForProvider
 */
export interface DomainServiceAccessPolicySpecForProvider {
  /**
   * The access rules you want to configure. These rules replace any existing rules. See the AWS documentation for details.
   *
   * @schema DomainServiceAccessPolicySpecForProvider#accessPolicy
   */
  readonly accessPolicy?: string;

  /**
   * The CloudSearch domain name the policy applies to.
   *
   * @schema DomainServiceAccessPolicySpecForProvider#domainName
   */
  readonly domainName?: string;

  /**
   * Reference to a Domain in cloudsearch to populate domainName.
   *
   * @schema DomainServiceAccessPolicySpecForProvider#domainNameRef
   */
  readonly domainNameRef?: DomainServiceAccessPolicySpecForProviderDomainNameRef;

  /**
   * Selector for a Domain in cloudsearch to populate domainName.
   *
   * @schema DomainServiceAccessPolicySpecForProvider#domainNameSelector
   */
  readonly domainNameSelector?: DomainServiceAccessPolicySpecForProviderDomainNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DomainServiceAccessPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecForProvider(obj: DomainServiceAccessPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPolicy': obj.accessPolicy,
    'domainName': obj.domainName,
    'domainNameRef': toJson_DomainServiceAccessPolicySpecForProviderDomainNameRef(obj.domainNameRef),
    'domainNameSelector': toJson_DomainServiceAccessPolicySpecForProviderDomainNameSelector(obj.domainNameSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DomainServiceAccessPolicySpecInitProvider
 */
export interface DomainServiceAccessPolicySpecInitProvider {
  /**
   * The access rules you want to configure. These rules replace any existing rules. See the AWS documentation for details.
   *
   * @schema DomainServiceAccessPolicySpecInitProvider#accessPolicy
   */
  readonly accessPolicy?: string;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecInitProvider(obj: DomainServiceAccessPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPolicy': obj.accessPolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DomainServiceAccessPolicySpecManagementPolicies
 */
export enum DomainServiceAccessPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DomainServiceAccessPolicySpecProviderConfigRef
 */
export interface DomainServiceAccessPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainServiceAccessPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainServiceAccessPolicySpecProviderConfigRef#policy
   */
  readonly policy?: DomainServiceAccessPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecProviderConfigRef(obj: DomainServiceAccessPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainServiceAccessPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsTo
 */
export interface DomainServiceAccessPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsTo(obj: DomainServiceAccessPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DomainServiceAccessPolicySpecWriteConnectionSecretToRef
 */
export interface DomainServiceAccessPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DomainServiceAccessPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DomainServiceAccessPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecWriteConnectionSecretToRef(obj: DomainServiceAccessPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Domain in cloudsearch to populate domainName.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameRef
 */
export interface DomainServiceAccessPolicySpecForProviderDomainNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameRef#policy
   */
  readonly policy?: DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecForProviderDomainNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecForProviderDomainNameRef(obj: DomainServiceAccessPolicySpecForProviderDomainNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Domain in cloudsearch to populate domainName.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelector
 */
export interface DomainServiceAccessPolicySpecForProviderDomainNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelector#policy
   */
  readonly policy?: DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecForProviderDomainNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecForProviderDomainNameSelector(obj: DomainServiceAccessPolicySpecForProviderDomainNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainServiceAccessPolicySpecProviderConfigRefPolicy
 */
export interface DomainServiceAccessPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainServiceAccessPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DomainServiceAccessPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainServiceAccessPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DomainServiceAccessPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecProviderConfigRefPolicy(obj: DomainServiceAccessPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef(obj: DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata
 */
export interface DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata(obj: DomainServiceAccessPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy
 */
export interface DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy#resolution
   */
  readonly resolution?: DomainServiceAccessPolicySpecForProviderDomainNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy#resolve
   */
  readonly resolve?: DomainServiceAccessPolicySpecForProviderDomainNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy(obj: DomainServiceAccessPolicySpecForProviderDomainNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy
 */
export interface DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy#resolution
   */
  readonly resolution?: DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy#resolve
   */
  readonly resolve?: DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy(obj: DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainServiceAccessPolicySpecProviderConfigRefPolicyResolution
 */
export enum DomainServiceAccessPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainServiceAccessPolicySpecProviderConfigRefPolicyResolve
 */
export enum DomainServiceAccessPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameRefPolicyResolution
 */
export enum DomainServiceAccessPolicySpecForProviderDomainNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameRefPolicyResolve
 */
export enum DomainServiceAccessPolicySpecForProviderDomainNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicyResolution
 */
export enum DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicyResolve
 */
export enum DomainServiceAccessPolicySpecForProviderDomainNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DomainServiceAccessPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

