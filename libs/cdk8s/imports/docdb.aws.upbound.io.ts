// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Cluster is the Schema for the Clusters API. Manages a DocDB Aurora Cluster
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.upbound.io/v1beta1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * Cluster is the Schema for the Clusters API. Manages a DocDB Aurora Cluster
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSpec defines the desired state of Cluster
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSpec defines the desired state of Cluster
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSpec#providerRef
   */
  readonly providerRef?: ClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * Specifies whether any cluster modifications are applied immediately, or during the next maintenance window. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * A list of EC2 Availability Zones that instances in the DB cluster can be created in.
   *
   * @schema ClusterSpecForProvider#availabilityZones
   */
  readonly availabilityZones?: string[];

  /**
   * The days to retain backups for. Default 1
   *
   * @schema ClusterSpecForProvider#backupRetentionPeriod
   */
  readonly backupRetentionPeriod?: number;

  /**
   * A cluster parameter group to associate with the cluster.
   *
   * @schema ClusterSpecForProvider#dbClusterParameterGroupName
   */
  readonly dbClusterParameterGroupName?: string;

  /**
   * A DB subnet group to associate with this DB instance.
   *
   * @schema ClusterSpecForProvider#dbSubnetGroupName
   */
  readonly dbSubnetGroupName?: string;

  /**
   * A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. By default, deletion protection is disabled.
   *
   * @schema ClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * List of log types to export to cloudwatch. If omitted, no logs will be exported. The following log types are supported: audit, profiler.
   *
   * @schema ClusterSpecForProvider#enabledCloudwatchLogsExports
   */
  readonly enabledCloudwatchLogsExports?: string[];

  /**
   * The name of the database engine to be used for this DB cluster. Defaults to docdb. Valid Values: docdb
   *
   * @default docdb. Valid Values: docdb
   * @schema ClusterSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The database engine version. Updating this argument results in an outage.
   *
   * @schema ClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The name of your final DB snapshot when this DB cluster is deleted. If omitted, no final snapshot will be made.
   *
   * @schema ClusterSpecForProvider#finalSnapshotIdentifier
   */
  readonly finalSnapshotIdentifier?: string;

  /**
   * The global cluster identifier specified on aws_docdb_global_cluster.
   *
   * @schema ClusterSpecForProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier?: string;

  /**
   * The ARN for the KMS encryption key. When specifying kms_key_id, storage_encrypted needs to be set to true.
   *
   * @schema ClusterSpecForProvider#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Reference to a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterSpecForProvider#kmsKeyIdRef
   */
  readonly kmsKeyIdRef?: ClusterSpecForProviderKmsKeyIdRef;

  /**
   * Selector for a Key in kms to populate kmsKeyId.
   *
   * @schema ClusterSpecForProvider#kmsKeyIdSelector
   */
  readonly kmsKeyIdSelector?: ClusterSpecForProviderKmsKeyIdSelector;

  /**
   * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the DocDB Naming Constraints.
   *
   * @schema ClusterSpecForProvider#masterPasswordSecretRef
   */
  readonly masterPasswordSecretRef?: ClusterSpecForProviderMasterPasswordSecretRef;

  /**
   * Username for the master DB user.
   *
   * @schema ClusterSpecForProvider#masterUsername
   */
  readonly masterUsername?: string;

  /**
   * The port on which the DB accepts connections
   *
   * @schema ClusterSpecForProvider#port
   */
  readonly port?: number;

  /**
   * The daily time range during which automated backups are created if automated backups are enabled using the BackupRetentionPeriod parameter.Time in UTC Default: A 30-minute window selected at random from an 8-hour block of time per regionE.g., 04:00-09:00
   *
   * @schema ClusterSpecForProvider#preferredBackupWindow
   */
  readonly preferredBackupWindow?: string;

  /**
   * The weekly time range during which system maintenance can occur, in (UTC) e.g., wed:04:00-wed:04:30
   *
   * @schema ClusterSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Determines whether a final DB snapshot is created before the DB cluster is deleted. If true is specified, no DB snapshot is created. If false is specified, a DB snapshot is created before the DB cluster is deleted, using the value from final_snapshot_identifier. Default is false.
   *
   * @default false.
   * @schema ClusterSpecForProvider#skipFinalSnapshot
   */
  readonly skipFinalSnapshot?: boolean;

  /**
   * Specifies whether or not to create this cluster from a snapshot. You can use either the name or ARN when specifying a DB cluster snapshot, or the ARN when specifying a DB snapshot.
   *
   * @schema ClusterSpecForProvider#snapshotIdentifier
   */
  readonly snapshotIdentifier?: string;

  /**
   * Specifies whether the DB cluster is encrypted. The default is false.
   *
   * @schema ClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * References to SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdRefs
   */
  readonly vpcSecurityGroupIdRefs?: ClusterSpecForProviderVpcSecurityGroupIdRefs[];

  /**
   * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIdSelector
   */
  readonly vpcSecurityGroupIdSelector?: ClusterSpecForProviderVpcSecurityGroupIdSelector;

  /**
   * List of VPC security groups to associate with the Cluster
   *
   * @schema ClusterSpecForProvider#vpcSecurityGroupIds
   */
  readonly vpcSecurityGroupIds?: string[];

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'availabilityZones': obj.availabilityZones?.map(y => y),
    'backupRetentionPeriod': obj.backupRetentionPeriod,
    'dbClusterParameterGroupName': obj.dbClusterParameterGroupName,
    'dbSubnetGroupName': obj.dbSubnetGroupName,
    'deletionProtection': obj.deletionProtection,
    'enabledCloudwatchLogsExports': obj.enabledCloudwatchLogsExports?.map(y => y),
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'finalSnapshotIdentifier': obj.finalSnapshotIdentifier,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'kmsKeyId': obj.kmsKeyId,
    'kmsKeyIdRef': toJson_ClusterSpecForProviderKmsKeyIdRef(obj.kmsKeyIdRef),
    'kmsKeyIdSelector': toJson_ClusterSpecForProviderKmsKeyIdSelector(obj.kmsKeyIdSelector),
    'masterPasswordSecretRef': toJson_ClusterSpecForProviderMasterPasswordSecretRef(obj.masterPasswordSecretRef),
    'masterUsername': obj.masterUsername,
    'port': obj.port,
    'preferredBackupWindow': obj.preferredBackupWindow,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'region': obj.region,
    'skipFinalSnapshot': obj.skipFinalSnapshot,
    'snapshotIdentifier': obj.snapshotIdentifier,
    'storageEncrypted': obj.storageEncrypted,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcSecurityGroupIdRefs': obj.vpcSecurityGroupIdRefs?.map(y => toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(y)),
    'vpcSecurityGroupIdSelector': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj.vpcSecurityGroupIdSelector),
    'vpcSecurityGroupIds': obj.vpcSecurityGroupIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSpecProviderRef
 */
export interface ClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderRef#policy
   */
  readonly policy?: ClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRef(obj: ClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRef
 */
export interface ClusterSpecForProviderKmsKeyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRef#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyIdRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdRef(obj: ClusterSpecForProviderKmsKeyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderKmsKeyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Key in kms to populate kmsKeyId.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelector
 */
export interface ClusterSpecForProviderKmsKeyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderKmsKeyIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdSelector(obj: ClusterSpecForProviderKmsKeyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderKmsKeyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Password for the master DB user. Note that this may show up in logs, and it will be stored in the state file. Please refer to the DocDB Naming Constraints.
 *
 * @schema ClusterSpecForProviderMasterPasswordSecretRef
 */
export interface ClusterSpecForProviderMasterPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderMasterPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderMasterPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderMasterPasswordSecretRef(obj: ClusterSpecForProviderMasterPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefs {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefs#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefs(obj: ClusterSpecForProviderVpcSecurityGroupIdRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of SecurityGroup in ec2 to populate vpcSecurityGroupIds.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelector#policy
   */
  readonly policy?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelector(obj: ClusterSpecForProviderVpcSecurityGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderRefPolicy
 */
export interface ClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRefPolicy(obj: ClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicy
 */
export interface ClusterSpecForProviderKmsKeyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyIdRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdRefPolicy(obj: ClusterSpecForProviderKmsKeyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy
 */
export interface ClusterSpecForProviderKmsKeyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderKmsKeyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderKmsKeyIdSelectorPolicy(obj: ClusterSpecForProviderKmsKeyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy
 */
export interface ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy(obj: ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderRefPolicyResolution
 */
export enum ClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderRefPolicyResolve
 */
export enum ClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyIdRefPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderKmsKeyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderKmsKeyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve
 */
export enum ClusterSpecForProviderVpcSecurityGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterInstance is the Schema for the ClusterInstances API. Provides an DocDB Cluster Resource Instance
 *
 * @schema ClusterInstance
 */
export class ClusterInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.upbound.io/v1beta1',
    kind: 'ClusterInstance',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterInstanceProps): any {
    return {
      ...ClusterInstance.GVK,
      ...toJson_ClusterInstanceProps(props),
    };
  }

  /**
   * Defines a "ClusterInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterInstanceProps) {
    super(scope, id, {
      ...ClusterInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterInstance.GVK,
      ...toJson_ClusterInstanceProps(resolved),
    };
  }
}

/**
 * ClusterInstance is the Schema for the ClusterInstances API. Provides an DocDB Cluster Resource Instance
 *
 * @schema ClusterInstance
 */
export interface ClusterInstanceProps {
  /**
   * @schema ClusterInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterInstanceSpec defines the desired state of ClusterInstance
   *
   * @schema ClusterInstance#spec
   */
  readonly spec: ClusterInstanceSpec;

}

/**
 * Converts an object of type 'ClusterInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceProps(obj: ClusterInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterInstanceSpec defines the desired state of ClusterInstance
 *
 * @schema ClusterInstanceSpec
 */
export interface ClusterInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ClusterInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterInstanceSpecDeletionPolicy;

  /**
   * @schema ClusterInstanceSpec#forProvider
   */
  readonly forProvider: ClusterInstanceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterInstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterInstanceSpec#providerRef
   */
  readonly providerRef?: ClusterInstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpec(obj: ClusterInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterInstanceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ClusterInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterInstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ClusterInstanceSpecDeletionPolicy
 */
export enum ClusterInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterInstanceSpecForProvider
 */
export interface ClusterInstanceSpecForProvider {
  /**
   * Specifies whether any database modifications are applied immediately, or during the next maintenance window. Default isfalse.
   *
   * @schema ClusterInstanceSpecForProvider#applyImmediately
   */
  readonly applyImmediately?: boolean;

  /**
   * This parameter does not apply to Amazon DocumentDB. Amazon DocumentDB does not perform minor version upgrades regardless of the value set (see docs). Default true.
   *
   * @schema ClusterInstanceSpecForProvider#autoMinorVersionUpgrade
   */
  readonly autoMinorVersionUpgrade?: boolean;

  /**
   * The EC2 Availability Zone that the DB instance is created in. See docs about the details.
   *
   * @schema ClusterInstanceSpecForProvider#availabilityZone
   */
  readonly availabilityZone?: string;

  /**
   * The identifier of the CA certificate for the DB instance.
   *
   * @schema ClusterInstanceSpecForProvider#caCertIdentifier
   */
  readonly caCertIdentifier?: string;

  /**
   * The identifier of the aws_docdb_cluster in which to launch this instance.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifier
   */
  readonly clusterIdentifier?: string;

  /**
   * Reference to a Cluster to populate clusterIdentifier.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifierRef
   */
  readonly clusterIdentifierRef?: ClusterInstanceSpecForProviderClusterIdentifierRef;

  /**
   * Selector for a Cluster to populate clusterIdentifier.
   *
   * @schema ClusterInstanceSpecForProvider#clusterIdentifierSelector
   */
  readonly clusterIdentifierSelector?: ClusterInstanceSpecForProviderClusterIdentifierSelector;

  /**
   * A value that indicates whether to enable Performance Insights for the DB Instance. Default false. See [docs] (https://docs.aws.amazon.com/documentdb/latest/developerguide/performance-insights.html) about the details.
   *
   * @schema ClusterInstanceSpecForProvider#enablePerformanceInsights
   */
  readonly enablePerformanceInsights?: boolean;

  /**
   * The name of the database engine to be used for the DocDB instance. Defaults to docdb. Valid Values: docdb.
   *
   * @default docdb. Valid Values: docdb.
   * @schema ClusterInstanceSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * The instance class to use. For details on CPU and memory, see Scaling for DocDB Instances. DocDB currently supports the below instance classes. Please see AWS Documentation for complete details.
   *
   * @schema ClusterInstanceSpecForProvider#instanceClass
   */
  readonly instanceClass: string;

  /**
   * The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key. If you do not specify a value for PerformanceInsightsKMSKeyId, then Amazon DocumentDB uses your default KMS key.
   *
   * @schema ClusterInstanceSpecForProvider#performanceInsightsKmsKeyId
   */
  readonly performanceInsightsKmsKeyId?: string;

  /**
   * The window to perform maintenance in. Syntax: "ddd:hh24:mi-ddd:hh24:mi". Eg: "Mon:00:00-Mon:03:00".
   *
   * @schema ClusterInstanceSpecForProvider#preferredMaintenanceWindow
   */
  readonly preferredMaintenanceWindow?: string;

  /**
   * Default 0. Failover Priority setting on instance level. The reader who has lower tier has higher priority to get promoter to writer.
   *
   * @schema ClusterInstanceSpecForProvider#promotionTier
   */
  readonly promotionTier?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterInstanceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProvider(obj: ClusterInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyImmediately': obj.applyImmediately,
    'autoMinorVersionUpgrade': obj.autoMinorVersionUpgrade,
    'availabilityZone': obj.availabilityZone,
    'caCertIdentifier': obj.caCertIdentifier,
    'clusterIdentifier': obj.clusterIdentifier,
    'clusterIdentifierRef': toJson_ClusterInstanceSpecForProviderClusterIdentifierRef(obj.clusterIdentifierRef),
    'clusterIdentifierSelector': toJson_ClusterInstanceSpecForProviderClusterIdentifierSelector(obj.clusterIdentifierSelector),
    'enablePerformanceInsights': obj.enablePerformanceInsights,
    'engine': obj.engine,
    'instanceClass': obj.instanceClass,
    'performanceInsightsKmsKeyId': obj.performanceInsightsKmsKeyId,
    'preferredMaintenanceWindow': obj.preferredMaintenanceWindow,
    'promotionTier': obj.promotionTier,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterInstanceSpecProviderConfigRef
 */
export interface ClusterInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderConfigRef(obj: ClusterInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterInstanceSpecProviderRef
 */
export interface ClusterInstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecProviderRef#policy
   */
  readonly policy?: ClusterInstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderRef(obj: ClusterInstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsTo
 */
export interface ClusterInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsTo(obj: ClusterInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterInstanceSpecWriteConnectionSecretToRef
 */
export interface ClusterInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecWriteConnectionSecretToRef(obj: ClusterInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster to populate clusterIdentifier.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRef
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRef#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierRef(obj: ClusterInstanceSpecForProviderClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecForProviderClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster to populate clusterIdentifier.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierSelector(obj: ClusterInstanceSpecForProviderClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicy
 */
export interface ClusterInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderConfigRefPolicy(obj: ClusterInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecProviderRefPolicy
 */
export interface ClusterInstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecProviderRefPolicy(obj: ClusterInstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRef(obj: ClusterInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToMetadata(obj: ClusterInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierRefPolicy(obj: ClusterInstanceSpecForProviderClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy
 */
export interface ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy(obj: ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicyResolution
 */
export enum ClusterInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecProviderConfigRefPolicyResolve
 */
export enum ClusterInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecProviderRefPolicyResolution
 */
export enum ClusterInstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecProviderRefPolicyResolve
 */
export enum ClusterInstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterInstanceSpecForProviderClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterParameterGroup is the Schema for the ClusterParameterGroups API. Manages a DocumentDB Cluster Parameter Group
 *
 * @schema ClusterParameterGroup
 */
export class ClusterParameterGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterParameterGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.upbound.io/v1beta1',
    kind: 'ClusterParameterGroup',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterParameterGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterParameterGroupProps): any {
    return {
      ...ClusterParameterGroup.GVK,
      ...toJson_ClusterParameterGroupProps(props),
    };
  }

  /**
   * Defines a "ClusterParameterGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterParameterGroupProps) {
    super(scope, id, {
      ...ClusterParameterGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterParameterGroup.GVK,
      ...toJson_ClusterParameterGroupProps(resolved),
    };
  }
}

/**
 * ClusterParameterGroup is the Schema for the ClusterParameterGroups API. Manages a DocumentDB Cluster Parameter Group
 *
 * @schema ClusterParameterGroup
 */
export interface ClusterParameterGroupProps {
  /**
   * @schema ClusterParameterGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterParameterGroupSpec defines the desired state of ClusterParameterGroup
   *
   * @schema ClusterParameterGroup#spec
   */
  readonly spec: ClusterParameterGroupSpec;

}

/**
 * Converts an object of type 'ClusterParameterGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupProps(obj: ClusterParameterGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterParameterGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterParameterGroupSpec defines the desired state of ClusterParameterGroup
 *
 * @schema ClusterParameterGroupSpec
 */
export interface ClusterParameterGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ClusterParameterGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterParameterGroupSpecDeletionPolicy;

  /**
   * @schema ClusterParameterGroupSpec#forProvider
   */
  readonly forProvider: ClusterParameterGroupSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterParameterGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterParameterGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterParameterGroupSpec#providerRef
   */
  readonly providerRef?: ClusterParameterGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterParameterGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterParameterGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterParameterGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterParameterGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpec(obj: ClusterParameterGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterParameterGroupSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ClusterParameterGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterParameterGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterParameterGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterParameterGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ClusterParameterGroupSpecDeletionPolicy
 */
export enum ClusterParameterGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterParameterGroupSpecForProvider
 */
export interface ClusterParameterGroupSpecForProvider {
  /**
   * The description of the documentDB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The family of the documentDB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProvider#family
   */
  readonly family: string;

  /**
   * A list of documentDB parameters to apply. Setting parameters to system default values may show a difference on imported resources.
   *
   * @schema ClusterParameterGroupSpecForProvider#parameter
   */
  readonly parameter?: ClusterParameterGroupSpecForProviderParameter[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterParameterGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ClusterParameterGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecForProvider(obj: ClusterParameterGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'family': obj.family,
    'parameter': obj.parameter?.map(y => toJson_ClusterParameterGroupSpecForProviderParameter(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRef
 */
export interface ClusterParameterGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderConfigRef(obj: ClusterParameterGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterParameterGroupSpecProviderRef
 */
export interface ClusterParameterGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecProviderRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderRef(obj: ClusterParameterGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterParameterGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsTo(obj: ClusterParameterGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef
 */
export interface ClusterParameterGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterParameterGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecWriteConnectionSecretToRef(obj: ClusterParameterGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterParameterGroupSpecForProviderParameter
 */
export interface ClusterParameterGroupSpecForProviderParameter {
  /**
   * Valid values are immediate and pending-reboot. Defaults to pending-reboot.
   *
   * @default pending-reboot.
   * @schema ClusterParameterGroupSpecForProviderParameter#applyMethod
   */
  readonly applyMethod?: string;

  /**
   * The name of the documentDB cluster parameter group.
   *
   * @schema ClusterParameterGroupSpecForProviderParameter#name
   */
  readonly name: string;

  /**
   * The value of the documentDB parameter.
   *
   * @schema ClusterParameterGroupSpecForProviderParameter#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecForProviderParameter' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecForProviderParameter(obj: ClusterParameterGroupSpecForProviderParameter | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyMethod': obj.applyMethod,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicy
 */
export interface ClusterParameterGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderConfigRefPolicy(obj: ClusterParameterGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecProviderRefPolicy
 */
export interface ClusterParameterGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecProviderRefPolicy(obj: ClusterParameterGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef(obj: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToMetadata(obj: ClusterParameterGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicyResolution
 */
export enum ClusterParameterGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecProviderConfigRefPolicyResolve
 */
export enum ClusterParameterGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecProviderRefPolicyResolution
 */
export enum ClusterParameterGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecProviderRefPolicyResolve
 */
export enum ClusterParameterGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterParameterGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ClusterSnapshot is the Schema for the ClusterSnapshots API. Manages a DocDB database cluster snapshot.
 *
 * @schema ClusterSnapshot
 */
export class ClusterSnapshot extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSnapshot"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.upbound.io/v1beta1',
    kind: 'ClusterSnapshot',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterSnapshot".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSnapshotProps): any {
    return {
      ...ClusterSnapshot.GVK,
      ...toJson_ClusterSnapshotProps(props),
    };
  }

  /**
   * Defines a "ClusterSnapshot" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterSnapshotProps) {
    super(scope, id, {
      ...ClusterSnapshot.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSnapshot.GVK,
      ...toJson_ClusterSnapshotProps(resolved),
    };
  }
}

/**
 * ClusterSnapshot is the Schema for the ClusterSnapshots API. Manages a DocDB database cluster snapshot.
 *
 * @schema ClusterSnapshot
 */
export interface ClusterSnapshotProps {
  /**
   * @schema ClusterSnapshot#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ClusterSnapshotSpec defines the desired state of ClusterSnapshot
   *
   * @schema ClusterSnapshot#spec
   */
  readonly spec: ClusterSnapshotSpec;

}

/**
 * Converts an object of type 'ClusterSnapshotProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotProps(obj: ClusterSnapshotProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSnapshotSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ClusterSnapshotSpec defines the desired state of ClusterSnapshot
 *
 * @schema ClusterSnapshotSpec
 */
export interface ClusterSnapshotSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ClusterSnapshotSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSnapshotSpecDeletionPolicy;

  /**
   * @schema ClusterSnapshotSpec#forProvider
   */
  readonly forProvider: ClusterSnapshotSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSnapshotSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSnapshotSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSnapshotSpec#providerRef
   */
  readonly providerRef?: ClusterSnapshotSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSnapshotSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSnapshotSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSnapshotSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSnapshotSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSnapshotSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpec(obj: ClusterSnapshotSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSnapshotSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ClusterSnapshotSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSnapshotSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSnapshotSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSnapshotSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ClusterSnapshotSpecDeletionPolicy
 */
export enum ClusterSnapshotSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ClusterSnapshotSpecForProvider
 */
export interface ClusterSnapshotSpecForProvider {
  /**
   * The DocDB Cluster Identifier from which to take the snapshot.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifier
   */
  readonly dbClusterIdentifier?: string;

  /**
   * Reference to a Cluster in docdb to populate dbClusterIdentifier.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifierRef
   */
  readonly dbClusterIdentifierRef?: ClusterSnapshotSpecForProviderDbClusterIdentifierRef;

  /**
   * Selector for a Cluster in docdb to populate dbClusterIdentifier.
   *
   * @schema ClusterSnapshotSpecForProvider#dbClusterIdentifierSelector
   */
  readonly dbClusterIdentifierSelector?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ClusterSnapshotSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProvider(obj: ClusterSnapshotSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'dbClusterIdentifierRef': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRef(obj.dbClusterIdentifierRef),
    'dbClusterIdentifierSelector': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelector(obj.dbClusterIdentifierSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSnapshotSpecProviderConfigRef
 */
export interface ClusterSnapshotSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSnapshotSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderConfigRef(obj: ClusterSnapshotSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSnapshotSpecProviderRef
 */
export interface ClusterSnapshotSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecProviderRef#policy
   */
  readonly policy?: ClusterSnapshotSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderRef(obj: ClusterSnapshotSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsTo
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSnapshotSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsTo(obj: ClusterSnapshotSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSnapshotSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSnapshotSpecWriteConnectionSecretToRef
 */
export interface ClusterSnapshotSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSnapshotSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSnapshotSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecWriteConnectionSecretToRef(obj: ClusterSnapshotSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in docdb to populate dbClusterIdentifier.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRef#policy
   */
  readonly policy?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRef(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in docdb to populate dbClusterIdentifier.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelector#policy
   */
  readonly policy?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelector(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicy
 */
export interface ClusterSnapshotSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderConfigRefPolicy(obj: ClusterSnapshotSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecProviderRefPolicy
 */
export interface ClusterSnapshotSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecProviderRefPolicy(obj: ClusterSnapshotSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRef(obj: ClusterSnapshotSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToMetadata(obj: ClusterSnapshotSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy
 */
export interface ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy(obj: ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSnapshotSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSnapshotSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecProviderRefPolicyResolution
 */
export enum ClusterSnapshotSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecProviderRefPolicyResolve
 */
export enum ClusterSnapshotSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve
 */
export enum ClusterSnapshotSpecForProviderDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSnapshotSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a DocumentDB event subscription resource.
 *
 * @schema EventSubscription
 */
export class EventSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EventSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.upbound.io/v1beta1',
    kind: 'EventSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "EventSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EventSubscriptionProps): any {
    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(props),
    };
  }

  /**
   * Defines a "EventSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EventSubscriptionProps) {
    super(scope, id, {
      ...EventSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EventSubscription.GVK,
      ...toJson_EventSubscriptionProps(resolved),
    };
  }
}

/**
 * EventSubscription is the Schema for the EventSubscriptions API. Provides a DocumentDB event subscription resource.
 *
 * @schema EventSubscription
 */
export interface EventSubscriptionProps {
  /**
   * @schema EventSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EventSubscriptionSpec defines the desired state of EventSubscription
   *
   * @schema EventSubscription#spec
   */
  readonly spec: EventSubscriptionSpec;

}

/**
 * Converts an object of type 'EventSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionProps(obj: EventSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EventSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EventSubscriptionSpec defines the desired state of EventSubscription
 *
 * @schema EventSubscriptionSpec
 */
export interface EventSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EventSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: EventSubscriptionSpecDeletionPolicy;

  /**
   * @schema EventSubscriptionSpec#forProvider
   */
  readonly forProvider: EventSubscriptionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EventSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: EventSubscriptionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EventSubscriptionSpec#providerRef
   */
  readonly providerRef?: EventSubscriptionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EventSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EventSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EventSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EventSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EventSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpec(obj: EventSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EventSubscriptionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EventSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EventSubscriptionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EventSubscriptionSpecDeletionPolicy
 */
export enum EventSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EventSubscriptionSpecForProvider
 */
export interface EventSubscriptionSpecForProvider {
  /**
   * A boolean flag to enable/disable the subscription. Defaults to true.
   *
   * @default true.
   * @schema EventSubscriptionSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * A list of event categories for a SourceType that you want to subscribe to. See https://docs.aws.amazon.com/documentdb/latest/developerguide/API_Event.html or run aws docdb describe-event-categories.
   *
   * @schema EventSubscriptionSpecForProvider#eventCategories
   */
  readonly eventCategories?: string[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema EventSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name of the DocDB event notification subscription
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArn
   */
  readonly snsTopicArn?: string;

  /**
   * Reference to a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnRef
   */
  readonly snsTopicArnRef?: EventSubscriptionSpecForProviderSnsTopicArnRef;

  /**
   * Selector for a Topic in sns to populate snsTopicArn.
   *
   * @schema EventSubscriptionSpecForProvider#snsTopicArnSelector
   */
  readonly snsTopicArnSelector?: EventSubscriptionSpecForProviderSnsTopicArnSelector;

  /**
   * A list of identifiers of the event sources for which events will be returned. If not specified, then all sources are included in the response. If specified, a source_type must also be specified.
   *
   * @schema EventSubscriptionSpecForProvider#sourceIds
   */
  readonly sourceIds?: string[];

  /**
   * The type of source that will be generating the events. Valid options are db-instance, db-cluster, db-parameter-group, db-security-group, db-cluster-snapshot. If not set, all sources will be subscribed to.
   *
   * @schema EventSubscriptionSpecForProvider#sourceType
   */
  readonly sourceType?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema EventSubscriptionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProvider(obj: EventSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'eventCategories': obj.eventCategories?.map(y => y),
    'region': obj.region,
    'snsTopicArn': obj.snsTopicArn,
    'snsTopicArnRef': toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj.snsTopicArnRef),
    'snsTopicArnSelector': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj.snsTopicArnSelector),
    'sourceIds': obj.sourceIds?.map(y => y),
    'sourceType': obj.sourceType,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EventSubscriptionSpecProviderConfigRef
 */
export interface EventSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRef(obj: EventSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EventSubscriptionSpecProviderRef
 */
export interface EventSubscriptionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecProviderRef#policy
   */
  readonly policy?: EventSubscriptionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRef(obj: EventSubscriptionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsTo
 */
export interface EventSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EventSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EventSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsTo(obj: EventSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EventSubscriptionSpecWriteConnectionSecretToRef
 */
export interface EventSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EventSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecWriteConnectionSecretToRef(obj: EventSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRef
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRef#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRef(obj: EventSubscriptionSpecForProviderSnsTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate snsTopicArn.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelector#policy
   */
  readonly policy?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelector(obj: EventSubscriptionSpecForProviderSnsTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicy
 */
export interface EventSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderConfigRefPolicy(obj: EventSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecProviderRefPolicy
 */
export interface EventSubscriptionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecProviderRefPolicy(obj: EventSubscriptionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToMetadata(obj: EventSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnRefPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy
 */
export interface EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy(obj: EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolution
 */
export enum EventSubscriptionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecProviderRefPolicyResolve
 */
export enum EventSubscriptionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve
 */
export enum EventSubscriptionSpecForProviderSnsTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EventSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalCluster is the Schema for the GlobalClusters API. Manages a DocDB Global Cluster
 *
 * @schema GlobalCluster
 */
export class GlobalCluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalCluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.upbound.io/v1beta1',
    kind: 'GlobalCluster',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalCluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalClusterProps): any {
    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(props),
    };
  }

  /**
   * Defines a "GlobalCluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalClusterProps) {
    super(scope, id, {
      ...GlobalCluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalCluster.GVK,
      ...toJson_GlobalClusterProps(resolved),
    };
  }
}

/**
 * GlobalCluster is the Schema for the GlobalClusters API. Manages a DocDB Global Cluster
 *
 * @schema GlobalCluster
 */
export interface GlobalClusterProps {
  /**
   * @schema GlobalCluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalClusterSpec defines the desired state of GlobalCluster
   *
   * @schema GlobalCluster#spec
   */
  readonly spec: GlobalClusterSpec;

}

/**
 * Converts an object of type 'GlobalClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterProps(obj: GlobalClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalClusterSpec defines the desired state of GlobalCluster
 *
 * @schema GlobalClusterSpec
 */
export interface GlobalClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema GlobalClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalClusterSpecDeletionPolicy;

  /**
   * @schema GlobalClusterSpec#forProvider
   */
  readonly forProvider: GlobalClusterSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GlobalClusterSpec#providerRef
   */
  readonly providerRef?: GlobalClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpec(obj: GlobalClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalClusterSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_GlobalClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GlobalClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema GlobalClusterSpecDeletionPolicy
 */
export enum GlobalClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GlobalClusterSpecForProvider
 */
export interface GlobalClusterSpecForProvider {
  /**
   * Name for an automatically created database on cluster creation.
   *
   * @schema GlobalClusterSpecForProvider#databaseName
   */
  readonly databaseName?: string;

  /**
   * If the Global Cluster should have deletion protection enabled. The database can't be deleted when this value is set to true. The default is false.
   *
   * @schema GlobalClusterSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: boolean;

  /**
   * Name of the database engine to be used for this DB cluster. Current Valid values: docdb. Defaults to docdb. Conflicts with source_db_cluster_identifier.
   *
   * @default docdb. Conflicts with source_db_cluster_identifier.
   * @schema GlobalClusterSpecForProvider#engine
   */
  readonly engine?: string;

  /**
   * Engine version of the global database. Upgrading the engine version will result in all cluster members being immediately updated and will.
   *
   * @schema GlobalClusterSpecForProvider#engineVersion
   */
  readonly engineVersion?: string;

  /**
   * The global cluster identifier.
   *
   * @schema GlobalClusterSpecForProvider#globalClusterIdentifier
   */
  readonly globalClusterIdentifier: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GlobalClusterSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) to use as the primary DB Cluster of the Global Cluster on creation.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifier
   */
  readonly sourceDbClusterIdentifier?: string;

  /**
   * Reference to a Cluster in docdb to populate sourceDbClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifierRef
   */
  readonly sourceDbClusterIdentifierRef?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef;

  /**
   * Selector for a Cluster in docdb to populate sourceDbClusterIdentifier.
   *
   * @schema GlobalClusterSpecForProvider#sourceDbClusterIdentifierSelector
   */
  readonly sourceDbClusterIdentifierSelector?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector;

  /**
   * Specifies whether the DB cluster is encrypted. The default is false unless source_db_cluster_identifier is specified and encrypted.
   *
   * @schema GlobalClusterSpecForProvider#storageEncrypted
   */
  readonly storageEncrypted?: boolean;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProvider(obj: GlobalClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'databaseName': obj.databaseName,
    'deletionProtection': obj.deletionProtection,
    'engine': obj.engine,
    'engineVersion': obj.engineVersion,
    'globalClusterIdentifier': obj.globalClusterIdentifier,
    'region': obj.region,
    'sourceDbClusterIdentifier': obj.sourceDbClusterIdentifier,
    'sourceDbClusterIdentifierRef': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj.sourceDbClusterIdentifierRef),
    'sourceDbClusterIdentifierSelector': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj.sourceDbClusterIdentifierSelector),
    'storageEncrypted': obj.storageEncrypted,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalClusterSpecProviderConfigRef
 */
export interface GlobalClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRef(obj: GlobalClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GlobalClusterSpecProviderRef
 */
export interface GlobalClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecProviderRef#policy
   */
  readonly policy?: GlobalClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderRef(obj: GlobalClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsTo
 */
export interface GlobalClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsTo(obj: GlobalClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalClusterSpecWriteConnectionSecretToRef
 */
export interface GlobalClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecWriteConnectionSecretToRef(obj: GlobalClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in docdb to populate sourceDbClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRef#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRef(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in docdb to populate sourceDbClusterIdentifier.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector#policy
   */
  readonly policy?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicy
 */
export interface GlobalClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderConfigRefPolicy(obj: GlobalClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecProviderRefPolicy
 */
export interface GlobalClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecProviderRefPolicy(obj: GlobalClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRef(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToMetadata(obj: GlobalClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy
 */
export interface GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy(obj: GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolution
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecProviderConfigRefPolicyResolve
 */
export enum GlobalClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecProviderRefPolicyResolution
 */
export enum GlobalClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecProviderRefPolicyResolve
 */
export enum GlobalClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve
 */
export enum GlobalClusterSpecForProviderSourceDbClusterIdentifierSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides an DocumentDB subnet group resource.
 *
 * @schema SubnetGroup
 */
export class SubnetGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SubnetGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'docdb.aws.upbound.io/v1beta1',
    kind: 'SubnetGroup',
  }

  /**
   * Renders a Kubernetes manifest for "SubnetGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubnetGroupProps): any {
    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(props),
    };
  }

  /**
   * Defines a "SubnetGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubnetGroupProps) {
    super(scope, id, {
      ...SubnetGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SubnetGroup.GVK,
      ...toJson_SubnetGroupProps(resolved),
    };
  }
}

/**
 * SubnetGroup is the Schema for the SubnetGroups API. Provides an DocumentDB subnet group resource.
 *
 * @schema SubnetGroup
 */
export interface SubnetGroupProps {
  /**
   * @schema SubnetGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SubnetGroupSpec defines the desired state of SubnetGroup
   *
   * @schema SubnetGroup#spec
   */
  readonly spec: SubnetGroupSpec;

}

/**
 * Converts an object of type 'SubnetGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupProps(obj: SubnetGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SubnetGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubnetGroupSpec defines the desired state of SubnetGroup
 *
 * @schema SubnetGroupSpec
 */
export interface SubnetGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema SubnetGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: SubnetGroupSpecDeletionPolicy;

  /**
   * @schema SubnetGroupSpec#forProvider
   */
  readonly forProvider: SubnetGroupSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SubnetGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: SubnetGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema SubnetGroupSpec#providerRef
   */
  readonly providerRef?: SubnetGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SubnetGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SubnetGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SubnetGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SubnetGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SubnetGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpec(obj: SubnetGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SubnetGroupSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_SubnetGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_SubnetGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema SubnetGroupSpecDeletionPolicy
 */
export enum SubnetGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SubnetGroupSpecForProvider
 */
export interface SubnetGroupSpecForProvider {
  /**
   * The description of the docDB subnet group.
   *
   * @schema SubnetGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SubnetGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of VPC subnet IDs.
   *
   * @schema SubnetGroupSpecForProvider#subnetIds
   */
  readonly subnetIds?: string[];

  /**
   * References to Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdsRefs
   */
  readonly subnetIdsRefs?: SubnetGroupSpecForProviderSubnetIdsRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetIds.
   *
   * @schema SubnetGroupSpecForProvider#subnetIdsSelector
   */
  readonly subnetIdsSelector?: SubnetGroupSpecForProviderSubnetIdsSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema SubnetGroupSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SubnetGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProvider(obj: SubnetGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'subnetIds': obj.subnetIds?.map(y => y),
    'subnetIdsRefs': obj.subnetIdsRefs?.map(y => toJson_SubnetGroupSpecForProviderSubnetIdsRefs(y)),
    'subnetIdsSelector': toJson_SubnetGroupSpecForProviderSubnetIdsSelector(obj.subnetIdsSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SubnetGroupSpecProviderConfigRef
 */
export interface SubnetGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecProviderConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRef(obj: SubnetGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema SubnetGroupSpecProviderRef
 */
export interface SubnetGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecProviderRef#policy
   */
  readonly policy?: SubnetGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderRef(obj: SubnetGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsTo
 */
export interface SubnetGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SubnetGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SubnetGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsTo(obj: SubnetGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SubnetGroupSpecWriteConnectionSecretToRef
 */
export interface SubnetGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SubnetGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecWriteConnectionSecretToRef(obj: SubnetGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsRefs
 */
export interface SubnetGroupSpecForProviderSubnetIdsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsRefs#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdsRefsPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdsRefs(obj: SubnetGroupSpecForProviderSubnetIdsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetIds.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsSelector
 */
export interface SubnetGroupSpecForProviderSubnetIdsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsSelector#policy
   */
  readonly policy?: SubnetGroupSpecForProviderSubnetIdsSelectorPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdsSelector(obj: SubnetGroupSpecForProviderSubnetIdsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SubnetGroupSpecForProviderSubnetIdsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicy
 */
export interface SubnetGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderConfigRefPolicy(obj: SubnetGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecProviderRefPolicy
 */
export interface SubnetGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecProviderRefPolicy(obj: SubnetGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRef(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata
 */
export interface SubnetGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToMetadata(obj: SubnetGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsRefsPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsRefsPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsRefsPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdsRefsPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdsRefsPolicy(obj: SubnetGroupSpecForProviderSubnetIdsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsSelectorPolicy
 */
export interface SubnetGroupSpecForProviderSubnetIdsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsSelectorPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecForProviderSubnetIdsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecForProviderSubnetIdsSelectorPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecForProviderSubnetIdsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecForProviderSubnetIdsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecForProviderSubnetIdsSelectorPolicy(obj: SubnetGroupSpecForProviderSubnetIdsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolution
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecProviderConfigRefPolicyResolve
 */
export enum SubnetGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecProviderRefPolicyResolution
 */
export enum SubnetGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecProviderRefPolicyResolve
 */
export enum SubnetGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsRefsPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsRefsPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsSelectorPolicyResolution
 */
export enum SubnetGroupSpecForProviderSubnetIdsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecForProviderSubnetIdsSelectorPolicyResolve
 */
export enum SubnetGroupSpecForProviderSubnetIdsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SubnetGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

