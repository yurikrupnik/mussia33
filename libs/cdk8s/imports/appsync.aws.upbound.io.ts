// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * APICache is the Schema for the APICaches API. Provides an AppSync API Cache.
 *
 * @schema APICache
 */
export class ApiCache extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APICache"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appsync.aws.upbound.io/v1beta1',
    kind: 'APICache',
  }

  /**
   * Renders a Kubernetes manifest for "APICache".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiCacheProps): any {
    return {
      ...ApiCache.GVK,
      ...toJson_ApiCacheProps(props),
    };
  }

  /**
   * Defines a "APICache" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiCacheProps) {
    super(scope, id, {
      ...ApiCache.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiCache.GVK,
      ...toJson_ApiCacheProps(resolved),
    };
  }
}

/**
 * APICache is the Schema for the APICaches API. Provides an AppSync API Cache.
 *
 * @schema APICache
 */
export interface ApiCacheProps {
  /**
   * @schema APICache#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APICacheSpec defines the desired state of APICache
   *
   * @schema APICache#spec
   */
  readonly spec: ApiCacheSpec;

}

/**
 * Converts an object of type 'ApiCacheProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheProps(obj: ApiCacheProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiCacheSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICacheSpec defines the desired state of APICache
 *
 * @schema ApiCacheSpec
 */
export interface ApiCacheSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ApiCacheSpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiCacheSpecDeletionPolicy;

  /**
   * @schema ApiCacheSpec#forProvider
   */
  readonly forProvider: ApiCacheSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiCacheSpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiCacheSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApiCacheSpec#providerRef
   */
  readonly providerRef?: ApiCacheSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiCacheSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiCacheSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiCacheSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiCacheSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiCacheSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpec(obj: ApiCacheSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiCacheSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ApiCacheSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApiCacheSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApiCacheSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiCacheSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ApiCacheSpecDeletionPolicy
 */
export enum ApiCacheSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApiCacheSpecForProvider
 */
export interface ApiCacheSpecForProvider {
  /**
   * Caching behavior. Valid values are FULL_REQUEST_CACHING and PER_RESOLVER_CACHING.
   *
   * @schema ApiCacheSpecForProvider#apiCachingBehavior
   */
  readonly apiCachingBehavior: string;

  /**
   * GraphQL API ID.
   *
   * @schema ApiCacheSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a GraphQLAPI in appsync to populate apiId.
   *
   * @schema ApiCacheSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: ApiCacheSpecForProviderApiIdRef;

  /**
   * Selector for a GraphQLAPI in appsync to populate apiId.
   *
   * @schema ApiCacheSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: ApiCacheSpecForProviderApiIdSelector;

  /**
   * At-rest encryption flag for cache. You cannot update this setting after creation.
   *
   * @schema ApiCacheSpecForProvider#atRestEncryptionEnabled
   */
  readonly atRestEncryptionEnabled?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApiCacheSpecForProvider#region
   */
  readonly region: string;

  /**
   * Transit encryption flag when connecting to cache. You cannot update this setting after creation.
   *
   * @schema ApiCacheSpecForProvider#transitEncryptionEnabled
   */
  readonly transitEncryptionEnabled?: boolean;

  /**
   * TTL in seconds for cache entries.
   *
   * @schema ApiCacheSpecForProvider#ttl
   */
  readonly ttl: number;

  /**
   * Cache instance type. Valid values are SMALL, MEDIUM, LARGE, XLARGE, LARGE_2X, LARGE_4X, LARGE_8X, LARGE_12X, T2_SMALL, T2_MEDIUM, R4_LARGE, R4_XLARGE, R4_2XLARGE, R4_4XLARGE, R4_8XLARGE.
   *
   * @schema ApiCacheSpecForProvider#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ApiCacheSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecForProvider(obj: ApiCacheSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCachingBehavior': obj.apiCachingBehavior,
    'apiId': obj.apiId,
    'apiIdRef': toJson_ApiCacheSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_ApiCacheSpecForProviderApiIdSelector(obj.apiIdSelector),
    'atRestEncryptionEnabled': obj.atRestEncryptionEnabled,
    'region': obj.region,
    'transitEncryptionEnabled': obj.transitEncryptionEnabled,
    'ttl': obj.ttl,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiCacheSpecProviderConfigRef
 */
export interface ApiCacheSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiCacheSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiCacheSpecProviderConfigRef#policy
   */
  readonly policy?: ApiCacheSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiCacheSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecProviderConfigRef(obj: ApiCacheSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiCacheSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApiCacheSpecProviderRef
 */
export interface ApiCacheSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiCacheSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiCacheSpecProviderRef#policy
   */
  readonly policy?: ApiCacheSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApiCacheSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecProviderRef(obj: ApiCacheSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiCacheSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiCacheSpecPublishConnectionDetailsTo
 */
export interface ApiCacheSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiCacheSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiCacheSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiCacheSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecPublishConnectionDetailsTo(obj: ApiCacheSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiCacheSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiCacheSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiCacheSpecWriteConnectionSecretToRef
 */
export interface ApiCacheSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiCacheSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiCacheSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiCacheSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecWriteConnectionSecretToRef(obj: ApiCacheSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GraphQLAPI in appsync to populate apiId.
 *
 * @schema ApiCacheSpecForProviderApiIdRef
 */
export interface ApiCacheSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiCacheSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiCacheSpecForProviderApiIdRef#policy
   */
  readonly policy?: ApiCacheSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'ApiCacheSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecForProviderApiIdRef(obj: ApiCacheSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiCacheSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GraphQLAPI in appsync to populate apiId.
 *
 * @schema ApiCacheSpecForProviderApiIdSelector
 */
export interface ApiCacheSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiCacheSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiCacheSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiCacheSpecForProviderApiIdSelector#policy
   */
  readonly policy?: ApiCacheSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ApiCacheSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecForProviderApiIdSelector(obj: ApiCacheSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiCacheSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiCacheSpecProviderConfigRefPolicy
 */
export interface ApiCacheSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiCacheSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiCacheSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiCacheSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiCacheSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiCacheSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecProviderConfigRefPolicy(obj: ApiCacheSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiCacheSpecProviderRefPolicy
 */
export interface ApiCacheSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiCacheSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApiCacheSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiCacheSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApiCacheSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiCacheSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecProviderRefPolicy(obj: ApiCacheSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiCacheSpecPublishConnectionDetailsToConfigRef
 */
export interface ApiCacheSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiCacheSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecPublishConnectionDetailsToConfigRef(obj: ApiCacheSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiCacheSpecPublishConnectionDetailsToMetadata
 */
export interface ApiCacheSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiCacheSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecPublishConnectionDetailsToMetadata(obj: ApiCacheSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiCacheSpecForProviderApiIdRefPolicy
 */
export interface ApiCacheSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiCacheSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: ApiCacheSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiCacheSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: ApiCacheSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiCacheSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecForProviderApiIdRefPolicy(obj: ApiCacheSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiCacheSpecForProviderApiIdSelectorPolicy
 */
export interface ApiCacheSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiCacheSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ApiCacheSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiCacheSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ApiCacheSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiCacheSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecForProviderApiIdSelectorPolicy(obj: ApiCacheSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiCacheSpecProviderConfigRefPolicyResolution
 */
export enum ApiCacheSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiCacheSpecProviderConfigRefPolicyResolve
 */
export enum ApiCacheSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiCacheSpecProviderRefPolicyResolution
 */
export enum ApiCacheSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiCacheSpecProviderRefPolicyResolve
 */
export enum ApiCacheSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiCacheSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiCacheSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiCacheSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiCacheSpecForProviderApiIdRefPolicyResolution
 */
export enum ApiCacheSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiCacheSpecForProviderApiIdRefPolicyResolve
 */
export enum ApiCacheSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiCacheSpecForProviderApiIdSelectorPolicyResolution
 */
export enum ApiCacheSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiCacheSpecForProviderApiIdSelectorPolicyResolve
 */
export enum ApiCacheSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiCacheSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiCacheSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiCacheSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiCacheSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * APIKey is the Schema for the APIKeys API. Provides an AppSync API Key.
 *
 * @schema APIKey
 */
export class ApiKey extends ApiObject {
  /**
   * Returns the apiVersion and kind for "APIKey"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appsync.aws.upbound.io/v1beta1',
    kind: 'APIKey',
  }

  /**
   * Renders a Kubernetes manifest for "APIKey".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ApiKeyProps): any {
    return {
      ...ApiKey.GVK,
      ...toJson_ApiKeyProps(props),
    };
  }

  /**
   * Defines a "APIKey" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ApiKeyProps) {
    super(scope, id, {
      ...ApiKey.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ApiKey.GVK,
      ...toJson_ApiKeyProps(resolved),
    };
  }
}

/**
 * APIKey is the Schema for the APIKeys API. Provides an AppSync API Key.
 *
 * @schema APIKey
 */
export interface ApiKeyProps {
  /**
   * @schema APIKey#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * APIKeySpec defines the desired state of APIKey
   *
   * @schema APIKey#spec
   */
  readonly spec: ApiKeySpec;

}

/**
 * Converts an object of type 'ApiKeyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeyProps(obj: ApiKeyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ApiKeySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APIKeySpec defines the desired state of APIKey
 *
 * @schema ApiKeySpec
 */
export interface ApiKeySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ApiKeySpec#deletionPolicy
   */
  readonly deletionPolicy?: ApiKeySpecDeletionPolicy;

  /**
   * @schema ApiKeySpec#forProvider
   */
  readonly forProvider: ApiKeySpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ApiKeySpec#providerConfigRef
   */
  readonly providerConfigRef?: ApiKeySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ApiKeySpec#providerRef
   */
  readonly providerRef?: ApiKeySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ApiKeySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ApiKeySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ApiKeySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ApiKeySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ApiKeySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpec(obj: ApiKeySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ApiKeySpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ApiKeySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ApiKeySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ApiKeySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ApiKeySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ApiKeySpecDeletionPolicy
 */
export enum ApiKeySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ApiKeySpecForProvider
 */
export interface ApiKeySpecForProvider {
  /**
   * ID of the associated AppSync API
   *
   * @schema ApiKeySpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a GraphQLAPI in appsync to populate apiId.
   *
   * @schema ApiKeySpecForProvider#apiIdRef
   */
  readonly apiIdRef?: ApiKeySpecForProviderApiIdRef;

  /**
   * Selector for a GraphQLAPI in appsync to populate apiId.
   *
   * @schema ApiKeySpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: ApiKeySpecForProviderApiIdSelector;

  /**
   * API key description.
   *
   * @schema ApiKeySpecForProvider#description
   */
  readonly description?: string;

  /**
   * RFC3339 string representation of the expiry date. Rounded down to nearest hour. By default, it is 7 days from the date of creation.
   *
   * @schema ApiKeySpecForProvider#expires
   */
  readonly expires?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ApiKeySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ApiKeySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProvider(obj: ApiKeySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_ApiKeySpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_ApiKeySpecForProviderApiIdSelector(obj.apiIdSelector),
    'description': obj.description,
    'expires': obj.expires,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ApiKeySpecProviderConfigRef
 */
export interface ApiKeySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecProviderConfigRef#policy
   */
  readonly policy?: ApiKeySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderConfigRef(obj: ApiKeySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ApiKeySpecProviderRef
 */
export interface ApiKeySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecProviderRef#policy
   */
  readonly policy?: ApiKeySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderRef(obj: ApiKeySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ApiKeySpecPublishConnectionDetailsTo
 */
export interface ApiKeySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ApiKeySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ApiKeySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ApiKeySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsTo(obj: ApiKeySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ApiKeySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ApiKeySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ApiKeySpecWriteConnectionSecretToRef
 */
export interface ApiKeySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ApiKeySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ApiKeySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ApiKeySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecWriteConnectionSecretToRef(obj: ApiKeySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GraphQLAPI in appsync to populate apiId.
 *
 * @schema ApiKeySpecForProviderApiIdRef
 */
export interface ApiKeySpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecForProviderApiIdRef#policy
   */
  readonly policy?: ApiKeySpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProviderApiIdRef(obj: ApiKeySpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GraphQLAPI in appsync to populate apiId.
 *
 * @schema ApiKeySpecForProviderApiIdSelector
 */
export interface ApiKeySpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ApiKeySpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ApiKeySpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ApiKeySpecForProviderApiIdSelector#policy
   */
  readonly policy?: ApiKeySpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProviderApiIdSelector(obj: ApiKeySpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ApiKeySpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecProviderConfigRefPolicy
 */
export interface ApiKeySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderConfigRefPolicy(obj: ApiKeySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecProviderRefPolicy
 */
export interface ApiKeySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecProviderRefPolicy(obj: ApiKeySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRef
 */
export interface ApiKeySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToConfigRef(obj: ApiKeySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToMetadata
 */
export interface ApiKeySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToMetadata(obj: ApiKeySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecForProviderApiIdRefPolicy
 */
export interface ApiKeySpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProviderApiIdRefPolicy(obj: ApiKeySpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ApiKeySpecForProviderApiIdSelectorPolicy
 */
export interface ApiKeySpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ApiKeySpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ApiKeySpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecForProviderApiIdSelectorPolicy(obj: ApiKeySpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecProviderConfigRefPolicyResolution
 */
export enum ApiKeySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecProviderConfigRefPolicyResolve
 */
export enum ApiKeySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecProviderRefPolicyResolution
 */
export enum ApiKeySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecProviderRefPolicyResolve
 */
export enum ApiKeySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ApiKeySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ApiKeySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ApiKeySpecPublishConnectionDetailsToConfigRefPolicy(obj: ApiKeySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecForProviderApiIdRefPolicyResolution
 */
export enum ApiKeySpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecForProviderApiIdRefPolicyResolve
 */
export enum ApiKeySpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecForProviderApiIdSelectorPolicyResolution
 */
export enum ApiKeySpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecForProviderApiIdSelectorPolicyResolve
 */
export enum ApiKeySpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ApiKeySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Datasource is the Schema for the Datasources API. Provides an AppSync Data Source.
 *
 * @schema Datasource
 */
export class Datasource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Datasource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appsync.aws.upbound.io/v1beta1',
    kind: 'Datasource',
  }

  /**
   * Renders a Kubernetes manifest for "Datasource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasourceProps): any {
    return {
      ...Datasource.GVK,
      ...toJson_DatasourceProps(props),
    };
  }

  /**
   * Defines a "Datasource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasourceProps) {
    super(scope, id, {
      ...Datasource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Datasource.GVK,
      ...toJson_DatasourceProps(resolved),
    };
  }
}

/**
 * Datasource is the Schema for the Datasources API. Provides an AppSync Data Source.
 *
 * @schema Datasource
 */
export interface DatasourceProps {
  /**
   * @schema Datasource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasourceSpec defines the desired state of Datasource
   *
   * @schema Datasource#spec
   */
  readonly spec: DatasourceSpec;

}

/**
 * Converts an object of type 'DatasourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceProps(obj: DatasourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasourceSpec defines the desired state of Datasource
 *
 * @schema DatasourceSpec
 */
export interface DatasourceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasourceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasourceSpecDeletionPolicy;

  /**
   * @schema DatasourceSpec#forProvider
   */
  readonly forProvider: DatasourceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasourceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasourceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasourceSpec#providerRef
   */
  readonly providerRef?: DatasourceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasourceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasourceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasourceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasourceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpec(obj: DatasourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasourceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasourceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasourceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasourceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasourceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasourceSpecDeletionPolicy
 */
export enum DatasourceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasourceSpecForProvider
 */
export interface DatasourceSpecForProvider {
  /**
   * API ID for the GraphQL API for the data source.
   *
   * @schema DatasourceSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a GraphQLAPI in appsync to populate apiId.
   *
   * @schema DatasourceSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: DatasourceSpecForProviderApiIdRef;

  /**
   * Selector for a GraphQLAPI in appsync to populate apiId.
   *
   * @schema DatasourceSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: DatasourceSpecForProviderApiIdSelector;

  /**
   * Description of the data source.
   *
   * @schema DatasourceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * DynamoDB settings. See below
   *
   * @schema DatasourceSpecForProvider#dynamodbConfig
   */
  readonly dynamodbConfig?: DatasourceSpecForProviderDynamodbConfig[];

  /**
   * Amazon Elasticsearch settings. See below
   *
   * @schema DatasourceSpecForProvider#elasticsearchConfig
   */
  readonly elasticsearchConfig?: DatasourceSpecForProviderElasticsearchConfig[];

  /**
   * HTTP settings. See below
   *
   * @schema DatasourceSpecForProvider#httpConfig
   */
  readonly httpConfig?: DatasourceSpecForProviderHttpConfig[];

  /**
   * AWS Lambda settings. See below
   *
   * @schema DatasourceSpecForProvider#lambdaConfig
   */
  readonly lambdaConfig?: DatasourceSpecForProviderLambdaConfig[];

  /**
   * AWS Region for RDS HTTP endpoint. Defaults to current region. Region is the region you'd like your resource to be created in.
   *
   * @default current region. Region is the region you'd like your resource to be created in.
   * @schema DatasourceSpecForProvider#region
   */
  readonly region: string;

  /**
   * AWS RDS settings. See Relational Database Config
   *
   * @schema DatasourceSpecForProvider#relationalDatabaseConfig
   */
  readonly relationalDatabaseConfig?: DatasourceSpecForProviderRelationalDatabaseConfig[];

  /**
   * IAM service role ARN for the data source.
   *
   * @schema DatasourceSpecForProvider#serviceRoleArn
   */
  readonly serviceRoleArn?: string;

  /**
   * Reference to a Role in iam to populate serviceRoleArn.
   *
   * @schema DatasourceSpecForProvider#serviceRoleArnRef
   */
  readonly serviceRoleArnRef?: DatasourceSpecForProviderServiceRoleArnRef;

  /**
   * Selector for a Role in iam to populate serviceRoleArn.
   *
   * @schema DatasourceSpecForProvider#serviceRoleArnSelector
   */
  readonly serviceRoleArnSelector?: DatasourceSpecForProviderServiceRoleArnSelector;

  /**
   * Type of the Data Source. Valid values: AWS_LAMBDA, AMAZON_DYNAMODB, AMAZON_ELASTICSEARCH, HTTP, NONE, RELATIONAL_DATABASE.
   *
   * @schema DatasourceSpecForProvider#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'DatasourceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProvider(obj: DatasourceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_DatasourceSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_DatasourceSpecForProviderApiIdSelector(obj.apiIdSelector),
    'description': obj.description,
    'dynamodbConfig': obj.dynamodbConfig?.map(y => toJson_DatasourceSpecForProviderDynamodbConfig(y)),
    'elasticsearchConfig': obj.elasticsearchConfig?.map(y => toJson_DatasourceSpecForProviderElasticsearchConfig(y)),
    'httpConfig': obj.httpConfig?.map(y => toJson_DatasourceSpecForProviderHttpConfig(y)),
    'lambdaConfig': obj.lambdaConfig?.map(y => toJson_DatasourceSpecForProviderLambdaConfig(y)),
    'region': obj.region,
    'relationalDatabaseConfig': obj.relationalDatabaseConfig?.map(y => toJson_DatasourceSpecForProviderRelationalDatabaseConfig(y)),
    'serviceRoleArn': obj.serviceRoleArn,
    'serviceRoleArnRef': toJson_DatasourceSpecForProviderServiceRoleArnRef(obj.serviceRoleArnRef),
    'serviceRoleArnSelector': toJson_DatasourceSpecForProviderServiceRoleArnSelector(obj.serviceRoleArnSelector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasourceSpecProviderConfigRef
 */
export interface DatasourceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasourceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasourceSpecProviderConfigRef#policy
   */
  readonly policy?: DatasourceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecProviderConfigRef(obj: DatasourceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasourceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasourceSpecProviderRef
 */
export interface DatasourceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasourceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasourceSpecProviderRef#policy
   */
  readonly policy?: DatasourceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecProviderRef(obj: DatasourceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasourceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasourceSpecPublishConnectionDetailsTo
 */
export interface DatasourceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasourceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasourceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasourceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasourceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasourceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasourceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecPublishConnectionDetailsTo(obj: DatasourceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasourceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasourceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasourceSpecWriteConnectionSecretToRef
 */
export interface DatasourceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasourceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasourceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasourceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecWriteConnectionSecretToRef(obj: DatasourceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GraphQLAPI in appsync to populate apiId.
 *
 * @schema DatasourceSpecForProviderApiIdRef
 */
export interface DatasourceSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasourceSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasourceSpecForProviderApiIdRef#policy
   */
  readonly policy?: DatasourceSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderApiIdRef(obj: DatasourceSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasourceSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GraphQLAPI in appsync to populate apiId.
 *
 * @schema DatasourceSpecForProviderApiIdSelector
 */
export interface DatasourceSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasourceSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasourceSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasourceSpecForProviderApiIdSelector#policy
   */
  readonly policy?: DatasourceSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderApiIdSelector(obj: DatasourceSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasourceSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderDynamodbConfig
 */
export interface DatasourceSpecForProviderDynamodbConfig {
  /**
   * @schema DatasourceSpecForProviderDynamodbConfig#deltaSyncConfig
   */
  readonly deltaSyncConfig?: DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig[];

  /**
   * AWS region of the DynamoDB table. Defaults to current region.
   *
   * @default current region.
   * @schema DatasourceSpecForProviderDynamodbConfig#region
   */
  readonly region?: string;

  /**
   * Name of the DynamoDB table.
   *
   * @schema DatasourceSpecForProviderDynamodbConfig#tableName
   */
  readonly tableName?: string;

  /**
   * Reference to a Table in dynamodb to populate tableName.
   *
   * @schema DatasourceSpecForProviderDynamodbConfig#tableNameRef
   */
  readonly tableNameRef?: DatasourceSpecForProviderDynamodbConfigTableNameRef;

  /**
   * Selector for a Table in dynamodb to populate tableName.
   *
   * @schema DatasourceSpecForProviderDynamodbConfig#tableNameSelector
   */
  readonly tableNameSelector?: DatasourceSpecForProviderDynamodbConfigTableNameSelector;

  /**
   * Set to true to use Amazon Cognito credentials with this data source.
   *
   * @schema DatasourceSpecForProviderDynamodbConfig#useCallerCredentials
   */
  readonly useCallerCredentials?: boolean;

  /**
   * @schema DatasourceSpecForProviderDynamodbConfig#versioned
   */
  readonly versioned?: boolean;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderDynamodbConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderDynamodbConfig(obj: DatasourceSpecForProviderDynamodbConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deltaSyncConfig': obj.deltaSyncConfig?.map(y => toJson_DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig(y)),
    'region': obj.region,
    'tableName': obj.tableName,
    'tableNameRef': toJson_DatasourceSpecForProviderDynamodbConfigTableNameRef(obj.tableNameRef),
    'tableNameSelector': toJson_DatasourceSpecForProviderDynamodbConfigTableNameSelector(obj.tableNameSelector),
    'useCallerCredentials': obj.useCallerCredentials,
    'versioned': obj.versioned,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderElasticsearchConfig
 */
export interface DatasourceSpecForProviderElasticsearchConfig {
  /**
   * HTTP endpoint of the Elasticsearch domain.
   *
   * @schema DatasourceSpecForProviderElasticsearchConfig#endpoint
   */
  readonly endpoint: string;

  /**
   * AWS region of Elasticsearch domain. Defaults to current region.
   *
   * @default current region.
   * @schema DatasourceSpecForProviderElasticsearchConfig#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderElasticsearchConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderElasticsearchConfig(obj: DatasourceSpecForProviderElasticsearchConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpoint': obj.endpoint,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderHttpConfig
 */
export interface DatasourceSpecForProviderHttpConfig {
  /**
   * Authorization configuration in case the HTTP endpoint requires authorization. See Authorization Config.
   *
   * @schema DatasourceSpecForProviderHttpConfig#authorizationConfig
   */
  readonly authorizationConfig?: DatasourceSpecForProviderHttpConfigAuthorizationConfig[];

  /**
   * HTTP URL.
   *
   * @schema DatasourceSpecForProviderHttpConfig#endpoint
   */
  readonly endpoint: string;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderHttpConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderHttpConfig(obj: DatasourceSpecForProviderHttpConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationConfig': obj.authorizationConfig?.map(y => toJson_DatasourceSpecForProviderHttpConfigAuthorizationConfig(y)),
    'endpoint': obj.endpoint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderLambdaConfig
 */
export interface DatasourceSpecForProviderLambdaConfig {
  /**
   * ARN for the Lambda function.
   *
   * @schema DatasourceSpecForProviderLambdaConfig#functionArn
   */
  readonly functionArn: string;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderLambdaConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderLambdaConfig(obj: DatasourceSpecForProviderLambdaConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderRelationalDatabaseConfig
 */
export interface DatasourceSpecForProviderRelationalDatabaseConfig {
  /**
   * Amazon RDS HTTP endpoint configuration. See HTTP Endpoint Config.
   *
   * @schema DatasourceSpecForProviderRelationalDatabaseConfig#httpEndpointConfig
   */
  readonly httpEndpointConfig?: DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig[];

  /**
   * Source type for the relational database. Valid values: RDS_HTTP_ENDPOINT.
   *
   * @schema DatasourceSpecForProviderRelationalDatabaseConfig#sourceType
   */
  readonly sourceType?: string;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderRelationalDatabaseConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderRelationalDatabaseConfig(obj: DatasourceSpecForProviderRelationalDatabaseConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpEndpointConfig': obj.httpEndpointConfig?.map(y => toJson_DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig(y)),
    'sourceType': obj.sourceType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate serviceRoleArn.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnRef
 */
export interface DatasourceSpecForProviderServiceRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnRef#policy
   */
  readonly policy?: DatasourceSpecForProviderServiceRoleArnRefPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderServiceRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderServiceRoleArnRef(obj: DatasourceSpecForProviderServiceRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasourceSpecForProviderServiceRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate serviceRoleArn.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnSelector
 */
export interface DatasourceSpecForProviderServiceRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnSelector#policy
   */
  readonly policy?: DatasourceSpecForProviderServiceRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderServiceRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderServiceRoleArnSelector(obj: DatasourceSpecForProviderServiceRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasourceSpecForProviderServiceRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasourceSpecProviderConfigRefPolicy
 */
export interface DatasourceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasourceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasourceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecProviderConfigRefPolicy(obj: DatasourceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasourceSpecProviderRefPolicy
 */
export interface DatasourceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasourceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasourceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecProviderRefPolicy(obj: DatasourceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasourceSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasourceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasourceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasourceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasourceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecPublishConnectionDetailsToConfigRef(obj: DatasourceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasourceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasourceSpecPublishConnectionDetailsToMetadata
 */
export interface DatasourceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasourceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasourceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasourceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasourceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecPublishConnectionDetailsToMetadata(obj: DatasourceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasourceSpecForProviderApiIdRefPolicy
 */
export interface DatasourceSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: DatasourceSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: DatasourceSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderApiIdRefPolicy(obj: DatasourceSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasourceSpecForProviderApiIdSelectorPolicy
 */
export interface DatasourceSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasourceSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasourceSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderApiIdSelectorPolicy(obj: DatasourceSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig
 */
export interface DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig {
  /**
   * @schema DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig#baseTableTtl
   */
  readonly baseTableTtl?: number;

  /**
   * User-supplied name for the data source.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig#deltaSyncTableName
   */
  readonly deltaSyncTableName: string;

  /**
   * @schema DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig#deltaSyncTableTtl
   */
  readonly deltaSyncTableTtl?: number;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig(obj: DatasourceSpecForProviderDynamodbConfigDeltaSyncConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseTableTtl': obj.baseTableTtl,
    'deltaSyncTableName': obj.deltaSyncTableName,
    'deltaSyncTableTtl': obj.deltaSyncTableTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Table in dynamodb to populate tableName.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameRef
 */
export interface DatasourceSpecForProviderDynamodbConfigTableNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameRef#policy
   */
  readonly policy?: DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderDynamodbConfigTableNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderDynamodbConfigTableNameRef(obj: DatasourceSpecForProviderDynamodbConfigTableNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Table in dynamodb to populate tableName.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelector
 */
export interface DatasourceSpecForProviderDynamodbConfigTableNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelector#policy
   */
  readonly policy?: DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderDynamodbConfigTableNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderDynamodbConfigTableNameSelector(obj: DatasourceSpecForProviderDynamodbConfigTableNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderHttpConfigAuthorizationConfig
 */
export interface DatasourceSpecForProviderHttpConfigAuthorizationConfig {
  /**
   * Authorization type that the HTTP endpoint requires. Default values is AWS_IAM.
   *
   * @schema DatasourceSpecForProviderHttpConfigAuthorizationConfig#authorizationType
   */
  readonly authorizationType?: string;

  /**
   * Identity and Access Management (IAM) settings. See AWS IAM Config.
   *
   * @schema DatasourceSpecForProviderHttpConfigAuthorizationConfig#awsIamConfig
   */
  readonly awsIamConfig?: DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig[];

}

/**
 * Converts an object of type 'DatasourceSpecForProviderHttpConfigAuthorizationConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderHttpConfigAuthorizationConfig(obj: DatasourceSpecForProviderHttpConfigAuthorizationConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizationType': obj.authorizationType,
    'awsIamConfig': obj.awsIamConfig?.map(y => toJson_DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig
 */
export interface DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig {
  /**
   * AWS secret store ARN for database credentials.
   *
   * @schema DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig#awsSecretStoreArn
   */
  readonly awsSecretStoreArn: string;

  /**
   * Logical database name.
   *
   * @schema DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig#databaseName
   */
  readonly databaseName?: string;

  /**
   * Amazon RDS cluster identifier.
   *
   * @schema DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig#dbClusterIdentifier
   */
  readonly dbClusterIdentifier: string;

  /**
   * AWS Region for RDS HTTP endpoint. Defaults to current region.
   *
   * @default current region.
   * @schema DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig#region
   */
  readonly region?: string;

  /**
   * Logical schema name.
   *
   * @schema DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig#schema
   */
  readonly schema?: string;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig(obj: DatasourceSpecForProviderRelationalDatabaseConfigHttpEndpointConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsSecretStoreArn': obj.awsSecretStoreArn,
    'databaseName': obj.databaseName,
    'dbClusterIdentifier': obj.dbClusterIdentifier,
    'region': obj.region,
    'schema': obj.schema,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnRefPolicy
 */
export interface DatasourceSpecForProviderServiceRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnRefPolicy#resolution
   */
  readonly resolution?: DatasourceSpecForProviderServiceRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnRefPolicy#resolve
   */
  readonly resolve?: DatasourceSpecForProviderServiceRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderServiceRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderServiceRoleArnRefPolicy(obj: DatasourceSpecForProviderServiceRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnSelectorPolicy
 */
export interface DatasourceSpecForProviderServiceRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: DatasourceSpecForProviderServiceRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecForProviderServiceRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: DatasourceSpecForProviderServiceRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderServiceRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderServiceRoleArnSelectorPolicy(obj: DatasourceSpecForProviderServiceRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecProviderConfigRefPolicyResolution
 */
export enum DatasourceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecProviderConfigRefPolicyResolve
 */
export enum DatasourceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecProviderRefPolicyResolution
 */
export enum DatasourceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecProviderRefPolicyResolve
 */
export enum DatasourceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasourceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasourceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasourceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasourceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasourceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecForProviderApiIdRefPolicyResolution
 */
export enum DatasourceSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecForProviderApiIdRefPolicyResolve
 */
export enum DatasourceSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecForProviderApiIdSelectorPolicyResolution
 */
export enum DatasourceSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecForProviderApiIdSelectorPolicyResolve
 */
export enum DatasourceSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy
 */
export interface DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy#resolution
   */
  readonly resolution?: DatasourceSpecForProviderDynamodbConfigTableNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy#resolve
   */
  readonly resolve?: DatasourceSpecForProviderDynamodbConfigTableNameRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy(obj: DatasourceSpecForProviderDynamodbConfigTableNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy
 */
export interface DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy#resolution
   */
  readonly resolution?: DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy#resolve
   */
  readonly resolve?: DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy(obj: DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig
 */
export interface DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig {
  /**
   * Signing Amazon Web Services Region for IAM authorization.
   *
   * @schema DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig#signingRegion
   */
  readonly signingRegion?: string;

  /**
   * Signing service name for IAM authorization.
   *
   * @schema DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig#signingServiceName
   */
  readonly signingServiceName?: string;

}

/**
 * Converts an object of type 'DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig(obj: DatasourceSpecForProviderHttpConfigAuthorizationConfigAwsIamConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'signingRegion': obj.signingRegion,
    'signingServiceName': obj.signingServiceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnRefPolicyResolution
 */
export enum DatasourceSpecForProviderServiceRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnRefPolicyResolve
 */
export enum DatasourceSpecForProviderServiceRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnSelectorPolicyResolution
 */
export enum DatasourceSpecForProviderServiceRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecForProviderServiceRoleArnSelectorPolicyResolve
 */
export enum DatasourceSpecForProviderServiceRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasourceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasourceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameRefPolicyResolution
 */
export enum DatasourceSpecForProviderDynamodbConfigTableNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameRefPolicyResolve
 */
export enum DatasourceSpecForProviderDynamodbConfigTableNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicyResolution
 */
export enum DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicyResolve
 */
export enum DatasourceSpecForProviderDynamodbConfigTableNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Function is the Schema for the Functions API. Provides an AppSync Function.
 *
 * @schema Function
 */
export class Function extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Function"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appsync.aws.upbound.io/v1beta1',
    kind: 'Function',
  }

  /**
   * Renders a Kubernetes manifest for "Function".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FunctionProps): any {
    return {
      ...Function.GVK,
      ...toJson_FunctionProps(props),
    };
  }

  /**
   * Defines a "Function" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FunctionProps) {
    super(scope, id, {
      ...Function.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Function.GVK,
      ...toJson_FunctionProps(resolved),
    };
  }
}

/**
 * Function is the Schema for the Functions API. Provides an AppSync Function.
 *
 * @schema Function
 */
export interface FunctionProps {
  /**
   * @schema Function#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FunctionSpec defines the desired state of Function
   *
   * @schema Function#spec
   */
  readonly spec: FunctionSpec;

}

/**
 * Converts an object of type 'FunctionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionProps(obj: FunctionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FunctionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FunctionSpec defines the desired state of Function
 *
 * @schema FunctionSpec
 */
export interface FunctionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema FunctionSpec#deletionPolicy
   */
  readonly deletionPolicy?: FunctionSpecDeletionPolicy;

  /**
   * @schema FunctionSpec#forProvider
   */
  readonly forProvider: FunctionSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema FunctionSpec#providerConfigRef
   */
  readonly providerConfigRef?: FunctionSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema FunctionSpec#providerRef
   */
  readonly providerRef?: FunctionSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema FunctionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: FunctionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema FunctionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: FunctionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'FunctionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpec(obj: FunctionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_FunctionSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_FunctionSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_FunctionSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_FunctionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_FunctionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema FunctionSpecDeletionPolicy
 */
export enum FunctionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema FunctionSpecForProvider
 */
export interface FunctionSpecForProvider {
  /**
   * ID of the associated AppSync API.
   *
   * @schema FunctionSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a GraphQLAPI in appsync to populate apiId.
   *
   * @schema FunctionSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: FunctionSpecForProviderApiIdRef;

  /**
   * Selector for a GraphQLAPI in appsync to populate apiId.
   *
   * @schema FunctionSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: FunctionSpecForProviderApiIdSelector;

  /**
   * The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
   *
   * @schema FunctionSpecForProvider#code
   */
  readonly code?: string;

  /**
   * Function data source name.
   *
   * @schema FunctionSpecForProvider#dataSource
   */
  readonly dataSource?: string;

  /**
   * Reference to a Datasource in appsync to populate dataSource.
   *
   * @schema FunctionSpecForProvider#dataSourceRef
   */
  readonly dataSourceRef?: FunctionSpecForProviderDataSourceRef;

  /**
   * Selector for a Datasource in appsync to populate dataSource.
   *
   * @schema FunctionSpecForProvider#dataSourceSelector
   */
  readonly dataSourceSelector?: FunctionSpecForProviderDataSourceSelector;

  /**
   * Function description.
   *
   * @schema FunctionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Version of the request mapping template. Currently the supported value is 2018-05-29. Does not apply when specifying code.
   *
   * @schema FunctionSpecForProvider#functionVersion
   */
  readonly functionVersion?: string;

  /**
   * Maximum batching size for a resolver. Valid values are between 0 and 2000.
   *
   * @schema FunctionSpecForProvider#maxBatchSize
   */
  readonly maxBatchSize?: number;

  /**
   * Function name. The function name does not have to be unique.
   *
   * @schema FunctionSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema FunctionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Function request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
   *
   * @schema FunctionSpecForProvider#requestMappingTemplate
   */
  readonly requestMappingTemplate?: string;

  /**
   * Function response mapping template.
   *
   * @schema FunctionSpecForProvider#responseMappingTemplate
   */
  readonly responseMappingTemplate?: string;

  /**
   * Describes a runtime used by an AWS AppSync pipeline resolver or AWS AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified. See Runtime.
   *
   * @schema FunctionSpecForProvider#runtime
   */
  readonly runtime?: FunctionSpecForProviderRuntime[];

  /**
   * Describes a Sync configuration for a resolver. See Sync Config.
   *
   * @schema FunctionSpecForProvider#syncConfig
   */
  readonly syncConfig?: FunctionSpecForProviderSyncConfig[];

}

/**
 * Converts an object of type 'FunctionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProvider(obj: FunctionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_FunctionSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_FunctionSpecForProviderApiIdSelector(obj.apiIdSelector),
    'code': obj.code,
    'dataSource': obj.dataSource,
    'dataSourceRef': toJson_FunctionSpecForProviderDataSourceRef(obj.dataSourceRef),
    'dataSourceSelector': toJson_FunctionSpecForProviderDataSourceSelector(obj.dataSourceSelector),
    'description': obj.description,
    'functionVersion': obj.functionVersion,
    'maxBatchSize': obj.maxBatchSize,
    'name': obj.name,
    'region': obj.region,
    'requestMappingTemplate': obj.requestMappingTemplate,
    'responseMappingTemplate': obj.responseMappingTemplate,
    'runtime': obj.runtime?.map(y => toJson_FunctionSpecForProviderRuntime(y)),
    'syncConfig': obj.syncConfig?.map(y => toJson_FunctionSpecForProviderSyncConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema FunctionSpecProviderConfigRef
 */
export interface FunctionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderConfigRef#policy
   */
  readonly policy?: FunctionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRef(obj: FunctionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema FunctionSpecProviderRef
 */
export interface FunctionSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecProviderRef#policy
   */
  readonly policy?: FunctionSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderRef(obj: FunctionSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema FunctionSpecPublishConnectionDetailsTo
 */
export interface FunctionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: FunctionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: FunctionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema FunctionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsTo(obj: FunctionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema FunctionSpecWriteConnectionSecretToRef
 */
export interface FunctionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema FunctionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'FunctionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecWriteConnectionSecretToRef(obj: FunctionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GraphQLAPI in appsync to populate apiId.
 *
 * @schema FunctionSpecForProviderApiIdRef
 */
export interface FunctionSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderApiIdRef#policy
   */
  readonly policy?: FunctionSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderApiIdRef(obj: FunctionSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GraphQLAPI in appsync to populate apiId.
 *
 * @schema FunctionSpecForProviderApiIdSelector
 */
export interface FunctionSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderApiIdSelector#policy
   */
  readonly policy?: FunctionSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderApiIdSelector(obj: FunctionSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Datasource in appsync to populate dataSource.
 *
 * @schema FunctionSpecForProviderDataSourceRef
 */
export interface FunctionSpecForProviderDataSourceRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecForProviderDataSourceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecForProviderDataSourceRef#policy
   */
  readonly policy?: FunctionSpecForProviderDataSourceRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderDataSourceRef(obj: FunctionSpecForProviderDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecForProviderDataSourceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Datasource in appsync to populate dataSource.
 *
 * @schema FunctionSpecForProviderDataSourceSelector
 */
export interface FunctionSpecForProviderDataSourceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema FunctionSpecForProviderDataSourceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema FunctionSpecForProviderDataSourceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema FunctionSpecForProviderDataSourceSelector#policy
   */
  readonly policy?: FunctionSpecForProviderDataSourceSelectorPolicy;

}

/**
 * Converts an object of type 'FunctionSpecForProviderDataSourceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderDataSourceSelector(obj: FunctionSpecForProviderDataSourceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_FunctionSpecForProviderDataSourceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderRuntime
 */
export interface FunctionSpecForProviderRuntime {
  /**
   * Function name. The function name does not have to be unique.
   *
   * @schema FunctionSpecForProviderRuntime#name
   */
  readonly name: string;

  /**
   * The version of the runtime to use. Currently, the only allowed version is 1.0.0.
   *
   * @schema FunctionSpecForProviderRuntime#runtimeVersion
   */
  readonly runtimeVersion: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderRuntime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderRuntime(obj: FunctionSpecForProviderRuntime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'runtimeVersion': obj.runtimeVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderSyncConfig
 */
export interface FunctionSpecForProviderSyncConfig {
  /**
   * Conflict Detection strategy to use. Valid values are NONE and VERSION.
   *
   * @schema FunctionSpecForProviderSyncConfig#conflictDetection
   */
  readonly conflictDetection?: string;

  /**
   * Conflict Resolution strategy to perform in the event of a conflict. Valid values are NONE, OPTIMISTIC_CONCURRENCY, AUTOMERGE, and LAMBDA.
   *
   * @schema FunctionSpecForProviderSyncConfig#conflictHandler
   */
  readonly conflictHandler?: string;

  /**
   * Lambda Conflict Handler Config when configuring LAMBDA as the Conflict Handler. See Lambda Conflict Handler Config.
   *
   * @schema FunctionSpecForProviderSyncConfig#lambdaConflictHandlerConfig
   */
  readonly lambdaConflictHandlerConfig?: FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig[];

}

/**
 * Converts an object of type 'FunctionSpecForProviderSyncConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSyncConfig(obj: FunctionSpecForProviderSyncConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conflictDetection': obj.conflictDetection,
    'conflictHandler': obj.conflictHandler,
    'lambdaConflictHandlerConfig': obj.lambdaConflictHandlerConfig?.map(y => toJson_FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderConfigRefPolicy
 */
export interface FunctionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderConfigRefPolicy(obj: FunctionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecProviderRefPolicy
 */
export interface FunctionSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecProviderRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecProviderRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecProviderRefPolicy(obj: FunctionSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRef
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: FunctionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRef(obj: FunctionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema FunctionSpecPublishConnectionDetailsToMetadata
 */
export interface FunctionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema FunctionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToMetadata(obj: FunctionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderApiIdRefPolicy
 */
export interface FunctionSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderApiIdRefPolicy(obj: FunctionSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderApiIdSelectorPolicy
 */
export interface FunctionSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderApiIdSelectorPolicy(obj: FunctionSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecForProviderDataSourceRefPolicy
 */
export interface FunctionSpecForProviderDataSourceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderDataSourceRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderDataSourceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderDataSourceRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderDataSourceRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderDataSourceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderDataSourceRefPolicy(obj: FunctionSpecForProviderDataSourceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema FunctionSpecForProviderDataSourceSelectorPolicy
 */
export interface FunctionSpecForProviderDataSourceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecForProviderDataSourceSelectorPolicy#resolution
   */
  readonly resolution?: FunctionSpecForProviderDataSourceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecForProviderDataSourceSelectorPolicy#resolve
   */
  readonly resolve?: FunctionSpecForProviderDataSourceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecForProviderDataSourceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderDataSourceSelectorPolicy(obj: FunctionSpecForProviderDataSourceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig
 */
export interface FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig {
  /**
   * ARN for the Lambda function to use as the Conflict Handler.
   *
   * @schema FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig#lambdaConflictHandlerArn
   */
  readonly lambdaConflictHandlerArn?: string;

}

/**
 * Converts an object of type 'FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig(obj: FunctionSpecForProviderSyncConfigLambdaConflictHandlerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaConflictHandlerArn': obj.lambdaConflictHandlerArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolution
 */
export enum FunctionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderConfigRefPolicyResolve
 */
export enum FunctionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecProviderRefPolicyResolution
 */
export enum FunctionSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecProviderRefPolicyResolve
 */
export enum FunctionSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface FunctionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'FunctionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FunctionSpecPublishConnectionDetailsToConfigRefPolicy(obj: FunctionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderApiIdRefPolicyResolution
 */
export enum FunctionSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderApiIdRefPolicyResolve
 */
export enum FunctionSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderApiIdSelectorPolicyResolution
 */
export enum FunctionSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderApiIdSelectorPolicyResolve
 */
export enum FunctionSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderDataSourceRefPolicyResolution
 */
export enum FunctionSpecForProviderDataSourceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderDataSourceRefPolicyResolve
 */
export enum FunctionSpecForProviderDataSourceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecForProviderDataSourceSelectorPolicyResolution
 */
export enum FunctionSpecForProviderDataSourceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecForProviderDataSourceSelectorPolicyResolve
 */
export enum FunctionSpecForProviderDataSourceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum FunctionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GraphQLAPI is the Schema for the GraphQLAPIs API. Provides an AppSync GraphQL API.
 *
 * @schema GraphQLAPI
 */
export class GraphQlapi extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GraphQLAPI"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appsync.aws.upbound.io/v1beta1',
    kind: 'GraphQLAPI',
  }

  /**
   * Renders a Kubernetes manifest for "GraphQLAPI".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GraphQlapiProps): any {
    return {
      ...GraphQlapi.GVK,
      ...toJson_GraphQlapiProps(props),
    };
  }

  /**
   * Defines a "GraphQLAPI" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GraphQlapiProps) {
    super(scope, id, {
      ...GraphQlapi.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GraphQlapi.GVK,
      ...toJson_GraphQlapiProps(resolved),
    };
  }
}

/**
 * GraphQLAPI is the Schema for the GraphQLAPIs API. Provides an AppSync GraphQL API.
 *
 * @schema GraphQLAPI
 */
export interface GraphQlapiProps {
  /**
   * @schema GraphQLAPI#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GraphQLAPISpec defines the desired state of GraphQLAPI
   *
   * @schema GraphQLAPI#spec
   */
  readonly spec: GraphQlapiSpec;

}

/**
 * Converts an object of type 'GraphQlapiProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiProps(obj: GraphQlapiProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GraphQlapiSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GraphQLAPISpec defines the desired state of GraphQLAPI
 *
 * @schema GraphQlapiSpec
 */
export interface GraphQlapiSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema GraphQlapiSpec#deletionPolicy
   */
  readonly deletionPolicy?: GraphQlapiSpecDeletionPolicy;

  /**
   * @schema GraphQlapiSpec#forProvider
   */
  readonly forProvider: GraphQlapiSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GraphQlapiSpec#providerConfigRef
   */
  readonly providerConfigRef?: GraphQlapiSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema GraphQlapiSpec#providerRef
   */
  readonly providerRef?: GraphQlapiSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GraphQlapiSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GraphQlapiSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GraphQlapiSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GraphQlapiSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GraphQlapiSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpec(obj: GraphQlapiSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GraphQlapiSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_GraphQlapiSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_GraphQlapiSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_GraphQlapiSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GraphQlapiSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema GraphQlapiSpecDeletionPolicy
 */
export enum GraphQlapiSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GraphQlapiSpecForProvider
 */
export interface GraphQlapiSpecForProvider {
  /**
   * One or more additional authentication providers for the GraphqlApi. Defined below.
   *
   * @schema GraphQlapiSpecForProvider#additionalAuthenticationProvider
   */
  readonly additionalAuthenticationProvider?: GraphQlapiSpecForProviderAdditionalAuthenticationProvider[];

  /**
   * Authentication type. Valid values: API_KEY, AWS_IAM, AMAZON_COGNITO_USER_POOLS, OPENID_CONNECT, AWS_LAMBDA
   *
   * @schema GraphQlapiSpecForProvider#authenticationType
   */
  readonly authenticationType: string;

  /**
   * Nested argument containing Lambda authorizer configuration. Defined below.
   *
   * @schema GraphQlapiSpecForProvider#lambdaAuthorizerConfig
   */
  readonly lambdaAuthorizerConfig?: GraphQlapiSpecForProviderLambdaAuthorizerConfig[];

  /**
   * Nested argument containing logging configuration. Defined below.
   *
   * @schema GraphQlapiSpecForProvider#logConfig
   */
  readonly logConfig?: GraphQlapiSpecForProviderLogConfig[];

  /**
   * User-supplied name for the GraphqlApi.
   *
   * @schema GraphQlapiSpecForProvider#name
   */
  readonly name: string;

  /**
   * Nested argument containing OpenID Connect configuration. Defined below.
   *
   * @schema GraphQlapiSpecForProvider#openidConnectConfig
   */
  readonly openidConnectConfig?: GraphQlapiSpecForProviderOpenidConnectConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GraphQlapiSpecForProvider#region
   */
  readonly region: string;

  /**
   * Schema definition, in GraphQL schema language format.
   *
   * @schema GraphQlapiSpecForProvider#schema
   */
  readonly schema?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GraphQlapiSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Amazon Cognito User Pool configuration. Defined below.
   *
   * @schema GraphQlapiSpecForProvider#userPoolConfig
   */
  readonly userPoolConfig?: GraphQlapiSpecForProviderUserPoolConfig[];

  /**
   * Whether tracing with X-ray is enabled. Defaults to false.
   *
   * @default false.
   * @schema GraphQlapiSpecForProvider#xrayEnabled
   */
  readonly xrayEnabled?: boolean;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProvider(obj: GraphQlapiSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalAuthenticationProvider': obj.additionalAuthenticationProvider?.map(y => toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProvider(y)),
    'authenticationType': obj.authenticationType,
    'lambdaAuthorizerConfig': obj.lambdaAuthorizerConfig?.map(y => toJson_GraphQlapiSpecForProviderLambdaAuthorizerConfig(y)),
    'logConfig': obj.logConfig?.map(y => toJson_GraphQlapiSpecForProviderLogConfig(y)),
    'name': obj.name,
    'openidConnectConfig': obj.openidConnectConfig?.map(y => toJson_GraphQlapiSpecForProviderOpenidConnectConfig(y)),
    'region': obj.region,
    'schema': obj.schema,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userPoolConfig': obj.userPoolConfig?.map(y => toJson_GraphQlapiSpecForProviderUserPoolConfig(y)),
    'xrayEnabled': obj.xrayEnabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GraphQlapiSpecProviderConfigRef
 */
export interface GraphQlapiSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphQlapiSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphQlapiSpecProviderConfigRef#policy
   */
  readonly policy?: GraphQlapiSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GraphQlapiSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecProviderConfigRef(obj: GraphQlapiSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphQlapiSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema GraphQlapiSpecProviderRef
 */
export interface GraphQlapiSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphQlapiSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphQlapiSpecProviderRef#policy
   */
  readonly policy?: GraphQlapiSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'GraphQlapiSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecProviderRef(obj: GraphQlapiSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphQlapiSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GraphQlapiSpecPublishConnectionDetailsTo
 */
export interface GraphQlapiSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GraphQlapiSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GraphQlapiSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecPublishConnectionDetailsTo(obj: GraphQlapiSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GraphQlapiSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GraphQlapiSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GraphQlapiSpecWriteConnectionSecretToRef
 */
export interface GraphQlapiSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GraphQlapiSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GraphQlapiSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecWriteConnectionSecretToRef(obj: GraphQlapiSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProvider
 */
export interface GraphQlapiSpecForProviderAdditionalAuthenticationProvider {
  /**
   * Authentication type. Valid values: API_KEY, AWS_IAM, AMAZON_COGNITO_USER_POOLS, OPENID_CONNECT, AWS_LAMBDA
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProvider#authenticationType
   */
  readonly authenticationType: string;

  /**
   * Nested argument containing Lambda authorizer configuration. Defined below.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProvider#lambdaAuthorizerConfig
   */
  readonly lambdaAuthorizerConfig?: GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig[];

  /**
   * Nested argument containing OpenID Connect configuration. Defined below.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProvider#openidConnectConfig
   */
  readonly openidConnectConfig?: GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig[];

  /**
   * Amazon Cognito User Pool configuration. Defined below.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProvider#userPoolConfig
   */
  readonly userPoolConfig?: GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig[];

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderAdditionalAuthenticationProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProvider(obj: GraphQlapiSpecForProviderAdditionalAuthenticationProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authenticationType': obj.authenticationType,
    'lambdaAuthorizerConfig': obj.lambdaAuthorizerConfig?.map(y => toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig(y)),
    'openidConnectConfig': obj.openidConnectConfig?.map(y => toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig(y)),
    'userPoolConfig': obj.userPoolConfig?.map(y => toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderLambdaAuthorizerConfig
 */
export interface GraphQlapiSpecForProviderLambdaAuthorizerConfig {
  /**
   * Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a ttlOverride key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
   *
   * @schema GraphQlapiSpecForProviderLambdaAuthorizerConfig#authorizerResultTtlInSeconds
   */
  readonly authorizerResultTtlInSeconds?: number;

  /**
   * ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow lambda:InvokeFunction from service principal appsync.amazonaws.com.
   *
   * @schema GraphQlapiSpecForProviderLambdaAuthorizerConfig#authorizerUri
   */
  readonly authorizerUri: string;

  /**
   * Regular expression for validation of tokens before the Lambda function is called.
   *
   * @schema GraphQlapiSpecForProviderLambdaAuthorizerConfig#identityValidationExpression
   */
  readonly identityValidationExpression?: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderLambdaAuthorizerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderLambdaAuthorizerConfig(obj: GraphQlapiSpecForProviderLambdaAuthorizerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizerResultTtlInSeconds': obj.authorizerResultTtlInSeconds,
    'authorizerUri': obj.authorizerUri,
    'identityValidationExpression': obj.identityValidationExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderLogConfig
 */
export interface GraphQlapiSpecForProviderLogConfig {
  /**
   * Amazon Resource Name of the service role that AWS AppSync will assume to publish to Amazon CloudWatch logs in your account.
   *
   * @schema GraphQlapiSpecForProviderLogConfig#cloudwatchLogsRoleArn
   */
  readonly cloudwatchLogsRoleArn?: string;

  /**
   * Reference to a Role in iam to populate cloudwatchLogsRoleArn.
   *
   * @schema GraphQlapiSpecForProviderLogConfig#cloudwatchLogsRoleArnRef
   */
  readonly cloudwatchLogsRoleArnRef?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef;

  /**
   * Selector for a Role in iam to populate cloudwatchLogsRoleArn.
   *
   * @schema GraphQlapiSpecForProviderLogConfig#cloudwatchLogsRoleArnSelector
   */
  readonly cloudwatchLogsRoleArnSelector?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector;

  /**
   * Set to TRUE to exclude sections that contain information such as headers, context, and evaluated mapping templates, regardless of logging  level. Valid values: true, false. Default value: false
   *
   * @schema GraphQlapiSpecForProviderLogConfig#excludeVerboseContent
   */
  readonly excludeVerboseContent?: boolean;

  /**
   * Field logging level. Valid values: ALL, ERROR, NONE.
   *
   * @schema GraphQlapiSpecForProviderLogConfig#fieldLogLevel
   */
  readonly fieldLogLevel: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderLogConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderLogConfig(obj: GraphQlapiSpecForProviderLogConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudwatchLogsRoleArn': obj.cloudwatchLogsRoleArn,
    'cloudwatchLogsRoleArnRef': toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef(obj.cloudwatchLogsRoleArnRef),
    'cloudwatchLogsRoleArnSelector': toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector(obj.cloudwatchLogsRoleArnSelector),
    'excludeVerboseContent': obj.excludeVerboseContent,
    'fieldLogLevel': obj.fieldLogLevel,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderOpenidConnectConfig
 */
export interface GraphQlapiSpecForProviderOpenidConnectConfig {
  /**
   * Number of milliseconds a token is valid after being authenticated.
   *
   * @schema GraphQlapiSpecForProviderOpenidConnectConfig#authTtl
   */
  readonly authTtl?: number;

  /**
   * Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
   *
   * @schema GraphQlapiSpecForProviderOpenidConnectConfig#clientId
   */
  readonly clientId?: string;

  /**
   * Number of milliseconds a token is valid after being issued to a user.
   *
   * @schema GraphQlapiSpecForProviderOpenidConnectConfig#iatTtl
   */
  readonly iatTtl?: number;

  /**
   * Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
   *
   * @schema GraphQlapiSpecForProviderOpenidConnectConfig#issuer
   */
  readonly issuer: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderOpenidConnectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderOpenidConnectConfig(obj: GraphQlapiSpecForProviderOpenidConnectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authTtl': obj.authTtl,
    'clientId': obj.clientId,
    'iatTtl': obj.iatTtl,
    'issuer': obj.issuer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderUserPoolConfig
 */
export interface GraphQlapiSpecForProviderUserPoolConfig {
  /**
   * Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfig#appIdClientRegex
   */
  readonly appIdClientRegex?: string;

  /**
   * AWS region in which the user pool was created.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfig#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Action that you want your GraphQL API to take when a request that uses Amazon Cognito User Pool authentication doesn't match the Amazon Cognito User Pool configuration. Valid: ALLOW and DENY
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfig#defaultAction
   */
  readonly defaultAction: string;

  /**
   * User pool ID.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfig#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfig#userPoolIdRef
   */
  readonly userPoolIdRef?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef;

  /**
   * Selector for a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfig#userPoolIdSelector
   */
  readonly userPoolIdSelector?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderUserPoolConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderUserPoolConfig(obj: GraphQlapiSpecForProviderUserPoolConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appIdClientRegex': obj.appIdClientRegex,
    'awsRegion': obj.awsRegion,
    'defaultAction': obj.defaultAction,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GraphQlapiSpecProviderConfigRefPolicy
 */
export interface GraphQlapiSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphQlapiSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GraphQlapiSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphQlapiSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GraphQlapiSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphQlapiSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecProviderConfigRefPolicy(obj: GraphQlapiSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GraphQlapiSpecProviderRefPolicy
 */
export interface GraphQlapiSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphQlapiSpecProviderRefPolicy#resolution
   */
  readonly resolution?: GraphQlapiSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphQlapiSpecProviderRefPolicy#resolve
   */
  readonly resolve?: GraphQlapiSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphQlapiSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecProviderRefPolicy(obj: GraphQlapiSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRef
 */
export interface GraphQlapiSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GraphQlapiSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecPublishConnectionDetailsToConfigRef(obj: GraphQlapiSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GraphQlapiSpecPublishConnectionDetailsToMetadata
 */
export interface GraphQlapiSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecPublishConnectionDetailsToMetadata(obj: GraphQlapiSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig
 */
export interface GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig {
  /**
   * Number of seconds a response should be cached for. The default is 5 minutes (300 seconds). The Lambda function can override this by returning a ttlOverride key in its response. A value of 0 disables caching of responses. Minimum value of 0. Maximum value of 3600.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig#authorizerResultTtlInSeconds
   */
  readonly authorizerResultTtlInSeconds?: number;

  /**
   * ARN of the Lambda function to be called for authorization. Note: This Lambda function must have a resource-based policy assigned to it, to allow lambda:InvokeFunction from service principal appsync.amazonaws.com.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig#authorizerUri
   */
  readonly authorizerUri: string;

  /**
   * Regular expression for validation of tokens before the Lambda function is called.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig#identityValidationExpression
   */
  readonly identityValidationExpression?: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig(obj: GraphQlapiSpecForProviderAdditionalAuthenticationProviderLambdaAuthorizerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizerResultTtlInSeconds': obj.authorizerResultTtlInSeconds,
    'authorizerUri': obj.authorizerUri,
    'identityValidationExpression': obj.identityValidationExpression,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig
 */
export interface GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig {
  /**
   * Number of milliseconds a token is valid after being authenticated.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig#authTtl
   */
  readonly authTtl?: number;

  /**
   * Client identifier of the Relying party at the OpenID identity provider. This identifier is typically obtained when the Relying party is registered with the OpenID identity provider. You can specify a regular expression so the AWS AppSync can validate against multiple client identifiers at a time.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig#clientId
   */
  readonly clientId?: string;

  /**
   * Number of milliseconds a token is valid after being issued to a user.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig#iatTtl
   */
  readonly iatTtl?: number;

  /**
   * Issuer for the OpenID Connect configuration. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig#issuer
   */
  readonly issuer: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig(obj: GraphQlapiSpecForProviderAdditionalAuthenticationProviderOpenidConnectConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authTtl': obj.authTtl,
    'clientId': obj.clientId,
    'iatTtl': obj.iatTtl,
    'issuer': obj.issuer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig
 */
export interface GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig {
  /**
   * Regular expression for validating the incoming Amazon Cognito User Pool app client ID.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig#appIdClientRegex
   */
  readonly appIdClientRegex?: string;

  /**
   * AWS region in which the user pool was created.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * User pool ID.
   *
   * @schema GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig#userPoolId
   */
  readonly userPoolId: string;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig(obj: GraphQlapiSpecForProviderAdditionalAuthenticationProviderUserPoolConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appIdClientRegex': obj.appIdClientRegex,
    'awsRegion': obj.awsRegion,
    'userPoolId': obj.userPoolId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate cloudwatchLogsRoleArn.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef
 */
export interface GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef#policy
   */
  readonly policy?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef(obj: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate cloudwatchLogsRoleArn.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector
 */
export interface GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector#policy
   */
  readonly policy?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector(obj: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef
 */
export interface GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef#policy
   */
  readonly policy?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef(obj: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector
 */
export interface GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector#policy
   */
  readonly policy?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector(obj: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphQlapiSpecProviderConfigRefPolicyResolution
 */
export enum GraphQlapiSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphQlapiSpecProviderConfigRefPolicyResolve
 */
export enum GraphQlapiSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphQlapiSpecProviderRefPolicyResolution
 */
export enum GraphQlapiSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphQlapiSpecProviderRefPolicyResolve
 */
export enum GraphQlapiSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy(obj: GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy
 */
export interface GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy#resolution
   */
  readonly resolution?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy#resolve
   */
  readonly resolve?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy(obj: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy
 */
export interface GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy(obj: GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy
 */
export interface GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy(obj: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy
 */
export interface GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy(obj: GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GraphQlapiSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicyResolution
 */
export enum GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicyResolve
 */
export enum GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicyResolution
 */
export enum GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicyResolve
 */
export enum GraphQlapiSpecForProviderLogConfigCloudwatchLogsRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicyResolution
 */
export enum GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicyResolve
 */
export enum GraphQlapiSpecForProviderUserPoolConfigUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicyResolution
 */
export enum GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicyResolve
 */
export enum GraphQlapiSpecForProviderUserPoolConfigUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Resolver is the Schema for the Resolvers API. Provides an AppSync Resolver.
 *
 * @schema Resolver
 */
export class Resolver extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Resolver"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'appsync.aws.upbound.io/v1beta1',
    kind: 'Resolver',
  }

  /**
   * Renders a Kubernetes manifest for "Resolver".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResolverProps): any {
    return {
      ...Resolver.GVK,
      ...toJson_ResolverProps(props),
    };
  }

  /**
   * Defines a "Resolver" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResolverProps) {
    super(scope, id, {
      ...Resolver.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Resolver.GVK,
      ...toJson_ResolverProps(resolved),
    };
  }
}

/**
 * Resolver is the Schema for the Resolvers API. Provides an AppSync Resolver.
 *
 * @schema Resolver
 */
export interface ResolverProps {
  /**
   * @schema Resolver#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResolverSpec defines the desired state of Resolver
   *
   * @schema Resolver#spec
   */
  readonly spec: ResolverSpec;

}

/**
 * Converts an object of type 'ResolverProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverProps(obj: ResolverProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResolverSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverSpec defines the desired state of Resolver
 *
 * @schema ResolverSpec
 */
export interface ResolverSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ResolverSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResolverSpecDeletionPolicy;

  /**
   * @schema ResolverSpec#forProvider
   */
  readonly forProvider: ResolverSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResolverSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResolverSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ResolverSpec#providerRef
   */
  readonly providerRef?: ResolverSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResolverSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResolverSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResolverSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResolverSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResolverSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpec(obj: ResolverSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResolverSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ResolverSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ResolverSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ResolverSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResolverSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ResolverSpecDeletionPolicy
 */
export enum ResolverSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResolverSpecForProvider
 */
export interface ResolverSpecForProvider {
  /**
   * API ID for the GraphQL API.
   *
   * @schema ResolverSpecForProvider#apiId
   */
  readonly apiId?: string;

  /**
   * Reference to a GraphQLAPI in appsync to populate apiId.
   *
   * @schema ResolverSpecForProvider#apiIdRef
   */
  readonly apiIdRef?: ResolverSpecForProviderApiIdRef;

  /**
   * Selector for a GraphQLAPI in appsync to populate apiId.
   *
   * @schema ResolverSpecForProvider#apiIdSelector
   */
  readonly apiIdSelector?: ResolverSpecForProviderApiIdSelector;

  /**
   * The Caching Config. See Caching Config.
   *
   * @schema ResolverSpecForProvider#cachingConfig
   */
  readonly cachingConfig?: ResolverSpecForProviderCachingConfig[];

  /**
   * The function code that contains the request and response functions. When code is used, the runtime is required. The runtime value must be APPSYNC_JS.
   *
   * @schema ResolverSpecForProvider#code
   */
  readonly code?: string;

  /**
   * Data source name.
   *
   * @schema ResolverSpecForProvider#dataSource
   */
  readonly dataSource?: string;

  /**
   * Reference to a Datasource in appsync to populate dataSource.
   *
   * @schema ResolverSpecForProvider#dataSourceRef
   */
  readonly dataSourceRef?: ResolverSpecForProviderDataSourceRef;

  /**
   * Selector for a Datasource in appsync to populate dataSource.
   *
   * @schema ResolverSpecForProvider#dataSourceSelector
   */
  readonly dataSourceSelector?: ResolverSpecForProviderDataSourceSelector;

  /**
   * Field name from the schema defined in the GraphQL API.
   *
   * @schema ResolverSpecForProvider#field
   */
  readonly field: string;

  /**
   * Resolver type. Valid values are UNIT and PIPELINE.
   *
   * @schema ResolverSpecForProvider#kind
   */
  readonly kind?: string;

  /**
   * Maximum batching size for a resolver. Valid values are between 0 and 2000.
   *
   * @schema ResolverSpecForProvider#maxBatchSize
   */
  readonly maxBatchSize?: number;

  /**
   * The caching configuration for the resolver. See Pipeline Config.
   *
   * @schema ResolverSpecForProvider#pipelineConfig
   */
  readonly pipelineConfig?: ResolverSpecForProviderPipelineConfig[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResolverSpecForProvider#region
   */
  readonly region: string;

  /**
   * Request mapping template for UNIT resolver or 'before mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
   *
   * @schema ResolverSpecForProvider#requestTemplate
   */
  readonly requestTemplate?: string;

  /**
   * Response mapping template for UNIT resolver or 'after mapping template' for PIPELINE resolver. Required for non-Lambda resolvers.
   *
   * @schema ResolverSpecForProvider#responseTemplate
   */
  readonly responseTemplate?: string;

  /**
   * Describes a runtime used by an AWS AppSync pipeline resolver or AWS AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified. See Runtime.
   *
   * @schema ResolverSpecForProvider#runtime
   */
  readonly runtime?: ResolverSpecForProviderRuntime[];

  /**
   * Describes a Sync configuration for a resolver. See Sync Config.
   *
   * @schema ResolverSpecForProvider#syncConfig
   */
  readonly syncConfig?: ResolverSpecForProviderSyncConfig[];

  /**
   * Type name from the schema defined in the GraphQL API.
   *
   * @schema ResolverSpecForProvider#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ResolverSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProvider(obj: ResolverSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiId': obj.apiId,
    'apiIdRef': toJson_ResolverSpecForProviderApiIdRef(obj.apiIdRef),
    'apiIdSelector': toJson_ResolverSpecForProviderApiIdSelector(obj.apiIdSelector),
    'cachingConfig': obj.cachingConfig?.map(y => toJson_ResolverSpecForProviderCachingConfig(y)),
    'code': obj.code,
    'dataSource': obj.dataSource,
    'dataSourceRef': toJson_ResolverSpecForProviderDataSourceRef(obj.dataSourceRef),
    'dataSourceSelector': toJson_ResolverSpecForProviderDataSourceSelector(obj.dataSourceSelector),
    'field': obj.field,
    'kind': obj.kind,
    'maxBatchSize': obj.maxBatchSize,
    'pipelineConfig': obj.pipelineConfig?.map(y => toJson_ResolverSpecForProviderPipelineConfig(y)),
    'region': obj.region,
    'requestTemplate': obj.requestTemplate,
    'responseTemplate': obj.responseTemplate,
    'runtime': obj.runtime?.map(y => toJson_ResolverSpecForProviderRuntime(y)),
    'syncConfig': obj.syncConfig?.map(y => toJson_ResolverSpecForProviderSyncConfig(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResolverSpecProviderConfigRef
 */
export interface ResolverSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverSpecProviderConfigRef#policy
   */
  readonly policy?: ResolverSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecProviderConfigRef(obj: ResolverSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ResolverSpecProviderRef
 */
export interface ResolverSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverSpecProviderRef#policy
   */
  readonly policy?: ResolverSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ResolverSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecProviderRef(obj: ResolverSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResolverSpecPublishConnectionDetailsTo
 */
export interface ResolverSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResolverSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResolverSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResolverSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResolverSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResolverSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResolverSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecPublishConnectionDetailsTo(obj: ResolverSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResolverSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResolverSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResolverSpecWriteConnectionSecretToRef
 */
export interface ResolverSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResolverSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResolverSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResolverSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecWriteConnectionSecretToRef(obj: ResolverSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GraphQLAPI in appsync to populate apiId.
 *
 * @schema ResolverSpecForProviderApiIdRef
 */
export interface ResolverSpecForProviderApiIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverSpecForProviderApiIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverSpecForProviderApiIdRef#policy
   */
  readonly policy?: ResolverSpecForProviderApiIdRefPolicy;

}

/**
 * Converts an object of type 'ResolverSpecForProviderApiIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderApiIdRef(obj: ResolverSpecForProviderApiIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverSpecForProviderApiIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GraphQLAPI in appsync to populate apiId.
 *
 * @schema ResolverSpecForProviderApiIdSelector
 */
export interface ResolverSpecForProviderApiIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverSpecForProviderApiIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverSpecForProviderApiIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverSpecForProviderApiIdSelector#policy
   */
  readonly policy?: ResolverSpecForProviderApiIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverSpecForProviderApiIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderApiIdSelector(obj: ResolverSpecForProviderApiIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverSpecForProviderApiIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverSpecForProviderCachingConfig
 */
export interface ResolverSpecForProviderCachingConfig {
  /**
   * The caching keys for a resolver that has caching activated. Valid values are entries from the $context.arguments, $context.source, and $context.identity maps.
   *
   * @schema ResolverSpecForProviderCachingConfig#cachingKeys
   */
  readonly cachingKeys?: string[];

  /**
   * The TTL in seconds for a resolver that has caching activated. Valid values are between 1 and 3600 seconds.
   *
   * @schema ResolverSpecForProviderCachingConfig#ttl
   */
  readonly ttl?: number;

}

/**
 * Converts an object of type 'ResolverSpecForProviderCachingConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderCachingConfig(obj: ResolverSpecForProviderCachingConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cachingKeys': obj.cachingKeys?.map(y => y),
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Datasource in appsync to populate dataSource.
 *
 * @schema ResolverSpecForProviderDataSourceRef
 */
export interface ResolverSpecForProviderDataSourceRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverSpecForProviderDataSourceRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverSpecForProviderDataSourceRef#policy
   */
  readonly policy?: ResolverSpecForProviderDataSourceRefPolicy;

}

/**
 * Converts an object of type 'ResolverSpecForProviderDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderDataSourceRef(obj: ResolverSpecForProviderDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverSpecForProviderDataSourceRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Datasource in appsync to populate dataSource.
 *
 * @schema ResolverSpecForProviderDataSourceSelector
 */
export interface ResolverSpecForProviderDataSourceSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResolverSpecForProviderDataSourceSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverSpecForProviderDataSourceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverSpecForProviderDataSourceSelector#policy
   */
  readonly policy?: ResolverSpecForProviderDataSourceSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverSpecForProviderDataSourceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderDataSourceSelector(obj: ResolverSpecForProviderDataSourceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverSpecForProviderDataSourceSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverSpecForProviderPipelineConfig
 */
export interface ResolverSpecForProviderPipelineConfig {
  /**
   * A list of Function objects.
   *
   * @schema ResolverSpecForProviderPipelineConfig#functions
   */
  readonly functions?: string[];

}

/**
 * Converts an object of type 'ResolverSpecForProviderPipelineConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderPipelineConfig(obj: ResolverSpecForProviderPipelineConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functions': obj.functions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverSpecForProviderRuntime
 */
export interface ResolverSpecForProviderRuntime {
  /**
   * The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
   *
   * @schema ResolverSpecForProviderRuntime#name
   */
  readonly name: string;

  /**
   * The version of the runtime to use. Currently, the only allowed version is 1.0.0.
   *
   * @schema ResolverSpecForProviderRuntime#runtimeVersion
   */
  readonly runtimeVersion: string;

}

/**
 * Converts an object of type 'ResolverSpecForProviderRuntime' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderRuntime(obj: ResolverSpecForProviderRuntime | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'runtimeVersion': obj.runtimeVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverSpecForProviderSyncConfig
 */
export interface ResolverSpecForProviderSyncConfig {
  /**
   * Conflict Detection strategy to use. Valid values are NONE and VERSION.
   *
   * @schema ResolverSpecForProviderSyncConfig#conflictDetection
   */
  readonly conflictDetection?: string;

  /**
   * Conflict Resolution strategy to perform in the event of a conflict. Valid values are NONE, OPTIMISTIC_CONCURRENCY, AUTOMERGE, and LAMBDA.
   *
   * @schema ResolverSpecForProviderSyncConfig#conflictHandler
   */
  readonly conflictHandler?: string;

  /**
   * Lambda Conflict Handler Config when configuring LAMBDA as the Conflict Handler. See Lambda Conflict Handler Config.
   *
   * @schema ResolverSpecForProviderSyncConfig#lambdaConflictHandlerConfig
   */
  readonly lambdaConflictHandlerConfig?: ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig[];

}

/**
 * Converts an object of type 'ResolverSpecForProviderSyncConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderSyncConfig(obj: ResolverSpecForProviderSyncConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conflictDetection': obj.conflictDetection,
    'conflictHandler': obj.conflictHandler,
    'lambdaConflictHandlerConfig': obj.lambdaConflictHandlerConfig?.map(y => toJson_ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverSpecProviderConfigRefPolicy
 */
export interface ResolverSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecProviderConfigRefPolicy(obj: ResolverSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverSpecProviderRefPolicy
 */
export interface ResolverSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ResolverSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ResolverSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecProviderRefPolicy(obj: ResolverSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResolverSpecPublishConnectionDetailsToConfigRef
 */
export interface ResolverSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResolverSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecPublishConnectionDetailsToConfigRef(obj: ResolverSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResolverSpecPublishConnectionDetailsToMetadata
 */
export interface ResolverSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResolverSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResolverSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecPublishConnectionDetailsToMetadata(obj: ResolverSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverSpecForProviderApiIdRefPolicy
 */
export interface ResolverSpecForProviderApiIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverSpecForProviderApiIdRefPolicy#resolution
   */
  readonly resolution?: ResolverSpecForProviderApiIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverSpecForProviderApiIdRefPolicy#resolve
   */
  readonly resolve?: ResolverSpecForProviderApiIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverSpecForProviderApiIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderApiIdRefPolicy(obj: ResolverSpecForProviderApiIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverSpecForProviderApiIdSelectorPolicy
 */
export interface ResolverSpecForProviderApiIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverSpecForProviderApiIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverSpecForProviderApiIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverSpecForProviderApiIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverSpecForProviderApiIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverSpecForProviderApiIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderApiIdSelectorPolicy(obj: ResolverSpecForProviderApiIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverSpecForProviderDataSourceRefPolicy
 */
export interface ResolverSpecForProviderDataSourceRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverSpecForProviderDataSourceRefPolicy#resolution
   */
  readonly resolution?: ResolverSpecForProviderDataSourceRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverSpecForProviderDataSourceRefPolicy#resolve
   */
  readonly resolve?: ResolverSpecForProviderDataSourceRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverSpecForProviderDataSourceRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderDataSourceRefPolicy(obj: ResolverSpecForProviderDataSourceRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverSpecForProviderDataSourceSelectorPolicy
 */
export interface ResolverSpecForProviderDataSourceSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverSpecForProviderDataSourceSelectorPolicy#resolution
   */
  readonly resolution?: ResolverSpecForProviderDataSourceSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverSpecForProviderDataSourceSelectorPolicy#resolve
   */
  readonly resolve?: ResolverSpecForProviderDataSourceSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverSpecForProviderDataSourceSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderDataSourceSelectorPolicy(obj: ResolverSpecForProviderDataSourceSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig
 */
export interface ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig {
  /**
   * ARN for the Lambda function to use as the Conflict Handler.
   *
   * @schema ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig#lambdaConflictHandlerArn
   */
  readonly lambdaConflictHandlerArn?: string;

}

/**
 * Converts an object of type 'ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig(obj: ResolverSpecForProviderSyncConfigLambdaConflictHandlerConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaConflictHandlerArn': obj.lambdaConflictHandlerArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverSpecProviderConfigRefPolicyResolution
 */
export enum ResolverSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverSpecProviderConfigRefPolicyResolve
 */
export enum ResolverSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverSpecProviderRefPolicyResolution
 */
export enum ResolverSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverSpecProviderRefPolicyResolve
 */
export enum ResolverSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResolverSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResolverSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResolverSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResolverSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResolverSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverSpecForProviderApiIdRefPolicyResolution
 */
export enum ResolverSpecForProviderApiIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverSpecForProviderApiIdRefPolicyResolve
 */
export enum ResolverSpecForProviderApiIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverSpecForProviderApiIdSelectorPolicyResolution
 */
export enum ResolverSpecForProviderApiIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverSpecForProviderApiIdSelectorPolicyResolve
 */
export enum ResolverSpecForProviderApiIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverSpecForProviderDataSourceRefPolicyResolution
 */
export enum ResolverSpecForProviderDataSourceRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverSpecForProviderDataSourceRefPolicyResolve
 */
export enum ResolverSpecForProviderDataSourceRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverSpecForProviderDataSourceSelectorPolicyResolution
 */
export enum ResolverSpecForProviderDataSourceSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverSpecForProviderDataSourceSelectorPolicyResolve
 */
export enum ResolverSpecForProviderDataSourceSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResolverSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResolverSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResolverSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResolverSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

