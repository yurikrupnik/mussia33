// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ConsentStore is the Schema for the ConsentStores API. The Consent Management API is a tool for tracking user consents and the documentation associated with the consents.
 *
 * @schema ConsentStore
 */
export class ConsentStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConsentStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'healthcare.gcp.upbound.io/v1beta1',
    kind: 'ConsentStore',
  }

  /**
   * Renders a Kubernetes manifest for "ConsentStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConsentStoreProps): any {
    return {
      ...ConsentStore.GVK,
      ...toJson_ConsentStoreProps(props),
    };
  }

  /**
   * Defines a "ConsentStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConsentStoreProps) {
    super(scope, id, {
      ...ConsentStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConsentStore.GVK,
      ...toJson_ConsentStoreProps(resolved),
    };
  }
}

/**
 * ConsentStore is the Schema for the ConsentStores API. The Consent Management API is a tool for tracking user consents and the documentation associated with the consents.
 *
 * @schema ConsentStore
 */
export interface ConsentStoreProps {
  /**
   * @schema ConsentStore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConsentStoreSpec defines the desired state of ConsentStore
   *
   * @schema ConsentStore#spec
   */
  readonly spec: ConsentStoreSpec;

}

/**
 * Converts an object of type 'ConsentStoreProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreProps(obj: ConsentStoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConsentStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConsentStoreSpec defines the desired state of ConsentStore
 *
 * @schema ConsentStoreSpec
 */
export interface ConsentStoreSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ConsentStoreSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConsentStoreSpecDeletionPolicy;

  /**
   * @schema ConsentStoreSpec#forProvider
   */
  readonly forProvider: ConsentStoreSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConsentStoreSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConsentStoreSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ConsentStoreSpec#providerRef
   */
  readonly providerRef?: ConsentStoreSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConsentStoreSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConsentStoreSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConsentStoreSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConsentStoreSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConsentStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpec(obj: ConsentStoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConsentStoreSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ConsentStoreSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ConsentStoreSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ConsentStoreSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConsentStoreSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ConsentStoreSpecDeletionPolicy
 */
export enum ConsentStoreSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConsentStoreSpecForProvider
 */
export interface ConsentStoreSpecForProvider {
  /**
   * Identifies the dataset addressed by this request. Must be in the format 'projects/{project}/locations/{location}/datasets/{dataset}'
   *
   * @schema ConsentStoreSpecForProvider#dataset
   */
  readonly dataset?: string;

  /**
   * Reference to a Dataset in healthcare to populate dataset.
   *
   * @schema ConsentStoreSpecForProvider#datasetRef
   */
  readonly datasetRef?: ConsentStoreSpecForProviderDatasetRef;

  /**
   * Selector for a Dataset in healthcare to populate dataset.
   *
   * @schema ConsentStoreSpecForProvider#datasetSelector
   */
  readonly datasetSelector?: ConsentStoreSpecForProviderDatasetSelector;

  /**
   * Default time to live for consents in this store. Must be at least 24 hours. Updating this field will not affect the expiration time of existing consents. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
   *
   * @schema ConsentStoreSpecForProvider#defaultConsentTtl
   */
  readonly defaultConsentTtl?: string;

  /**
   * If true, [consents.patch] [google.cloud.healthcare.v1.consent.UpdateConsent] creates the consent if it does not already exist.
   *
   * @schema ConsentStoreSpecForProvider#enableConsentCreateOnUpdate
   */
  readonly enableConsentCreateOnUpdate?: boolean;

  /**
   * User-supplied key-value pairs used to organize Consent stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema ConsentStoreSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The name of this ConsentStore, for example: "consent1"
   *
   * @schema ConsentStoreSpecForProvider#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConsentStoreSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecForProvider(obj: ConsentStoreSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dataset': obj.dataset,
    'datasetRef': toJson_ConsentStoreSpecForProviderDatasetRef(obj.datasetRef),
    'datasetSelector': toJson_ConsentStoreSpecForProviderDatasetSelector(obj.datasetSelector),
    'defaultConsentTtl': obj.defaultConsentTtl,
    'enableConsentCreateOnUpdate': obj.enableConsentCreateOnUpdate,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConsentStoreSpecProviderConfigRef
 */
export interface ConsentStoreSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConsentStoreSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConsentStoreSpecProviderConfigRef#policy
   */
  readonly policy?: ConsentStoreSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConsentStoreSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecProviderConfigRef(obj: ConsentStoreSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConsentStoreSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ConsentStoreSpecProviderRef
 */
export interface ConsentStoreSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConsentStoreSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConsentStoreSpecProviderRef#policy
   */
  readonly policy?: ConsentStoreSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ConsentStoreSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecProviderRef(obj: ConsentStoreSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConsentStoreSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConsentStoreSpecPublishConnectionDetailsTo
 */
export interface ConsentStoreSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConsentStoreSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConsentStoreSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConsentStoreSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecPublishConnectionDetailsTo(obj: ConsentStoreSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConsentStoreSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConsentStoreSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConsentStoreSpecWriteConnectionSecretToRef
 */
export interface ConsentStoreSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConsentStoreSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConsentStoreSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConsentStoreSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecWriteConnectionSecretToRef(obj: ConsentStoreSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in healthcare to populate dataset.
 *
 * @schema ConsentStoreSpecForProviderDatasetRef
 */
export interface ConsentStoreSpecForProviderDatasetRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConsentStoreSpecForProviderDatasetRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConsentStoreSpecForProviderDatasetRef#policy
   */
  readonly policy?: ConsentStoreSpecForProviderDatasetRefPolicy;

}

/**
 * Converts an object of type 'ConsentStoreSpecForProviderDatasetRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecForProviderDatasetRef(obj: ConsentStoreSpecForProviderDatasetRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConsentStoreSpecForProviderDatasetRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in healthcare to populate dataset.
 *
 * @schema ConsentStoreSpecForProviderDatasetSelector
 */
export interface ConsentStoreSpecForProviderDatasetSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConsentStoreSpecForProviderDatasetSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConsentStoreSpecForProviderDatasetSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConsentStoreSpecForProviderDatasetSelector#policy
   */
  readonly policy?: ConsentStoreSpecForProviderDatasetSelectorPolicy;

}

/**
 * Converts an object of type 'ConsentStoreSpecForProviderDatasetSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecForProviderDatasetSelector(obj: ConsentStoreSpecForProviderDatasetSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConsentStoreSpecForProviderDatasetSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConsentStoreSpecProviderConfigRefPolicy
 */
export interface ConsentStoreSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConsentStoreSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConsentStoreSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConsentStoreSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConsentStoreSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConsentStoreSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecProviderConfigRefPolicy(obj: ConsentStoreSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConsentStoreSpecProviderRefPolicy
 */
export interface ConsentStoreSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConsentStoreSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ConsentStoreSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConsentStoreSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ConsentStoreSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ConsentStoreSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecProviderRefPolicy(obj: ConsentStoreSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRef
 */
export interface ConsentStoreSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConsentStoreSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecPublishConnectionDetailsToConfigRef(obj: ConsentStoreSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConsentStoreSpecPublishConnectionDetailsToMetadata
 */
export interface ConsentStoreSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConsentStoreSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecPublishConnectionDetailsToMetadata(obj: ConsentStoreSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConsentStoreSpecForProviderDatasetRefPolicy
 */
export interface ConsentStoreSpecForProviderDatasetRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConsentStoreSpecForProviderDatasetRefPolicy#resolution
   */
  readonly resolution?: ConsentStoreSpecForProviderDatasetRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConsentStoreSpecForProviderDatasetRefPolicy#resolve
   */
  readonly resolve?: ConsentStoreSpecForProviderDatasetRefPolicyResolve;

}

/**
 * Converts an object of type 'ConsentStoreSpecForProviderDatasetRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecForProviderDatasetRefPolicy(obj: ConsentStoreSpecForProviderDatasetRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConsentStoreSpecForProviderDatasetSelectorPolicy
 */
export interface ConsentStoreSpecForProviderDatasetSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConsentStoreSpecForProviderDatasetSelectorPolicy#resolution
   */
  readonly resolution?: ConsentStoreSpecForProviderDatasetSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConsentStoreSpecForProviderDatasetSelectorPolicy#resolve
   */
  readonly resolve?: ConsentStoreSpecForProviderDatasetSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConsentStoreSpecForProviderDatasetSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecForProviderDatasetSelectorPolicy(obj: ConsentStoreSpecForProviderDatasetSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConsentStoreSpecProviderConfigRefPolicyResolution
 */
export enum ConsentStoreSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConsentStoreSpecProviderConfigRefPolicyResolve
 */
export enum ConsentStoreSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConsentStoreSpecProviderRefPolicyResolution
 */
export enum ConsentStoreSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConsentStoreSpecProviderRefPolicyResolve
 */
export enum ConsentStoreSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConsentStoreSpecForProviderDatasetRefPolicyResolution
 */
export enum ConsentStoreSpecForProviderDatasetRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConsentStoreSpecForProviderDatasetRefPolicyResolve
 */
export enum ConsentStoreSpecForProviderDatasetRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConsentStoreSpecForProviderDatasetSelectorPolicyResolution
 */
export enum ConsentStoreSpecForProviderDatasetSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConsentStoreSpecForProviderDatasetSelectorPolicyResolve
 */
export enum ConsentStoreSpecForProviderDatasetSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConsentStoreSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Dataset is the Schema for the Datasets API. A Healthcare
 *
 * @schema Dataset
 */
export class Dataset extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Dataset"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'healthcare.gcp.upbound.io/v1beta1',
    kind: 'Dataset',
  }

  /**
   * Renders a Kubernetes manifest for "Dataset".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetProps): any {
    return {
      ...Dataset.GVK,
      ...toJson_DatasetProps(props),
    };
  }

  /**
   * Defines a "Dataset" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetProps) {
    super(scope, id, {
      ...Dataset.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Dataset.GVK,
      ...toJson_DatasetProps(resolved),
    };
  }
}

/**
 * Dataset is the Schema for the Datasets API. A Healthcare
 *
 * @schema Dataset
 */
export interface DatasetProps {
  /**
   * @schema Dataset#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetSpec defines the desired state of Dataset
   *
   * @schema Dataset#spec
   */
  readonly spec: DatasetSpec;

}

/**
 * Converts an object of type 'DatasetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetProps(obj: DatasetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetSpec defines the desired state of Dataset
 *
 * @schema DatasetSpec
 */
export interface DatasetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasetSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetSpecDeletionPolicy;

  /**
   * @schema DatasetSpec#forProvider
   */
  readonly forProvider: DatasetSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasetSpec#providerRef
   */
  readonly providerRef?: DatasetSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpec(obj: DatasetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasetSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasetSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasetSpecDeletionPolicy
 */
export enum DatasetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetSpecForProvider
 */
export interface DatasetSpecForProvider {
  /**
   * The location for the Dataset.
   *
   * @schema DatasetSpecForProvider#location
   */
  readonly location: string;

  /**
   * The resource name for the Dataset.
   *
   * @schema DatasetSpecForProvider#name
   */
  readonly name: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema DatasetSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The default timezone used by this dataset. Must be a either a valid IANA time zone name such as "America/New_York" or empty, which defaults to UTC. This is used for parsing times in resources (e.g., HL7 messages) where no explicit timezone is specified.
   *
   * @schema DatasetSpecForProvider#timeZone
   */
  readonly timeZone?: string;

}

/**
 * Converts an object of type 'DatasetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecForProvider(obj: DatasetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'location': obj.location,
    'name': obj.name,
    'project': obj.project,
    'timeZone': obj.timeZone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetSpecProviderConfigRef
 */
export interface DatasetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecProviderConfigRef#policy
   */
  readonly policy?: DatasetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderConfigRef(obj: DatasetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasetSpecProviderRef
 */
export interface DatasetSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecProviderRef#policy
   */
  readonly policy?: DatasetSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderRef(obj: DatasetSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetSpecPublishConnectionDetailsTo
 */
export interface DatasetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsTo(obj: DatasetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetSpecWriteConnectionSecretToRef
 */
export interface DatasetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecWriteConnectionSecretToRef(obj: DatasetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecProviderConfigRefPolicy
 */
export interface DatasetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderConfigRefPolicy(obj: DatasetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecProviderRefPolicy
 */
export interface DatasetSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecProviderRefPolicy(obj: DatasetSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToConfigRef(obj: DatasetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetSpecPublishConnectionDetailsToMetadata
 */
export interface DatasetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToMetadata(obj: DatasetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecProviderConfigRefPolicyResolution
 */
export enum DatasetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecProviderConfigRefPolicyResolve
 */
export enum DatasetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecProviderRefPolicyResolution
 */
export enum DatasetSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecProviderRefPolicyResolve
 */
export enum DatasetSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * DatasetIAMMember is the Schema for the DatasetIAMMembers API. <no value>
 *
 * @schema DatasetIAMMember
 */
export class DatasetIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DatasetIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'healthcare.gcp.upbound.io/v1beta1',
    kind: 'DatasetIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "DatasetIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DatasetIamMemberProps): any {
    return {
      ...DatasetIamMember.GVK,
      ...toJson_DatasetIamMemberProps(props),
    };
  }

  /**
   * Defines a "DatasetIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DatasetIamMemberProps) {
    super(scope, id, {
      ...DatasetIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...DatasetIamMember.GVK,
      ...toJson_DatasetIamMemberProps(resolved),
    };
  }
}

/**
 * DatasetIAMMember is the Schema for the DatasetIAMMembers API. <no value>
 *
 * @schema DatasetIAMMember
 */
export interface DatasetIamMemberProps {
  /**
   * @schema DatasetIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DatasetIAMMemberSpec defines the desired state of DatasetIAMMember
   *
   * @schema DatasetIAMMember#spec
   */
  readonly spec: DatasetIamMemberSpec;

}

/**
 * Converts an object of type 'DatasetIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberProps(obj: DatasetIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DatasetIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DatasetIAMMemberSpec defines the desired state of DatasetIAMMember
 *
 * @schema DatasetIamMemberSpec
 */
export interface DatasetIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema DatasetIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: DatasetIamMemberSpecDeletionPolicy;

  /**
   * @schema DatasetIamMemberSpec#forProvider
   */
  readonly forProvider: DatasetIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DatasetIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: DatasetIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema DatasetIamMemberSpec#providerRef
   */
  readonly providerRef?: DatasetIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DatasetIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DatasetIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DatasetIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DatasetIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DatasetIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpec(obj: DatasetIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DatasetIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_DatasetIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_DatasetIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_DatasetIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DatasetIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema DatasetIamMemberSpecDeletionPolicy
 */
export enum DatasetIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DatasetIamMemberSpecForProvider
 */
export interface DatasetIamMemberSpecForProvider {
  /**
   * @schema DatasetIamMemberSpecForProvider#condition
   */
  readonly condition?: DatasetIamMemberSpecForProviderCondition[];

  /**
   * @schema DatasetIamMemberSpecForProvider#datasetId
   */
  readonly datasetId?: string;

  /**
   * Reference to a Dataset in healthcare to populate datasetId.
   *
   * @schema DatasetIamMemberSpecForProvider#datasetIdRef
   */
  readonly datasetIdRef?: DatasetIamMemberSpecForProviderDatasetIdRef;

  /**
   * Selector for a Dataset in healthcare to populate datasetId.
   *
   * @schema DatasetIamMemberSpecForProvider#datasetIdSelector
   */
  readonly datasetIdSelector?: DatasetIamMemberSpecForProviderDatasetIdSelector;

  /**
   * @schema DatasetIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema DatasetIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProvider(obj: DatasetIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_DatasetIamMemberSpecForProviderCondition(y)),
    'datasetId': obj.datasetId,
    'datasetIdRef': toJson_DatasetIamMemberSpecForProviderDatasetIdRef(obj.datasetIdRef),
    'datasetIdSelector': toJson_DatasetIamMemberSpecForProviderDatasetIdSelector(obj.datasetIdSelector),
    'member': obj.member,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DatasetIamMemberSpecProviderConfigRef
 */
export interface DatasetIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: DatasetIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderConfigRef(obj: DatasetIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema DatasetIamMemberSpecProviderRef
 */
export interface DatasetIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecProviderRef#policy
   */
  readonly policy?: DatasetIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderRef(obj: DatasetIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsTo
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DatasetIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsTo(obj: DatasetIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DatasetIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DatasetIamMemberSpecWriteConnectionSecretToRef
 */
export interface DatasetIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DatasetIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DatasetIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecWriteConnectionSecretToRef(obj: DatasetIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DatasetIamMemberSpecForProviderCondition
 */
export interface DatasetIamMemberSpecForProviderCondition {
  /**
   * @schema DatasetIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema DatasetIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema DatasetIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderCondition(obj: DatasetIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Dataset in healthcare to populate datasetId.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRef
 */
export interface DatasetIamMemberSpecForProviderDatasetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRef#policy
   */
  readonly policy?: DatasetIamMemberSpecForProviderDatasetIdRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdRef(obj: DatasetIamMemberSpecForProviderDatasetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecForProviderDatasetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Dataset in healthcare to populate datasetId.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelector
 */
export interface DatasetIamMemberSpecForProviderDatasetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelector#policy
   */
  readonly policy?: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdSelector(obj: DatasetIamMemberSpecForProviderDatasetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecProviderConfigRefPolicy
 */
export interface DatasetIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderConfigRefPolicy(obj: DatasetIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecProviderRefPolicy
 */
export interface DatasetIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecProviderRefPolicy(obj: DatasetIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRef(obj: DatasetIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsToMetadata(obj: DatasetIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicy
 */
export interface DatasetIamMemberSpecForProviderDatasetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdRefPolicy(obj: DatasetIamMemberSpecForProviderDatasetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy
 */
export interface DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy(obj: DatasetIamMemberSpecForProviderDatasetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum DatasetIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum DatasetIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecProviderRefPolicyResolution
 */
export enum DatasetIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecProviderRefPolicyResolve
 */
export enum DatasetIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolution
 */
export enum DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolve
 */
export enum DatasetIamMemberSpecForProviderDatasetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolution
 */
export enum DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolve
 */
export enum DatasetIamMemberSpecForProviderDatasetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DatasetIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

