// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Environment is the Schema for the Environments API. A Cloud AI Platform Notebook environment.
 *
 * @schema Environment
 */
export class Environment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Environment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notebooks.gcp.upbound.io/v1beta1',
    kind: 'Environment',
  }

  /**
   * Renders a Kubernetes manifest for "Environment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EnvironmentProps): any {
    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(props),
    };
  }

  /**
   * Defines a "Environment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EnvironmentProps) {
    super(scope, id, {
      ...Environment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Environment.GVK,
      ...toJson_EnvironmentProps(resolved),
    };
  }
}

/**
 * Environment is the Schema for the Environments API. A Cloud AI Platform Notebook environment.
 *
 * @schema Environment
 */
export interface EnvironmentProps {
  /**
   * @schema Environment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EnvironmentSpec defines the desired state of Environment
   *
   * @schema Environment#spec
   */
  readonly spec: EnvironmentSpec;

}

/**
 * Converts an object of type 'EnvironmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentProps(obj: EnvironmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EnvironmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentSpec defines the desired state of Environment
 *
 * @schema EnvironmentSpec
 */
export interface EnvironmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema EnvironmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: EnvironmentSpecDeletionPolicy;

  /**
   * @schema EnvironmentSpec#forProvider
   */
  readonly forProvider: EnvironmentSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EnvironmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: EnvironmentSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EnvironmentSpec#providerRef
   */
  readonly providerRef?: EnvironmentSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EnvironmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EnvironmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EnvironmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EnvironmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EnvironmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpec(obj: EnvironmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EnvironmentSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_EnvironmentSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EnvironmentSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EnvironmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EnvironmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema EnvironmentSpecDeletionPolicy
 */
export enum EnvironmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EnvironmentSpecForProvider
 */
export interface EnvironmentSpecForProvider {
  /**
   * Use a container image to start the notebook instance. Structure is documented below.
   *
   * @schema EnvironmentSpecForProvider#containerImage
   */
  readonly containerImage?: EnvironmentSpecForProviderContainerImage[];

  /**
   * A brief description of this environment.
   *
   * @schema EnvironmentSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Display name of this environment for the UI.
   *
   * @schema EnvironmentSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * A reference to the zone where the machine resides.
   *
   * @schema EnvironmentSpecForProvider#location
   */
  readonly location: string;

  /**
   * Path to a Bash script that automatically runs after a notebook instance fully boots up. The path must be a URL or Cloud Storage path. Example: "gs://path-to-file/file-name"
   *
   * @schema EnvironmentSpecForProvider#postStartupScript
   */
  readonly postStartupScript?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema EnvironmentSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Use a Compute Engine VM image to start the notebook instance. Structure is documented below.
   *
   * @schema EnvironmentSpecForProvider#vmImage
   */
  readonly vmImage?: EnvironmentSpecForProviderVmImage[];

}

/**
 * Converts an object of type 'EnvironmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProvider(obj: EnvironmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerImage': obj.containerImage?.map(y => toJson_EnvironmentSpecForProviderContainerImage(y)),
    'description': obj.description,
    'displayName': obj.displayName,
    'location': obj.location,
    'postStartupScript': obj.postStartupScript,
    'project': obj.project,
    'vmImage': obj.vmImage?.map(y => toJson_EnvironmentSpecForProviderVmImage(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EnvironmentSpecProviderConfigRef
 */
export interface EnvironmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderConfigRef#policy
   */
  readonly policy?: EnvironmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRef(obj: EnvironmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EnvironmentSpecProviderRef
 */
export interface EnvironmentSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecProviderRef#policy
   */
  readonly policy?: EnvironmentSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRef(obj: EnvironmentSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsTo
 */
export interface EnvironmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EnvironmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EnvironmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsTo(obj: EnvironmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EnvironmentSpecWriteConnectionSecretToRef
 */
export interface EnvironmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EnvironmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EnvironmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecWriteConnectionSecretToRef(obj: EnvironmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderContainerImage
 */
export interface EnvironmentSpecForProviderContainerImage {
  /**
   * The path to the container image repository. For example: gcr.io/{project_id}/{imageName}
   *
   * @schema EnvironmentSpecForProviderContainerImage#repository
   */
  readonly repository: string;

  /**
   * The tag of the container image. If not specified, this defaults to the latest tag.
   *
   * @schema EnvironmentSpecForProviderContainerImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderContainerImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderContainerImage(obj: EnvironmentSpecForProviderContainerImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EnvironmentSpecForProviderVmImage
 */
export interface EnvironmentSpecForProviderVmImage {
  /**
   * Use this VM image family to find the image; the newest image in this family will be used.
   *
   * @schema EnvironmentSpecForProviderVmImage#imageFamily
   */
  readonly imageFamily?: string;

  /**
   * Use VM image name to find the image.
   *
   * @schema EnvironmentSpecForProviderVmImage#imageName
   */
  readonly imageName?: string;

  /**
   * The name of the Google Cloud project that this VM image belongs to. Format: projects/{project_id}
   *
   * @schema EnvironmentSpecForProviderVmImage#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'EnvironmentSpecForProviderVmImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecForProviderVmImage(obj: EnvironmentSpecForProviderVmImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageFamily': obj.imageFamily,
    'imageName': obj.imageName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicy
 */
export interface EnvironmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderConfigRefPolicy(obj: EnvironmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecProviderRefPolicy
 */
export interface EnvironmentSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecProviderRefPolicy(obj: EnvironmentSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRef(obj: EnvironmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToMetadata
 */
export interface EnvironmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToMetadata(obj: EnvironmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolution
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderConfigRefPolicyResolve
 */
export enum EnvironmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolution
 */
export enum EnvironmentSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecProviderRefPolicyResolve
 */
export enum EnvironmentSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: EnvironmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EnvironmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Instance is the Schema for the Instances API. A Cloud AI Platform Notebook instance.
 *
 * @schema Instance
 */
export class Instance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Instance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notebooks.gcp.upbound.io/v1beta1',
    kind: 'Instance',
  }

  /**
   * Renders a Kubernetes manifest for "Instance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceProps): any {
    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(props),
    };
  }

  /**
   * Defines a "Instance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceProps) {
    super(scope, id, {
      ...Instance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Instance.GVK,
      ...toJson_InstanceProps(resolved),
    };
  }
}

/**
 * Instance is the Schema for the Instances API. A Cloud AI Platform Notebook instance.
 *
 * @schema Instance
 */
export interface InstanceProps {
  /**
   * @schema Instance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceSpec defines the desired state of Instance
   *
   * @schema Instance#spec
   */
  readonly spec: InstanceSpec;

}

/**
 * Converts an object of type 'InstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceProps(obj: InstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceSpec defines the desired state of Instance
 *
 * @schema InstanceSpec
 */
export interface InstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceSpecDeletionPolicy;

  /**
   * @schema InstanceSpec#forProvider
   */
  readonly forProvider: InstanceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InstanceSpec#providerRef
   */
  readonly providerRef?: InstanceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpec(obj: InstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InstanceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InstanceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InstanceSpecDeletionPolicy
 */
export enum InstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceSpecForProvider
 */
export interface InstanceSpecForProvider {
  /**
   * The hardware accelerator used on this instance. If you use accelerators, make sure that your configuration has enough vCPUs and memory to support the machineType you have selected. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#acceleratorConfig
   */
  readonly acceleratorConfig?: InstanceSpecForProviderAcceleratorConfig[];

  /**
   * The size of the boot disk in GB attached to this instance, up to a maximum of 64000 GB (64 TB). The minimum recommended value is 100 GB. If not specified, this defaults to 100.
   *
   * @schema InstanceSpecForProvider#bootDiskSizeGb
   */
  readonly bootDiskSizeGb?: number;

  /**
   * Possible disk types for notebook instances. Possible values are DISK_TYPE_UNSPECIFIED, PD_STANDARD, PD_SSD, PD_BALANCED, and PD_EXTREME.
   *
   * @schema InstanceSpecForProvider#bootDiskType
   */
  readonly bootDiskType?: string;

  /**
   * Use a container image to start the notebook instance. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#containerImage
   */
  readonly containerImage?: InstanceSpecForProviderContainerImage[];

  /**
   * Specify a custom Cloud Storage path where the GPU driver is stored. If not specified, we'll automatically choose from official GPU drivers.
   *
   * @schema InstanceSpecForProvider#customGpuDriverPath
   */
  readonly customGpuDriverPath?: string;

  /**
   * The size of the data disk in GB attached to this instance, up to a maximum of 64000 GB (64 TB). You can choose the size of the data disk based on how big your notebooks and data are. If not specified, this defaults to 100.
   *
   * @schema InstanceSpecForProvider#dataDiskSizeGb
   */
  readonly dataDiskSizeGb?: number;

  /**
   * Possible disk types for notebook instances. Possible values are DISK_TYPE_UNSPECIFIED, PD_STANDARD, PD_SSD, PD_BALANCED, and PD_EXTREME.
   *
   * @schema InstanceSpecForProvider#dataDiskType
   */
  readonly dataDiskType?: string;

  /**
   * Disk encryption method used on the boot and data disks, defaults to GMEK. Possible values are DISK_ENCRYPTION_UNSPECIFIED, GMEK, and CMEK.
   *
   * @schema InstanceSpecForProvider#diskEncryption
   */
  readonly diskEncryption?: string;

  /**
   * Whether the end user authorizes Google Cloud to install GPU driver on this instance. If this field is empty or set to false, the GPU driver won't be installed. Only applicable to instances with GPUs.
   *
   * @schema InstanceSpecForProvider#installGpuDriver
   */
  readonly installGpuDriver?: boolean;

  /**
   * The list of owners of this instance after creation. Format: alias@example.com. Currently supports one owner only. If not specified, all of the service account users of your VM instance's service account can use the instance.
   *
   * @schema InstanceSpecForProvider#instanceOwners
   */
  readonly instanceOwners?: string[];

  /**
   * The KMS key used to encrypt the disks, only applicable if diskEncryption is CMEK. Format: projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}
   *
   * @schema InstanceSpecForProvider#kmsKey
   */
  readonly kmsKey?: string;

  /**
   * Labels to apply to this instance. These can be later modified by the setLabels method. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema InstanceSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * A reference to the zone where the machine resides.
   *
   * @schema InstanceSpecForProvider#location
   */
  readonly location: string;

  /**
   * A reference to a machine type which defines VM kind.
   *
   * @schema InstanceSpecForProvider#machineType
   */
  readonly machineType: string;

  /**
   * Custom metadata to apply to this instance. An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
   *
   * @schema InstanceSpecForProvider#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * The name of the VPC that this instance is in. Format: projects/{project_id}/global/networks/{network_id}
   *
   * @schema InstanceSpecForProvider#network
   */
  readonly network?: string;

  /**
   * The type of vNIC driver. Possible values are UNSPECIFIED_NIC_TYPE, VIRTIO_NET, and GVNIC.
   *
   * @schema InstanceSpecForProvider#nicType
   */
  readonly nicType?: string;

  /**
   * The notebook instance will not register with the proxy..
   *
   * @schema InstanceSpecForProvider#noProxyAccess
   */
  readonly noProxyAccess?: boolean;

  /**
   * No public IP will be assigned to this instance.
   *
   * @schema InstanceSpecForProvider#noPublicIp
   */
  readonly noPublicIp?: boolean;

  /**
   * If true, the data disk will not be auto deleted when deleting the instance.
   *
   * @schema InstanceSpecForProvider#noRemoveDataDisk
   */
  readonly noRemoveDataDisk?: boolean;

  /**
   * Path to a Bash script that automatically runs after a notebook instance fully boots up. The path must be a URL or Cloud Storage path (gs://path-to-file/file-name).
   *
   * @schema InstanceSpecForProvider#postStartupScript
   */
  readonly postStartupScript?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema InstanceSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Reservation Affinity for consuming Zonal reservation. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#reservationAffinity
   */
  readonly reservationAffinity?: InstanceSpecForProviderReservationAffinity[];

  /**
   * The service account on this instance, giving access to other Google Cloud services. You can use any service account within the same project, but you must have the service account user permission to use the instance. If not specified, the Compute Engine default service account is used.
   *
   * @schema InstanceSpecForProvider#serviceAccount
   */
  readonly serviceAccount?: string;

  /**
   * Optional. The URIs of service account scopes to be included in Compute Engine instances. If not specified, the following scopes are defined:
   *
   * @schema InstanceSpecForProvider#serviceAccountScopes
   */
  readonly serviceAccountScopes?: string[];

  /**
   * A set of Shielded Instance options. Check [Images using supported Shielded VM features] Not all combinations are valid Structure is documented below.
   *
   * @schema InstanceSpecForProvider#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: InstanceSpecForProviderShieldedInstanceConfig[];

  /**
   * The name of the subnet that this instance is in. Format: projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}
   *
   * @schema InstanceSpecForProvider#subnet
   */
  readonly subnet?: string;

  /**
   * The Compute Engine tags to add to instance.
   *
   * @schema InstanceSpecForProvider#tags
   */
  readonly tags?: string[];

  /**
   * Use a Compute Engine VM image to start the notebook instance. Structure is documented below.
   *
   * @schema InstanceSpecForProvider#vmImage
   */
  readonly vmImage?: InstanceSpecForProviderVmImage[];

}

/**
 * Converts an object of type 'InstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProvider(obj: InstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorConfig': obj.acceleratorConfig?.map(y => toJson_InstanceSpecForProviderAcceleratorConfig(y)),
    'bootDiskSizeGb': obj.bootDiskSizeGb,
    'bootDiskType': obj.bootDiskType,
    'containerImage': obj.containerImage?.map(y => toJson_InstanceSpecForProviderContainerImage(y)),
    'customGpuDriverPath': obj.customGpuDriverPath,
    'dataDiskSizeGb': obj.dataDiskSizeGb,
    'dataDiskType': obj.dataDiskType,
    'diskEncryption': obj.diskEncryption,
    'installGpuDriver': obj.installGpuDriver,
    'instanceOwners': obj.instanceOwners?.map(y => y),
    'kmsKey': obj.kmsKey,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'location': obj.location,
    'machineType': obj.machineType,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'network': obj.network,
    'nicType': obj.nicType,
    'noProxyAccess': obj.noProxyAccess,
    'noPublicIp': obj.noPublicIp,
    'noRemoveDataDisk': obj.noRemoveDataDisk,
    'postStartupScript': obj.postStartupScript,
    'project': obj.project,
    'reservationAffinity': obj.reservationAffinity?.map(y => toJson_InstanceSpecForProviderReservationAffinity(y)),
    'serviceAccount': obj.serviceAccount,
    'serviceAccountScopes': obj.serviceAccountScopes?.map(y => y),
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_InstanceSpecForProviderShieldedInstanceConfig(y)),
    'subnet': obj.subnet,
    'tags': obj.tags?.map(y => y),
    'vmImage': obj.vmImage?.map(y => toJson_InstanceSpecForProviderVmImage(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceSpecProviderConfigRef
 */
export interface InstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRef(obj: InstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InstanceSpecProviderRef
 */
export interface InstanceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecProviderRef#policy
   */
  readonly policy?: InstanceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRef(obj: InstanceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceSpecPublishConnectionDetailsTo
 */
export interface InstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsTo(obj: InstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceSpecWriteConnectionSecretToRef
 */
export interface InstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecWriteConnectionSecretToRef(obj: InstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderAcceleratorConfig
 */
export interface InstanceSpecForProviderAcceleratorConfig {
  /**
   * Count of cores of this accelerator.
   *
   * @schema InstanceSpecForProviderAcceleratorConfig#coreCount
   */
  readonly coreCount: number;

  /**
   * Type of this accelerator. Possible values are ACCELERATOR_TYPE_UNSPECIFIED, NVIDIA_TESLA_K80, NVIDIA_TESLA_P100, NVIDIA_TESLA_V100, NVIDIA_TESLA_P4, NVIDIA_TESLA_T4, NVIDIA_TESLA_T4_VWS, NVIDIA_TESLA_P100_VWS, NVIDIA_TESLA_P4_VWS, NVIDIA_TESLA_A100, TPU_V2, and TPU_V3.
   *
   * @schema InstanceSpecForProviderAcceleratorConfig#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderAcceleratorConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderAcceleratorConfig(obj: InstanceSpecForProviderAcceleratorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coreCount': obj.coreCount,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderContainerImage
 */
export interface InstanceSpecForProviderContainerImage {
  /**
   * The path to the container image repository. For example: gcr.io/{project_id}/{imageName}
   *
   * @schema InstanceSpecForProviderContainerImage#repository
   */
  readonly repository: string;

  /**
   * The tag of the container image. If not specified, this defaults to the latest tag.
   *
   * @schema InstanceSpecForProviderContainerImage#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderContainerImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderContainerImage(obj: InstanceSpecForProviderContainerImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderReservationAffinity
 */
export interface InstanceSpecForProviderReservationAffinity {
  /**
   * The type of Compute Reservation. Possible values are NO_RESERVATION, ANY_RESERVATION, and SPECIFIC_RESERVATION.
   *
   * @schema InstanceSpecForProviderReservationAffinity#consumeReservationType
   */
  readonly consumeReservationType: string;

  /**
   * Corresponds to the label key of reservation resource.
   *
   * @schema InstanceSpecForProviderReservationAffinity#key
   */
  readonly key?: string;

  /**
   * Corresponds to the label values of reservation resource.
   *
   * @schema InstanceSpecForProviderReservationAffinity#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'InstanceSpecForProviderReservationAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderReservationAffinity(obj: InstanceSpecForProviderReservationAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'consumeReservationType': obj.consumeReservationType,
    'key': obj.key,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderShieldedInstanceConfig
 */
export interface InstanceSpecForProviderShieldedInstanceConfig {
  /**
   * Defines whether the instance has integrity monitoring enabled. Enables monitoring and attestation of the boot integrity of the instance. The attestation is performed against the integrity policy baseline. This baseline is initially derived from the implicitly trusted boot image when the instance is created. Enabled by default.
   *
   * @schema InstanceSpecForProviderShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines whether the instance has Secure Boot enabled. Secure Boot helps ensure that the system only runs authentic software by verifying the digital signature of all boot components, and halting the boot process if signature verification fails. Disabled by default.
   *
   * @schema InstanceSpecForProviderShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;

  /**
   * Defines whether the instance has the vTPM enabled. Enabled by default.
   *
   * @schema InstanceSpecForProviderShieldedInstanceConfig#enableVtpm
   */
  readonly enableVtpm?: boolean;

}

/**
 * Converts an object of type 'InstanceSpecForProviderShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderShieldedInstanceConfig(obj: InstanceSpecForProviderShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
    'enableVtpm': obj.enableVtpm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceSpecForProviderVmImage
 */
export interface InstanceSpecForProviderVmImage {
  /**
   * Use this VM image family to find the image; the newest image in this family will be used.
   *
   * @schema InstanceSpecForProviderVmImage#imageFamily
   */
  readonly imageFamily?: string;

  /**
   * Use VM image name to find the image.
   *
   * @schema InstanceSpecForProviderVmImage#imageName
   */
  readonly imageName?: string;

  /**
   * The name of the Google Cloud project that this VM image belongs to. Format: projects/{project_id}
   *
   * @schema InstanceSpecForProviderVmImage#project
   */
  readonly project: string;

}

/**
 * Converts an object of type 'InstanceSpecForProviderVmImage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecForProviderVmImage(obj: InstanceSpecForProviderVmImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'imageFamily': obj.imageFamily,
    'imageName': obj.imageName,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderConfigRefPolicy
 */
export interface InstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderConfigRefPolicy(obj: InstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecProviderRefPolicy
 */
export interface InstanceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecProviderRefPolicy(obj: InstanceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRef(obj: InstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToMetadata(obj: InstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolution
 */
export enum InstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderConfigRefPolicyResolve
 */
export enum InstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecProviderRefPolicyResolution
 */
export enum InstanceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecProviderRefPolicyResolve
 */
export enum InstanceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InstanceIAMMember is the Schema for the InstanceIAMMembers API. <no value>
 *
 * @schema InstanceIAMMember
 */
export class InstanceIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notebooks.gcp.upbound.io/v1beta1',
    kind: 'InstanceIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "InstanceIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceIamMemberProps): any {
    return {
      ...InstanceIamMember.GVK,
      ...toJson_InstanceIamMemberProps(props),
    };
  }

  /**
   * Defines a "InstanceIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceIamMemberProps) {
    super(scope, id, {
      ...InstanceIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceIamMember.GVK,
      ...toJson_InstanceIamMemberProps(resolved),
    };
  }
}

/**
 * InstanceIAMMember is the Schema for the InstanceIAMMembers API. <no value>
 *
 * @schema InstanceIAMMember
 */
export interface InstanceIamMemberProps {
  /**
   * @schema InstanceIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceIAMMemberSpec defines the desired state of InstanceIAMMember
   *
   * @schema InstanceIAMMember#spec
   */
  readonly spec: InstanceIamMemberSpec;

}

/**
 * Converts an object of type 'InstanceIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberProps(obj: InstanceIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceIAMMemberSpec defines the desired state of InstanceIAMMember
 *
 * @schema InstanceIamMemberSpec
 */
export interface InstanceIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema InstanceIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceIamMemberSpecDeletionPolicy;

  /**
   * @schema InstanceIamMemberSpec#forProvider
   */
  readonly forProvider: InstanceIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema InstanceIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema InstanceIamMemberSpec#providerRef
   */
  readonly providerRef?: InstanceIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema InstanceIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema InstanceIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpec(obj: InstanceIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_InstanceIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_InstanceIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_InstanceIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema InstanceIamMemberSpecDeletionPolicy
 */
export enum InstanceIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceIamMemberSpecForProvider
 */
export interface InstanceIamMemberSpecForProvider {
  /**
   * @schema InstanceIamMemberSpecForProvider#condition
   */
  readonly condition?: InstanceIamMemberSpecForProviderCondition[];

  /**
   * @schema InstanceIamMemberSpecForProvider#instanceName
   */
  readonly instanceName?: string;

  /**
   * Reference to a Instance to populate instanceName.
   *
   * @schema InstanceIamMemberSpecForProvider#instanceNameRef
   */
  readonly instanceNameRef?: InstanceIamMemberSpecForProviderInstanceNameRef;

  /**
   * Selector for a Instance to populate instanceName.
   *
   * @schema InstanceIamMemberSpecForProvider#instanceNameSelector
   */
  readonly instanceNameSelector?: InstanceIamMemberSpecForProviderInstanceNameSelector;

  /**
   * @schema InstanceIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema InstanceIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema InstanceIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema InstanceIamMemberSpecForProvider#role
   */
  readonly role: string;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecForProvider(obj: InstanceIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_InstanceIamMemberSpecForProviderCondition(y)),
    'instanceName': obj.instanceName,
    'instanceNameRef': toJson_InstanceIamMemberSpecForProviderInstanceNameRef(obj.instanceNameRef),
    'instanceNameSelector': toJson_InstanceIamMemberSpecForProviderInstanceNameSelector(obj.instanceNameSelector),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema InstanceIamMemberSpecProviderConfigRef
 */
export interface InstanceIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecProviderConfigRef(obj: InstanceIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema InstanceIamMemberSpecProviderRef
 */
export interface InstanceIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceIamMemberSpecProviderRef#policy
   */
  readonly policy?: InstanceIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecProviderRef(obj: InstanceIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema InstanceIamMemberSpecPublishConnectionDetailsTo
 */
export interface InstanceIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecPublishConnectionDetailsTo(obj: InstanceIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema InstanceIamMemberSpecWriteConnectionSecretToRef
 */
export interface InstanceIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecWriteConnectionSecretToRef(obj: InstanceIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceIamMemberSpecForProviderCondition
 */
export interface InstanceIamMemberSpecForProviderCondition {
  /**
   * @schema InstanceIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema InstanceIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema InstanceIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecForProviderCondition(obj: InstanceIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Instance to populate instanceName.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameRef
 */
export interface InstanceIamMemberSpecForProviderInstanceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameRef#policy
   */
  readonly policy?: InstanceIamMemberSpecForProviderInstanceNameRefPolicy;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecForProviderInstanceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecForProviderInstanceNameRef(obj: InstanceIamMemberSpecForProviderInstanceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceIamMemberSpecForProviderInstanceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Instance to populate instanceName.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameSelector
 */
export interface InstanceIamMemberSpecForProviderInstanceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameSelector#policy
   */
  readonly policy?: InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecForProviderInstanceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecForProviderInstanceNameSelector(obj: InstanceIamMemberSpecForProviderInstanceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceIamMemberSpecProviderConfigRefPolicy
 */
export interface InstanceIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecProviderConfigRefPolicy(obj: InstanceIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceIamMemberSpecProviderRefPolicy
 */
export interface InstanceIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: InstanceIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: InstanceIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecProviderRefPolicy(obj: InstanceIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecPublishConnectionDetailsToConfigRef(obj: InstanceIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecPublishConnectionDetailsToMetadata(obj: InstanceIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameRefPolicy
 */
export interface InstanceIamMemberSpecForProviderInstanceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameRefPolicy#resolution
   */
  readonly resolution?: InstanceIamMemberSpecForProviderInstanceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameRefPolicy#resolve
   */
  readonly resolve?: InstanceIamMemberSpecForProviderInstanceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecForProviderInstanceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecForProviderInstanceNameRefPolicy(obj: InstanceIamMemberSpecForProviderInstanceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy
 */
export interface InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy#resolution
   */
  readonly resolution?: InstanceIamMemberSpecForProviderInstanceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy#resolve
   */
  readonly resolve?: InstanceIamMemberSpecForProviderInstanceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy(obj: InstanceIamMemberSpecForProviderInstanceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum InstanceIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum InstanceIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceIamMemberSpecProviderRefPolicyResolution
 */
export enum InstanceIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceIamMemberSpecProviderRefPolicyResolve
 */
export enum InstanceIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameRefPolicyResolution
 */
export enum InstanceIamMemberSpecForProviderInstanceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameRefPolicyResolve
 */
export enum InstanceIamMemberSpecForProviderInstanceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameSelectorPolicyResolution
 */
export enum InstanceIamMemberSpecForProviderInstanceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceIamMemberSpecForProviderInstanceNameSelectorPolicyResolve
 */
export enum InstanceIamMemberSpecForProviderInstanceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Runtime is the Schema for the Runtimes API. A Cloud AI Platform Notebook runtime.
 *
 * @schema Runtime
 */
export class Runtime extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Runtime"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notebooks.gcp.upbound.io/v1beta1',
    kind: 'Runtime',
  }

  /**
   * Renders a Kubernetes manifest for "Runtime".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuntimeProps): any {
    return {
      ...Runtime.GVK,
      ...toJson_RuntimeProps(props),
    };
  }

  /**
   * Defines a "Runtime" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuntimeProps) {
    super(scope, id, {
      ...Runtime.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Runtime.GVK,
      ...toJson_RuntimeProps(resolved),
    };
  }
}

/**
 * Runtime is the Schema for the Runtimes API. A Cloud AI Platform Notebook runtime.
 *
 * @schema Runtime
 */
export interface RuntimeProps {
  /**
   * @schema Runtime#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuntimeSpec defines the desired state of Runtime
   *
   * @schema Runtime#spec
   */
  readonly spec: RuntimeSpec;

}

/**
 * Converts an object of type 'RuntimeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeProps(obj: RuntimeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuntimeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuntimeSpec defines the desired state of Runtime
 *
 * @schema RuntimeSpec
 */
export interface RuntimeSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RuntimeSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuntimeSpecDeletionPolicy;

  /**
   * @schema RuntimeSpec#forProvider
   */
  readonly forProvider: RuntimeSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuntimeSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuntimeSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuntimeSpec#providerRef
   */
  readonly providerRef?: RuntimeSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuntimeSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuntimeSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuntimeSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuntimeSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuntimeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpec(obj: RuntimeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuntimeSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RuntimeSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuntimeSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuntimeSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuntimeSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RuntimeSpecDeletionPolicy
 */
export enum RuntimeSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuntimeSpecForProvider
 */
export interface RuntimeSpecForProvider {
  /**
   * The config settings for accessing runtime. Structure is documented below.
   *
   * @schema RuntimeSpecForProvider#accessConfig
   */
  readonly accessConfig?: RuntimeSpecForProviderAccessConfig[];

  /**
   * A reference to the zone where the machine resides.
   *
   * @schema RuntimeSpecForProvider#location
   */
  readonly location: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema RuntimeSpecForProvider#project
   */
  readonly project?: string;

  /**
   * The config settings for software inside the runtime. Structure is documented below.
   *
   * @schema RuntimeSpecForProvider#softwareConfig
   */
  readonly softwareConfig?: RuntimeSpecForProviderSoftwareConfig[];

  /**
   * Use a Compute Engine VM image to start the managed notebook instance. Structure is documented below.
   *
   * @schema RuntimeSpecForProvider#virtualMachine
   */
  readonly virtualMachine?: RuntimeSpecForProviderVirtualMachine[];

}

/**
 * Converts an object of type 'RuntimeSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProvider(obj: RuntimeSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessConfig': obj.accessConfig?.map(y => toJson_RuntimeSpecForProviderAccessConfig(y)),
    'location': obj.location,
    'project': obj.project,
    'softwareConfig': obj.softwareConfig?.map(y => toJson_RuntimeSpecForProviderSoftwareConfig(y)),
    'virtualMachine': obj.virtualMachine?.map(y => toJson_RuntimeSpecForProviderVirtualMachine(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuntimeSpecProviderConfigRef
 */
export interface RuntimeSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuntimeSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuntimeSpecProviderConfigRef#policy
   */
  readonly policy?: RuntimeSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuntimeSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecProviderConfigRef(obj: RuntimeSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuntimeSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuntimeSpecProviderRef
 */
export interface RuntimeSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuntimeSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuntimeSpecProviderRef#policy
   */
  readonly policy?: RuntimeSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuntimeSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecProviderRef(obj: RuntimeSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuntimeSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuntimeSpecPublishConnectionDetailsTo
 */
export interface RuntimeSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuntimeSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuntimeSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuntimeSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuntimeSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuntimeSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuntimeSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecPublishConnectionDetailsTo(obj: RuntimeSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuntimeSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuntimeSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuntimeSpecWriteConnectionSecretToRef
 */
export interface RuntimeSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuntimeSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuntimeSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuntimeSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecWriteConnectionSecretToRef(obj: RuntimeSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderAccessConfig
 */
export interface RuntimeSpecForProviderAccessConfig {
  /**
   * The type of access mode this instance. For valid values, see https://cloud.google.com/vertex-ai/docs/workbench/reference/ rest/v1/projects.locations.runtimes#RuntimeAccessType.
   *
   * @schema RuntimeSpecForProviderAccessConfig#accessType
   */
  readonly accessType?: string;

  /**
   * The owner of this runtime after creation. Format: alias@example.com. Currently supports one owner only.
   *
   * @schema RuntimeSpecForProviderAccessConfig#runtimeOwner
   */
  readonly runtimeOwner?: string;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderAccessConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderAccessConfig(obj: RuntimeSpecForProviderAccessConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessType': obj.accessType,
    'runtimeOwner': obj.runtimeOwner,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderSoftwareConfig
 */
export interface RuntimeSpecForProviderSoftwareConfig {
  /**
   * Specify a custom Cloud Storage path where the GPU driver is stored. If not specified, we'll automatically choose from official GPU drivers.
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#customGpuDriverPath
   */
  readonly customGpuDriverPath?: string;

  /**
   * Verifies core internal services are running. Default: True.
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#enableHealthMonitoring
   */
  readonly enableHealthMonitoring?: boolean;

  /**
   * Runtime will automatically shutdown after idle_shutdown_time. Default: True
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#idleShutdown
   */
  readonly idleShutdown?: boolean;

  /**
   * Time in minutes to wait before shuting down runtime. Default: 180 minutes
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#idleShutdownTimeout
   */
  readonly idleShutdownTimeout?: number;

  /**
   * Install Nvidia Driver automatically.
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#installGpuDriver
   */
  readonly installGpuDriver?: boolean;

  /**
   * Use a list of container images to use as Kernels in the notebook instance. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#kernels
   */
  readonly kernels?: RuntimeSpecForProviderSoftwareConfigKernels[];

  /**
   * Cron expression in UTC timezone for schedule instance auto upgrade. Please follow the cron format.
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#notebookUpgradeSchedule
   */
  readonly notebookUpgradeSchedule?: string;

  /**
   * Path to a Bash script that automatically runs after a notebook instance fully boots up. The path must be a URL or Cloud Storage path (gs://path-to-file/file-name).
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#postStartupScript
   */
  readonly postStartupScript?: string;

  /**
   * Behavior for the post startup script. Possible values are POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED, RUN_EVERY_START, and DOWNLOAD_AND_RUN_EVERY_START.
   *
   * @schema RuntimeSpecForProviderSoftwareConfig#postStartupScriptBehavior
   */
  readonly postStartupScriptBehavior?: string;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderSoftwareConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderSoftwareConfig(obj: RuntimeSpecForProviderSoftwareConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customGpuDriverPath': obj.customGpuDriverPath,
    'enableHealthMonitoring': obj.enableHealthMonitoring,
    'idleShutdown': obj.idleShutdown,
    'idleShutdownTimeout': obj.idleShutdownTimeout,
    'installGpuDriver': obj.installGpuDriver,
    'kernels': obj.kernels?.map(y => toJson_RuntimeSpecForProviderSoftwareConfigKernels(y)),
    'notebookUpgradeSchedule': obj.notebookUpgradeSchedule,
    'postStartupScript': obj.postStartupScript,
    'postStartupScriptBehavior': obj.postStartupScriptBehavior,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderVirtualMachine
 */
export interface RuntimeSpecForProviderVirtualMachine {
  /**
   * Virtual Machine configuration settings. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderVirtualMachine#virtualMachineConfig
   */
  readonly virtualMachineConfig?: RuntimeSpecForProviderVirtualMachineVirtualMachineConfig[];

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachine' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachine(obj: RuntimeSpecForProviderVirtualMachine | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'virtualMachineConfig': obj.virtualMachineConfig?.map(y => toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfig(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuntimeSpecProviderConfigRefPolicy
 */
export interface RuntimeSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuntimeSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuntimeSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecProviderConfigRefPolicy(obj: RuntimeSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuntimeSpecProviderRefPolicy
 */
export interface RuntimeSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuntimeSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuntimeSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecProviderRefPolicy(obj: RuntimeSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuntimeSpecPublishConnectionDetailsToConfigRef
 */
export interface RuntimeSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuntimeSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuntimeSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuntimeSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuntimeSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecPublishConnectionDetailsToConfigRef(obj: RuntimeSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuntimeSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuntimeSpecPublishConnectionDetailsToMetadata
 */
export interface RuntimeSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuntimeSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuntimeSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuntimeSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuntimeSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecPublishConnectionDetailsToMetadata(obj: RuntimeSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderSoftwareConfigKernels
 */
export interface RuntimeSpecForProviderSoftwareConfigKernels {
  /**
   * The path to the container image repository. For example: gcr.io/{project_id}/{imageName}
   *
   * @schema RuntimeSpecForProviderSoftwareConfigKernels#repository
   */
  readonly repository: string;

  /**
   * The tag of the container image. If not specified, this defaults to the latest tag.
   *
   * @schema RuntimeSpecForProviderSoftwareConfigKernels#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderSoftwareConfigKernels' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderSoftwareConfigKernels(obj: RuntimeSpecForProviderSoftwareConfigKernels | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig
 */
export interface RuntimeSpecForProviderVirtualMachineVirtualMachineConfig {
  /**
   * The Compute Engine accelerator configuration for this runtime. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#acceleratorConfig
   */
  readonly acceleratorConfig?: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig[];

  /**
   * Use a list of container images to start the notebook instance. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#containerImages
   */
  readonly containerImages?: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages[];

  /**
   * Data disk option configuration settings. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#dataDisk
   */
  readonly dataDisk: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk[];

  /**
   * Encryption settings for virtual machine data disk. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#encryptionConfig
   */
  readonly encryptionConfig?: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig[];

  /**
   * If true, runtime will only have internal IP addresses. By default, runtimes are not restricted to internal IP addresses, and will have ephemeral external IP addresses assigned to each vm. This internal_ip_only restriction can only be enabled for subnetwork enabled networks, and all dependencies must be configured to be accessible without external IP addresses.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#internalIpOnly
   */
  readonly internalIpOnly?: boolean;

  /**
   * The labels to associate with this runtime. Label keys must contain 1 to 63 characters, and must conform to [RFC 1035] (https://www.ietf.org/rfc/rfc1035.txt). Label values may be empty, but, if present, must contain 1 to 63 characters, and must conform to RFC 1035. No more than 32 labels can be associated with a cluster.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The Compute Engine machine type used for runtimes.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#machineType
   */
  readonly machineType: string;

  /**
   * The Compute Engine metadata entries to add to virtual machine. (see [Project and instance metadata](https://cloud.google.com /compute/docs/storing-retrieving-metadata#project_and_instance _metadata)).
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#metadata
   */
  readonly metadata?: { [key: string]: string };

  /**
   * The Compute Engine network to be used for machine communications. Cannot be specified with subnetwork. If neither network nor subnet is specified, the "default" network of the project is used, if it exists. A full URL or partial URI. Examples:
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#network
   */
  readonly network?: string;

  /**
   * The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet. Possible values are UNSPECIFIED_NIC_TYPE, VIRTIO_NET, and GVNIC.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#nicType
   */
  readonly nicType?: string;

  /**
   * Reserved IP Range name is used for VPC Peering. The subnetwork allocation will use the range name if it's assigned.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#reservedIpRange
   */
  readonly reservedIpRange?: string;

  /**
   * Shielded VM Instance configuration settings. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#shieldedInstanceConfig
   */
  readonly shieldedInstanceConfig?: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig[];

  /**
   * The Compute Engine subnetwork to be used for machine communications. Cannot be specified with network. A full URL or partial URI are valid. Examples:
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#subnet
   */
  readonly subnet?: string;

  /**
   * The Compute Engine tags to add to runtime (see [Tagging instances] (https://cloud.google.com/compute/docs/ label-or-tag-resources#tags)).
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfig#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachineVirtualMachineConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfig(obj: RuntimeSpecForProviderVirtualMachineVirtualMachineConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'acceleratorConfig': obj.acceleratorConfig?.map(y => toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig(y)),
    'containerImages': obj.containerImages?.map(y => toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages(y)),
    'dataDisk': obj.dataDisk?.map(y => toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk(y)),
    'encryptionConfig': obj.encryptionConfig?.map(y => toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig(y)),
    'internalIpOnly': obj.internalIpOnly,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'machineType': obj.machineType,
    'metadata': ((obj.metadata) === undefined) ? undefined : (Object.entries(obj.metadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'network': obj.network,
    'nicType': obj.nicType,
    'reservedIpRange': obj.reservedIpRange,
    'shieldedInstanceConfig': obj.shieldedInstanceConfig?.map(y => toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig(y)),
    'subnet': obj.subnet,
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeSpecProviderConfigRefPolicyResolution
 */
export enum RuntimeSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeSpecProviderConfigRefPolicyResolve
 */
export enum RuntimeSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeSpecProviderRefPolicyResolution
 */
export enum RuntimeSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeSpecProviderRefPolicyResolve
 */
export enum RuntimeSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuntimeSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuntimeSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuntimeSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuntimeSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuntimeSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig
 */
export interface RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig {
  /**
   * Count of cores of this accelerator.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig#coreCount
   */
  readonly coreCount?: number;

  /**
   * Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig(obj: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigAcceleratorConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coreCount': obj.coreCount,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages
 */
export interface RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages {
  /**
   * The path to the container image repository. For example: gcr.io/{project_id}/{imageName}
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages#repository
   */
  readonly repository: string;

  /**
   * The tag of the container image. If not specified, this defaults to the latest tag.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages(obj: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigContainerImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'repository': obj.repository,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk
 */
export interface RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk {
  /**
   * Input only. Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance. This property is mutually exclusive with the source property; you can only define one or the other, but not both. Structure is documented below.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk#initializeParams
   */
  readonly initializeParams?: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams[];

  /**
   * "Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. Persistent disks must always use SCSI and the request will fail if you attempt to attach a persistent disk in any other format than SCSI. Local SSDs can use either NVME or SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance. Valid values: * NVME * SCSI".
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk#interface
   */
  readonly interface?: string;

  /**
   * The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk#mode
   */
  readonly mode?: string;

  /**
   * Specifies a valid partial or full URL to an existing Persistent Disk resource.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk#source
   */
  readonly source?: string;

  /**
   * Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk(obj: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDisk | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'initializeParams': obj.initializeParams?.map(y => toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams(y)),
    'interface': obj.interface,
    'mode': obj.mode,
    'source': obj.source,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig
 */
export interface RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig {
  /**
   * The Cloud KMS resource identifier of the customer-managed encryption key used to protect a resource, such as a disks. It has the following format: projects/{PROJECT_ID}/locations/{REGION}/keyRings/ {KEY_RING_NAME}/cryptoKeys/{KEY_NAME}
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig#kmsKey
   */
  readonly kmsKey?: string;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig(obj: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigEncryptionConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kmsKey': obj.kmsKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig
 */
export interface RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig {
  /**
   * Defines whether the instance has integrity monitoring enabled. Enables monitoring and attestation of the boot integrity of the instance. The attestation is performed against the integrity policy baseline. This baseline is initially derived from the implicitly trusted boot image when the instance is created. Enabled by default.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig#enableIntegrityMonitoring
   */
  readonly enableIntegrityMonitoring?: boolean;

  /**
   * Defines whether the instance has Secure Boot enabled.Secure Boot helps ensure that the system only runs authentic software by verifying the digital signature of all boot components, and halting the boot process if signature verification fails. Disabled by default.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig#enableSecureBoot
   */
  readonly enableSecureBoot?: boolean;

  /**
   * Defines whether the instance has the vTPM enabled. Enabled by default.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig#enableVtpm
   */
  readonly enableVtpm?: boolean;

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig(obj: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigShieldedInstanceConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enableIntegrityMonitoring': obj.enableIntegrityMonitoring,
    'enableSecureBoot': obj.enableSecureBoot,
    'enableVtpm': obj.enableVtpm,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuntimeSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuntimeSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams
 */
export interface RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams {
  /**
   * Provide this property when creating the disk.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams#description
   */
  readonly description?: string;

  /**
   * Specifies the disk name. If not specified, the default is to use the name of the instance. If the disk with the instance name exists already in the given zone/region, a new name will be automatically generated.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams#diskName
   */
  readonly diskName?: string;

  /**
   * Specifies the size of the disk in base-2 GB. If not specified, the disk will be the same size as the image (usually 10GB). If specified, the size must be equal to or larger than 10GB. Default 100 GB.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams#diskSizeGb
   */
  readonly diskSizeGb?: number;

  /**
   * The type of the boot disk attached to this runtime, defaults to standard persistent disk. For valid values, see https://cloud.google.com/vertex-ai/docs/workbench/ reference/rest/v1/projects.locations.runtimes#disktype
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams#diskType
   */
  readonly diskType?: string;

  /**
   * The labels to associate with this runtime. Label keys must contain 1 to 63 characters, and must conform to [RFC 1035] (https://www.ietf.org/rfc/rfc1035.txt). Label values may be empty, but, if present, must contain 1 to 63 characters, and must conform to RFC 1035. No more than 32 labels can be associated with a cluster.
   *
   * @schema RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams(obj: RuntimeSpecForProviderVirtualMachineVirtualMachineConfigDataDiskInitializeParams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'diskName': obj.diskName,
    'diskSizeGb': obj.diskSizeGb,
    'diskType': obj.diskType,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * RuntimeIAMMember is the Schema for the RuntimeIAMMembers API. <no value>
 *
 * @schema RuntimeIAMMember
 */
export class RuntimeIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RuntimeIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'notebooks.gcp.upbound.io/v1beta1',
    kind: 'RuntimeIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "RuntimeIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RuntimeIamMemberProps): any {
    return {
      ...RuntimeIamMember.GVK,
      ...toJson_RuntimeIamMemberProps(props),
    };
  }

  /**
   * Defines a "RuntimeIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RuntimeIamMemberProps) {
    super(scope, id, {
      ...RuntimeIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RuntimeIamMember.GVK,
      ...toJson_RuntimeIamMemberProps(resolved),
    };
  }
}

/**
 * RuntimeIAMMember is the Schema for the RuntimeIAMMembers API. <no value>
 *
 * @schema RuntimeIAMMember
 */
export interface RuntimeIamMemberProps {
  /**
   * @schema RuntimeIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RuntimeIAMMemberSpec defines the desired state of RuntimeIAMMember
   *
   * @schema RuntimeIAMMember#spec
   */
  readonly spec: RuntimeIamMemberSpec;

}

/**
 * Converts an object of type 'RuntimeIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberProps(obj: RuntimeIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RuntimeIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RuntimeIAMMemberSpec defines the desired state of RuntimeIAMMember
 *
 * @schema RuntimeIamMemberSpec
 */
export interface RuntimeIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RuntimeIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: RuntimeIamMemberSpecDeletionPolicy;

  /**
   * @schema RuntimeIamMemberSpec#forProvider
   */
  readonly forProvider: RuntimeIamMemberSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RuntimeIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: RuntimeIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RuntimeIamMemberSpec#providerRef
   */
  readonly providerRef?: RuntimeIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RuntimeIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RuntimeIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RuntimeIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RuntimeIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpec(obj: RuntimeIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RuntimeIamMemberSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RuntimeIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RuntimeIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RuntimeIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RuntimeIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RuntimeIamMemberSpecDeletionPolicy
 */
export enum RuntimeIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RuntimeIamMemberSpecForProvider
 */
export interface RuntimeIamMemberSpecForProvider {
  /**
   * @schema RuntimeIamMemberSpecForProvider#condition
   */
  readonly condition?: RuntimeIamMemberSpecForProviderCondition[];

  /**
   * @schema RuntimeIamMemberSpecForProvider#location
   */
  readonly location?: string;

  /**
   * @schema RuntimeIamMemberSpecForProvider#member
   */
  readonly member: string;

  /**
   * @schema RuntimeIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema RuntimeIamMemberSpecForProvider#role
   */
  readonly role: string;

  /**
   * @schema RuntimeIamMemberSpecForProvider#runtimeName
   */
  readonly runtimeName?: string;

  /**
   * Reference to a Runtime to populate runtimeName.
   *
   * @schema RuntimeIamMemberSpecForProvider#runtimeNameRef
   */
  readonly runtimeNameRef?: RuntimeIamMemberSpecForProviderRuntimeNameRef;

  /**
   * Selector for a Runtime to populate runtimeName.
   *
   * @schema RuntimeIamMemberSpecForProvider#runtimeNameSelector
   */
  readonly runtimeNameSelector?: RuntimeIamMemberSpecForProviderRuntimeNameSelector;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecForProvider(obj: RuntimeIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_RuntimeIamMemberSpecForProviderCondition(y)),
    'location': obj.location,
    'member': obj.member,
    'project': obj.project,
    'role': obj.role,
    'runtimeName': obj.runtimeName,
    'runtimeNameRef': toJson_RuntimeIamMemberSpecForProviderRuntimeNameRef(obj.runtimeNameRef),
    'runtimeNameSelector': toJson_RuntimeIamMemberSpecForProviderRuntimeNameSelector(obj.runtimeNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RuntimeIamMemberSpecProviderConfigRef
 */
export interface RuntimeIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuntimeIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuntimeIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: RuntimeIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecProviderConfigRef(obj: RuntimeIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuntimeIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RuntimeIamMemberSpecProviderRef
 */
export interface RuntimeIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuntimeIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuntimeIamMemberSpecProviderRef#policy
   */
  readonly policy?: RuntimeIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecProviderRef(obj: RuntimeIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuntimeIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RuntimeIamMemberSpecPublishConnectionDetailsTo
 */
export interface RuntimeIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RuntimeIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecPublishConnectionDetailsTo(obj: RuntimeIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RuntimeIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RuntimeIamMemberSpecWriteConnectionSecretToRef
 */
export interface RuntimeIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RuntimeIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RuntimeIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecWriteConnectionSecretToRef(obj: RuntimeIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RuntimeIamMemberSpecForProviderCondition
 */
export interface RuntimeIamMemberSpecForProviderCondition {
  /**
   * @schema RuntimeIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema RuntimeIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema RuntimeIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecForProviderCondition(obj: RuntimeIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Runtime to populate runtimeName.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameRef
 */
export interface RuntimeIamMemberSpecForProviderRuntimeNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameRef#policy
   */
  readonly policy?: RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecForProviderRuntimeNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecForProviderRuntimeNameRef(obj: RuntimeIamMemberSpecForProviderRuntimeNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Runtime to populate runtimeName.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelector
 */
export interface RuntimeIamMemberSpecForProviderRuntimeNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelector#policy
   */
  readonly policy?: RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecForProviderRuntimeNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecForProviderRuntimeNameSelector(obj: RuntimeIamMemberSpecForProviderRuntimeNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuntimeIamMemberSpecProviderConfigRefPolicy
 */
export interface RuntimeIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RuntimeIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RuntimeIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecProviderConfigRefPolicy(obj: RuntimeIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuntimeIamMemberSpecProviderRefPolicy
 */
export interface RuntimeIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RuntimeIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RuntimeIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecProviderRefPolicy(obj: RuntimeIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef(obj: RuntimeIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RuntimeIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface RuntimeIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecPublishConnectionDetailsToMetadata(obj: RuntimeIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy
 */
export interface RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy#resolution
   */
  readonly resolution?: RuntimeIamMemberSpecForProviderRuntimeNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy#resolve
   */
  readonly resolve?: RuntimeIamMemberSpecForProviderRuntimeNameRefPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy(obj: RuntimeIamMemberSpecForProviderRuntimeNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy
 */
export interface RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy#resolution
   */
  readonly resolution?: RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy#resolve
   */
  readonly resolve?: RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy(obj: RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum RuntimeIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum RuntimeIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeIamMemberSpecProviderRefPolicyResolution
 */
export enum RuntimeIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeIamMemberSpecProviderRefPolicyResolve
 */
export enum RuntimeIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameRefPolicyResolution
 */
export enum RuntimeIamMemberSpecForProviderRuntimeNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameRefPolicyResolve
 */
export enum RuntimeIamMemberSpecForProviderRuntimeNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicyResolution
 */
export enum RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicyResolve
 */
export enum RuntimeIamMemberSpecForProviderRuntimeNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RuntimeIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

