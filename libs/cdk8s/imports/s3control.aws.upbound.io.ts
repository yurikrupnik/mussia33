// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccessPoint is the Schema for the AccessPoints API. Manages an S3 Access Point.
 *
 * @schema AccessPoint
 */
export class AccessPoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessPoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'AccessPoint',
  }

  /**
   * Renders a Kubernetes manifest for "AccessPoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessPointProps): any {
    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(props),
    };
  }

  /**
   * Defines a "AccessPoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessPointProps) {
    super(scope, id, {
      ...AccessPoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessPoint.GVK,
      ...toJson_AccessPointProps(resolved),
    };
  }
}

/**
 * AccessPoint is the Schema for the AccessPoints API. Manages an S3 Access Point.
 *
 * @schema AccessPoint
 */
export interface AccessPointProps {
  /**
   * @schema AccessPoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessPointSpec defines the desired state of AccessPoint
   *
   * @schema AccessPoint#spec
   */
  readonly spec: AccessPointSpec;

}

/**
 * Converts an object of type 'AccessPointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointProps(obj: AccessPointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessPointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessPointSpec defines the desired state of AccessPoint
 *
 * @schema AccessPointSpec
 */
export interface AccessPointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPointSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessPointSpecDeletionPolicy;

  /**
   * @schema AccessPointSpec#forProvider
   */
  readonly forProvider: AccessPointSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPointSpec#managementPolicy
   */
  readonly managementPolicy?: AccessPointSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessPointSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessPointSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccessPointSpec#providerRef
   */
  readonly providerRef?: AccessPointSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessPointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessPointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessPointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessPointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessPointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpec(obj: AccessPointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessPointSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AccessPointSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccessPointSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccessPointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessPointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPointSpecDeletionPolicy
 */
export enum AccessPointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccessPointSpecForProvider
 */
export interface AccessPointSpecForProvider {
  /**
   * AWS account ID for the owner of the bucket for which you want to create an access point.
   *
   * @schema AccessPointSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Name of an AWS Partition S3 Bucket or the ARN of S3 on Outposts Bucket that you want to associate this access point with.
   *
   * @schema AccessPointSpecForProvider#bucket
   */
  readonly bucket?: string;

  /**
   * AWS account ID associated with the S3 bucket associated with this access point.
   *
   * @schema AccessPointSpecForProvider#bucketAccountId
   */
  readonly bucketAccountId?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema AccessPointSpecForProvider#bucketRef
   */
  readonly bucketRef?: AccessPointSpecForProviderBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema AccessPointSpecForProvider#bucketSelector
   */
  readonly bucketSelector?: AccessPointSpecForProviderBucketSelector;

  /**
   * Name you want to assign to this access point.
   *
   * @schema AccessPointSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Valid JSON document that specifies the policy that you want to apply to this access point. Removing policy from your configuration or setting policy to null or an empty string (i.e., policy = "") will not delete the policy since it could have been set by aws_s3control_access_point_policy. To remove the policy, set it to "{}" (an empty JSON document).
   *
   * @schema AccessPointSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Configuration block to manage the PublicAccessBlock configuration that you want to apply to this Amazon S3 bucket. You can enable the configuration options in any combination. Detailed below.
   *
   * @schema AccessPointSpecForProvider#publicAccessBlockConfiguration
   */
  readonly publicAccessBlockConfiguration?: AccessPointSpecForProviderPublicAccessBlockConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccessPointSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block to restrict access to this access point to requests from the specified Virtual Private Cloud (VPC). Required for S3 on Outposts. Detailed below.
   *
   * @schema AccessPointSpecForProvider#vpcConfiguration
   */
  readonly vpcConfiguration?: AccessPointSpecForProviderVpcConfiguration[];

}

/**
 * Converts an object of type 'AccessPointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProvider(obj: AccessPointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'bucket': obj.bucket,
    'bucketAccountId': obj.bucketAccountId,
    'bucketRef': toJson_AccessPointSpecForProviderBucketRef(obj.bucketRef),
    'bucketSelector': toJson_AccessPointSpecForProviderBucketSelector(obj.bucketSelector),
    'name': obj.name,
    'policy': obj.policy,
    'publicAccessBlockConfiguration': obj.publicAccessBlockConfiguration?.map(y => toJson_AccessPointSpecForProviderPublicAccessBlockConfiguration(y)),
    'region': obj.region,
    'vpcConfiguration': obj.vpcConfiguration?.map(y => toJson_AccessPointSpecForProviderVpcConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPointSpecManagementPolicy
 */
export enum AccessPointSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessPointSpecProviderConfigRef
 */
export interface AccessPointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecProviderConfigRef#policy
   */
  readonly policy?: AccessPointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRef(obj: AccessPointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccessPointSpecProviderRef
 */
export interface AccessPointSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecProviderRef#policy
   */
  readonly policy?: AccessPointSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderRef(obj: AccessPointSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessPointSpecPublishConnectionDetailsTo
 */
export interface AccessPointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessPointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessPointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessPointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsTo(obj: AccessPointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessPointSpecWriteConnectionSecretToRef
 */
export interface AccessPointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessPointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessPointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecWriteConnectionSecretToRef(obj: AccessPointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema AccessPointSpecForProviderBucketRef
 */
export interface AccessPointSpecForProviderBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderBucketRef#policy
   */
  readonly policy?: AccessPointSpecForProviderBucketRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketRef(obj: AccessPointSpecForProviderBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema AccessPointSpecForProviderBucketSelector
 */
export interface AccessPointSpecForProviderBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderBucketSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderBucketSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketSelector(obj: AccessPointSpecForProviderBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration
 */
export interface AccessPointSpecForProviderPublicAccessBlockConfiguration {
  /**
   * Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to true. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   *
   * @default true. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#blockPublicAcls
   */
  readonly blockPublicAcls?: boolean;

  /**
   * Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to true. Enabling this setting does not affect existing bucket policies. When set to true causes Amazon S3 to:
   *
   * @default true. Enabling this setting does not affect existing bucket policies. When set to true causes Amazon S3 to:
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to true. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   *
   * @default true. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#ignorePublicAcls
   */
  readonly ignorePublicAcls?: boolean;

  /**
   * Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to true. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   *
   * @default true. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   * @schema AccessPointSpecForProviderPublicAccessBlockConfiguration#restrictPublicBuckets
   */
  readonly restrictPublicBuckets?: boolean;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderPublicAccessBlockConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderPublicAccessBlockConfiguration(obj: AccessPointSpecForProviderPublicAccessBlockConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockPublicAcls': obj.blockPublicAcls,
    'blockPublicPolicy': obj.blockPublicPolicy,
    'ignorePublicAcls': obj.ignorePublicAcls,
    'restrictPublicBuckets': obj.restrictPublicBuckets,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AccessPointSpecForProviderVpcConfiguration
 */
export interface AccessPointSpecForProviderVpcConfiguration {
  /**
   * This access point will only allow connections from the specified VPC ID.
   *
   * @schema AccessPointSpecForProviderVpcConfiguration#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema AccessPointSpecForProviderVpcConfiguration#vpcIdRef
   */
  readonly vpcIdRef?: AccessPointSpecForProviderVpcConfigurationVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema AccessPointSpecForProviderVpcConfiguration#vpcIdSelector
   */
  readonly vpcIdSelector?: AccessPointSpecForProviderVpcConfigurationVpcIdSelector;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderVpcConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderVpcConfiguration(obj: AccessPointSpecForProviderVpcConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_AccessPointSpecForProviderVpcConfigurationVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_AccessPointSpecForProviderVpcConfigurationVpcIdSelector(obj.vpcIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecProviderConfigRefPolicy
 */
export interface AccessPointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderConfigRefPolicy(obj: AccessPointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecProviderRefPolicy
 */
export interface AccessPointSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecProviderRefPolicy(obj: AccessPointSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRef
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRef(obj: AccessPointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToMetadata
 */
export interface AccessPointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToMetadata(obj: AccessPointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderBucketRefPolicy
 */
export interface AccessPointSpecForProviderBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderBucketRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderBucketRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketRefPolicy(obj: AccessPointSpecForProviderBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderBucketSelectorPolicy
 */
export interface AccessPointSpecForProviderBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderBucketSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderBucketSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderBucketSelectorPolicy(obj: AccessPointSpecForProviderBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRef
 */
export interface AccessPointSpecForProviderVpcConfigurationVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRef#policy
   */
  readonly policy?: AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderVpcConfigurationVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderVpcConfigurationVpcIdRef(obj: AccessPointSpecForProviderVpcConfigurationVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelector
 */
export interface AccessPointSpecForProviderVpcConfigurationVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelector#policy
   */
  readonly policy?: AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderVpcConfigurationVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderVpcConfigurationVpcIdSelector(obj: AccessPointSpecForProviderVpcConfigurationVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolution
 */
export enum AccessPointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecProviderConfigRefPolicyResolve
 */
export enum AccessPointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecProviderRefPolicyResolution
 */
export enum AccessPointSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecProviderRefPolicyResolve
 */
export enum AccessPointSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessPointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessPointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderBucketRefPolicyResolution
 */
export enum AccessPointSpecForProviderBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderBucketRefPolicyResolve
 */
export enum AccessPointSpecForProviderBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderBucketSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderBucketSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy
 */
export interface AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy(obj: AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy
 */
export interface AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy(obj: AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicyResolution
 */
export enum AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicyResolve
 */
export enum AccessPointSpecForProviderVpcConfigurationVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicyResolution
 */
export enum AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicyResolve
 */
export enum AccessPointSpecForProviderVpcConfigurationVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AccessPointPolicy is the Schema for the AccessPointPolicys API. Provides a resource to manage an S3 Access Point resource policy.
 *
 * @schema AccessPointPolicy
 */
export class AccessPointPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccessPointPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'AccessPointPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "AccessPointPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccessPointPolicyProps): any {
    return {
      ...AccessPointPolicy.GVK,
      ...toJson_AccessPointPolicyProps(props),
    };
  }

  /**
   * Defines a "AccessPointPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccessPointPolicyProps) {
    super(scope, id, {
      ...AccessPointPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccessPointPolicy.GVK,
      ...toJson_AccessPointPolicyProps(resolved),
    };
  }
}

/**
 * AccessPointPolicy is the Schema for the AccessPointPolicys API. Provides a resource to manage an S3 Access Point resource policy.
 *
 * @schema AccessPointPolicy
 */
export interface AccessPointPolicyProps {
  /**
   * @schema AccessPointPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccessPointPolicySpec defines the desired state of AccessPointPolicy
   *
   * @schema AccessPointPolicy#spec
   */
  readonly spec: AccessPointPolicySpec;

}

/**
 * Converts an object of type 'AccessPointPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicyProps(obj: AccessPointPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccessPointPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessPointPolicySpec defines the desired state of AccessPointPolicy
 *
 * @schema AccessPointPolicySpec
 */
export interface AccessPointPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPointPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: AccessPointPolicySpecDeletionPolicy;

  /**
   * @schema AccessPointPolicySpec#forProvider
   */
  readonly forProvider: AccessPointPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccessPointPolicySpec#managementPolicy
   */
  readonly managementPolicy?: AccessPointPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccessPointPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: AccessPointPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccessPointPolicySpec#providerRef
   */
  readonly providerRef?: AccessPointPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccessPointPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccessPointPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccessPointPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccessPointPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccessPointPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpec(obj: AccessPointPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccessPointPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AccessPointPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccessPointPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccessPointPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccessPointPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPointPolicySpecDeletionPolicy
 */
export enum AccessPointPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccessPointPolicySpecForProvider
 */
export interface AccessPointPolicySpecForProvider {
  /**
   * The ARN of the access point that you want to associate with the specified policy.
   *
   * @schema AccessPointPolicySpecForProvider#accessPointArn
   */
  readonly accessPointArn?: string;

  /**
   * Reference to a AccessPoint in s3control to populate accessPointArn.
   *
   * @schema AccessPointPolicySpecForProvider#accessPointArnRef
   */
  readonly accessPointArnRef?: AccessPointPolicySpecForProviderAccessPointArnRef;

  /**
   * Selector for a AccessPoint in s3control to populate accessPointArn.
   *
   * @schema AccessPointPolicySpecForProvider#accessPointArnSelector
   */
  readonly accessPointArnSelector?: AccessPointPolicySpecForProviderAccessPointArnSelector;

  /**
   * The policy that you want to apply to the specified access point.
   *
   * @schema AccessPointPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccessPointPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AccessPointPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecForProvider(obj: AccessPointPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessPointArn': obj.accessPointArn,
    'accessPointArnRef': toJson_AccessPointPolicySpecForProviderAccessPointArnRef(obj.accessPointArnRef),
    'accessPointArnSelector': toJson_AccessPointPolicySpecForProviderAccessPointArnSelector(obj.accessPointArnSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccessPointPolicySpecManagementPolicy
 */
export enum AccessPointPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccessPointPolicySpecProviderConfigRef
 */
export interface AccessPointPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointPolicySpecProviderConfigRef#policy
   */
  readonly policy?: AccessPointPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecProviderConfigRef(obj: AccessPointPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccessPointPolicySpecProviderRef
 */
export interface AccessPointPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointPolicySpecProviderRef#policy
   */
  readonly policy?: AccessPointPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccessPointPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecProviderRef(obj: AccessPointPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccessPointPolicySpecPublishConnectionDetailsTo
 */
export interface AccessPointPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccessPointPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccessPointPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccessPointPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecPublishConnectionDetailsTo(obj: AccessPointPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccessPointPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccessPointPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccessPointPolicySpecWriteConnectionSecretToRef
 */
export interface AccessPointPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccessPointPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccessPointPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccessPointPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecWriteConnectionSecretToRef(obj: AccessPointPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AccessPoint in s3control to populate accessPointArn.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnRef
 */
export interface AccessPointPolicySpecForProviderAccessPointArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnRef#policy
   */
  readonly policy?: AccessPointPolicySpecForProviderAccessPointArnRefPolicy;

}

/**
 * Converts an object of type 'AccessPointPolicySpecForProviderAccessPointArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecForProviderAccessPointArnRef(obj: AccessPointPolicySpecForProviderAccessPointArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointPolicySpecForProviderAccessPointArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AccessPoint in s3control to populate accessPointArn.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnSelector
 */
export interface AccessPointPolicySpecForProviderAccessPointArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnSelector#policy
   */
  readonly policy?: AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy;

}

/**
 * Converts an object of type 'AccessPointPolicySpecForProviderAccessPointArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecForProviderAccessPointArnSelector(obj: AccessPointPolicySpecForProviderAccessPointArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointPolicySpecProviderConfigRefPolicy
 */
export interface AccessPointPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecProviderConfigRefPolicy(obj: AccessPointPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointPolicySpecProviderRefPolicy
 */
export interface AccessPointPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccessPointPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccessPointPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecProviderRefPolicy(obj: AccessPointPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface AccessPointPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccessPointPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecPublishConnectionDetailsToConfigRef(obj: AccessPointPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccessPointPolicySpecPublishConnectionDetailsToMetadata
 */
export interface AccessPointPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccessPointPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecPublishConnectionDetailsToMetadata(obj: AccessPointPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnRefPolicy
 */
export interface AccessPointPolicySpecForProviderAccessPointArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnRefPolicy#resolution
   */
  readonly resolution?: AccessPointPolicySpecForProviderAccessPointArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnRefPolicy#resolve
   */
  readonly resolve?: AccessPointPolicySpecForProviderAccessPointArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointPolicySpecForProviderAccessPointArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecForProviderAccessPointArnRefPolicy(obj: AccessPointPolicySpecForProviderAccessPointArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy
 */
export interface AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy#resolution
   */
  readonly resolution?: AccessPointPolicySpecForProviderAccessPointArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy#resolve
   */
  readonly resolve?: AccessPointPolicySpecForProviderAccessPointArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy(obj: AccessPointPolicySpecForProviderAccessPointArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointPolicySpecProviderConfigRefPolicyResolution
 */
export enum AccessPointPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointPolicySpecProviderConfigRefPolicyResolve
 */
export enum AccessPointPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointPolicySpecProviderRefPolicyResolution
 */
export enum AccessPointPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointPolicySpecProviderRefPolicyResolve
 */
export enum AccessPointPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnRefPolicyResolution
 */
export enum AccessPointPolicySpecForProviderAccessPointArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnRefPolicyResolve
 */
export enum AccessPointPolicySpecForProviderAccessPointArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnSelectorPolicyResolution
 */
export enum AccessPointPolicySpecForProviderAccessPointArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointPolicySpecForProviderAccessPointArnSelectorPolicyResolve
 */
export enum AccessPointPolicySpecForProviderAccessPointArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * AccountPublicAccessBlock is the Schema for the AccountPublicAccessBlocks API. Manages S3 account-level Public Access Block Configuration
 *
 * @schema AccountPublicAccessBlock
 */
export class AccountPublicAccessBlock extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccountPublicAccessBlock"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'AccountPublicAccessBlock',
  }

  /**
   * Renders a Kubernetes manifest for "AccountPublicAccessBlock".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountPublicAccessBlockProps): any {
    return {
      ...AccountPublicAccessBlock.GVK,
      ...toJson_AccountPublicAccessBlockProps(props),
    };
  }

  /**
   * Defines a "AccountPublicAccessBlock" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountPublicAccessBlockProps) {
    super(scope, id, {
      ...AccountPublicAccessBlock.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccountPublicAccessBlock.GVK,
      ...toJson_AccountPublicAccessBlockProps(resolved),
    };
  }
}

/**
 * AccountPublicAccessBlock is the Schema for the AccountPublicAccessBlocks API. Manages S3 account-level Public Access Block Configuration
 *
 * @schema AccountPublicAccessBlock
 */
export interface AccountPublicAccessBlockProps {
  /**
   * @schema AccountPublicAccessBlock#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountPublicAccessBlockSpec defines the desired state of AccountPublicAccessBlock
   *
   * @schema AccountPublicAccessBlock#spec
   */
  readonly spec: AccountPublicAccessBlockSpec;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockProps(obj: AccountPublicAccessBlockProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountPublicAccessBlockSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountPublicAccessBlockSpec defines the desired state of AccountPublicAccessBlock
 *
 * @schema AccountPublicAccessBlockSpec
 */
export interface AccountPublicAccessBlockSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountPublicAccessBlockSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountPublicAccessBlockSpecDeletionPolicy;

  /**
   * @schema AccountPublicAccessBlockSpec#forProvider
   */
  readonly forProvider: AccountPublicAccessBlockSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountPublicAccessBlockSpec#managementPolicy
   */
  readonly managementPolicy?: AccountPublicAccessBlockSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AccountPublicAccessBlockSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountPublicAccessBlockSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema AccountPublicAccessBlockSpec#providerRef
   */
  readonly providerRef?: AccountPublicAccessBlockSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AccountPublicAccessBlockSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountPublicAccessBlockSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AccountPublicAccessBlockSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountPublicAccessBlockSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpec(obj: AccountPublicAccessBlockSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountPublicAccessBlockSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_AccountPublicAccessBlockSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_AccountPublicAccessBlockSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountPublicAccessBlockSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountPublicAccessBlockSpecDeletionPolicy
 */
export enum AccountPublicAccessBlockSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountPublicAccessBlockSpecForProvider
 */
export interface AccountPublicAccessBlockSpecForProvider {
  /**
   * AWS account ID to configure.
   *
   * @schema AccountPublicAccessBlockSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to false. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   *
   * @default false. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   * @schema AccountPublicAccessBlockSpecForProvider#blockPublicAcls
   */
  readonly blockPublicAcls?: boolean;

  /**
   * Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to false. Enabling this setting does not affect existing bucket policies. When set to true causes Amazon S3 to:
   *
   * @default false. Enabling this setting does not affect existing bucket policies. When set to true causes Amazon S3 to:
   * @schema AccountPublicAccessBlockSpecForProvider#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to false. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   *
   * @default false. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   * @schema AccountPublicAccessBlockSpecForProvider#ignorePublicAcls
   */
  readonly ignorePublicAcls?: boolean;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountPublicAccessBlockSpecForProvider#region
   */
  readonly region: string;

  /**
   * Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to false. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   *
   * @default false. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   * @schema AccountPublicAccessBlockSpecForProvider#restrictPublicBuckets
   */
  readonly restrictPublicBuckets?: boolean;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecForProvider(obj: AccountPublicAccessBlockSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'blockPublicAcls': obj.blockPublicAcls,
    'blockPublicPolicy': obj.blockPublicPolicy,
    'ignorePublicAcls': obj.ignorePublicAcls,
    'region': obj.region,
    'restrictPublicBuckets': obj.restrictPublicBuckets,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountPublicAccessBlockSpecManagementPolicy
 */
export enum AccountPublicAccessBlockSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AccountPublicAccessBlockSpecProviderConfigRef
 */
export interface AccountPublicAccessBlockSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountPublicAccessBlockSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountPublicAccessBlockSpecProviderConfigRef#policy
   */
  readonly policy?: AccountPublicAccessBlockSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecProviderConfigRef(obj: AccountPublicAccessBlockSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountPublicAccessBlockSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema AccountPublicAccessBlockSpecProviderRef
 */
export interface AccountPublicAccessBlockSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountPublicAccessBlockSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountPublicAccessBlockSpecProviderRef#policy
   */
  readonly policy?: AccountPublicAccessBlockSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecProviderRef(obj: AccountPublicAccessBlockSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountPublicAccessBlockSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsTo
 */
export interface AccountPublicAccessBlockSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsTo(obj: AccountPublicAccessBlockSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AccountPublicAccessBlockSpecWriteConnectionSecretToRef
 */
export interface AccountPublicAccessBlockSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountPublicAccessBlockSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountPublicAccessBlockSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecWriteConnectionSecretToRef(obj: AccountPublicAccessBlockSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountPublicAccessBlockSpecProviderConfigRefPolicy
 */
export interface AccountPublicAccessBlockSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountPublicAccessBlockSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountPublicAccessBlockSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountPublicAccessBlockSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountPublicAccessBlockSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecProviderConfigRefPolicy(obj: AccountPublicAccessBlockSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountPublicAccessBlockSpecProviderRefPolicy
 */
export interface AccountPublicAccessBlockSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountPublicAccessBlockSpecProviderRefPolicy#resolution
   */
  readonly resolution?: AccountPublicAccessBlockSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountPublicAccessBlockSpecProviderRefPolicy#resolve
   */
  readonly resolve?: AccountPublicAccessBlockSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecProviderRefPolicy(obj: AccountPublicAccessBlockSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef(obj: AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata
 */
export interface AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata(obj: AccountPublicAccessBlockSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountPublicAccessBlockSpecProviderConfigRefPolicyResolution
 */
export enum AccountPublicAccessBlockSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountPublicAccessBlockSpecProviderConfigRefPolicyResolve
 */
export enum AccountPublicAccessBlockSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountPublicAccessBlockSpecProviderRefPolicyResolution
 */
export enum AccountPublicAccessBlockSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountPublicAccessBlockSpecProviderRefPolicyResolve
 */
export enum AccountPublicAccessBlockSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountPublicAccessBlockSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MultiRegionAccessPoint is the Schema for the MultiRegionAccessPoints API. Provides a resource to manage an S3 Multi-Region Access Point associated with specified buckets.
 *
 * @schema MultiRegionAccessPoint
 */
export class MultiRegionAccessPoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MultiRegionAccessPoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'MultiRegionAccessPoint',
  }

  /**
   * Renders a Kubernetes manifest for "MultiRegionAccessPoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MultiRegionAccessPointProps): any {
    return {
      ...MultiRegionAccessPoint.GVK,
      ...toJson_MultiRegionAccessPointProps(props),
    };
  }

  /**
   * Defines a "MultiRegionAccessPoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MultiRegionAccessPointProps) {
    super(scope, id, {
      ...MultiRegionAccessPoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MultiRegionAccessPoint.GVK,
      ...toJson_MultiRegionAccessPointProps(resolved),
    };
  }
}

/**
 * MultiRegionAccessPoint is the Schema for the MultiRegionAccessPoints API. Provides a resource to manage an S3 Multi-Region Access Point associated with specified buckets.
 *
 * @schema MultiRegionAccessPoint
 */
export interface MultiRegionAccessPointProps {
  /**
   * @schema MultiRegionAccessPoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MultiRegionAccessPointSpec defines the desired state of MultiRegionAccessPoint
   *
   * @schema MultiRegionAccessPoint#spec
   */
  readonly spec: MultiRegionAccessPointSpec;

}

/**
 * Converts an object of type 'MultiRegionAccessPointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointProps(obj: MultiRegionAccessPointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MultiRegionAccessPointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MultiRegionAccessPointSpec defines the desired state of MultiRegionAccessPoint
 *
 * @schema MultiRegionAccessPointSpec
 */
export interface MultiRegionAccessPointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MultiRegionAccessPointSpec#deletionPolicy
   */
  readonly deletionPolicy?: MultiRegionAccessPointSpecDeletionPolicy;

  /**
   * @schema MultiRegionAccessPointSpec#forProvider
   */
  readonly forProvider: MultiRegionAccessPointSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MultiRegionAccessPointSpec#managementPolicy
   */
  readonly managementPolicy?: MultiRegionAccessPointSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MultiRegionAccessPointSpec#providerConfigRef
   */
  readonly providerConfigRef?: MultiRegionAccessPointSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MultiRegionAccessPointSpec#providerRef
   */
  readonly providerRef?: MultiRegionAccessPointSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MultiRegionAccessPointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MultiRegionAccessPointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MultiRegionAccessPointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MultiRegionAccessPointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpec(obj: MultiRegionAccessPointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MultiRegionAccessPointSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MultiRegionAccessPointSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MultiRegionAccessPointSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MultiRegionAccessPointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MultiRegionAccessPointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MultiRegionAccessPointSpecDeletionPolicy
 */
export enum MultiRegionAccessPointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MultiRegionAccessPointSpecForProvider
 */
export interface MultiRegionAccessPointSpecForProvider {
  /**
   * The AWS account ID for the owner of the buckets for which you want to create a Multi-Region Access Point.
   *
   * @schema MultiRegionAccessPointSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * A configuration block containing details about the Multi-Region Access Point. See Details Configuration Block below for more details
   *
   * @schema MultiRegionAccessPointSpecForProvider#details
   */
  readonly details?: MultiRegionAccessPointSpecForProviderDetails[];

  /**
   * The Region configuration block to specify the bucket associated with the Multi-Region Access Point. See Region Configuration below for more details. Region is the region you'd like your resource to be created in.
   *
   * @schema MultiRegionAccessPointSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProvider(obj: MultiRegionAccessPointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'details': obj.details?.map(y => toJson_MultiRegionAccessPointSpecForProviderDetails(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MultiRegionAccessPointSpecManagementPolicy
 */
export enum MultiRegionAccessPointSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MultiRegionAccessPointSpecProviderConfigRef
 */
export interface MultiRegionAccessPointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiRegionAccessPointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiRegionAccessPointSpecProviderConfigRef#policy
   */
  readonly policy?: MultiRegionAccessPointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecProviderConfigRef(obj: MultiRegionAccessPointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiRegionAccessPointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MultiRegionAccessPointSpecProviderRef
 */
export interface MultiRegionAccessPointSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiRegionAccessPointSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiRegionAccessPointSpecProviderRef#policy
   */
  readonly policy?: MultiRegionAccessPointSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecProviderRef(obj: MultiRegionAccessPointSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiRegionAccessPointSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MultiRegionAccessPointSpecPublishConnectionDetailsTo
 */
export interface MultiRegionAccessPointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecPublishConnectionDetailsTo(obj: MultiRegionAccessPointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MultiRegionAccessPointSpecWriteConnectionSecretToRef
 */
export interface MultiRegionAccessPointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MultiRegionAccessPointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MultiRegionAccessPointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecWriteConnectionSecretToRef(obj: MultiRegionAccessPointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MultiRegionAccessPointSpecForProviderDetails
 */
export interface MultiRegionAccessPointSpecForProviderDetails {
  /**
   * The name of the Multi-Region Access Point.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetails#name
   */
  readonly name: string;

  /**
   * Configuration block to manage the PublicAccessBlock configuration that you want to apply to this Multi-Region Access Point. You can enable the configuration options in any combination. See Public Access Block Configuration below for more details.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetails#publicAccessBlock
   */
  readonly publicAccessBlock?: MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock[];

  /**
   * The Region configuration block to specify the bucket associated with the Multi-Region Access Point. See Region Configuration below for more details.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetails#region
   */
  readonly region: MultiRegionAccessPointSpecForProviderDetailsRegion[];

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProviderDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProviderDetails(obj: MultiRegionAccessPointSpecForProviderDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'publicAccessBlock': obj.publicAccessBlock?.map(y => toJson_MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock(y)),
    'region': obj.region?.map(y => toJson_MultiRegionAccessPointSpecForProviderDetailsRegion(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MultiRegionAccessPointSpecProviderConfigRefPolicy
 */
export interface MultiRegionAccessPointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecProviderConfigRefPolicy(obj: MultiRegionAccessPointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MultiRegionAccessPointSpecProviderRefPolicy
 */
export interface MultiRegionAccessPointSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecProviderRefPolicy(obj: MultiRegionAccessPointSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef
 */
export interface MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef(obj: MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata
 */
export interface MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata(obj: MultiRegionAccessPointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock
 */
export interface MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock {
  /**
   * Whether Amazon S3 should block public ACLs for buckets in this account. Defaults to true. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   *
   * @default true. Enabling this setting does not affect existing policies or ACLs. When set to true causes the following behavior:
   * @schema MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock#blockPublicAcls
   */
  readonly blockPublicAcls?: boolean;

  /**
   * Whether Amazon S3 should block public bucket policies for buckets in this account. Defaults to true. Enabling this setting does not affect existing bucket policies. When set to true causes Amazon S3 to:
   *
   * @default true. Enabling this setting does not affect existing bucket policies. When set to true causes Amazon S3 to:
   * @schema MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock#blockPublicPolicy
   */
  readonly blockPublicPolicy?: boolean;

  /**
   * Whether Amazon S3 should ignore public ACLs for buckets in this account. Defaults to true. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   *
   * @default true. Enabling this setting does not affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. When set to true causes Amazon S3 to:
   * @schema MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock#ignorePublicAcls
   */
  readonly ignorePublicAcls?: boolean;

  /**
   * Whether Amazon S3 should restrict public bucket policies for buckets in this account. Defaults to true. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   *
   * @default true. Enabling this setting does not affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. When set to true:
   * @schema MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock#restrictPublicBuckets
   */
  readonly restrictPublicBuckets?: boolean;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock(obj: MultiRegionAccessPointSpecForProviderDetailsPublicAccessBlock | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockPublicAcls': obj.blockPublicAcls,
    'blockPublicPolicy': obj.blockPublicPolicy,
    'ignorePublicAcls': obj.ignorePublicAcls,
    'restrictPublicBuckets': obj.restrictPublicBuckets,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegion
 */
export interface MultiRegionAccessPointSpecForProviderDetailsRegion {
  /**
   * The name of the associated bucket for the Region.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegion#bucket
   */
  readonly bucket?: string;

  /**
   * Reference to a Bucket in s3 to populate bucket.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegion#bucketRef
   */
  readonly bucketRef?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef;

  /**
   * Selector for a Bucket in s3 to populate bucket.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegion#bucketSelector
   */
  readonly bucketSelector?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProviderDetailsRegion' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProviderDetailsRegion(obj: MultiRegionAccessPointSpecForProviderDetailsRegion | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bucket': obj.bucket,
    'bucketRef': toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef(obj.bucketRef),
    'bucketSelector': toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector(obj.bucketSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointSpecProviderConfigRefPolicyResolution
 */
export enum MultiRegionAccessPointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointSpecProviderConfigRefPolicyResolve
 */
export enum MultiRegionAccessPointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointSpecProviderRefPolicyResolution
 */
export enum MultiRegionAccessPointSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointSpecProviderRefPolicyResolve
 */
export enum MultiRegionAccessPointSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj: MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate bucket.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef
 */
export interface MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef#policy
   */
  readonly policy?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef(obj: MultiRegionAccessPointSpecForProviderDetailsRegionBucketRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate bucket.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector
 */
export interface MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector#policy
   */
  readonly policy?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector(obj: MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MultiRegionAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy
 */
export interface MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy(obj: MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy
 */
export interface MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy(obj: MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicyResolution
 */
export enum MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicyResolve
 */
export enum MultiRegionAccessPointSpecForProviderDetailsRegionBucketRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicyResolution
 */
export enum MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicyResolve
 */
export enum MultiRegionAccessPointSpecForProviderDetailsRegionBucketSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MultiRegionAccessPointPolicy is the Schema for the MultiRegionAccessPointPolicys API. Provides a resource to manage an S3 Multi-Region Access Point access control policy.
 *
 * @schema MultiRegionAccessPointPolicy
 */
export class MultiRegionAccessPointPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MultiRegionAccessPointPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'MultiRegionAccessPointPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "MultiRegionAccessPointPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MultiRegionAccessPointPolicyProps): any {
    return {
      ...MultiRegionAccessPointPolicy.GVK,
      ...toJson_MultiRegionAccessPointPolicyProps(props),
    };
  }

  /**
   * Defines a "MultiRegionAccessPointPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MultiRegionAccessPointPolicyProps) {
    super(scope, id, {
      ...MultiRegionAccessPointPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MultiRegionAccessPointPolicy.GVK,
      ...toJson_MultiRegionAccessPointPolicyProps(resolved),
    };
  }
}

/**
 * MultiRegionAccessPointPolicy is the Schema for the MultiRegionAccessPointPolicys API. Provides a resource to manage an S3 Multi-Region Access Point access control policy.
 *
 * @schema MultiRegionAccessPointPolicy
 */
export interface MultiRegionAccessPointPolicyProps {
  /**
   * @schema MultiRegionAccessPointPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MultiRegionAccessPointPolicySpec defines the desired state of MultiRegionAccessPointPolicy
   *
   * @schema MultiRegionAccessPointPolicy#spec
   */
  readonly spec: MultiRegionAccessPointPolicySpec;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicyProps(obj: MultiRegionAccessPointPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MultiRegionAccessPointPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MultiRegionAccessPointPolicySpec defines the desired state of MultiRegionAccessPointPolicy
 *
 * @schema MultiRegionAccessPointPolicySpec
 */
export interface MultiRegionAccessPointPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MultiRegionAccessPointPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: MultiRegionAccessPointPolicySpecDeletionPolicy;

  /**
   * @schema MultiRegionAccessPointPolicySpec#forProvider
   */
  readonly forProvider: MultiRegionAccessPointPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MultiRegionAccessPointPolicySpec#managementPolicy
   */
  readonly managementPolicy?: MultiRegionAccessPointPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MultiRegionAccessPointPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: MultiRegionAccessPointPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MultiRegionAccessPointPolicySpec#providerRef
   */
  readonly providerRef?: MultiRegionAccessPointPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MultiRegionAccessPointPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MultiRegionAccessPointPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpec(obj: MultiRegionAccessPointPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MultiRegionAccessPointPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MultiRegionAccessPointPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MultiRegionAccessPointPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MultiRegionAccessPointPolicySpecDeletionPolicy
 */
export enum MultiRegionAccessPointPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MultiRegionAccessPointPolicySpecForProvider
 */
export interface MultiRegionAccessPointPolicySpecForProvider {
  /**
   * The AWS account ID for the owner of the Multi-Region Access Point.
   *
   * @schema MultiRegionAccessPointPolicySpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * A configuration block containing details about the policy for the Multi-Region Access Point. See Details Configuration Block below for more details
   *
   * @schema MultiRegionAccessPointPolicySpecForProvider#details
   */
  readonly details?: MultiRegionAccessPointPolicySpecForProviderDetails[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema MultiRegionAccessPointPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecForProvider(obj: MultiRegionAccessPointPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'details': obj.details?.map(y => toJson_MultiRegionAccessPointPolicySpecForProviderDetails(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MultiRegionAccessPointPolicySpecManagementPolicy
 */
export enum MultiRegionAccessPointPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MultiRegionAccessPointPolicySpecProviderConfigRef
 */
export interface MultiRegionAccessPointPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderConfigRef#policy
   */
  readonly policy?: MultiRegionAccessPointPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecProviderConfigRef(obj: MultiRegionAccessPointPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiRegionAccessPointPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MultiRegionAccessPointPolicySpecProviderRef
 */
export interface MultiRegionAccessPointPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderRef#policy
   */
  readonly policy?: MultiRegionAccessPointPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecProviderRef(obj: MultiRegionAccessPointPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiRegionAccessPointPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo
 */
export interface MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo(obj: MultiRegionAccessPointPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef
 */
export interface MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef(obj: MultiRegionAccessPointPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MultiRegionAccessPointPolicySpecForProviderDetails
 */
export interface MultiRegionAccessPointPolicySpecForProviderDetails {
  /**
   * The name of the Multi-Region Access Point.
   *
   * @schema MultiRegionAccessPointPolicySpecForProviderDetails#name
   */
  readonly name: string;

  /**
   * A valid JSON document that specifies the policy that you want to associate with this Multi-Region Access Point. Once applied, the policy can be edited, but not deleted. For more information, see the documentation on Multi-Region Access Point Permissions.
   *
   * @schema MultiRegionAccessPointPolicySpecForProviderDetails#policy
   */
  readonly policy: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecForProviderDetails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecForProviderDetails(obj: MultiRegionAccessPointPolicySpecForProviderDetails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MultiRegionAccessPointPolicySpecProviderConfigRefPolicy
 */
export interface MultiRegionAccessPointPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecProviderConfigRefPolicy(obj: MultiRegionAccessPointPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MultiRegionAccessPointPolicySpecProviderRefPolicy
 */
export interface MultiRegionAccessPointPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecProviderRefPolicy(obj: MultiRegionAccessPointPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef(obj: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata
 */
export interface MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata(obj: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointPolicySpecProviderConfigRefPolicyResolution
 */
export enum MultiRegionAccessPointPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointPolicySpecProviderConfigRefPolicyResolve
 */
export enum MultiRegionAccessPointPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointPolicySpecProviderRefPolicyResolution
 */
export enum MultiRegionAccessPointPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointPolicySpecProviderRefPolicyResolve
 */
export enum MultiRegionAccessPointPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MultiRegionAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObjectLambdaAccessPoint is the Schema for the ObjectLambdaAccessPoints API. Provides a resource to manage an S3 Object Lambda Access Point.
 *
 * @schema ObjectLambdaAccessPoint
 */
export class ObjectLambdaAccessPoint extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectLambdaAccessPoint"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'ObjectLambdaAccessPoint',
  }

  /**
   * Renders a Kubernetes manifest for "ObjectLambdaAccessPoint".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectLambdaAccessPointProps): any {
    return {
      ...ObjectLambdaAccessPoint.GVK,
      ...toJson_ObjectLambdaAccessPointProps(props),
    };
  }

  /**
   * Defines a "ObjectLambdaAccessPoint" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectLambdaAccessPointProps) {
    super(scope, id, {
      ...ObjectLambdaAccessPoint.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectLambdaAccessPoint.GVK,
      ...toJson_ObjectLambdaAccessPointProps(resolved),
    };
  }
}

/**
 * ObjectLambdaAccessPoint is the Schema for the ObjectLambdaAccessPoints API. Provides a resource to manage an S3 Object Lambda Access Point.
 *
 * @schema ObjectLambdaAccessPoint
 */
export interface ObjectLambdaAccessPointProps {
  /**
   * @schema ObjectLambdaAccessPoint#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectLambdaAccessPointSpec defines the desired state of ObjectLambdaAccessPoint
   *
   * @schema ObjectLambdaAccessPoint#spec
   */
  readonly spec: ObjectLambdaAccessPointSpec;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointProps(obj: ObjectLambdaAccessPointProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectLambdaAccessPointSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectLambdaAccessPointSpec defines the desired state of ObjectLambdaAccessPoint
 *
 * @schema ObjectLambdaAccessPointSpec
 */
export interface ObjectLambdaAccessPointSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectLambdaAccessPointSpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectLambdaAccessPointSpecDeletionPolicy;

  /**
   * @schema ObjectLambdaAccessPointSpec#forProvider
   */
  readonly forProvider: ObjectLambdaAccessPointSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectLambdaAccessPointSpec#managementPolicy
   */
  readonly managementPolicy?: ObjectLambdaAccessPointSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectLambdaAccessPointSpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectLambdaAccessPointSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObjectLambdaAccessPointSpec#providerRef
   */
  readonly providerRef?: ObjectLambdaAccessPointSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectLambdaAccessPointSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectLambdaAccessPointSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectLambdaAccessPointSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectLambdaAccessPointSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpec(obj: ObjectLambdaAccessPointSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectLambdaAccessPointSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ObjectLambdaAccessPointSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ObjectLambdaAccessPointSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectLambdaAccessPointSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectLambdaAccessPointSpecDeletionPolicy
 */
export enum ObjectLambdaAccessPointSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectLambdaAccessPointSpecForProvider
 */
export interface ObjectLambdaAccessPointSpecForProvider {
  /**
   * The AWS account ID for the owner of the bucket for which you want to create an Object Lambda Access Point.
   *
   * @schema ObjectLambdaAccessPointSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * A configuration block containing details about the Object Lambda Access Point. See Configuration below for more details.
   *
   * @schema ObjectLambdaAccessPointSpecForProvider#configuration
   */
  readonly configuration?: ObjectLambdaAccessPointSpecForProviderConfiguration[];

  /**
   * The name for this Object Lambda Access Point.
   *
   * @schema ObjectLambdaAccessPointSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ObjectLambdaAccessPointSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProvider(obj: ObjectLambdaAccessPointSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'configuration': obj.configuration?.map(y => toJson_ObjectLambdaAccessPointSpecForProviderConfiguration(y)),
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectLambdaAccessPointSpecManagementPolicy
 */
export enum ObjectLambdaAccessPointSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectLambdaAccessPointSpecProviderConfigRef
 */
export interface ObjectLambdaAccessPointSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointSpecProviderConfigRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecProviderConfigRef(obj: ObjectLambdaAccessPointSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObjectLambdaAccessPointSpecProviderRef
 */
export interface ObjectLambdaAccessPointSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointSpecProviderRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecProviderRef(obj: ObjectLambdaAccessPointSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsTo
 */
export interface ObjectLambdaAccessPointSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsTo(obj: ObjectLambdaAccessPointSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectLambdaAccessPointSpecWriteConnectionSecretToRef
 */
export interface ObjectLambdaAccessPointSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectLambdaAccessPointSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectLambdaAccessPointSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecWriteConnectionSecretToRef(obj: ObjectLambdaAccessPointSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ObjectLambdaAccessPointSpecForProviderConfiguration
 */
export interface ObjectLambdaAccessPointSpecForProviderConfiguration {
  /**
   * Allowed features. Valid values: GetObject-Range, GetObject-PartNumber.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfiguration#allowedFeatures
   */
  readonly allowedFeatures?: string[];

  /**
   * Whether or not the CloudWatch metrics configuration is enabled.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfiguration#cloudWatchMetricsEnabled
   */
  readonly cloudWatchMetricsEnabled?: boolean;

  /**
   * Standard access point associated with the Object Lambda Access Point.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfiguration#supportingAccessPoint
   */
  readonly supportingAccessPoint?: string;

  /**
   * Reference to a AccessPoint in s3control to populate supportingAccessPoint.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfiguration#supportingAccessPointRef
   */
  readonly supportingAccessPointRef?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef;

  /**
   * Selector for a AccessPoint in s3control to populate supportingAccessPoint.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfiguration#supportingAccessPointSelector
   */
  readonly supportingAccessPointSelector?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector;

  /**
   * List of transformation configurations for the Object Lambda Access Point. See Transformation Configuration below for more details.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfiguration#transformationConfiguration
   */
  readonly transformationConfiguration: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration[];

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfiguration(obj: ObjectLambdaAccessPointSpecForProviderConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedFeatures': obj.allowedFeatures?.map(y => y),
    'cloudWatchMetricsEnabled': obj.cloudWatchMetricsEnabled,
    'supportingAccessPoint': obj.supportingAccessPoint,
    'supportingAccessPointRef': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef(obj.supportingAccessPointRef),
    'supportingAccessPointSelector': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector(obj.supportingAccessPointSelector),
    'transformationConfiguration': obj.transformationConfiguration?.map(y => toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointSpecProviderConfigRefPolicy
 */
export interface ObjectLambdaAccessPointSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecProviderConfigRefPolicy(obj: ObjectLambdaAccessPointSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointSpecProviderRefPolicy
 */
export interface ObjectLambdaAccessPointSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecProviderRefPolicy(obj: ObjectLambdaAccessPointSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef(obj: ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata
 */
export interface ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata(obj: ObjectLambdaAccessPointSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a AccessPoint in s3control to populate supportingAccessPoint.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef(obj: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a AccessPoint in s3control to populate supportingAccessPoint.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector#policy
   */
  readonly policy?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector(obj: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration {
  /**
   * The actions of an Object Lambda Access Point configuration. Valid values: GetObject.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration#actions
   */
  readonly actions: string[];

  /**
   * The content transformation of an Object Lambda Access Point configuration. See Content Transformation below for more details.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration#contentTransformation
   */
  readonly contentTransformation: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation[];

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration(obj: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => y),
    'contentTransformation': obj.contentTransformation?.map(y => toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointSpecProviderConfigRefPolicyResolution
 */
export enum ObjectLambdaAccessPointSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointSpecProviderConfigRefPolicyResolve
 */
export enum ObjectLambdaAccessPointSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointSpecProviderRefPolicyResolution
 */
export enum ObjectLambdaAccessPointSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointSpecProviderRefPolicyResolve
 */
export enum ObjectLambdaAccessPointSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy(obj: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy(obj: ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation {
  /**
   * Configuration for an AWS Lambda function. See AWS Lambda below for more details.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation#awsLambda
   */
  readonly awsLambda: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda[];

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation(obj: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsLambda': obj.awsLambda?.map(y => toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectLambdaAccessPointSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicyResolution
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicyResolve
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicyResolution
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicyResolve
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationSupportingAccessPointSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda {
  /**
   * The Amazon Resource Name (ARN) of the AWS Lambda function.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda#functionArn
   */
  readonly functionArn?: string;

  /**
   * Reference to a Function in lambda to populate functionArn.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda#functionArnRef
   */
  readonly functionArnRef?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef;

  /**
   * Selector for a Function in lambda to populate functionArn.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda#functionArnSelector
   */
  readonly functionArnSelector?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector;

  /**
   * Additional JSON that provides supplemental data to the Lambda function used to transform objects.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda#functionPayload
   */
  readonly functionPayload?: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda(obj: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambda | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'functionArn': obj.functionArn,
    'functionArnRef': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef(obj.functionArnRef),
    'functionArnSelector': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector(obj.functionArnSelector),
    'functionPayload': obj.functionPayload,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Function in lambda to populate functionArn.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef(obj: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Function in lambda to populate functionArn.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector#policy
   */
  readonly policy?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector(obj: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy(obj: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy
 */
export interface ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy(obj: ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicyResolution
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicyResolve
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicyResolution
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicyResolve
 */
export enum ObjectLambdaAccessPointSpecForProviderConfigurationTransformationConfigurationContentTransformationAwsLambdaFunctionArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ObjectLambdaAccessPointPolicy is the Schema for the ObjectLambdaAccessPointPolicys API. Provides a resource to manage an S3 Object Lambda Access Point resource policy.
 *
 * @schema ObjectLambdaAccessPointPolicy
 */
export class ObjectLambdaAccessPointPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ObjectLambdaAccessPointPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'ObjectLambdaAccessPointPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "ObjectLambdaAccessPointPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ObjectLambdaAccessPointPolicyProps): any {
    return {
      ...ObjectLambdaAccessPointPolicy.GVK,
      ...toJson_ObjectLambdaAccessPointPolicyProps(props),
    };
  }

  /**
   * Defines a "ObjectLambdaAccessPointPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ObjectLambdaAccessPointPolicyProps) {
    super(scope, id, {
      ...ObjectLambdaAccessPointPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ObjectLambdaAccessPointPolicy.GVK,
      ...toJson_ObjectLambdaAccessPointPolicyProps(resolved),
    };
  }
}

/**
 * ObjectLambdaAccessPointPolicy is the Schema for the ObjectLambdaAccessPointPolicys API. Provides a resource to manage an S3 Object Lambda Access Point resource policy.
 *
 * @schema ObjectLambdaAccessPointPolicy
 */
export interface ObjectLambdaAccessPointPolicyProps {
  /**
   * @schema ObjectLambdaAccessPointPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ObjectLambdaAccessPointPolicySpec defines the desired state of ObjectLambdaAccessPointPolicy
   *
   * @schema ObjectLambdaAccessPointPolicy#spec
   */
  readonly spec: ObjectLambdaAccessPointPolicySpec;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicyProps(obj: ObjectLambdaAccessPointPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ObjectLambdaAccessPointPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ObjectLambdaAccessPointPolicySpec defines the desired state of ObjectLambdaAccessPointPolicy
 *
 * @schema ObjectLambdaAccessPointPolicySpec
 */
export interface ObjectLambdaAccessPointPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectLambdaAccessPointPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: ObjectLambdaAccessPointPolicySpecDeletionPolicy;

  /**
   * @schema ObjectLambdaAccessPointPolicySpec#forProvider
   */
  readonly forProvider: ObjectLambdaAccessPointPolicySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ObjectLambdaAccessPointPolicySpec#managementPolicy
   */
  readonly managementPolicy?: ObjectLambdaAccessPointPolicySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ObjectLambdaAccessPointPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: ObjectLambdaAccessPointPolicySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ObjectLambdaAccessPointPolicySpec#providerRef
   */
  readonly providerRef?: ObjectLambdaAccessPointPolicySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ObjectLambdaAccessPointPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ObjectLambdaAccessPointPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpec(obj: ObjectLambdaAccessPointPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ObjectLambdaAccessPointPolicySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_ObjectLambdaAccessPointPolicySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ObjectLambdaAccessPointPolicySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectLambdaAccessPointPolicySpecDeletionPolicy
 */
export enum ObjectLambdaAccessPointPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ObjectLambdaAccessPointPolicySpecForProvider
 */
export interface ObjectLambdaAccessPointPolicySpecForProvider {
  /**
   * The AWS account ID for the account that owns the Object Lambda Access Point.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * The name of the Object Lambda Access Point.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Reference to a ObjectLambdaAccessPoint in s3control to populate name.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProvider#nameRef
   */
  readonly nameRef?: ObjectLambdaAccessPointPolicySpecForProviderNameRef;

  /**
   * Selector for a ObjectLambdaAccessPoint in s3control to populate name.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProvider#nameSelector
   */
  readonly nameSelector?: ObjectLambdaAccessPointPolicySpecForProviderNameSelector;

  /**
   * The Object Lambda Access Point resource policy document.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecForProvider(obj: ObjectLambdaAccessPointPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'name': obj.name,
    'nameRef': toJson_ObjectLambdaAccessPointPolicySpecForProviderNameRef(obj.nameRef),
    'nameSelector': toJson_ObjectLambdaAccessPointPolicySpecForProviderNameSelector(obj.nameSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ObjectLambdaAccessPointPolicySpecManagementPolicy
 */
export enum ObjectLambdaAccessPointPolicySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRef
 */
export interface ObjectLambdaAccessPointPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecProviderConfigRef(obj: ObjectLambdaAccessPointPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderRef
 */
export interface ObjectLambdaAccessPointPolicySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointPolicySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecProviderRef(obj: ObjectLambdaAccessPointPolicySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointPolicySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo
 */
export interface ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo(obj: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef
 */
export interface ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef(obj: ObjectLambdaAccessPointPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a ObjectLambdaAccessPoint in s3control to populate name.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRef
 */
export interface ObjectLambdaAccessPointPolicySpecForProviderNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecForProviderNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecForProviderNameRef(obj: ObjectLambdaAccessPointPolicySpecForProviderNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a ObjectLambdaAccessPoint in s3control to populate name.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelector
 */
export interface ObjectLambdaAccessPointPolicySpecForProviderNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelector#policy
   */
  readonly policy?: ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecForProviderNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecForProviderNameSelector(obj: ObjectLambdaAccessPointPolicySpecForProviderNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy
 */
export interface ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy(obj: ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderRefPolicy
 */
export interface ObjectLambdaAccessPointPolicySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointPolicySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointPolicySpecProviderRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointPolicySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecProviderRefPolicy(obj: ObjectLambdaAccessPointPolicySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef(obj: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata
 */
export interface ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata(obj: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy
 */
export interface ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy(obj: ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy
 */
export interface ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy(obj: ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicyResolution
 */
export enum ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicyResolve
 */
export enum ObjectLambdaAccessPointPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderRefPolicyResolution
 */
export enum ObjectLambdaAccessPointPolicySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointPolicySpecProviderRefPolicyResolve
 */
export enum ObjectLambdaAccessPointPolicySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicyResolution
 */
export enum ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicyResolve
 */
export enum ObjectLambdaAccessPointPolicySpecForProviderNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicyResolution
 */
export enum ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicyResolve
 */
export enum ObjectLambdaAccessPointPolicySpecForProviderNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ObjectLambdaAccessPointPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StorageLensConfiguration is the Schema for the StorageLensConfigurations API. Provides a resource to manage an S3 Storage Lens configuration.
 *
 * @schema StorageLensConfiguration
 */
export class StorageLensConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StorageLensConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 's3control.aws.upbound.io/v1beta1',
    kind: 'StorageLensConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "StorageLensConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StorageLensConfigurationProps): any {
    return {
      ...StorageLensConfiguration.GVK,
      ...toJson_StorageLensConfigurationProps(props),
    };
  }

  /**
   * Defines a "StorageLensConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StorageLensConfigurationProps) {
    super(scope, id, {
      ...StorageLensConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StorageLensConfiguration.GVK,
      ...toJson_StorageLensConfigurationProps(resolved),
    };
  }
}

/**
 * StorageLensConfiguration is the Schema for the StorageLensConfigurations API. Provides a resource to manage an S3 Storage Lens configuration.
 *
 * @schema StorageLensConfiguration
 */
export interface StorageLensConfigurationProps {
  /**
   * @schema StorageLensConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StorageLensConfigurationSpec defines the desired state of StorageLensConfiguration
   *
   * @schema StorageLensConfiguration#spec
   */
  readonly spec: StorageLensConfigurationSpec;

}

/**
 * Converts an object of type 'StorageLensConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationProps(obj: StorageLensConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StorageLensConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StorageLensConfigurationSpec defines the desired state of StorageLensConfiguration
 *
 * @schema StorageLensConfigurationSpec
 */
export interface StorageLensConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StorageLensConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: StorageLensConfigurationSpecDeletionPolicy;

  /**
   * @schema StorageLensConfigurationSpec#forProvider
   */
  readonly forProvider: StorageLensConfigurationSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StorageLensConfigurationSpec#managementPolicy
   */
  readonly managementPolicy?: StorageLensConfigurationSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema StorageLensConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: StorageLensConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema StorageLensConfigurationSpec#providerRef
   */
  readonly providerRef?: StorageLensConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema StorageLensConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StorageLensConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema StorageLensConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StorageLensConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpec(obj: StorageLensConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StorageLensConfigurationSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_StorageLensConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_StorageLensConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_StorageLensConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StorageLensConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StorageLensConfigurationSpecDeletionPolicy
 */
export enum StorageLensConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StorageLensConfigurationSpecForProvider
 */
export interface StorageLensConfigurationSpecForProvider {
  /**
   * The AWS account ID for the S3 Storage Lens configuration.
   *
   * @schema StorageLensConfigurationSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * The ID of the S3 Storage Lens configuration.
   *
   * @schema StorageLensConfigurationSpecForProvider#configId
   */
  readonly configId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StorageLensConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The S3 Storage Lens configuration. See Storage Lens Configuration below for more details.
   *
   * @schema StorageLensConfigurationSpecForProvider#storageLensConfiguration
   */
  readonly storageLensConfiguration?: StorageLensConfigurationSpecForProviderStorageLensConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema StorageLensConfigurationSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProvider(obj: StorageLensConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'configId': obj.configId,
    'region': obj.region,
    'storageLensConfiguration': obj.storageLensConfiguration?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StorageLensConfigurationSpecManagementPolicy
 */
export enum StorageLensConfigurationSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema StorageLensConfigurationSpecProviderConfigRef
 */
export interface StorageLensConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StorageLensConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StorageLensConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: StorageLensConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecProviderConfigRef(obj: StorageLensConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StorageLensConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema StorageLensConfigurationSpecProviderRef
 */
export interface StorageLensConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema StorageLensConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StorageLensConfigurationSpecProviderRef#policy
   */
  readonly policy?: StorageLensConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecProviderRef(obj: StorageLensConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StorageLensConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema StorageLensConfigurationSpecPublishConnectionDetailsTo
 */
export interface StorageLensConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StorageLensConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecPublishConnectionDetailsTo(obj: StorageLensConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StorageLensConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema StorageLensConfigurationSpecWriteConnectionSecretToRef
 */
export interface StorageLensConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StorageLensConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StorageLensConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecWriteConnectionSecretToRef(obj: StorageLensConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfiguration
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfiguration {
  /**
   * level configurations of the S3 Storage Lens configuration. See Account Level below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfiguration#accountLevel
   */
  readonly accountLevel: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel[];

  /**
   * The Amazon Web Services organization for the S3 Storage Lens configuration. See AWS Org below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfiguration#awsOrg
   */
  readonly awsOrg?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg[];

  /**
   * Properties of S3 Storage Lens metrics export including the destination, schema and format. See Data Export below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfiguration#dataExport
   */
  readonly dataExport?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport[];

  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfiguration#enabled
   */
  readonly enabled: boolean;

  /**
   * What is excluded in this configuration. Conflicts with include. See Exclude below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfiguration#exclude
   */
  readonly exclude?: StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude[];

  /**
   * What is included in this configuration. Conflicts with exclude. See Include below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfiguration#include
   */
  readonly include?: StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfiguration(obj: StorageLensConfigurationSpecForProviderStorageLensConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountLevel': obj.accountLevel?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel(y)),
    'awsOrg': obj.awsOrg?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg(y)),
    'dataExport': obj.dataExport?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport(y)),
    'enabled': obj.enabled,
    'exclude': obj.exclude?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude(y)),
    'include': obj.include?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StorageLensConfigurationSpecProviderConfigRefPolicy
 */
export interface StorageLensConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StorageLensConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StorageLensConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StorageLensConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StorageLensConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecProviderConfigRefPolicy(obj: StorageLensConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StorageLensConfigurationSpecProviderRefPolicy
 */
export interface StorageLensConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StorageLensConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: StorageLensConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StorageLensConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: StorageLensConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecProviderRefPolicy(obj: StorageLensConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef(obj: StorageLensConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StorageLensConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface StorageLensConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecPublishConnectionDetailsToMetadata(obj: StorageLensConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel {
  /**
   * S3 Storage Lens activity metrics. See Activity Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel#activityMetrics
   */
  readonly activityMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics[];

  /**
   * optimization metrics for S3 Storage Lens. See Advanced Cost-Optimization Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel#advancedCostOptimizationMetrics
   */
  readonly advancedCostOptimizationMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics[];

  /**
   * protection metrics for S3 Storage Lens. See Advanced Data-Protection Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel#advancedDataProtectionMetrics
   */
  readonly advancedDataProtectionMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics[];

  /**
   * level configuration. See Bucket Level below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel#bucketLevel
   */
  readonly bucketLevel: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel[];

  /**
   * Detailed status code metrics for S3 Storage Lens. See Detailed Status Code Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel#detailedStatusCodeMetrics
   */
  readonly detailedStatusCodeMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activityMetrics': obj.activityMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics(y)),
    'advancedCostOptimizationMetrics': obj.advancedCostOptimizationMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics(y)),
    'advancedDataProtectionMetrics': obj.advancedDataProtectionMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics(y)),
    'bucketLevel': obj.bucketLevel?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel(y)),
    'detailedStatusCodeMetrics': obj.detailedStatusCodeMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg {
  /**
   * The Amazon Resource Name (ARN) of the bucket.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg#arn
   */
  readonly arn: string;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAwsOrg | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport {
  /**
   * Amazon CloudWatch publishing for S3 Storage Lens metrics. See Cloud Watch Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport#cloudWatchMetrics
   */
  readonly cloudWatchMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics[];

  /**
   * The bucket where the S3 Storage Lens metrics export will be located. See S3 Bucket Destination below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport#s3BucketDestination
   */
  readonly s3BucketDestination?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExport | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloudWatchMetrics': obj.cloudWatchMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics(y)),
    's3BucketDestination': obj.s3BucketDestination?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude {
  /**
   * List of S3 bucket ARNs.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude#buckets
   */
  readonly buckets?: string[];

  /**
   * List of AWS Regions.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude#regions
   */
  readonly regions?: string[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationExclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => y),
    'regions': obj.regions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude {
  /**
   * List of S3 bucket ARNs.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude#buckets
   */
  readonly buckets?: string[];

  /**
   * List of AWS Regions.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude#regions
   */
  readonly regions?: string[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationInclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buckets': obj.buckets?.map(y => y),
    'regions': obj.regions?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StorageLensConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum StorageLensConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StorageLensConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum StorageLensConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StorageLensConfigurationSpecProviderRefPolicyResolution
 */
export enum StorageLensConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StorageLensConfigurationSpecProviderRefPolicyResolve
 */
export enum StorageLensConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics {
  /**
   * Whether the activity metrics are enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelActivityMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedCostOptimizationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelAdvancedDataProtectionMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel {
  /**
   * S3 Storage Lens activity metrics. See Activity Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel#activityMetrics
   */
  readonly activityMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics[];

  /**
   * optimization metrics for S3 Storage Lens. See Advanced Cost-Optimization Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel#advancedCostOptimizationMetrics
   */
  readonly advancedCostOptimizationMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics[];

  /**
   * protection metrics for S3 Storage Lens. See Advanced Data-Protection Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel#advancedDataProtectionMetrics
   */
  readonly advancedDataProtectionMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics[];

  /**
   * Detailed status code metrics for S3 Storage Lens. See Detailed Status Code Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel#detailedStatusCodeMetrics
   */
  readonly detailedStatusCodeMetrics?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics[];

  /**
   * level metrics for S3 Storage Lens. See Prefix Level below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel#prefixLevel
   */
  readonly prefixLevel?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'activityMetrics': obj.activityMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics(y)),
    'advancedCostOptimizationMetrics': obj.advancedCostOptimizationMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics(y)),
    'advancedDataProtectionMetrics': obj.advancedDataProtectionMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics(y)),
    'detailedStatusCodeMetrics': obj.detailedStatusCodeMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics(y)),
    'prefixLevel': obj.prefixLevel?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelDetailedStatusCodeMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportCloudWatchMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination {
  /**
   * The account ID of the owner of the S3 Storage Lens metrics export bucket.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#accountId
   */
  readonly accountId: string;

  /**
   * The Amazon Resource Name (ARN) of the bucket.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#arn
   */
  readonly arn?: string;

  /**
   * Reference to a Bucket in s3 to populate arn.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#arnRef
   */
  readonly arnRef?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef;

  /**
   * Selector for a Bucket in s3 to populate arn.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#arnSelector
   */
  readonly arnSelector?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector;

  /**
   * Encryption of the metrics exports in this bucket. See Encryption below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#encryption
   */
  readonly encryption?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption[];

  /**
   * The export format. Valid values: CSV, Parquet.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#format
   */
  readonly format: string;

  /**
   * The schema version of the export file. Valid values: V_1.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#outputSchemaVersion
   */
  readonly outputSchemaVersion: string;

  /**
   * The prefix of the destination bucket where the metrics export will be delivered.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination#prefix
   */
  readonly prefix?: string;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'arn': obj.arn,
    'arnRef': toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef(obj.arnRef),
    'arnSelector': toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector(obj.arnSelector),
    'encryption': obj.encryption?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption(y)),
    'format': obj.format,
    'outputSchemaVersion': obj.outputSchemaVersion,
    'prefix': obj.prefix,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StorageLensConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelActivityMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedCostOptimizationMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelAdvancedDataProtectionMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelDetailedStatusCodeMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel {
  /**
   * level storage metrics for S3 Storage Lens. See Prefix Level Storage Metrics below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel#storageMetrics
   */
  readonly storageMetrics: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevel | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'storageMetrics': obj.storageMetrics?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Bucket in s3 to populate arn.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef#policy
   */
  readonly policy?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Bucket in s3 to populate arn.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector#policy
   */
  readonly policy?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption {
  /**
   * KMS encryption. See SSE KMS below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption#sseKms
   */
  readonly sseKms?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms[];

  /**
   * S3 encryption. An empty configuration block {} should be used.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption#sseS3
   */
  readonly sseS3?: any[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryption | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sseKms': obj.sseKms?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms(y)),
    'sseS3': obj.sseS3?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics {
  /**
   * Whether the S3 Storage Lens configuration is enabled.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics#enabled
   */
  readonly enabled?: boolean;

  /**
   * Selection criteria. See Selection Criteria below for more details.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics#selectionCriteria
   */
  readonly selectionCriteria?: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria[];

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetrics | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'selectionCriteria': obj.selectionCriteria?.map(y => toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy#resolution
   */
  readonly resolution?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy#resolve
   */
  readonly resolve?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy#resolution
   */
  readonly resolution?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy#resolve
   */
  readonly resolve?: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms {
  /**
   * KMS key ARN.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms#keyId
   */
  readonly keyId: string;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationEncryptionSseKms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'keyId': obj.keyId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria
 */
export interface StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria {
  /**
   * The delimiter of the selection criteria being used.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria#delimiter
   */
  readonly delimiter?: string;

  /**
   * The max depth of the selection criteria.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria#maxDepth
   */
  readonly maxDepth?: number;

  /**
   * The minimum number of storage bytes percentage whose metrics will be selected.
   *
   * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria#minStorageBytesPercentage
   */
  readonly minStorageBytesPercentage?: number;

}

/**
 * Converts an object of type 'StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria(obj: StorageLensConfigurationSpecForProviderStorageLensConfigurationAccountLevelBucketLevelPrefixLevelStorageMetricsSelectionCriteria | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delimiter': obj.delimiter,
    'maxDepth': obj.maxDepth,
    'minStorageBytesPercentage': obj.minStorageBytesPercentage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicyResolution
 */
export enum StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicyResolve
 */
export enum StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicyResolution
 */
export enum StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicyResolve
 */
export enum StorageLensConfigurationSpecForProviderStorageLensConfigurationDataExportS3BucketDestinationArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

