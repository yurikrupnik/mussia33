// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * IdentityProvider is the Schema for the IdentityProviders API. Provides a Cognito User Identity Provider resource.
 *
 * @schema IdentityProvider
 */
export class IdentityProvider extends ApiObject {
  /**
   * Returns the apiVersion and kind for "IdentityProvider"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'IdentityProvider',
  }

  /**
   * Renders a Kubernetes manifest for "IdentityProvider".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: IdentityProviderProps): any {
    return {
      ...IdentityProvider.GVK,
      ...toJson_IdentityProviderProps(props),
    };
  }

  /**
   * Defines a "IdentityProvider" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: IdentityProviderProps) {
    super(scope, id, {
      ...IdentityProvider.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...IdentityProvider.GVK,
      ...toJson_IdentityProviderProps(resolved),
    };
  }
}

/**
 * IdentityProvider is the Schema for the IdentityProviders API. Provides a Cognito User Identity Provider resource.
 *
 * @schema IdentityProvider
 */
export interface IdentityProviderProps {
  /**
   * @schema IdentityProvider#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * IdentityProviderSpec defines the desired state of IdentityProvider
   *
   * @schema IdentityProvider#spec
   */
  readonly spec: IdentityProviderSpec;

}

/**
 * Converts an object of type 'IdentityProviderProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderProps(obj: IdentityProviderProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_IdentityProviderSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IdentityProviderSpec defines the desired state of IdentityProvider
 *
 * @schema IdentityProviderSpec
 */
export interface IdentityProviderSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema IdentityProviderSpec#deletionPolicy
   */
  readonly deletionPolicy?: IdentityProviderSpecDeletionPolicy;

  /**
   * @schema IdentityProviderSpec#forProvider
   */
  readonly forProvider: IdentityProviderSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema IdentityProviderSpec#providerConfigRef
   */
  readonly providerConfigRef?: IdentityProviderSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema IdentityProviderSpec#providerRef
   */
  readonly providerRef?: IdentityProviderSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema IdentityProviderSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: IdentityProviderSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema IdentityProviderSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: IdentityProviderSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'IdentityProviderSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpec(obj: IdentityProviderSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_IdentityProviderSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_IdentityProviderSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_IdentityProviderSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_IdentityProviderSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_IdentityProviderSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema IdentityProviderSpecDeletionPolicy
 */
export enum IdentityProviderSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema IdentityProviderSpecForProvider
 */
export interface IdentityProviderSpecForProvider {
  /**
   * The map of attribute mapping of user pool attributes. AttributeMapping in AWS API documentation
   *
   * @schema IdentityProviderSpecForProvider#attributeMapping
   */
  readonly attributeMapping?: { [key: string]: string };

  /**
   * The list of identity providers.
   *
   * @schema IdentityProviderSpecForProvider#idpIdentifiers
   */
  readonly idpIdentifiers?: string[];

  /**
   * The map of identity details, such as access token
   *
   * @schema IdentityProviderSpecForProvider#providerDetails
   */
  readonly providerDetails: { [key: string]: string };

  /**
   * The provider name
   *
   * @schema IdentityProviderSpecForProvider#providerName
   */
  readonly providerName: string;

  /**
   * The provider type.  See AWS API for valid values
   *
   * @schema IdentityProviderSpecForProvider#providerType
   */
  readonly providerType: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema IdentityProviderSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user pool id
   *
   * @schema IdentityProviderSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool to populate userPoolId.
   *
   * @schema IdentityProviderSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: IdentityProviderSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool to populate userPoolId.
   *
   * @schema IdentityProviderSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: IdentityProviderSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProvider(obj: IdentityProviderSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeMapping': ((obj.attributeMapping) === undefined) ? undefined : (Object.entries(obj.attributeMapping).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'idpIdentifiers': obj.idpIdentifiers?.map(y => y),
    'providerDetails': ((obj.providerDetails) === undefined) ? undefined : (Object.entries(obj.providerDetails).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'providerName': obj.providerName,
    'providerType': obj.providerType,
    'region': obj.region,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_IdentityProviderSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_IdentityProviderSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema IdentityProviderSpecProviderConfigRef
 */
export interface IdentityProviderSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderSpecProviderConfigRef#policy
   */
  readonly policy?: IdentityProviderSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecProviderConfigRef(obj: IdentityProviderSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema IdentityProviderSpecProviderRef
 */
export interface IdentityProviderSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderSpecProviderRef#policy
   */
  readonly policy?: IdentityProviderSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecProviderRef(obj: IdentityProviderSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsTo
 */
export interface IdentityProviderSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: IdentityProviderSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: IdentityProviderSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsTo(obj: IdentityProviderSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_IdentityProviderSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema IdentityProviderSpecWriteConnectionSecretToRef
 */
export interface IdentityProviderSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema IdentityProviderSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema IdentityProviderSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'IdentityProviderSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecWriteConnectionSecretToRef(obj: IdentityProviderSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool to populate userPoolId.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRef
 */
export interface IdentityProviderSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: IdentityProviderSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdRef(obj: IdentityProviderSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool to populate userPoolId.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelector
 */
export interface IdentityProviderSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: IdentityProviderSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdSelector(obj: IdentityProviderSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_IdentityProviderSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderSpecProviderConfigRefPolicy
 */
export interface IdentityProviderSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecProviderConfigRefPolicy(obj: IdentityProviderSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderSpecProviderRefPolicy
 */
export interface IdentityProviderSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecProviderRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecProviderRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecProviderRefPolicy(obj: IdentityProviderSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRef
 */
export interface IdentityProviderSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRef(obj: IdentityProviderSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata
 */
export interface IdentityProviderSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsToMetadata(obj: IdentityProviderSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicy
 */
export interface IdentityProviderSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdRefPolicy(obj: IdentityProviderSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicy
 */
export interface IdentityProviderSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecForProviderUserPoolIdSelectorPolicy(obj: IdentityProviderSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecProviderConfigRefPolicyResolution
 */
export enum IdentityProviderSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecProviderConfigRefPolicyResolve
 */
export enum IdentityProviderSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecProviderRefPolicyResolution
 */
export enum IdentityProviderSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecProviderRefPolicyResolve
 */
export enum IdentityProviderSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy(obj: IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum IdentityProviderSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum IdentityProviderSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum IdentityProviderSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum IdentityProviderSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResourceServer is the Schema for the ResourceServers API. Provides a Cognito Resource Server.
 *
 * @schema ResourceServer
 */
export class ResourceServer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResourceServer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'ResourceServer',
  }

  /**
   * Renders a Kubernetes manifest for "ResourceServer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceServerProps): any {
    return {
      ...ResourceServer.GVK,
      ...toJson_ResourceServerProps(props),
    };
  }

  /**
   * Defines a "ResourceServer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceServerProps) {
    super(scope, id, {
      ...ResourceServer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ResourceServer.GVK,
      ...toJson_ResourceServerProps(resolved),
    };
  }
}

/**
 * ResourceServer is the Schema for the ResourceServers API. Provides a Cognito Resource Server.
 *
 * @schema ResourceServer
 */
export interface ResourceServerProps {
  /**
   * @schema ResourceServer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourceServerSpec defines the desired state of ResourceServer
   *
   * @schema ResourceServer#spec
   */
  readonly spec: ResourceServerSpec;

}

/**
 * Converts an object of type 'ResourceServerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerProps(obj: ResourceServerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceServerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceServerSpec defines the desired state of ResourceServer
 *
 * @schema ResourceServerSpec
 */
export interface ResourceServerSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ResourceServerSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourceServerSpecDeletionPolicy;

  /**
   * @schema ResourceServerSpec#forProvider
   */
  readonly forProvider: ResourceServerSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourceServerSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourceServerSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ResourceServerSpec#providerRef
   */
  readonly providerRef?: ResourceServerSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourceServerSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourceServerSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourceServerSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourceServerSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourceServerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpec(obj: ResourceServerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourceServerSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ResourceServerSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ResourceServerSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ResourceServerSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourceServerSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ResourceServerSpecDeletionPolicy
 */
export enum ResourceServerSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResourceServerSpecForProvider
 */
export interface ResourceServerSpecForProvider {
  /**
   * An identifier for the resource server.
   *
   * @schema ResourceServerSpecForProvider#identifier
   */
  readonly identifier: string;

  /**
   * A name for the resource server.
   *
   * @schema ResourceServerSpecForProvider#name
   */
  readonly name: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResourceServerSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of Authorization Scope.
   *
   * @schema ResourceServerSpecForProvider#scope
   */
  readonly scope?: ResourceServerSpecForProviderScope[];

  /**
   * @schema ResourceServerSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool to populate userPoolId.
   *
   * @schema ResourceServerSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: ResourceServerSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool to populate userPoolId.
   *
   * @schema ResourceServerSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: ResourceServerSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'ResourceServerSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProvider(obj: ResourceServerSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identifier': obj.identifier,
    'name': obj.name,
    'region': obj.region,
    'scope': obj.scope?.map(y => toJson_ResourceServerSpecForProviderScope(y)),
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_ResourceServerSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_ResourceServerSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourceServerSpecProviderConfigRef
 */
export interface ResourceServerSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceServerSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceServerSpecProviderConfigRef#policy
   */
  readonly policy?: ResourceServerSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecProviderConfigRef(obj: ResourceServerSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceServerSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ResourceServerSpecProviderRef
 */
export interface ResourceServerSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceServerSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceServerSpecProviderRef#policy
   */
  readonly policy?: ResourceServerSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecProviderRef(obj: ResourceServerSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceServerSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsTo
 */
export interface ResourceServerSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourceServerSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourceServerSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsTo(obj: ResourceServerSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourceServerSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourceServerSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourceServerSpecWriteConnectionSecretToRef
 */
export interface ResourceServerSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourceServerSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceServerSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceServerSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecWriteConnectionSecretToRef(obj: ResourceServerSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ResourceServerSpecForProviderScope
 */
export interface ResourceServerSpecForProviderScope {
  /**
   * The scope description.
   *
   * @schema ResourceServerSpecForProviderScope#scopeDescription
   */
  readonly scopeDescription: string;

  /**
   * The scope name.
   *
   * @schema ResourceServerSpecForProviderScope#scopeName
   */
  readonly scopeName: string;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderScope' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderScope(obj: ResourceServerSpecForProviderScope | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scopeDescription': obj.scopeDescription,
    'scopeName': obj.scopeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool to populate userPoolId.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRef
 */
export interface ResourceServerSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: ResourceServerSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdRef(obj: ResourceServerSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceServerSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool to populate userPoolId.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelector
 */
export interface ResourceServerSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: ResourceServerSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdSelector(obj: ResourceServerSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceServerSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceServerSpecProviderConfigRefPolicy
 */
export interface ResourceServerSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecProviderConfigRefPolicy(obj: ResourceServerSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceServerSpecProviderRefPolicy
 */
export interface ResourceServerSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecProviderRefPolicy(obj: ResourceServerSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRef
 */
export interface ResourceServerSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsToConfigRef(obj: ResourceServerSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToMetadata
 */
export interface ResourceServerSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsToMetadata(obj: ResourceServerSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRefPolicy
 */
export interface ResourceServerSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdRefPolicy(obj: ResourceServerSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicy
 */
export interface ResourceServerSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecForProviderUserPoolIdSelectorPolicy(obj: ResourceServerSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecProviderConfigRefPolicyResolution
 */
export enum ResourceServerSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecProviderConfigRefPolicyResolve
 */
export enum ResourceServerSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecProviderRefPolicyResolution
 */
export enum ResourceServerSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecProviderRefPolicyResolve
 */
export enum ResourceServerSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourceServerSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum ResourceServerSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum ResourceServerSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum ResourceServerSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourceServerSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * RiskConfiguration is the Schema for the RiskConfigurations API. Provides a Cognito Risk Configuration resource.
 *
 * @schema RiskConfiguration
 */
export class RiskConfiguration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RiskConfiguration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'RiskConfiguration',
  }

  /**
   * Renders a Kubernetes manifest for "RiskConfiguration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: RiskConfigurationProps): any {
    return {
      ...RiskConfiguration.GVK,
      ...toJson_RiskConfigurationProps(props),
    };
  }

  /**
   * Defines a "RiskConfiguration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: RiskConfigurationProps) {
    super(scope, id, {
      ...RiskConfiguration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...RiskConfiguration.GVK,
      ...toJson_RiskConfigurationProps(resolved),
    };
  }
}

/**
 * RiskConfiguration is the Schema for the RiskConfigurations API. Provides a Cognito Risk Configuration resource.
 *
 * @schema RiskConfiguration
 */
export interface RiskConfigurationProps {
  /**
   * @schema RiskConfiguration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RiskConfigurationSpec defines the desired state of RiskConfiguration
   *
   * @schema RiskConfiguration#spec
   */
  readonly spec: RiskConfigurationSpec;

}

/**
 * Converts an object of type 'RiskConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationProps(obj: RiskConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RiskConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RiskConfigurationSpec defines the desired state of RiskConfiguration
 *
 * @schema RiskConfigurationSpec
 */
export interface RiskConfigurationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema RiskConfigurationSpec#deletionPolicy
   */
  readonly deletionPolicy?: RiskConfigurationSpecDeletionPolicy;

  /**
   * @schema RiskConfigurationSpec#forProvider
   */
  readonly forProvider: RiskConfigurationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema RiskConfigurationSpec#providerConfigRef
   */
  readonly providerConfigRef?: RiskConfigurationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema RiskConfigurationSpec#providerRef
   */
  readonly providerRef?: RiskConfigurationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema RiskConfigurationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RiskConfigurationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema RiskConfigurationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RiskConfigurationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RiskConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpec(obj: RiskConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RiskConfigurationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_RiskConfigurationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_RiskConfigurationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_RiskConfigurationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RiskConfigurationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema RiskConfigurationSpecDeletionPolicy
 */
export enum RiskConfigurationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RiskConfigurationSpecForProvider
 */
export interface RiskConfigurationSpecForProvider {
  /**
   * The account takeover risk configuration. See details below.
   *
   * @schema RiskConfigurationSpecForProvider#accountTakeoverRiskConfiguration
   */
  readonly accountTakeoverRiskConfiguration?: RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration[];

  /**
   * The app client ID. When the client ID is not provided, the same risk configuration is applied to all the clients in the User Pool.
   *
   * @schema RiskConfigurationSpecForProvider#clientId
   */
  readonly clientId?: string;

  /**
   * The compromised credentials risk configuration. See details below.
   *
   * @schema RiskConfigurationSpecForProvider#compromisedCredentialsRiskConfiguration
   */
  readonly compromisedCredentialsRiskConfiguration?: RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RiskConfigurationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The configuration to override the risk decision. See details below.
   *
   * @schema RiskConfigurationSpecForProvider#riskExceptionConfiguration
   */
  readonly riskExceptionConfiguration?: RiskConfigurationSpecForProviderRiskExceptionConfiguration[];

  /**
   * The user pool ID.
   *
   * @schema RiskConfigurationSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema RiskConfigurationSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: RiskConfigurationSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema RiskConfigurationSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: RiskConfigurationSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProvider(obj: RiskConfigurationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountTakeoverRiskConfiguration': obj.accountTakeoverRiskConfiguration?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration(y)),
    'clientId': obj.clientId,
    'compromisedCredentialsRiskConfiguration': obj.compromisedCredentialsRiskConfiguration?.map(y => toJson_RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration(y)),
    'region': obj.region,
    'riskExceptionConfiguration': obj.riskExceptionConfiguration?.map(y => toJson_RiskConfigurationSpecForProviderRiskExceptionConfiguration(y)),
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_RiskConfigurationSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_RiskConfigurationSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema RiskConfigurationSpecProviderConfigRef
 */
export interface RiskConfigurationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RiskConfigurationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RiskConfigurationSpecProviderConfigRef#policy
   */
  readonly policy?: RiskConfigurationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RiskConfigurationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecProviderConfigRef(obj: RiskConfigurationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RiskConfigurationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema RiskConfigurationSpecProviderRef
 */
export interface RiskConfigurationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema RiskConfigurationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RiskConfigurationSpecProviderRef#policy
   */
  readonly policy?: RiskConfigurationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'RiskConfigurationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecProviderRef(obj: RiskConfigurationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RiskConfigurationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema RiskConfigurationSpecPublishConnectionDetailsTo
 */
export interface RiskConfigurationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RiskConfigurationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RiskConfigurationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecPublishConnectionDetailsTo(obj: RiskConfigurationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RiskConfigurationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RiskConfigurationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema RiskConfigurationSpecWriteConnectionSecretToRef
 */
export interface RiskConfigurationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RiskConfigurationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RiskConfigurationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecWriteConnectionSecretToRef(obj: RiskConfigurationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration {
  /**
   * Account takeover risk configuration actions. See details below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration#actions
   */
  readonly actions: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions[];

  /**
   * The notify configuration used to construct email notifications. See details below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration#notifyConfiguration
   */
  readonly notifyConfiguration: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration[];

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions(y)),
    'notifyConfiguration': obj.notifyConfiguration?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration
 */
export interface RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration {
  /**
   * The compromised credentials risk configuration actions. See details below.
   *
   * @schema RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration#actions
   */
  readonly actions: RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions[];

  /**
   * Perform the action for these events. The default is to perform all events if no event filter is specified. Valid values are SIGN_IN, PASSWORD_CHANGE, and SIGN_UP.
   *
   * @schema RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration#eventFilter
   */
  readonly eventFilter?: string[];

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration(obj: RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'actions': obj.actions?.map(y => toJson_RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions(y)),
    'eventFilter': obj.eventFilter?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderRiskExceptionConfiguration
 */
export interface RiskConfigurationSpecForProviderRiskExceptionConfiguration {
  /**
   * Overrides the risk decision to always block the pre-authentication requests. The IP range is in CIDR notation, a compact representation of an IP address and its routing prefix.
   *
   * @schema RiskConfigurationSpecForProviderRiskExceptionConfiguration#blockedIpRangeList
   */
  readonly blockedIpRangeList?: string[];

  /**
   * Risk detection isn't performed on the IP addresses in this range list. The IP range is in CIDR notation.
   *
   * @schema RiskConfigurationSpecForProviderRiskExceptionConfiguration#skippedIpRangeList
   */
  readonly skippedIpRangeList?: string[];

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderRiskExceptionConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderRiskExceptionConfiguration(obj: RiskConfigurationSpecForProviderRiskExceptionConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockedIpRangeList': obj.blockedIpRangeList?.map(y => y),
    'skippedIpRangeList': obj.skippedIpRangeList?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdRef
 */
export interface RiskConfigurationSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: RiskConfigurationSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderUserPoolIdRef(obj: RiskConfigurationSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RiskConfigurationSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdSelector
 */
export interface RiskConfigurationSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderUserPoolIdSelector(obj: RiskConfigurationSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RiskConfigurationSpecProviderConfigRefPolicy
 */
export interface RiskConfigurationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RiskConfigurationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RiskConfigurationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RiskConfigurationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RiskConfigurationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RiskConfigurationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecProviderConfigRefPolicy(obj: RiskConfigurationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RiskConfigurationSpecProviderRefPolicy
 */
export interface RiskConfigurationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RiskConfigurationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: RiskConfigurationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RiskConfigurationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: RiskConfigurationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'RiskConfigurationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecProviderRefPolicy(obj: RiskConfigurationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRef
 */
export interface RiskConfigurationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RiskConfigurationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecPublishConnectionDetailsToConfigRef(obj: RiskConfigurationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RiskConfigurationSpecPublishConnectionDetailsToMetadata
 */
export interface RiskConfigurationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecPublishConnectionDetailsToMetadata(obj: RiskConfigurationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions {
  /**
   * Action to take for a high risk. See action block below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions#highAction
   */
  readonly highAction?: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction[];

  /**
   * Action to take for a low risk. See action block below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions#lowAction
   */
  readonly lowAction?: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction[];

  /**
   * Action to take for a medium risk. See action block below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions#mediumAction
   */
  readonly mediumAction?: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction[];

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'highAction': obj.highAction?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction(y)),
    'lowAction': obj.lowAction?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction(y)),
    'mediumAction': obj.mediumAction?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration {
  /**
   * Email template used when a detected risk event is blocked. See notify email type below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration#blockEmail
   */
  readonly blockEmail?: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail[];

  /**
   * The email address that is sending the email. The address must be either individually verified with Amazon Simple Email Service, or from a domain that has been verified with Amazon SES.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration#from
   */
  readonly from?: string;

  /**
   * The multi-factor authentication (MFA) email template used when MFA is challenged as part of a detected risk. See notify email type below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration#mfaEmail
   */
  readonly mfaEmail?: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail[];

  /**
   * The email template used when a detected risk event is allowed. See notify email type below.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration#noActionEmail
   */
  readonly noActionEmail?: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail[];

  /**
   * The destination to which the receiver of an email should reply to.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration#replyTo
   */
  readonly replyTo?: string;

  /**
   * The Amazon Resource Name (ARN) of the identity that is associated with the sending authorization policy. This identity permits Amazon Cognito to send for the email address specified in the From parameter.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration#sourceArn
   */
  readonly sourceArn: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'blockEmail': obj.blockEmail?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail(y)),
    'from': obj.from,
    'mfaEmail': obj.mfaEmail?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail(y)),
    'noActionEmail': obj.noActionEmail?.map(y => toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail(y)),
    'replyTo': obj.replyTo,
    'sourceArn': obj.sourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions
 */
export interface RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions {
  /**
   * The action to take in response to the account takeover action. Valid values are BLOCK, MFA_IF_CONFIGURED, MFA_REQUIRED and NO_ACTION.
   *
   * @schema RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions#eventAction
   */
  readonly eventAction: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions(obj: RiskConfigurationSpecForProviderCompromisedCredentialsRiskConfigurationActions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventAction': obj.eventAction,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdRefPolicy
 */
export interface RiskConfigurationSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: RiskConfigurationSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: RiskConfigurationSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderUserPoolIdRefPolicy(obj: RiskConfigurationSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy
 */
export interface RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: RiskConfigurationSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: RiskConfigurationSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy(obj: RiskConfigurationSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RiskConfigurationSpecProviderConfigRefPolicyResolution
 */
export enum RiskConfigurationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RiskConfigurationSpecProviderConfigRefPolicyResolve
 */
export enum RiskConfigurationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RiskConfigurationSpecProviderRefPolicyResolution
 */
export enum RiskConfigurationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RiskConfigurationSpecProviderRefPolicyResolve
 */
export enum RiskConfigurationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy(obj: RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction {
  /**
   * The action to take in response to the account takeover action. Valid values are BLOCK, MFA_IF_CONFIGURED, MFA_REQUIRED and NO_ACTION.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction#eventAction
   */
  readonly eventAction: string;

  /**
   * Whether to send a notification.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction#notify
   */
  readonly notify: boolean;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsHighAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventAction': obj.eventAction,
    'notify': obj.notify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction {
  /**
   * The action to take in response to the account takeover action. Valid values are BLOCK, MFA_IF_CONFIGURED, MFA_REQUIRED and NO_ACTION.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction#eventAction
   */
  readonly eventAction: string;

  /**
   * Whether to send a notification.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction#notify
   */
  readonly notify: boolean;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsLowAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventAction': obj.eventAction,
    'notify': obj.notify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction {
  /**
   * The action to take in response to the account takeover action. Valid values are BLOCK, MFA_IF_CONFIGURED, MFA_REQUIRED and NO_ACTION.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction#eventAction
   */
  readonly eventAction: string;

  /**
   * Whether to send a notification.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction#notify
   */
  readonly notify: boolean;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationActionsMediumAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'eventAction': obj.eventAction,
    'notify': obj.notify,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail {
  /**
   * The email HTML body.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail#htmlBody
   */
  readonly htmlBody: string;

  /**
   * The email subject.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail#subject
   */
  readonly subject: string;

  /**
   * The email text body.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail#textBody
   */
  readonly textBody: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationBlockEmail | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'htmlBody': obj.htmlBody,
    'subject': obj.subject,
    'textBody': obj.textBody,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail {
  /**
   * The email HTML body.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail#htmlBody
   */
  readonly htmlBody: string;

  /**
   * The email subject.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail#subject
   */
  readonly subject: string;

  /**
   * The email text body.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail#textBody
   */
  readonly textBody: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationMfaEmail | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'htmlBody': obj.htmlBody,
    'subject': obj.subject,
    'textBody': obj.textBody,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail
 */
export interface RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail {
  /**
   * The email HTML body.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail#htmlBody
   */
  readonly htmlBody: string;

  /**
   * The email subject.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail#subject
   */
  readonly subject: string;

  /**
   * The email text body.
   *
   * @schema RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail#textBody
   */
  readonly textBody: string;

}

/**
 * Converts an object of type 'RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail(obj: RiskConfigurationSpecForProviderAccountTakeoverRiskConfigurationNotifyConfigurationNoActionEmail | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'htmlBody': obj.htmlBody,
    'subject': obj.subject,
    'textBody': obj.textBody,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum RiskConfigurationSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum RiskConfigurationSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum RiskConfigurationSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RiskConfigurationSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum RiskConfigurationSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RiskConfigurationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API. Provides a Cognito User resource.
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API. Provides a Cognito User resource.
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserSpec#providerRef
   */
  readonly providerRef?: UserSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * A map that contains user attributes and attribute values to be set for the user.
   *
   * @schema UserSpecForProvider#attributes
   */
  readonly attributes?: { [key: string]: string };

  /**
   * A map of custom key-value pairs that you can provide as input for any custom workflows that user creation triggers. Amazon Cognito does not store the client_metadata value. This data is available only to Lambda triggers that are assigned to a user pool to support custom workflows. If your user pool configuration does not include triggers, the ClientMetadata parameter serves no purpose. For more information, see Customizing User Pool Workflows with Lambda Triggers.
   *
   * @schema UserSpecForProvider#clientMetadata
   */
  readonly clientMetadata?: { [key: string]: string };

  /**
   * A list of mediums to the welcome message will be sent through. Allowed values are EMAIL and SMS. If it's provided, make sure you have also specified email attribute for the EMAIL medium and phone_number for the SMS. More than one value can be specified. Amazon Cognito does not store the desired_delivery_mediums value. Defaults to ["SMS"].
   *
   * @default SMS"].
   * @schema UserSpecForProvider#desiredDeliveryMediums
   */
  readonly desiredDeliveryMediums?: string[];

  /**
   * Specifies whether the user should be enabled after creation. The welcome message will be sent regardless of the enabled value. The behavior can be changed with message_action argument. Defaults to true.
   *
   * @default true.
   * @schema UserSpecForProvider#enabled
   */
  readonly enabled?: boolean;

  /**
   * If this parameter is set to True and the phone_number or email address specified in the attributes parameter already exists as an alias with a different user, Amazon Cognito will migrate the alias from the previous user to the newly created user. The previous user will no longer be able to log in using that alias. Amazon Cognito does not store the force_alias_creation value. Defaults to false.
   *
   * @default false.
   * @schema UserSpecForProvider#forceAliasCreation
   */
  readonly forceAliasCreation?: boolean;

  /**
   * Set to RESEND to resend the invitation message to a user that already exists and reset the expiration limit on the user's account. Set to SUPPRESS to suppress sending the message. Only one value can be specified. Amazon Cognito does not store the message_action value.
   *
   * @schema UserSpecForProvider#messageAction
   */
  readonly messageAction?: string;

  /**
   * The user's permanent password. This password must conform to the password policy specified by user pool the user belongs to. The welcome message always contains only temporary_password value. You can suppress sending the welcome message with the message_action argument. Amazon Cognito does not store the password value. Conflicts with temporary_password.
   *
   * @schema UserSpecForProvider#passwordSecretRef
   */
  readonly passwordSecretRef?: UserSpecForProviderPasswordSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user's temporary password. Conflicts with password.
   *
   * @schema UserSpecForProvider#temporaryPasswordSecretRef
   */
  readonly temporaryPasswordSecretRef?: UserSpecForProviderTemporaryPasswordSecretRef;

  /**
   * The user pool ID for the user pool where the user will be created.
   *
   * @schema UserSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema UserSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema UserSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserSpecForProviderUserPoolIdSelector;

  /**
   * The user's validation data. This is an array of name-value pairs that contain user attributes and attribute values that you can use for custom validation, such as restricting the types of user accounts that can be registered. Amazon Cognito does not store the validation_data value. For more information, see Customizing User Pool Workflows with Lambda Triggers.
   *
   * @schema UserSpecForProvider#validationData
   */
  readonly validationData?: { [key: string]: string };

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributes': ((obj.attributes) === undefined) ? undefined : (Object.entries(obj.attributes).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'clientMetadata': ((obj.clientMetadata) === undefined) ? undefined : (Object.entries(obj.clientMetadata).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'desiredDeliveryMediums': obj.desiredDeliveryMediums?.map(y => y),
    'enabled': obj.enabled,
    'forceAliasCreation': obj.forceAliasCreation,
    'messageAction': obj.messageAction,
    'passwordSecretRef': toJson_UserSpecForProviderPasswordSecretRef(obj.passwordSecretRef),
    'region': obj.region,
    'temporaryPasswordSecretRef': toJson_UserSpecForProviderTemporaryPasswordSecretRef(obj.temporaryPasswordSecretRef),
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
    'validationData': ((obj.validationData) === undefined) ? undefined : (Object.entries(obj.validationData).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserSpecProviderRef
 */
export interface UserSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderRef#policy
   */
  readonly policy?: UserSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderRef(obj: UserSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The user's permanent password. This password must conform to the password policy specified by user pool the user belongs to. The welcome message always contains only temporary_password value. You can suppress sending the welcome message with the message_action argument. Amazon Cognito does not store the password value. Conflicts with temporary_password.
 *
 * @schema UserSpecForProviderPasswordSecretRef
 */
export interface UserSpecForProviderPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema UserSpecForProviderPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecForProviderPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecForProviderPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPasswordSecretRef(obj: UserSpecForProviderPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The user's temporary password. Conflicts with password.
 *
 * @schema UserSpecForProviderTemporaryPasswordSecretRef
 */
export interface UserSpecForProviderTemporaryPasswordSecretRef {
  /**
   * The key to select.
   *
   * @schema UserSpecForProviderTemporaryPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema UserSpecForProviderTemporaryPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecForProviderTemporaryPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecForProviderTemporaryPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderTemporaryPasswordSecretRef(obj: UserSpecForProviderTemporaryPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema UserSpecForProviderUserPoolIdRef
 */
export interface UserSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderUserPoolIdRef(obj: UserSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema UserSpecForProviderUserPoolIdSelector
 */
export interface UserSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderUserPoolIdSelector(obj: UserSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderRefPolicy
 */
export interface UserSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderRefPolicy(obj: UserSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecForProviderUserPoolIdRefPolicy
 */
export interface UserSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderUserPoolIdRefPolicy(obj: UserSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderUserPoolIdSelectorPolicy(obj: UserSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderRefPolicyResolution
 */
export enum UserSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecProviderRefPolicyResolve
 */
export enum UserSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserGroup is the Schema for the UserGroups API. Provides a Cognito User Group resource.
 *
 * @schema UserGroup
 */
export class UserGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'UserGroup',
  }

  /**
   * Renders a Kubernetes manifest for "UserGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserGroupProps): any {
    return {
      ...UserGroup.GVK,
      ...toJson_UserGroupProps(props),
    };
  }

  /**
   * Defines a "UserGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserGroupProps) {
    super(scope, id, {
      ...UserGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserGroup.GVK,
      ...toJson_UserGroupProps(resolved),
    };
  }
}

/**
 * UserGroup is the Schema for the UserGroups API. Provides a Cognito User Group resource.
 *
 * @schema UserGroup
 */
export interface UserGroupProps {
  /**
   * @schema UserGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserGroupSpec defines the desired state of UserGroup
   *
   * @schema UserGroup#spec
   */
  readonly spec: UserGroupSpec;

}

/**
 * Converts an object of type 'UserGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupProps(obj: UserGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserGroupSpec defines the desired state of UserGroup
 *
 * @schema UserGroupSpec
 */
export interface UserGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema UserGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserGroupSpecDeletionPolicy;

  /**
   * @schema UserGroupSpec#forProvider
   */
  readonly forProvider: UserGroupSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserGroupSpec#providerRef
   */
  readonly providerRef?: UserGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpec(obj: UserGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserGroupSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_UserGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema UserGroupSpecDeletionPolicy
 */
export enum UserGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserGroupSpecForProvider
 */
export interface UserGroupSpecForProvider {
  /**
   * The description of the user group.
   *
   * @schema UserGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The name of the user group.
   *
   * @schema UserGroupSpecForProvider#name
   */
  readonly name: string;

  /**
   * The precedence of the user group.
   *
   * @schema UserGroupSpecForProvider#precedence
   */
  readonly precedence?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the IAM role to be associated with the user group.
   *
   * @schema UserGroupSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema UserGroupSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: UserGroupSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema UserGroupSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: UserGroupSpecForProviderRoleArnSelector;

  /**
   * The user pool ID.
   *
   * @schema UserGroupSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool to populate userPoolId.
   *
   * @schema UserGroupSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserGroupSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool to populate userPoolId.
   *
   * @schema UserGroupSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserGroupSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'UserGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProvider(obj: UserGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'name': obj.name,
    'precedence': obj.precedence,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_UserGroupSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_UserGroupSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserGroupSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserGroupSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserGroupSpecProviderConfigRef
 */
export interface UserGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserGroupSpecProviderConfigRef#policy
   */
  readonly policy?: UserGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecProviderConfigRef(obj: UserGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserGroupSpecProviderRef
 */
export interface UserGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserGroupSpecProviderRef#policy
   */
  readonly policy?: UserGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecProviderRef(obj: UserGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserGroupSpecPublishConnectionDetailsTo
 */
export interface UserGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecPublishConnectionDetailsTo(obj: UserGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserGroupSpecWriteConnectionSecretToRef
 */
export interface UserGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecWriteConnectionSecretToRef(obj: UserGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema UserGroupSpecForProviderRoleArnRef
 */
export interface UserGroupSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserGroupSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserGroupSpecForProviderRoleArnRef#policy
   */
  readonly policy?: UserGroupSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderRoleArnRef(obj: UserGroupSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserGroupSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema UserGroupSpecForProviderRoleArnSelector
 */
export interface UserGroupSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserGroupSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserGroupSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserGroupSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: UserGroupSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderRoleArnSelector(obj: UserGroupSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserGroupSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool to populate userPoolId.
 *
 * @schema UserGroupSpecForProviderUserPoolIdRef
 */
export interface UserGroupSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserGroupSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserGroupSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserGroupSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderUserPoolIdRef(obj: UserGroupSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserGroupSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool to populate userPoolId.
 *
 * @schema UserGroupSpecForProviderUserPoolIdSelector
 */
export interface UserGroupSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserGroupSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserGroupSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserGroupSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserGroupSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderUserPoolIdSelector(obj: UserGroupSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserGroupSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserGroupSpecProviderConfigRefPolicy
 */
export interface UserGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecProviderConfigRefPolicy(obj: UserGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserGroupSpecProviderRefPolicy
 */
export interface UserGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecProviderRefPolicy(obj: UserGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface UserGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecPublishConnectionDetailsToConfigRef(obj: UserGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserGroupSpecPublishConnectionDetailsToMetadata
 */
export interface UserGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecPublishConnectionDetailsToMetadata(obj: UserGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserGroupSpecForProviderRoleArnRefPolicy
 */
export interface UserGroupSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserGroupSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: UserGroupSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserGroupSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: UserGroupSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderRoleArnRefPolicy(obj: UserGroupSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserGroupSpecForProviderRoleArnSelectorPolicy
 */
export interface UserGroupSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserGroupSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: UserGroupSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserGroupSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: UserGroupSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderRoleArnSelectorPolicy(obj: UserGroupSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserGroupSpecForProviderUserPoolIdRefPolicy
 */
export interface UserGroupSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserGroupSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserGroupSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserGroupSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserGroupSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderUserPoolIdRefPolicy(obj: UserGroupSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserGroupSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserGroupSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserGroupSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserGroupSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserGroupSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserGroupSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserGroupSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecForProviderUserPoolIdSelectorPolicy(obj: UserGroupSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserGroupSpecProviderConfigRefPolicyResolution
 */
export enum UserGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserGroupSpecProviderConfigRefPolicyResolve
 */
export enum UserGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserGroupSpecProviderRefPolicyResolution
 */
export enum UserGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserGroupSpecProviderRefPolicyResolve
 */
export enum UserGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserGroupSpecForProviderRoleArnRefPolicyResolution
 */
export enum UserGroupSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserGroupSpecForProviderRoleArnRefPolicyResolve
 */
export enum UserGroupSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserGroupSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum UserGroupSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserGroupSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum UserGroupSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserGroupSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserGroupSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserGroupSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserGroupSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserGroupSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserGroupSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserGroupSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserGroupSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserInGroup is the Schema for the UserInGroups API. Adds the specified user to the specified group.
 *
 * @schema UserInGroup
 */
export class UserInGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserInGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'UserInGroup',
  }

  /**
   * Renders a Kubernetes manifest for "UserInGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserInGroupProps): any {
    return {
      ...UserInGroup.GVK,
      ...toJson_UserInGroupProps(props),
    };
  }

  /**
   * Defines a "UserInGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserInGroupProps) {
    super(scope, id, {
      ...UserInGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserInGroup.GVK,
      ...toJson_UserInGroupProps(resolved),
    };
  }
}

/**
 * UserInGroup is the Schema for the UserInGroups API. Adds the specified user to the specified group.
 *
 * @schema UserInGroup
 */
export interface UserInGroupProps {
  /**
   * @schema UserInGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserInGroupSpec defines the desired state of UserInGroup
   *
   * @schema UserInGroup#spec
   */
  readonly spec: UserInGroupSpec;

}

/**
 * Converts an object of type 'UserInGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupProps(obj: UserInGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserInGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserInGroupSpec defines the desired state of UserInGroup
 *
 * @schema UserInGroupSpec
 */
export interface UserInGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema UserInGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserInGroupSpecDeletionPolicy;

  /**
   * @schema UserInGroupSpec#forProvider
   */
  readonly forProvider: UserInGroupSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserInGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserInGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserInGroupSpec#providerRef
   */
  readonly providerRef?: UserInGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserInGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserInGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserInGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserInGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserInGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpec(obj: UserInGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserInGroupSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_UserInGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserInGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserInGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserInGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema UserInGroupSpecDeletionPolicy
 */
export enum UserInGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserInGroupSpecForProvider
 */
export interface UserInGroupSpecForProvider {
  /**
   * The name of the group to which the user is to be added.
   *
   * @schema UserInGroupSpecForProvider#groupName
   */
  readonly groupName?: string;

  /**
   * Reference to a UserGroup in cognitoidp to populate groupName.
   *
   * @schema UserInGroupSpecForProvider#groupNameRef
   */
  readonly groupNameRef?: UserInGroupSpecForProviderGroupNameRef;

  /**
   * Selector for a UserGroup in cognitoidp to populate groupName.
   *
   * @schema UserInGroupSpecForProvider#groupNameSelector
   */
  readonly groupNameSelector?: UserInGroupSpecForProviderGroupNameSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserInGroupSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user pool ID of the user and group.
   *
   * @schema UserInGroupSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema UserInGroupSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserInGroupSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool in cognitoidp to populate userPoolId.
   *
   * @schema UserInGroupSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserInGroupSpecForProviderUserPoolIdSelector;

  /**
   * The username of the user to be added to the group.
   *
   * @schema UserInGroupSpecForProvider#username
   */
  readonly username?: string;

  /**
   * Reference to a User in cognitoidp to populate username.
   *
   * @schema UserInGroupSpecForProvider#usernameRef
   */
  readonly usernameRef?: UserInGroupSpecForProviderUsernameRef;

  /**
   * Selector for a User in cognitoidp to populate username.
   *
   * @schema UserInGroupSpecForProvider#usernameSelector
   */
  readonly usernameSelector?: UserInGroupSpecForProviderUsernameSelector;

}

/**
 * Converts an object of type 'UserInGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProvider(obj: UserInGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupName': obj.groupName,
    'groupNameRef': toJson_UserInGroupSpecForProviderGroupNameRef(obj.groupNameRef),
    'groupNameSelector': toJson_UserInGroupSpecForProviderGroupNameSelector(obj.groupNameSelector),
    'region': obj.region,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserInGroupSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserInGroupSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
    'username': obj.username,
    'usernameRef': toJson_UserInGroupSpecForProviderUsernameRef(obj.usernameRef),
    'usernameSelector': toJson_UserInGroupSpecForProviderUsernameSelector(obj.usernameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserInGroupSpecProviderConfigRef
 */
export interface UserInGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserInGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserInGroupSpecProviderConfigRef#policy
   */
  readonly policy?: UserInGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecProviderConfigRef(obj: UserInGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserInGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserInGroupSpecProviderRef
 */
export interface UserInGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserInGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserInGroupSpecProviderRef#policy
   */
  readonly policy?: UserInGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecProviderRef(obj: UserInGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserInGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserInGroupSpecPublishConnectionDetailsTo
 */
export interface UserInGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserInGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserInGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserInGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecPublishConnectionDetailsTo(obj: UserInGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserInGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserInGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserInGroupSpecWriteConnectionSecretToRef
 */
export interface UserInGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserInGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserInGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserInGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecWriteConnectionSecretToRef(obj: UserInGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserGroup in cognitoidp to populate groupName.
 *
 * @schema UserInGroupSpecForProviderGroupNameRef
 */
export interface UserInGroupSpecForProviderGroupNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserInGroupSpecForProviderGroupNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserInGroupSpecForProviderGroupNameRef#policy
   */
  readonly policy?: UserInGroupSpecForProviderGroupNameRefPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderGroupNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderGroupNameRef(obj: UserInGroupSpecForProviderGroupNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserInGroupSpecForProviderGroupNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserGroup in cognitoidp to populate groupName.
 *
 * @schema UserInGroupSpecForProviderGroupNameSelector
 */
export interface UserInGroupSpecForProviderGroupNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserInGroupSpecForProviderGroupNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserInGroupSpecForProviderGroupNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserInGroupSpecForProviderGroupNameSelector#policy
   */
  readonly policy?: UserInGroupSpecForProviderGroupNameSelectorPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderGroupNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderGroupNameSelector(obj: UserInGroupSpecForProviderGroupNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserInGroupSpecForProviderGroupNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdRef
 */
export interface UserInGroupSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserInGroupSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUserPoolIdRef(obj: UserInGroupSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserInGroupSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool in cognitoidp to populate userPoolId.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdSelector
 */
export interface UserInGroupSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserInGroupSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUserPoolIdSelector(obj: UserInGroupSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserInGroupSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in cognitoidp to populate username.
 *
 * @schema UserInGroupSpecForProviderUsernameRef
 */
export interface UserInGroupSpecForProviderUsernameRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserInGroupSpecForProviderUsernameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserInGroupSpecForProviderUsernameRef#policy
   */
  readonly policy?: UserInGroupSpecForProviderUsernameRefPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUsernameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUsernameRef(obj: UserInGroupSpecForProviderUsernameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserInGroupSpecForProviderUsernameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in cognitoidp to populate username.
 *
 * @schema UserInGroupSpecForProviderUsernameSelector
 */
export interface UserInGroupSpecForProviderUsernameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserInGroupSpecForProviderUsernameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserInGroupSpecForProviderUsernameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserInGroupSpecForProviderUsernameSelector#policy
   */
  readonly policy?: UserInGroupSpecForProviderUsernameSelectorPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUsernameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUsernameSelector(obj: UserInGroupSpecForProviderUsernameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserInGroupSpecForProviderUsernameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserInGroupSpecProviderConfigRefPolicy
 */
export interface UserInGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecProviderConfigRefPolicy(obj: UserInGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserInGroupSpecProviderRefPolicy
 */
export interface UserInGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecProviderRefPolicy(obj: UserInGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserInGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface UserInGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserInGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecPublishConnectionDetailsToConfigRef(obj: UserInGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserInGroupSpecPublishConnectionDetailsToMetadata
 */
export interface UserInGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserInGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecPublishConnectionDetailsToMetadata(obj: UserInGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserInGroupSpecForProviderGroupNameRefPolicy
 */
export interface UserInGroupSpecForProviderGroupNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecForProviderGroupNameRefPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecForProviderGroupNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecForProviderGroupNameRefPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecForProviderGroupNameRefPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderGroupNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderGroupNameRefPolicy(obj: UserInGroupSpecForProviderGroupNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserInGroupSpecForProviderGroupNameSelectorPolicy
 */
export interface UserInGroupSpecForProviderGroupNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecForProviderGroupNameSelectorPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecForProviderGroupNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecForProviderGroupNameSelectorPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecForProviderGroupNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderGroupNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderGroupNameSelectorPolicy(obj: UserInGroupSpecForProviderGroupNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdRefPolicy
 */
export interface UserInGroupSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUserPoolIdRefPolicy(obj: UserInGroupSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserInGroupSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUserPoolIdSelectorPolicy(obj: UserInGroupSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserInGroupSpecForProviderUsernameRefPolicy
 */
export interface UserInGroupSpecForProviderUsernameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecForProviderUsernameRefPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecForProviderUsernameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecForProviderUsernameRefPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecForProviderUsernameRefPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUsernameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUsernameRefPolicy(obj: UserInGroupSpecForProviderUsernameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserInGroupSpecForProviderUsernameSelectorPolicy
 */
export interface UserInGroupSpecForProviderUsernameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecForProviderUsernameSelectorPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecForProviderUsernameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecForProviderUsernameSelectorPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecForProviderUsernameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecForProviderUsernameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecForProviderUsernameSelectorPolicy(obj: UserInGroupSpecForProviderUsernameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecProviderConfigRefPolicyResolution
 */
export enum UserInGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecProviderConfigRefPolicyResolve
 */
export enum UserInGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecProviderRefPolicyResolution
 */
export enum UserInGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecProviderRefPolicyResolve
 */
export enum UserInGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserInGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserInGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserInGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecForProviderGroupNameRefPolicyResolution
 */
export enum UserInGroupSpecForProviderGroupNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecForProviderGroupNameRefPolicyResolve
 */
export enum UserInGroupSpecForProviderGroupNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecForProviderGroupNameSelectorPolicyResolution
 */
export enum UserInGroupSpecForProviderGroupNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecForProviderGroupNameSelectorPolicyResolve
 */
export enum UserInGroupSpecForProviderGroupNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserInGroupSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserInGroupSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserInGroupSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserInGroupSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecForProviderUsernameRefPolicyResolution
 */
export enum UserInGroupSpecForProviderUsernameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecForProviderUsernameRefPolicyResolve
 */
export enum UserInGroupSpecForProviderUsernameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecForProviderUsernameSelectorPolicyResolution
 */
export enum UserInGroupSpecForProviderUsernameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecForProviderUsernameSelectorPolicyResolve
 */
export enum UserInGroupSpecForProviderUsernameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserInGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserInGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserInGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserInGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserPool is the Schema for the UserPools API. Provides a Cognito User Pool resource.
 *
 * @schema UserPool
 */
export class UserPool extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserPool"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'UserPool',
  }

  /**
   * Renders a Kubernetes manifest for "UserPool".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserPoolProps): any {
    return {
      ...UserPool.GVK,
      ...toJson_UserPoolProps(props),
    };
  }

  /**
   * Defines a "UserPool" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserPoolProps) {
    super(scope, id, {
      ...UserPool.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserPool.GVK,
      ...toJson_UserPoolProps(resolved),
    };
  }
}

/**
 * UserPool is the Schema for the UserPools API. Provides a Cognito User Pool resource.
 *
 * @schema UserPool
 */
export interface UserPoolProps {
  /**
   * @schema UserPool#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserPoolSpec defines the desired state of UserPool
   *
   * @schema UserPool#spec
   */
  readonly spec: UserPoolSpec;

}

/**
 * Converts an object of type 'UserPoolProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolProps(obj: UserPoolProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserPoolSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolSpec defines the desired state of UserPool
 *
 * @schema UserPoolSpec
 */
export interface UserPoolSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema UserPoolSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserPoolSpecDeletionPolicy;

  /**
   * @schema UserPoolSpec#forProvider
   */
  readonly forProvider: UserPoolSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserPoolSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserPoolSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserPoolSpec#providerRef
   */
  readonly providerRef?: UserPoolSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserPoolSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserPoolSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserPoolSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserPoolSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserPoolSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpec(obj: UserPoolSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserPoolSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_UserPoolSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserPoolSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserPoolSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserPoolSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema UserPoolSpecDeletionPolicy
 */
export enum UserPoolSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserPoolSpecForProvider
 */
export interface UserPoolSpecForProvider {
  /**
   * Configuration block to define which verified available method a user can use to recover their forgotten password. Detailed below.
   *
   * @schema UserPoolSpecForProvider#accountRecoverySetting
   */
  readonly accountRecoverySetting?: UserPoolSpecForProviderAccountRecoverySetting[];

  /**
   * Configuration block for creating a new user profile. Detailed below.
   *
   * @schema UserPoolSpecForProvider#adminCreateUserConfig
   */
  readonly adminCreateUserConfig?: UserPoolSpecForProviderAdminCreateUserConfig[];

  /**
   * Attributes supported as an alias for this user pool. Valid values: phone_number, email, or preferred_username. Conflicts with username_attributes.
   *
   * @schema UserPoolSpecForProvider#aliasAttributes
   */
  readonly aliasAttributes?: string[];

  /**
   * Attributes to be auto-verified. Valid values: email, phone_number.
   *
   * @schema UserPoolSpecForProvider#autoVerifiedAttributes
   */
  readonly autoVerifiedAttributes?: string[];

  /**
   * When active, DeletionProtection prevents accidental deletion of your user pool. Before you can delete a user pool that you have protected against deletion, you must deactivate this feature. Valid values are ACTIVE and INACTIVE, Default value is INACTIVE.
   *
   * @schema UserPoolSpecForProvider#deletionProtection
   */
  readonly deletionProtection?: string;

  /**
   * Configuration block for the user pool's device tracking. Detailed below.
   *
   * @schema UserPoolSpecForProvider#deviceConfiguration
   */
  readonly deviceConfiguration?: UserPoolSpecForProviderDeviceConfiguration[];

  /**
   * Configuration block for configuring email. Detailed below.
   *
   * @schema UserPoolSpecForProvider#emailConfiguration
   */
  readonly emailConfiguration?: UserPoolSpecForProviderEmailConfiguration[];

  /**
   * String representing the email verification message. Conflicts with verification_message_template configuration block email_message argument.
   *
   * @schema UserPoolSpecForProvider#emailVerificationMessage
   */
  readonly emailVerificationMessage?: string;

  /**
   * String representing the email verification subject. Conflicts with verification_message_template configuration block email_subject argument.
   *
   * @schema UserPoolSpecForProvider#emailVerificationSubject
   */
  readonly emailVerificationSubject?: string;

  /**
   * Configuration block for the AWS Lambda triggers associated with the user pool. Detailed below.
   *
   * @schema UserPoolSpecForProvider#lambdaConfig
   */
  readonly lambdaConfig?: UserPoolSpecForProviderLambdaConfig[];

  /**
   * Multi-Factor Authentication (MFA) configuration for the User Pool. Defaults of OFF. Valid values are OFF (MFA Tokens are not required), ON (MFA is required for all users to sign in; requires at least one of sms_configuration or software_token_mfa_configuration to be configured), or OPTIONAL (MFA Will be required only for individual users who have MFA Enabled; requires at least one of sms_configuration or software_token_mfa_configuration to be configured).
   *
   * @schema UserPoolSpecForProvider#mfaConfiguration
   */
  readonly mfaConfiguration?: string;

  /**
   * Name of the user pool.
   *
   * @schema UserPoolSpecForProvider#name
   */
  readonly name: string;

  /**
   * Configuration blocked for information about the user pool password policy. Detailed below.
   *
   * @schema UserPoolSpecForProvider#passwordPolicy
   */
  readonly passwordPolicy?: UserPoolSpecForProviderPasswordPolicy[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserPoolSpecForProvider#region
   */
  readonly region: string;

  /**
   * Configuration block for the schema attributes of a user pool. Detailed below. Schema attributes from the standard attribute set only need to be specified if they are different from the default configuration. Attributes can be added, but not modified or removed. Maximum of 50 attributes.
   *
   * @schema UserPoolSpecForProvider#schema
   */
  readonly schema?: UserPoolSpecForProviderSchema[];

  /**
   * String representing the SMS authentication message. The Message must contain the {####} placeholder, which will be replaced with the code.
   *
   * @schema UserPoolSpecForProvider#smsAuthenticationMessage
   */
  readonly smsAuthenticationMessage?: string;

  /**
   * Configuration block for Short Message Service (SMS) settings. Detailed below. These settings apply to SMS user verification and SMS Multi-Factor Authentication (MFA). Due to Cognito API restrictions, the SMS configuration cannot be removed without recreating the Cognito User Pool. For user data safety, this resource will ignore the removal of this configuration by disabling drift detection. To force resource recreation after this configuration has been applied, see the taint command.
   *
   * @schema UserPoolSpecForProvider#smsConfiguration
   */
  readonly smsConfiguration?: UserPoolSpecForProviderSmsConfiguration[];

  /**
   * String representing the SMS verification message. Conflicts with verification_message_template configuration block sms_message argument.
   *
   * @schema UserPoolSpecForProvider#smsVerificationMessage
   */
  readonly smsVerificationMessage?: string;

  /**
   * Configuration block for software token Mult-Factor Authentication (MFA) settings. Detailed below.
   *
   * @schema UserPoolSpecForProvider#softwareTokenMfaConfiguration
   */
  readonly softwareTokenMfaConfiguration?: UserPoolSpecForProviderSoftwareTokenMfaConfiguration[];

  /**
   * Key-value map of resource tags.
   *
   * @schema UserPoolSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block for user attribute update settings. Detailed below.
   *
   * @schema UserPoolSpecForProvider#userAttributeUpdateSettings
   */
  readonly userAttributeUpdateSettings?: UserPoolSpecForProviderUserAttributeUpdateSettings[];

  /**
   * Configuration block for user pool add-ons to enable user pool advanced security mode features. Detailed below.
   *
   * @schema UserPoolSpecForProvider#userPoolAddOns
   */
  readonly userPoolAddOns?: UserPoolSpecForProviderUserPoolAddOns[];

  /**
   * Whether email addresses or phone numbers can be specified as usernames when a user signs up. Conflicts with alias_attributes.
   *
   * @schema UserPoolSpecForProvider#usernameAttributes
   */
  readonly usernameAttributes?: string[];

  /**
   * Configuration block for username configuration. Detailed below.
   *
   * @schema UserPoolSpecForProvider#usernameConfiguration
   */
  readonly usernameConfiguration?: UserPoolSpecForProviderUsernameConfiguration[];

  /**
   * Configuration block for verification message templates. Detailed below.
   *
   * @schema UserPoolSpecForProvider#verificationMessageTemplate
   */
  readonly verificationMessageTemplate?: UserPoolSpecForProviderVerificationMessageTemplate[];

}

/**
 * Converts an object of type 'UserPoolSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProvider(obj: UserPoolSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountRecoverySetting': obj.accountRecoverySetting?.map(y => toJson_UserPoolSpecForProviderAccountRecoverySetting(y)),
    'adminCreateUserConfig': obj.adminCreateUserConfig?.map(y => toJson_UserPoolSpecForProviderAdminCreateUserConfig(y)),
    'aliasAttributes': obj.aliasAttributes?.map(y => y),
    'autoVerifiedAttributes': obj.autoVerifiedAttributes?.map(y => y),
    'deletionProtection': obj.deletionProtection,
    'deviceConfiguration': obj.deviceConfiguration?.map(y => toJson_UserPoolSpecForProviderDeviceConfiguration(y)),
    'emailConfiguration': obj.emailConfiguration?.map(y => toJson_UserPoolSpecForProviderEmailConfiguration(y)),
    'emailVerificationMessage': obj.emailVerificationMessage,
    'emailVerificationSubject': obj.emailVerificationSubject,
    'lambdaConfig': obj.lambdaConfig?.map(y => toJson_UserPoolSpecForProviderLambdaConfig(y)),
    'mfaConfiguration': obj.mfaConfiguration,
    'name': obj.name,
    'passwordPolicy': obj.passwordPolicy?.map(y => toJson_UserPoolSpecForProviderPasswordPolicy(y)),
    'region': obj.region,
    'schema': obj.schema?.map(y => toJson_UserPoolSpecForProviderSchema(y)),
    'smsAuthenticationMessage': obj.smsAuthenticationMessage,
    'smsConfiguration': obj.smsConfiguration?.map(y => toJson_UserPoolSpecForProviderSmsConfiguration(y)),
    'smsVerificationMessage': obj.smsVerificationMessage,
    'softwareTokenMfaConfiguration': obj.softwareTokenMfaConfiguration?.map(y => toJson_UserPoolSpecForProviderSoftwareTokenMfaConfiguration(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'userAttributeUpdateSettings': obj.userAttributeUpdateSettings?.map(y => toJson_UserPoolSpecForProviderUserAttributeUpdateSettings(y)),
    'userPoolAddOns': obj.userPoolAddOns?.map(y => toJson_UserPoolSpecForProviderUserPoolAddOns(y)),
    'usernameAttributes': obj.usernameAttributes?.map(y => y),
    'usernameConfiguration': obj.usernameConfiguration?.map(y => toJson_UserPoolSpecForProviderUsernameConfiguration(y)),
    'verificationMessageTemplate': obj.verificationMessageTemplate?.map(y => toJson_UserPoolSpecForProviderVerificationMessageTemplate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserPoolSpecProviderConfigRef
 */
export interface UserPoolSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolSpecProviderConfigRef#policy
   */
  readonly policy?: UserPoolSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecProviderConfigRef(obj: UserPoolSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserPoolSpecProviderRef
 */
export interface UserPoolSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolSpecProviderRef#policy
   */
  readonly policy?: UserPoolSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecProviderRef(obj: UserPoolSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserPoolSpecPublishConnectionDetailsTo
 */
export interface UserPoolSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserPoolSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserPoolSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserPoolSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserPoolSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserPoolSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsTo(obj: UserPoolSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserPoolSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserPoolSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserPoolSpecWriteConnectionSecretToRef
 */
export interface UserPoolSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserPoolSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserPoolSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserPoolSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecWriteConnectionSecretToRef(obj: UserPoolSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderAccountRecoverySetting
 */
export interface UserPoolSpecForProviderAccountRecoverySetting {
  /**
   * List of Account Recovery Options of the following structure:
   *
   * @schema UserPoolSpecForProviderAccountRecoverySetting#recoveryMechanism
   */
  readonly recoveryMechanism: UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism[];

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAccountRecoverySetting' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAccountRecoverySetting(obj: UserPoolSpecForProviderAccountRecoverySetting | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'recoveryMechanism': obj.recoveryMechanism?.map(y => toJson_UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderAdminCreateUserConfig
 */
export interface UserPoolSpecForProviderAdminCreateUserConfig {
  /**
   * Set to True if only the administrator is allowed to create user profiles. Set to False if users can sign themselves up via an app.
   *
   * @schema UserPoolSpecForProviderAdminCreateUserConfig#allowAdminCreateUserOnly
   */
  readonly allowAdminCreateUserOnly?: boolean;

  /**
   * Invite message template structure. Detailed below.
   *
   * @schema UserPoolSpecForProviderAdminCreateUserConfig#inviteMessageTemplate
   */
  readonly inviteMessageTemplate?: UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate[];

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAdminCreateUserConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAdminCreateUserConfig(obj: UserPoolSpecForProviderAdminCreateUserConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowAdminCreateUserOnly': obj.allowAdminCreateUserOnly,
    'inviteMessageTemplate': obj.inviteMessageTemplate?.map(y => toJson_UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderDeviceConfiguration
 */
export interface UserPoolSpecForProviderDeviceConfiguration {
  /**
   * Whether a challenge is required on a new device. Only applicable to a new device.
   *
   * @schema UserPoolSpecForProviderDeviceConfiguration#challengeRequiredOnNewDevice
   */
  readonly challengeRequiredOnNewDevice?: boolean;

  /**
   * Whether a device is only remembered on user prompt. false equates to "Always" remember, true is "User Opt In," and not using a device_configuration block is "No."
   *
   * @schema UserPoolSpecForProviderDeviceConfiguration#deviceOnlyRememberedOnUserPrompt
   */
  readonly deviceOnlyRememberedOnUserPrompt?: boolean;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderDeviceConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderDeviceConfiguration(obj: UserPoolSpecForProviderDeviceConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'challengeRequiredOnNewDevice': obj.challengeRequiredOnNewDevice,
    'deviceOnlyRememberedOnUserPrompt': obj.deviceOnlyRememberedOnUserPrompt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderEmailConfiguration
 */
export interface UserPoolSpecForProviderEmailConfiguration {
  /**
   * Email configuration set name from SES.
   *
   * @schema UserPoolSpecForProviderEmailConfiguration#configurationSet
   */
  readonly configurationSet?: string;

  /**
   * Email delivery method to use. COGNITO_DEFAULT for the default email functionality built into Cognito or DEVELOPER to use your Amazon SES configuration.
   *
   * @schema UserPoolSpecForProviderEmailConfiguration#emailSendingAccount
   */
  readonly emailSendingAccount?: string;

  /**
   * Sender’s email address or sender’s display name with their email address (e.g., john@example.com, John Smith <john@example.com> or \"John Smith Ph.D.\" <john@example.com>). Escaped double quotes are required around display names that contain certain characters as specified in RFC 5322.
   *
   * @schema UserPoolSpecForProviderEmailConfiguration#fromEmailAddress
   */
  readonly fromEmailAddress?: string;

  /**
   * REPLY-TO email address.
   *
   * @schema UserPoolSpecForProviderEmailConfiguration#replyToEmailAddress
   */
  readonly replyToEmailAddress?: string;

  /**
   * ARN of the SES verified email identity to use. Required if email_sending_account is set to DEVELOPER.
   *
   * @schema UserPoolSpecForProviderEmailConfiguration#sourceArn
   */
  readonly sourceArn?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderEmailConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderEmailConfiguration(obj: UserPoolSpecForProviderEmailConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configurationSet': obj.configurationSet,
    'emailSendingAccount': obj.emailSendingAccount,
    'fromEmailAddress': obj.fromEmailAddress,
    'replyToEmailAddress': obj.replyToEmailAddress,
    'sourceArn': obj.sourceArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderLambdaConfig
 */
export interface UserPoolSpecForProviderLambdaConfig {
  /**
   * ARN of the lambda creating an authentication challenge.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#createAuthChallenge
   */
  readonly createAuthChallenge?: string;

  /**
   * A custom email sender AWS Lambda trigger. See custom_email_sender Below.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#customEmailSender
   */
  readonly customEmailSender?: UserPoolSpecForProviderLambdaConfigCustomEmailSender[];

  /**
   * Custom Message AWS Lambda trigger.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#customMessage
   */
  readonly customMessage?: string;

  /**
   * A custom SMS sender AWS Lambda trigger. See custom_sms_sender Below.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#customSmsSender
   */
  readonly customSmsSender?: UserPoolSpecForProviderLambdaConfigCustomSmsSender[];

  /**
   * Defines the authentication challenge.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#defineAuthChallenge
   */
  readonly defineAuthChallenge?: string;

  /**
   * The Amazon Resource Name of Key Management Service Customer master keys. Amazon Cognito uses the key to encrypt codes and temporary passwords sent to CustomEmailSender and CustomSMSSender.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#kmsKeyId
   */
  readonly kmsKeyId?: string;

  /**
   * Post-authentication AWS Lambda trigger.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#postAuthentication
   */
  readonly postAuthentication?: string;

  /**
   * Post-confirmation AWS Lambda trigger.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#postConfirmation
   */
  readonly postConfirmation?: string;

  /**
   * Pre-authentication AWS Lambda trigger.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#preAuthentication
   */
  readonly preAuthentication?: string;

  /**
   * Pre-registration AWS Lambda trigger.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#preSignUp
   */
  readonly preSignUp?: string;

  /**
   * Allow to customize identity token claims before token generation.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#preTokenGeneration
   */
  readonly preTokenGeneration?: string;

  /**
   * User migration Lambda config type.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#userMigration
   */
  readonly userMigration?: string;

  /**
   * Verifies the authentication challenge response.
   *
   * @schema UserPoolSpecForProviderLambdaConfig#verifyAuthChallengeResponse
   */
  readonly verifyAuthChallengeResponse?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderLambdaConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderLambdaConfig(obj: UserPoolSpecForProviderLambdaConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'createAuthChallenge': obj.createAuthChallenge,
    'customEmailSender': obj.customEmailSender?.map(y => toJson_UserPoolSpecForProviderLambdaConfigCustomEmailSender(y)),
    'customMessage': obj.customMessage,
    'customSmsSender': obj.customSmsSender?.map(y => toJson_UserPoolSpecForProviderLambdaConfigCustomSmsSender(y)),
    'defineAuthChallenge': obj.defineAuthChallenge,
    'kmsKeyId': obj.kmsKeyId,
    'postAuthentication': obj.postAuthentication,
    'postConfirmation': obj.postConfirmation,
    'preAuthentication': obj.preAuthentication,
    'preSignUp': obj.preSignUp,
    'preTokenGeneration': obj.preTokenGeneration,
    'userMigration': obj.userMigration,
    'verifyAuthChallengeResponse': obj.verifyAuthChallengeResponse,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderPasswordPolicy
 */
export interface UserPoolSpecForProviderPasswordPolicy {
  /**
   * Minimum length of the password policy that you have set.
   *
   * @schema UserPoolSpecForProviderPasswordPolicy#minimumLength
   */
  readonly minimumLength?: number;

  /**
   * Whether you have required users to use at least one lowercase letter in their password.
   *
   * @schema UserPoolSpecForProviderPasswordPolicy#requireLowercase
   */
  readonly requireLowercase?: boolean;

  /**
   * Whether you have required users to use at least one number in their password.
   *
   * @schema UserPoolSpecForProviderPasswordPolicy#requireNumbers
   */
  readonly requireNumbers?: boolean;

  /**
   * Whether you have required users to use at least one symbol in their password.
   *
   * @schema UserPoolSpecForProviderPasswordPolicy#requireSymbols
   */
  readonly requireSymbols?: boolean;

  /**
   * Whether you have required users to use at least one uppercase letter in their password.
   *
   * @schema UserPoolSpecForProviderPasswordPolicy#requireUppercase
   */
  readonly requireUppercase?: boolean;

  /**
   * In the password policy you have set, refers to the number of days a temporary password is valid. If the user does not sign-in during this time, their password will need to be reset by an administrator.
   *
   * @schema UserPoolSpecForProviderPasswordPolicy#temporaryPasswordValidityDays
   */
  readonly temporaryPasswordValidityDays?: number;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderPasswordPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderPasswordPolicy(obj: UserPoolSpecForProviderPasswordPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minimumLength': obj.minimumLength,
    'requireLowercase': obj.requireLowercase,
    'requireNumbers': obj.requireNumbers,
    'requireSymbols': obj.requireSymbols,
    'requireUppercase': obj.requireUppercase,
    'temporaryPasswordValidityDays': obj.temporaryPasswordValidityDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderSchema
 */
export interface UserPoolSpecForProviderSchema {
  /**
   * Attribute data type. Must be one of Boolean, Number, String, DateTime.
   *
   * @schema UserPoolSpecForProviderSchema#attributeDataType
   */
  readonly attributeDataType: string;

  /**
   * Whether the attribute type is developer only.
   *
   * @schema UserPoolSpecForProviderSchema#developerOnlyAttribute
   */
  readonly developerOnlyAttribute?: boolean;

  /**
   * Whether the attribute can be changed once it has been created.
   *
   * @schema UserPoolSpecForProviderSchema#mutable
   */
  readonly mutable?: boolean;

  /**
   * Name of the user pool.
   *
   * @schema UserPoolSpecForProviderSchema#name
   */
  readonly name: string;

  /**
   * Configuration block for the constraints for an attribute of the number type. Detailed below.
   *
   * @schema UserPoolSpecForProviderSchema#numberAttributeConstraints
   */
  readonly numberAttributeConstraints?: UserPoolSpecForProviderSchemaNumberAttributeConstraints[];

  /**
   * Whether a user pool attribute is required. If the attribute is required and the user does not provide a value, registration or sign-in will fail.
   *
   * @schema UserPoolSpecForProviderSchema#required
   */
  readonly required?: boolean;

  /**
   * Constraints for an attribute of the string type. Detailed below.
   *
   * @schema UserPoolSpecForProviderSchema#stringAttributeConstraints
   */
  readonly stringAttributeConstraints?: UserPoolSpecForProviderSchemaStringAttributeConstraints[];

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSchema' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSchema(obj: UserPoolSpecForProviderSchema | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributeDataType': obj.attributeDataType,
    'developerOnlyAttribute': obj.developerOnlyAttribute,
    'mutable': obj.mutable,
    'name': obj.name,
    'numberAttributeConstraints': obj.numberAttributeConstraints?.map(y => toJson_UserPoolSpecForProviderSchemaNumberAttributeConstraints(y)),
    'required': obj.required,
    'stringAttributeConstraints': obj.stringAttributeConstraints?.map(y => toJson_UserPoolSpecForProviderSchemaStringAttributeConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderSmsConfiguration
 */
export interface UserPoolSpecForProviderSmsConfiguration {
  /**
   * External ID used in IAM role trust relationships. For more information about using external IDs, see How to Use an External ID When Granting Access to Your AWS Resources to a Third Party.
   *
   * @schema UserPoolSpecForProviderSmsConfiguration#externalId
   */
  readonly externalId: string;

  /**
   * ARN of the Amazon SNS caller. This is usually the IAM role that you've given Cognito permission to assume.
   *
   * @schema UserPoolSpecForProviderSmsConfiguration#snsCallerArn
   */
  readonly snsCallerArn?: string;

  /**
   * Reference to a Role in iam to populate snsCallerArn.
   *
   * @schema UserPoolSpecForProviderSmsConfiguration#snsCallerArnRef
   */
  readonly snsCallerArnRef?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef;

  /**
   * Selector for a Role in iam to populate snsCallerArn.
   *
   * @schema UserPoolSpecForProviderSmsConfiguration#snsCallerArnSelector
   */
  readonly snsCallerArnSelector?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector;

  /**
   * The AWS Region to use with Amazon SNS integration. You can choose the same Region as your user pool, or a supported Legacy Amazon SNS alternate Region. Amazon Cognito resources in the Asia Pacific (Seoul) AWS Region must use your Amazon SNS configuration in the Asia Pacific (Tokyo) Region. For more information, see SMS message settings for Amazon Cognito user pools.
   *
   * @schema UserPoolSpecForProviderSmsConfiguration#snsRegion
   */
  readonly snsRegion?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSmsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSmsConfiguration(obj: UserPoolSpecForProviderSmsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalId': obj.externalId,
    'snsCallerArn': obj.snsCallerArn,
    'snsCallerArnRef': toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef(obj.snsCallerArnRef),
    'snsCallerArnSelector': toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector(obj.snsCallerArnSelector),
    'snsRegion': obj.snsRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderSoftwareTokenMfaConfiguration
 */
export interface UserPoolSpecForProviderSoftwareTokenMfaConfiguration {
  /**
   * Boolean whether to enable software token Multi-Factor (MFA) tokens, such as Time-based One-Time Password (TOTP). To disable software token MFA When sms_configuration is not present, the mfa_configuration argument must be set to OFF and the software_token_mfa_configuration configuration block must be fully removed.
   *
   * @schema UserPoolSpecForProviderSoftwareTokenMfaConfiguration#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSoftwareTokenMfaConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSoftwareTokenMfaConfiguration(obj: UserPoolSpecForProviderSoftwareTokenMfaConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderUserAttributeUpdateSettings
 */
export interface UserPoolSpecForProviderUserAttributeUpdateSettings {
  /**
   * A list of attributes requiring verification before update. If set, the provided value(s) must also be set in auto_verified_attributes. Valid values: email, phone_number.
   *
   * @schema UserPoolSpecForProviderUserAttributeUpdateSettings#attributesRequireVerificationBeforeUpdate
   */
  readonly attributesRequireVerificationBeforeUpdate: string[];

}

/**
 * Converts an object of type 'UserPoolSpecForProviderUserAttributeUpdateSettings' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderUserAttributeUpdateSettings(obj: UserPoolSpecForProviderUserAttributeUpdateSettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attributesRequireVerificationBeforeUpdate': obj.attributesRequireVerificationBeforeUpdate?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderUserPoolAddOns
 */
export interface UserPoolSpecForProviderUserPoolAddOns {
  /**
   * Mode for advanced security, must be one of OFF, AUDIT or ENFORCED.
   *
   * @schema UserPoolSpecForProviderUserPoolAddOns#advancedSecurityMode
   */
  readonly advancedSecurityMode: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderUserPoolAddOns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderUserPoolAddOns(obj: UserPoolSpecForProviderUserPoolAddOns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'advancedSecurityMode': obj.advancedSecurityMode,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderUsernameConfiguration
 */
export interface UserPoolSpecForProviderUsernameConfiguration {
  /**
   * Whether username case sensitivity will be applied for all users in the user pool through Cognito APIs.
   *
   * @schema UserPoolSpecForProviderUsernameConfiguration#caseSensitive
   */
  readonly caseSensitive: boolean;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderUsernameConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderUsernameConfiguration(obj: UserPoolSpecForProviderUsernameConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caseSensitive': obj.caseSensitive,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderVerificationMessageTemplate
 */
export interface UserPoolSpecForProviderVerificationMessageTemplate {
  /**
   * Default email option. Must be either CONFIRM_WITH_CODE or CONFIRM_WITH_LINK. Defaults to CONFIRM_WITH_CODE.
   *
   * @default CONFIRM_WITH_CODE.
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#defaultEmailOption
   */
  readonly defaultEmailOption?: string;

  /**
   * Email message template. Must contain the {####} placeholder. Conflicts with email_verification_message argument.
   *
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailMessage
   */
  readonly emailMessage?: string;

  /**
   * Email message template for sending a confirmation link to the user, it must contain the {##Click Here##} placeholder.
   *
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailMessageByLink
   */
  readonly emailMessageByLink?: string;

  /**
   * Subject line for the email message template. Conflicts with email_verification_subject argument.
   *
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailSubject
   */
  readonly emailSubject?: string;

  /**
   * Subject line for the email message template for sending a confirmation link to the user.
   *
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#emailSubjectByLink
   */
  readonly emailSubjectByLink?: string;

  /**
   * SMS message template. Must contain the {####} placeholder. Conflicts with sms_verification_message argument.
   *
   * @schema UserPoolSpecForProviderVerificationMessageTemplate#smsMessage
   */
  readonly smsMessage?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderVerificationMessageTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderVerificationMessageTemplate(obj: UserPoolSpecForProviderVerificationMessageTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultEmailOption': obj.defaultEmailOption,
    'emailMessage': obj.emailMessage,
    'emailMessageByLink': obj.emailMessageByLink,
    'emailSubject': obj.emailSubject,
    'emailSubjectByLink': obj.emailSubjectByLink,
    'smsMessage': obj.smsMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolSpecProviderConfigRefPolicy
 */
export interface UserPoolSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecProviderConfigRefPolicy(obj: UserPoolSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolSpecProviderRefPolicy
 */
export interface UserPoolSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserPoolSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserPoolSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecProviderRefPolicy(obj: UserPoolSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRef
 */
export interface UserPoolSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserPoolSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsToConfigRef(obj: UserPoolSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToMetadata
 */
export interface UserPoolSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsToMetadata(obj: UserPoolSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism
 */
export interface UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism {
  /**
   * Name of the user pool.
   *
   * @schema UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism#name
   */
  readonly name: string;

  /**
   * Positive integer specifying priority of a method with 1 being the highest priority.
   *
   * @schema UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism#priority
   */
  readonly priority: number;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism(obj: UserPoolSpecForProviderAccountRecoverySettingRecoveryMechanism | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'priority': obj.priority,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate
 */
export interface UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate {
  /**
   * Message template for email messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
   *
   * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate#emailMessage
   */
  readonly emailMessage?: string;

  /**
   * Subject line for email messages.
   *
   * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate#emailSubject
   */
  readonly emailSubject?: string;

  /**
   * Message template for SMS messages. Must contain {username} and {####} placeholders, for username and temporary password, respectively.
   *
   * @schema UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate#smsMessage
   */
  readonly smsMessage?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate(obj: UserPoolSpecForProviderAdminCreateUserConfigInviteMessageTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'emailMessage': obj.emailMessage,
    'emailSubject': obj.emailSubject,
    'smsMessage': obj.smsMessage,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderLambdaConfigCustomEmailSender
 */
export interface UserPoolSpecForProviderLambdaConfigCustomEmailSender {
  /**
   * The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send email notifications to users.
   *
   * @schema UserPoolSpecForProviderLambdaConfigCustomEmailSender#lambdaArn
   */
  readonly lambdaArn: string;

  /**
   * The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom email Lambda function. The only supported value is V1_0.
   *
   * @schema UserPoolSpecForProviderLambdaConfigCustomEmailSender#lambdaVersion
   */
  readonly lambdaVersion: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderLambdaConfigCustomEmailSender' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderLambdaConfigCustomEmailSender(obj: UserPoolSpecForProviderLambdaConfigCustomEmailSender | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaArn': obj.lambdaArn,
    'lambdaVersion': obj.lambdaVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderLambdaConfigCustomSmsSender
 */
export interface UserPoolSpecForProviderLambdaConfigCustomSmsSender {
  /**
   * The Lambda Amazon Resource Name of the Lambda function that Amazon Cognito triggers to send SMS notifications to users.
   *
   * @schema UserPoolSpecForProviderLambdaConfigCustomSmsSender#lambdaArn
   */
  readonly lambdaArn: string;

  /**
   * The Lambda version represents the signature of the "request" attribute in the "event" information Amazon Cognito passes to your custom SMS Lambda function. The only supported value is V1_0.
   *
   * @schema UserPoolSpecForProviderLambdaConfigCustomSmsSender#lambdaVersion
   */
  readonly lambdaVersion: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderLambdaConfigCustomSmsSender' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderLambdaConfigCustomSmsSender(obj: UserPoolSpecForProviderLambdaConfigCustomSmsSender | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'lambdaArn': obj.lambdaArn,
    'lambdaVersion': obj.lambdaVersion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderSchemaNumberAttributeConstraints
 */
export interface UserPoolSpecForProviderSchemaNumberAttributeConstraints {
  /**
   * Maximum value of an attribute that is of the number data type.
   *
   * @schema UserPoolSpecForProviderSchemaNumberAttributeConstraints#maxValue
   */
  readonly maxValue?: string;

  /**
   * Minimum value of an attribute that is of the number data type.
   *
   * @schema UserPoolSpecForProviderSchemaNumberAttributeConstraints#minValue
   */
  readonly minValue?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSchemaNumberAttributeConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSchemaNumberAttributeConstraints(obj: UserPoolSpecForProviderSchemaNumberAttributeConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxValue': obj.maxValue,
    'minValue': obj.minValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolSpecForProviderSchemaStringAttributeConstraints
 */
export interface UserPoolSpecForProviderSchemaStringAttributeConstraints {
  /**
   * Maximum length of an attribute value of the string type.
   *
   * @schema UserPoolSpecForProviderSchemaStringAttributeConstraints#maxLength
   */
  readonly maxLength?: string;

  /**
   * Minimum length of an attribute value of the string type.
   *
   * @schema UserPoolSpecForProviderSchemaStringAttributeConstraints#minLength
   */
  readonly minLength?: string;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSchemaStringAttributeConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSchemaStringAttributeConstraints(obj: UserPoolSpecForProviderSchemaStringAttributeConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxLength': obj.maxLength,
    'minLength': obj.minLength,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate snsCallerArn.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef
 */
export interface UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef#policy
   */
  readonly policy?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef(obj: UserPoolSpecForProviderSmsConfigurationSnsCallerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate snsCallerArn.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector
 */
export interface UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector#policy
   */
  readonly policy?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector(obj: UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolSpecProviderConfigRefPolicyResolution
 */
export enum UserPoolSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolSpecProviderConfigRefPolicyResolve
 */
export enum UserPoolSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolSpecProviderRefPolicyResolution
 */
export enum UserPoolSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolSpecProviderRefPolicyResolve
 */
export enum UserPoolSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserPoolSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserPoolSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy
 */
export interface UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy#resolution
   */
  readonly resolution?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy#resolve
   */
  readonly resolve?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy(obj: UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy
 */
export interface UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy(obj: UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserPoolSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicyResolution
 */
export enum UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicyResolve
 */
export enum UserPoolSpecForProviderSmsConfigurationSnsCallerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolution
 */
export enum UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolve
 */
export enum UserPoolSpecForProviderSmsConfigurationSnsCallerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserPoolClient is the Schema for the UserPoolClients API. Provides a Cognito User Pool Client resource.
 *
 * @schema UserPoolClient
 */
export class UserPoolClient extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserPoolClient"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'UserPoolClient',
  }

  /**
   * Renders a Kubernetes manifest for "UserPoolClient".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserPoolClientProps): any {
    return {
      ...UserPoolClient.GVK,
      ...toJson_UserPoolClientProps(props),
    };
  }

  /**
   * Defines a "UserPoolClient" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserPoolClientProps) {
    super(scope, id, {
      ...UserPoolClient.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserPoolClient.GVK,
      ...toJson_UserPoolClientProps(resolved),
    };
  }
}

/**
 * UserPoolClient is the Schema for the UserPoolClients API. Provides a Cognito User Pool Client resource.
 *
 * @schema UserPoolClient
 */
export interface UserPoolClientProps {
  /**
   * @schema UserPoolClient#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserPoolClientSpec defines the desired state of UserPoolClient
   *
   * @schema UserPoolClient#spec
   */
  readonly spec: UserPoolClientSpec;

}

/**
 * Converts an object of type 'UserPoolClientProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientProps(obj: UserPoolClientProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserPoolClientSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolClientSpec defines the desired state of UserPoolClient
 *
 * @schema UserPoolClientSpec
 */
export interface UserPoolClientSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema UserPoolClientSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserPoolClientSpecDeletionPolicy;

  /**
   * @schema UserPoolClientSpec#forProvider
   */
  readonly forProvider: UserPoolClientSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserPoolClientSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserPoolClientSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserPoolClientSpec#providerRef
   */
  readonly providerRef?: UserPoolClientSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserPoolClientSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserPoolClientSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserPoolClientSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserPoolClientSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserPoolClientSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpec(obj: UserPoolClientSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserPoolClientSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_UserPoolClientSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserPoolClientSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserPoolClientSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserPoolClientSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema UserPoolClientSpecDeletionPolicy
 */
export enum UserPoolClientSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserPoolClientSpecForProvider
 */
export interface UserPoolClientSpecForProvider {
  /**
   * Time limit, between 5 minutes and 1 day, after which the access token is no longer valid and cannot be used. This value will be overridden if you have entered a value in token_validity_units.
   *
   * @schema UserPoolClientSpecForProvider#accessTokenValidity
   */
  readonly accessTokenValidity?: number;

  /**
   * List of allowed OAuth flows (code, implicit, client_credentials).
   *
   * @schema UserPoolClientSpecForProvider#allowedOauthFlows
   */
  readonly allowedOauthFlows?: string[];

  /**
   * Whether the client is allowed to follow the OAuth protocol when interacting with Cognito user pools.
   *
   * @schema UserPoolClientSpecForProvider#allowedOauthFlowsUserPoolClient
   */
  readonly allowedOauthFlowsUserPoolClient?: boolean;

  /**
   * List of allowed OAuth scopes (phone, email, openid, profile, and aws.cognito.signin.user.admin).
   *
   * @schema UserPoolClientSpecForProvider#allowedOauthScopes
   */
  readonly allowedOauthScopes?: string[];

  /**
   * Configuration block for Amazon Pinpoint analytics for collecting metrics for this user pool. Detailed below.
   *
   * @schema UserPoolClientSpecForProvider#analyticsConfiguration
   */
  readonly analyticsConfiguration?: UserPoolClientSpecForProviderAnalyticsConfiguration[];

  /**
   * Amazon Cognito creates a session token for each API request in an authentication flow. AuthSessionValidity is the duration, in minutes, of that session token. Your user pool native user must respond to each authentication challenge before the session expires. Valid values between 3 and 15. Default value is 3.
   *
   * @schema UserPoolClientSpecForProvider#authSessionValidity
   */
  readonly authSessionValidity?: number;

  /**
   * List of allowed callback URLs for the identity providers.
   *
   * @schema UserPoolClientSpecForProvider#callbackUrls
   */
  readonly callbackUrls?: string[];

  /**
   * Default redirect URI. Must be in the list of callback URLs.
   *
   * @schema UserPoolClientSpecForProvider#defaultRedirectUri
   */
  readonly defaultRedirectUri?: string;

  /**
   * Activates the propagation of additional user context data.
   *
   * @schema UserPoolClientSpecForProvider#enablePropagateAdditionalUserContextData
   */
  readonly enablePropagateAdditionalUserContextData?: boolean;

  /**
   * Enables or disables token revocation.
   *
   * @schema UserPoolClientSpecForProvider#enableTokenRevocation
   */
  readonly enableTokenRevocation?: boolean;

  /**
   * List of authentication flows (ADMIN_NO_SRP_AUTH, CUSTOM_AUTH_FLOW_ONLY, USER_PASSWORD_AUTH, ALLOW_ADMIN_USER_PASSWORD_AUTH, ALLOW_CUSTOM_AUTH, ALLOW_USER_PASSWORD_AUTH, ALLOW_USER_SRP_AUTH, ALLOW_REFRESH_TOKEN_AUTH).
   *
   * @schema UserPoolClientSpecForProvider#explicitAuthFlows
   */
  readonly explicitAuthFlows?: string[];

  /**
   * Should an application secret be generated.
   *
   * @schema UserPoolClientSpecForProvider#generateSecret
   */
  readonly generateSecret?: boolean;

  /**
   * Time limit, between 5 minutes and 1 day, after which the ID token is no longer valid and cannot be used. This value will be overridden if you have entered a value in token_validity_units.
   *
   * @schema UserPoolClientSpecForProvider#idTokenValidity
   */
  readonly idTokenValidity?: number;

  /**
   * List of allowed logout URLs for the identity providers.
   *
   * @schema UserPoolClientSpecForProvider#logoutUrls
   */
  readonly logoutUrls?: string[];

  /**
   * Name of the application client.
   *
   * @schema UserPoolClientSpecForProvider#name
   */
  readonly name: string;

  /**
   * Choose which errors and responses are returned by Cognito APIs during authentication, account confirmation, and password recovery when the user does not exist in the user pool. When set to ENABLED and the user does not exist, authentication returns an error indicating either the username or password was incorrect, and account confirmation and password recovery return a response indicating a code was sent to a simulated destination. When set to LEGACY, those APIs will return a UserNotFoundException exception if the user does not exist in the user pool.
   *
   * @schema UserPoolClientSpecForProvider#preventUserExistenceErrors
   */
  readonly preventUserExistenceErrors?: string;

  /**
   * List of user pool attributes the application client can read from.
   *
   * @schema UserPoolClientSpecForProvider#readAttributes
   */
  readonly readAttributes?: string[];

  /**
   * Time limit in days refresh tokens are valid for.
   *
   * @schema UserPoolClientSpecForProvider#refreshTokenValidity
   */
  readonly refreshTokenValidity?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserPoolClientSpecForProvider#region
   */
  readonly region: string;

  /**
   * List of provider names for the identity providers that are supported on this client. Uses the provider_name attribute of aws_cognito_identity_provider resource(s), or the equivalent string(s).
   *
   * @schema UserPoolClientSpecForProvider#supportedIdentityProviders
   */
  readonly supportedIdentityProviders?: string[];

  /**
   * Configuration block for units in which the validity times are represented in. Detailed below.
   *
   * @schema UserPoolClientSpecForProvider#tokenValidityUnits
   */
  readonly tokenValidityUnits?: UserPoolClientSpecForProviderTokenValidityUnits[];

  /**
   * User pool the client belongs to.
   *
   * @schema UserPoolClientSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool to populate userPoolId.
   *
   * @schema UserPoolClientSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserPoolClientSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool to populate userPoolId.
   *
   * @schema UserPoolClientSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserPoolClientSpecForProviderUserPoolIdSelector;

  /**
   * List of user pool attributes the application client can write to.
   *
   * @schema UserPoolClientSpecForProvider#writeAttributes
   */
  readonly writeAttributes?: string[];

}

/**
 * Converts an object of type 'UserPoolClientSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProvider(obj: UserPoolClientSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenValidity': obj.accessTokenValidity,
    'allowedOauthFlows': obj.allowedOauthFlows?.map(y => y),
    'allowedOauthFlowsUserPoolClient': obj.allowedOauthFlowsUserPoolClient,
    'allowedOauthScopes': obj.allowedOauthScopes?.map(y => y),
    'analyticsConfiguration': obj.analyticsConfiguration?.map(y => toJson_UserPoolClientSpecForProviderAnalyticsConfiguration(y)),
    'authSessionValidity': obj.authSessionValidity,
    'callbackUrls': obj.callbackUrls?.map(y => y),
    'defaultRedirectUri': obj.defaultRedirectUri,
    'enablePropagateAdditionalUserContextData': obj.enablePropagateAdditionalUserContextData,
    'enableTokenRevocation': obj.enableTokenRevocation,
    'explicitAuthFlows': obj.explicitAuthFlows?.map(y => y),
    'generateSecret': obj.generateSecret,
    'idTokenValidity': obj.idTokenValidity,
    'logoutUrls': obj.logoutUrls?.map(y => y),
    'name': obj.name,
    'preventUserExistenceErrors': obj.preventUserExistenceErrors,
    'readAttributes': obj.readAttributes?.map(y => y),
    'refreshTokenValidity': obj.refreshTokenValidity,
    'region': obj.region,
    'supportedIdentityProviders': obj.supportedIdentityProviders?.map(y => y),
    'tokenValidityUnits': obj.tokenValidityUnits?.map(y => toJson_UserPoolClientSpecForProviderTokenValidityUnits(y)),
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserPoolClientSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserPoolClientSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
    'writeAttributes': obj.writeAttributes?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserPoolClientSpecProviderConfigRef
 */
export interface UserPoolClientSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecProviderConfigRef#policy
   */
  readonly policy?: UserPoolClientSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecProviderConfigRef(obj: UserPoolClientSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserPoolClientSpecProviderRef
 */
export interface UserPoolClientSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecProviderRef#policy
   */
  readonly policy?: UserPoolClientSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecProviderRef(obj: UserPoolClientSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsTo
 */
export interface UserPoolClientSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserPoolClientSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserPoolClientSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsTo(obj: UserPoolClientSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserPoolClientSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserPoolClientSpecWriteConnectionSecretToRef
 */
export interface UserPoolClientSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserPoolClientSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserPoolClientSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecWriteConnectionSecretToRef(obj: UserPoolClientSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolClientSpecForProviderAnalyticsConfiguration
 */
export interface UserPoolClientSpecForProviderAnalyticsConfiguration {
  /**
   * Application ARN for an Amazon Pinpoint application. Conflicts with external_id and role_arn.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#applicationArn
   */
  readonly applicationArn?: string;

  /**
   * Application ID for an Amazon Pinpoint application.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#applicationId
   */
  readonly applicationId?: string;

  /**
   * Reference to a App in pinpoint to populate applicationId.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#applicationIdRef
   */
  readonly applicationIdRef?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef;

  /**
   * Selector for a App in pinpoint to populate applicationId.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#applicationIdSelector
   */
  readonly applicationIdSelector?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector;

  /**
   * ID for the Analytics Configuration. Conflicts with application_arn.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#externalId
   */
  readonly externalId?: string;

  /**
   * ARN of an IAM role that authorizes Amazon Cognito to publish events to Amazon Pinpoint analytics. Conflicts with application_arn.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#roleArnRef
   */
  readonly roleArnRef?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#roleArnSelector
   */
  readonly roleArnSelector?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector;

  /**
   * If set to true, Amazon Cognito will include user data in the events it publishes to Amazon Pinpoint analytics.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfiguration#userDataShared
   */
  readonly userDataShared?: boolean;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfiguration(obj: UserPoolClientSpecForProviderAnalyticsConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationArn': obj.applicationArn,
    'applicationId': obj.applicationId,
    'applicationIdRef': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef(obj.applicationIdRef),
    'applicationIdSelector': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector(obj.applicationIdSelector),
    'externalId': obj.externalId,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector(obj.roleArnSelector),
    'userDataShared': obj.userDataShared,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserPoolClientSpecForProviderTokenValidityUnits
 */
export interface UserPoolClientSpecForProviderTokenValidityUnits {
  /**
   * Time unit in for the value in access_token_validity, defaults to hours.
   *
   * @schema UserPoolClientSpecForProviderTokenValidityUnits#accessToken
   */
  readonly accessToken?: string;

  /**
   * Time unit in for the value in id_token_validity, defaults to hours.
   *
   * @schema UserPoolClientSpecForProviderTokenValidityUnits#idToken
   */
  readonly idToken?: string;

  /**
   * Time unit in for the value in refresh_token_validity, defaults to days.
   *
   * @schema UserPoolClientSpecForProviderTokenValidityUnits#refreshToken
   */
  readonly refreshToken?: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderTokenValidityUnits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderTokenValidityUnits(obj: UserPoolClientSpecForProviderTokenValidityUnits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': obj.accessToken,
    'idToken': obj.idToken,
    'refreshToken': obj.refreshToken,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool to populate userPoolId.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRef
 */
export interface UserPoolClientSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserPoolClientSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdRef(obj: UserPoolClientSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool to populate userPoolId.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelector
 */
export interface UserPoolClientSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserPoolClientSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdSelector(obj: UserPoolClientSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolClientSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecProviderConfigRefPolicy
 */
export interface UserPoolClientSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecProviderConfigRefPolicy(obj: UserPoolClientSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecProviderRefPolicy
 */
export interface UserPoolClientSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecProviderRefPolicy(obj: UserPoolClientSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRef
 */
export interface UserPoolClientSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRef(obj: UserPoolClientSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata
 */
export interface UserPoolClientSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsToMetadata(obj: UserPoolClientSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a App in pinpoint to populate applicationId.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef#policy
   */
  readonly policy?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef(obj: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a App in pinpoint to populate applicationId.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector#policy
   */
  readonly policy?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector(obj: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef#policy
   */
  readonly policy?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef(obj: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector#policy
   */
  readonly policy?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector(obj: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicy
 */
export interface UserPoolClientSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdRefPolicy(obj: UserPoolClientSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserPoolClientSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderUserPoolIdSelectorPolicy(obj: UserPoolClientSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecProviderConfigRefPolicyResolution
 */
export enum UserPoolClientSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecProviderConfigRefPolicyResolve
 */
export enum UserPoolClientSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecProviderRefPolicyResolution
 */
export enum UserPoolClientSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecProviderRefPolicyResolve
 */
export enum UserPoolClientSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy(obj: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy(obj: UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy(obj: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy
 */
export interface UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy(obj: UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserPoolClientSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserPoolClientSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserPoolClientSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserPoolClientSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicyResolution
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicyResolve
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolution
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolve
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationApplicationIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicyResolution
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicyResolve
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolution
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolve
 */
export enum UserPoolClientSpecForProviderAnalyticsConfigurationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserPoolDomain is the Schema for the UserPoolDomains API. Provides a Cognito User Pool Domain resource.
 *
 * @schema UserPoolDomain
 */
export class UserPoolDomain extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserPoolDomain"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'UserPoolDomain',
  }

  /**
   * Renders a Kubernetes manifest for "UserPoolDomain".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserPoolDomainProps): any {
    return {
      ...UserPoolDomain.GVK,
      ...toJson_UserPoolDomainProps(props),
    };
  }

  /**
   * Defines a "UserPoolDomain" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserPoolDomainProps) {
    super(scope, id, {
      ...UserPoolDomain.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserPoolDomain.GVK,
      ...toJson_UserPoolDomainProps(resolved),
    };
  }
}

/**
 * UserPoolDomain is the Schema for the UserPoolDomains API. Provides a Cognito User Pool Domain resource.
 *
 * @schema UserPoolDomain
 */
export interface UserPoolDomainProps {
  /**
   * @schema UserPoolDomain#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserPoolDomainSpec defines the desired state of UserPoolDomain
   *
   * @schema UserPoolDomain#spec
   */
  readonly spec: UserPoolDomainSpec;

}

/**
 * Converts an object of type 'UserPoolDomainProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainProps(obj: UserPoolDomainProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserPoolDomainSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolDomainSpec defines the desired state of UserPoolDomain
 *
 * @schema UserPoolDomainSpec
 */
export interface UserPoolDomainSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema UserPoolDomainSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserPoolDomainSpecDeletionPolicy;

  /**
   * @schema UserPoolDomainSpec#forProvider
   */
  readonly forProvider: UserPoolDomainSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserPoolDomainSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserPoolDomainSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserPoolDomainSpec#providerRef
   */
  readonly providerRef?: UserPoolDomainSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserPoolDomainSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserPoolDomainSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserPoolDomainSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserPoolDomainSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserPoolDomainSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpec(obj: UserPoolDomainSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserPoolDomainSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_UserPoolDomainSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserPoolDomainSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserPoolDomainSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserPoolDomainSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema UserPoolDomainSpecDeletionPolicy
 */
export enum UserPoolDomainSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserPoolDomainSpecForProvider
 */
export interface UserPoolDomainSpecForProvider {
  /**
   * The ARN of an ISSUED ACM certificate in us-east-1 for a custom domain.
   *
   * @schema UserPoolDomainSpecForProvider#certificateArn
   */
  readonly certificateArn?: string;

  /**
   * Reference to a Certificate in acm to populate certificateArn.
   *
   * @schema UserPoolDomainSpecForProvider#certificateArnRef
   */
  readonly certificateArnRef?: UserPoolDomainSpecForProviderCertificateArnRef;

  /**
   * Selector for a Certificate in acm to populate certificateArn.
   *
   * @schema UserPoolDomainSpecForProvider#certificateArnSelector
   */
  readonly certificateArnSelector?: UserPoolDomainSpecForProviderCertificateArnSelector;

  /**
   * For custom domains, this is the fully-qualified domain name, such as auth.example.com. For Amazon Cognito prefix domains, this is the prefix alone, such as auth.
   *
   * @schema UserPoolDomainSpecForProvider#domain
   */
  readonly domain: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserPoolDomainSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user pool ID.
   *
   * @schema UserPoolDomainSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool to populate userPoolId.
   *
   * @schema UserPoolDomainSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserPoolDomainSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool to populate userPoolId.
   *
   * @schema UserPoolDomainSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserPoolDomainSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProvider(obj: UserPoolDomainSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificateArn': obj.certificateArn,
    'certificateArnRef': toJson_UserPoolDomainSpecForProviderCertificateArnRef(obj.certificateArnRef),
    'certificateArnSelector': toJson_UserPoolDomainSpecForProviderCertificateArnSelector(obj.certificateArnSelector),
    'domain': obj.domain,
    'region': obj.region,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserPoolDomainSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserPoolDomainSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserPoolDomainSpecProviderConfigRef
 */
export interface UserPoolDomainSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecProviderConfigRef#policy
   */
  readonly policy?: UserPoolDomainSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecProviderConfigRef(obj: UserPoolDomainSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserPoolDomainSpecProviderRef
 */
export interface UserPoolDomainSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecProviderRef#policy
   */
  readonly policy?: UserPoolDomainSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecProviderRef(obj: UserPoolDomainSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsTo
 */
export interface UserPoolDomainSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserPoolDomainSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserPoolDomainSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsTo(obj: UserPoolDomainSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserPoolDomainSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserPoolDomainSpecWriteConnectionSecretToRef
 */
export interface UserPoolDomainSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserPoolDomainSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserPoolDomainSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserPoolDomainSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecWriteConnectionSecretToRef(obj: UserPoolDomainSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Certificate in acm to populate certificateArn.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnRef
 */
export interface UserPoolDomainSpecForProviderCertificateArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnRef#policy
   */
  readonly policy?: UserPoolDomainSpecForProviderCertificateArnRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderCertificateArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderCertificateArnRef(obj: UserPoolDomainSpecForProviderCertificateArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecForProviderCertificateArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Certificate in acm to populate certificateArn.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnSelector
 */
export interface UserPoolDomainSpecForProviderCertificateArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnSelector#policy
   */
  readonly policy?: UserPoolDomainSpecForProviderCertificateArnSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderCertificateArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderCertificateArnSelector(obj: UserPoolDomainSpecForProviderCertificateArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolDomainSpecForProviderCertificateArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool to populate userPoolId.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRef
 */
export interface UserPoolDomainSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserPoolDomainSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdRef(obj: UserPoolDomainSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool to populate userPoolId.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelector
 */
export interface UserPoolDomainSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdSelector(obj: UserPoolDomainSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecProviderConfigRefPolicy
 */
export interface UserPoolDomainSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecProviderConfigRefPolicy(obj: UserPoolDomainSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecProviderRefPolicy
 */
export interface UserPoolDomainSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecProviderRefPolicy(obj: UserPoolDomainSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRef
 */
export interface UserPoolDomainSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRef(obj: UserPoolDomainSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata
 */
export interface UserPoolDomainSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsToMetadata(obj: UserPoolDomainSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnRefPolicy
 */
export interface UserPoolDomainSpecForProviderCertificateArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecForProviderCertificateArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecForProviderCertificateArnRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderCertificateArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderCertificateArnRefPolicy(obj: UserPoolDomainSpecForProviderCertificateArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnSelectorPolicy
 */
export interface UserPoolDomainSpecForProviderCertificateArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecForProviderCertificateArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecForProviderCertificateArnSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecForProviderCertificateArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderCertificateArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderCertificateArnSelectorPolicy(obj: UserPoolDomainSpecForProviderCertificateArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicy
 */
export interface UserPoolDomainSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdRefPolicy(obj: UserPoolDomainSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy(obj: UserPoolDomainSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecProviderConfigRefPolicyResolution
 */
export enum UserPoolDomainSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecProviderConfigRefPolicyResolve
 */
export enum UserPoolDomainSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecProviderRefPolicyResolution
 */
export enum UserPoolDomainSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecProviderRefPolicyResolve
 */
export enum UserPoolDomainSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnRefPolicyResolution
 */
export enum UserPoolDomainSpecForProviderCertificateArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnRefPolicyResolve
 */
export enum UserPoolDomainSpecForProviderCertificateArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnSelectorPolicyResolution
 */
export enum UserPoolDomainSpecForProviderCertificateArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecForProviderCertificateArnSelectorPolicyResolve
 */
export enum UserPoolDomainSpecForProviderCertificateArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserPoolDomainSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserPoolDomainSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserPoolDomainSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * UserPoolUICustomization is the Schema for the UserPoolUICustomizations API. Provides a Cognito User Pool UI Customization resource.
 *
 * @schema UserPoolUICustomization
 */
export class UserPoolUiCustomization extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserPoolUICustomization"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cognitoidp.aws.upbound.io/v1beta1',
    kind: 'UserPoolUICustomization',
  }

  /**
   * Renders a Kubernetes manifest for "UserPoolUICustomization".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserPoolUiCustomizationProps): any {
    return {
      ...UserPoolUiCustomization.GVK,
      ...toJson_UserPoolUiCustomizationProps(props),
    };
  }

  /**
   * Defines a "UserPoolUICustomization" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserPoolUiCustomizationProps) {
    super(scope, id, {
      ...UserPoolUiCustomization.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserPoolUiCustomization.GVK,
      ...toJson_UserPoolUiCustomizationProps(resolved),
    };
  }
}

/**
 * UserPoolUICustomization is the Schema for the UserPoolUICustomizations API. Provides a Cognito User Pool UI Customization resource.
 *
 * @schema UserPoolUICustomization
 */
export interface UserPoolUiCustomizationProps {
  /**
   * @schema UserPoolUICustomization#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserPoolUICustomizationSpec defines the desired state of UserPoolUICustomization
   *
   * @schema UserPoolUICustomization#spec
   */
  readonly spec: UserPoolUiCustomizationSpec;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationProps(obj: UserPoolUiCustomizationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserPoolUiCustomizationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserPoolUICustomizationSpec defines the desired state of UserPoolUICustomization
 *
 * @schema UserPoolUiCustomizationSpec
 */
export interface UserPoolUiCustomizationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema UserPoolUiCustomizationSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserPoolUiCustomizationSpecDeletionPolicy;

  /**
   * @schema UserPoolUiCustomizationSpec#forProvider
   */
  readonly forProvider: UserPoolUiCustomizationSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema UserPoolUiCustomizationSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserPoolUiCustomizationSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema UserPoolUiCustomizationSpec#providerRef
   */
  readonly providerRef?: UserPoolUiCustomizationSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema UserPoolUiCustomizationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserPoolUiCustomizationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema UserPoolUiCustomizationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserPoolUiCustomizationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpec(obj: UserPoolUiCustomizationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserPoolUiCustomizationSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_UserPoolUiCustomizationSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_UserPoolUiCustomizationSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserPoolUiCustomizationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema UserPoolUiCustomizationSpecDeletionPolicy
 */
export enum UserPoolUiCustomizationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserPoolUiCustomizationSpecForProvider
 */
export interface UserPoolUiCustomizationSpecForProvider {
  /**
   * The client ID for the client app. Defaults to ALL. If ALL is specified, the css and/or image_file settings will be used for every client that has no UI customization set previously.
   *
   * @default ALL. If ALL is specified, the css and/or image_file settings will be used for every client that has no UI customization set previously.
   * @schema UserPoolUiCustomizationSpecForProvider#clientId
   */
  readonly clientId?: string;

  /**
   * Reference to a UserPoolClient to populate clientId.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#clientIdRef
   */
  readonly clientIdRef?: UserPoolUiCustomizationSpecForProviderClientIdRef;

  /**
   * Selector for a UserPoolClient to populate clientId.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#clientIdSelector
   */
  readonly clientIdSelector?: UserPoolUiCustomizationSpecForProviderClientIdSelector;

  /**
   * The CSS values in the UI customization, provided as a String. At least one of css or image_file is required.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#css
   */
  readonly css?: string;

  /**
   * The uploaded logo image for the UI customization, provided as a base64-encoded String. Drift detection is not possible for this argument. At least one of css or image_file is required.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#imageFile
   */
  readonly imageFile?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user pool ID for the user pool.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#userPoolId
   */
  readonly userPoolId?: string;

  /**
   * Reference to a UserPool to populate userPoolId.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#userPoolIdRef
   */
  readonly userPoolIdRef?: UserPoolUiCustomizationSpecForProviderUserPoolIdRef;

  /**
   * Selector for a UserPool to populate userPoolId.
   *
   * @schema UserPoolUiCustomizationSpecForProvider#userPoolIdSelector
   */
  readonly userPoolIdSelector?: UserPoolUiCustomizationSpecForProviderUserPoolIdSelector;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProvider(obj: UserPoolUiCustomizationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientIdRef': toJson_UserPoolUiCustomizationSpecForProviderClientIdRef(obj.clientIdRef),
    'clientIdSelector': toJson_UserPoolUiCustomizationSpecForProviderClientIdSelector(obj.clientIdSelector),
    'css': obj.css,
    'imageFile': obj.imageFile,
    'region': obj.region,
    'userPoolId': obj.userPoolId,
    'userPoolIdRef': toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdRef(obj.userPoolIdRef),
    'userPoolIdSelector': toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdSelector(obj.userPoolIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema UserPoolUiCustomizationSpecProviderConfigRef
 */
export interface UserPoolUiCustomizationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolUiCustomizationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolUiCustomizationSpecProviderConfigRef#policy
   */
  readonly policy?: UserPoolUiCustomizationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecProviderConfigRef(obj: UserPoolUiCustomizationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolUiCustomizationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema UserPoolUiCustomizationSpecProviderRef
 */
export interface UserPoolUiCustomizationSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolUiCustomizationSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolUiCustomizationSpecProviderRef#policy
   */
  readonly policy?: UserPoolUiCustomizationSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecProviderRef(obj: UserPoolUiCustomizationSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolUiCustomizationSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsTo
 */
export interface UserPoolUiCustomizationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsTo(obj: UserPoolUiCustomizationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema UserPoolUiCustomizationSpecWriteConnectionSecretToRef
 */
export interface UserPoolUiCustomizationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserPoolUiCustomizationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserPoolUiCustomizationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecWriteConnectionSecretToRef(obj: UserPoolUiCustomizationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPoolClient to populate clientId.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdRef
 */
export interface UserPoolUiCustomizationSpecForProviderClientIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdRef#policy
   */
  readonly policy?: UserPoolUiCustomizationSpecForProviderClientIdRefPolicy;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderClientIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderClientIdRef(obj: UserPoolUiCustomizationSpecForProviderClientIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolUiCustomizationSpecForProviderClientIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPoolClient to populate clientId.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdSelector
 */
export interface UserPoolUiCustomizationSpecForProviderClientIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdSelector#policy
   */
  readonly policy?: UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderClientIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderClientIdSelector(obj: UserPoolUiCustomizationSpecForProviderClientIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a UserPool to populate userPoolId.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRef
 */
export interface UserPoolUiCustomizationSpecForProviderUserPoolIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRef#policy
   */
  readonly policy?: UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderUserPoolIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdRef(obj: UserPoolUiCustomizationSpecForProviderUserPoolIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a UserPool to populate userPoolId.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelector
 */
export interface UserPoolUiCustomizationSpecForProviderUserPoolIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelector#policy
   */
  readonly policy?: UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderUserPoolIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdSelector(obj: UserPoolUiCustomizationSpecForProviderUserPoolIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolUiCustomizationSpecProviderConfigRefPolicy
 */
export interface UserPoolUiCustomizationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolUiCustomizationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolUiCustomizationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolUiCustomizationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolUiCustomizationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecProviderConfigRefPolicy(obj: UserPoolUiCustomizationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolUiCustomizationSpecProviderRefPolicy
 */
export interface UserPoolUiCustomizationSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolUiCustomizationSpecProviderRefPolicy#resolution
   */
  readonly resolution?: UserPoolUiCustomizationSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolUiCustomizationSpecProviderRefPolicy#resolve
   */
  readonly resolve?: UserPoolUiCustomizationSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecProviderRefPolicy(obj: UserPoolUiCustomizationSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef
 */
export interface UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef(obj: UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata
 */
export interface UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata(obj: UserPoolUiCustomizationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdRefPolicy
 */
export interface UserPoolUiCustomizationSpecForProviderClientIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdRefPolicy#resolution
   */
  readonly resolution?: UserPoolUiCustomizationSpecForProviderClientIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdRefPolicy#resolve
   */
  readonly resolve?: UserPoolUiCustomizationSpecForProviderClientIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderClientIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderClientIdRefPolicy(obj: UserPoolUiCustomizationSpecForProviderClientIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy
 */
export interface UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy(obj: UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy
 */
export interface UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy#resolution
   */
  readonly resolution?: UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy#resolve
   */
  readonly resolve?: UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy(obj: UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy
 */
export interface UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy#resolution
   */
  readonly resolution?: UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy#resolve
   */
  readonly resolve?: UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy(obj: UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolUiCustomizationSpecProviderConfigRefPolicyResolution
 */
export enum UserPoolUiCustomizationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolUiCustomizationSpecProviderConfigRefPolicyResolve
 */
export enum UserPoolUiCustomizationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolUiCustomizationSpecProviderRefPolicyResolution
 */
export enum UserPoolUiCustomizationSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolUiCustomizationSpecProviderRefPolicyResolve
 */
export enum UserPoolUiCustomizationSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdRefPolicyResolution
 */
export enum UserPoolUiCustomizationSpecForProviderClientIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdRefPolicyResolve
 */
export enum UserPoolUiCustomizationSpecForProviderClientIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicyResolution
 */
export enum UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicyResolve
 */
export enum UserPoolUiCustomizationSpecForProviderClientIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicyResolution
 */
export enum UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicyResolve
 */
export enum UserPoolUiCustomizationSpecForProviderUserPoolIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicyResolution
 */
export enum UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicyResolve
 */
export enum UserPoolUiCustomizationSpecForProviderUserPoolIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserPoolUiCustomizationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

