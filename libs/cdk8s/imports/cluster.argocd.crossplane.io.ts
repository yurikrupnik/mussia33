// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Cluster is a managed resource that represents an ArgoCD Git Cluster
 *
 * @schema Cluster
 */
export class Cluster extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Cluster"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cluster.argocd.crossplane.io/v1alpha1',
    kind: 'Cluster',
  }

  /**
   * Renders a Kubernetes manifest for "Cluster".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterProps): any {
    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(props),
    };
  }

  /**
   * Defines a "Cluster" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterProps) {
    super(scope, id, {
      ...Cluster.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Cluster.GVK,
      ...toJson_ClusterProps(resolved),
    };
  }
}

/**
 * A Cluster is a managed resource that represents an ArgoCD Git Cluster
 *
 * @schema Cluster
 */
export interface ClusterProps {
  /**
   * @schema Cluster#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * A ClusterSpec defines the desired state of an ArgoCD Cluster.
   *
   * @schema Cluster#spec
   */
  readonly spec: ClusterSpec;

}

/**
 * Converts an object of type 'ClusterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterProps(obj: ClusterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ClusterSpec defines the desired state of an ArgoCD Cluster.
 *
 * @schema ClusterSpec
 */
export interface ClusterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ClusterSpec#deletionPolicy
   */
  readonly deletionPolicy?: ClusterSpecDeletionPolicy;

  /**
   * ClusterParameters define the desired state of an ArgoCD Cluster
   *
   * @schema ClusterSpec#forProvider
   */
  readonly forProvider: ClusterSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ClusterSpec#providerConfigRef
   */
  readonly providerConfigRef?: ClusterSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ClusterSpec#providerRef
   */
  readonly providerRef?: ClusterSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ClusterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ClusterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ClusterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ClusterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ClusterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpec(obj: ClusterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ClusterSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ClusterSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ClusterSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ClusterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ClusterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ClusterSpecDeletionPolicy
 */
export enum ClusterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * ClusterParameters define the desired state of an ArgoCD Cluster
 *
 * @schema ClusterSpecForProvider
 */
export interface ClusterSpecForProvider {
  /**
   * Annotations for cluster secret metadata
   *
   * @schema ClusterSpecForProvider#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Config holds cluster information for connecting to a cluster
   *
   * @schema ClusterSpecForProvider#config
   */
  readonly config: ClusterSpecForProviderConfig;

  /**
   * Labels for cluster secret metadata
   *
   * @schema ClusterSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the cluster. If omitted, will use the server address
   *
   * @schema ClusterSpecForProvider#name
   */
  readonly name: string;

  /**
   * Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
   *
   * @schema ClusterSpecForProvider#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Reference between project and cluster that allow you automatically to be added as item inside Destinations project entity
   *
   * @schema ClusterSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Server is the API server URL of the Kubernetes cluster
   *
   * @schema ClusterSpecForProvider#server
   */
  readonly server: string;

  /**
   * Shard contains optional shard number. Calculated on the fly by the application controller if not specified.
   *
   * @schema ClusterSpecForProvider#shard
   */
  readonly shard?: number;

}

/**
 * Converts an object of type 'ClusterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProvider(obj: ClusterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'config': toJson_ClusterSpecForProviderConfig(obj.config),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
    'namespaces': obj.namespaces?.map(y => y),
    'project': obj.project,
    'server': obj.server,
    'shard': obj.shard,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ClusterSpecProviderConfigRef
 */
export interface ClusterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderConfigRef#policy
   */
  readonly policy?: ClusterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRef(obj: ClusterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ClusterSpecProviderRef
 */
export interface ClusterSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecProviderRef#policy
   */
  readonly policy?: ClusterSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRef(obj: ClusterSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ClusterSpecPublishConnectionDetailsTo
 */
export interface ClusterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ClusterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ClusterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ClusterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsTo(obj: ClusterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ClusterSpecWriteConnectionSecretToRef
 */
export interface ClusterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecWriteConnectionSecretToRef(obj: ClusterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Config holds cluster information for connecting to a cluster
 *
 * @schema ClusterSpecForProviderConfig
 */
export interface ClusterSpecForProviderConfig {
  /**
   * AWSAuthConfig contains IAM authentication configuration
   *
   * @schema ClusterSpecForProviderConfig#awsAuthConfig
   */
  readonly awsAuthConfig?: ClusterSpecForProviderConfigAwsAuthConfig;

  /**
   * BearerTokenSecretRef contains a reference to a kubernetes secret containing the BearerToken
   *
   * @schema ClusterSpecForProviderConfig#bearerTokenSecretRef
   */
  readonly bearerTokenSecretRef?: ClusterSpecForProviderConfigBearerTokenSecretRef;

  /**
   * ExecProviderConfig contains configuration for an exec provider
   *
   * @schema ClusterSpecForProviderConfig#execProviderConfig
   */
  readonly execProviderConfig?: ClusterSpecForProviderConfigExecProviderConfig;

  /**
   * PasswordSecretRef contains a reference to a kubernetes secret containing the Password
   *
   * @schema ClusterSpecForProviderConfig#passwordSecretRef
   */
  readonly passwordSecretRef?: ClusterSpecForProviderConfigPasswordSecretRef;

  /**
   * TLSClientConfig contains settings to enable transport layer security
   *
   * @schema ClusterSpecForProviderConfig#tlsClientConfig
   */
  readonly tlsClientConfig: ClusterSpecForProviderConfigTlsClientConfig;

  /**
   * Server requires Basic authentication
   *
   * @schema ClusterSpecForProviderConfig#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfig(obj: ClusterSpecForProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsAuthConfig': toJson_ClusterSpecForProviderConfigAwsAuthConfig(obj.awsAuthConfig),
    'bearerTokenSecretRef': toJson_ClusterSpecForProviderConfigBearerTokenSecretRef(obj.bearerTokenSecretRef),
    'execProviderConfig': toJson_ClusterSpecForProviderConfigExecProviderConfig(obj.execProviderConfig),
    'passwordSecretRef': toJson_ClusterSpecForProviderConfigPasswordSecretRef(obj.passwordSecretRef),
    'tlsClientConfig': toJson_ClusterSpecForProviderConfigTlsClientConfig(obj.tlsClientConfig),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderConfigRefPolicy
 */
export interface ClusterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderConfigRefPolicy(obj: ClusterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecProviderRefPolicy
 */
export interface ClusterSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecProviderRefPolicy(obj: ClusterSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRef
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ClusterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRef(obj: ClusterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ClusterSpecPublishConnectionDetailsToMetadata
 */
export interface ClusterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ClusterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToMetadata(obj: ClusterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSAuthConfig contains IAM authentication configuration
 *
 * @schema ClusterSpecForProviderConfigAwsAuthConfig
 */
export interface ClusterSpecForProviderConfigAwsAuthConfig {
  /**
   * ClusterName contains AWS cluster name
   *
   * @schema ClusterSpecForProviderConfigAwsAuthConfig#clusterName
   */
  readonly clusterName?: string;

  /**
   * RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster operations instead of the default AWS credential provider chain.
   *
   * @schema ClusterSpecForProviderConfigAwsAuthConfig#roleARN
   */
  readonly roleArn?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigAwsAuthConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigAwsAuthConfig(obj: ClusterSpecForProviderConfigAwsAuthConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterName': obj.clusterName,
    'roleARN': obj.roleArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BearerTokenSecretRef contains a reference to a kubernetes secret containing the BearerToken
 *
 * @schema ClusterSpecForProviderConfigBearerTokenSecretRef
 */
export interface ClusterSpecForProviderConfigBearerTokenSecretRef {
  /**
   * Key whose value will be used.
   *
   * @schema ClusterSpecForProviderConfigBearerTokenSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderConfigBearerTokenSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderConfigBearerTokenSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigBearerTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigBearerTokenSecretRef(obj: ClusterSpecForProviderConfigBearerTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExecProviderConfig contains configuration for an exec provider
 *
 * @schema ClusterSpecForProviderConfigExecProviderConfig
 */
export interface ClusterSpecForProviderConfigExecProviderConfig {
  /**
   * Preferred input version of the ExecInfo
   *
   * @schema ClusterSpecForProviderConfigExecProviderConfig#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Arguments to pass to the command when executing it
   *
   * @schema ClusterSpecForProviderConfigExecProviderConfig#args
   */
  readonly args?: string[];

  /**
   * Command to execute
   *
   * @schema ClusterSpecForProviderConfigExecProviderConfig#command
   */
  readonly command?: string;

  /**
   * Env defines additional environment variables to expose to the process
   *
   * @schema ClusterSpecForProviderConfigExecProviderConfig#env
   */
  readonly env?: { [key: string]: string };

  /**
   * This text is shown to the user when the executable doesn't seem to be present
   *
   * @schema ClusterSpecForProviderConfigExecProviderConfig#installHint
   */
  readonly installHint?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigExecProviderConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigExecProviderConfig(obj: ClusterSpecForProviderConfigExecProviderConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'args': obj.args?.map(y => y),
    'command': obj.command,
    'env': ((obj.env) === undefined) ? undefined : (Object.entries(obj.env).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'installHint': obj.installHint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PasswordSecretRef contains a reference to a kubernetes secret containing the Password
 *
 * @schema ClusterSpecForProviderConfigPasswordSecretRef
 */
export interface ClusterSpecForProviderConfigPasswordSecretRef {
  /**
   * Key whose value will be used.
   *
   * @schema ClusterSpecForProviderConfigPasswordSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderConfigPasswordSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderConfigPasswordSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigPasswordSecretRef(obj: ClusterSpecForProviderConfigPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSClientConfig contains settings to enable transport layer security
 *
 * @schema ClusterSpecForProviderConfigTlsClientConfig
 */
export interface ClusterSpecForProviderConfigTlsClientConfig {
  /**
   * CAData holds PEM-encoded bytes (typically read from a root certificates bundle). CAData takes precedence over CAFile
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfig#caData
   */
  readonly caData?: string;

  /**
   * CADataSecretRef references a secret holding PEM-encoded bytes (typically read from a root certificates bundle).
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfig#caDataSecretRef
   */
  readonly caDataSecretRef?: ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef;

  /**
   * CertDataSecretRef references a secret holding PEM-encoded bytes (typically read from a client certificate file).
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfig#certDataSecretRef
   */
  readonly certDataSecretRef?: ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef;

  /**
   * Insecure specifies that the server should be accessed without verifying the TLS certificate. For testing only.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfig#insecure
   */
  readonly insecure: boolean;

  /**
   * KeyDataSecretRef references a secret holding PEM-encoded bytes (typically read from a client certificate key file).
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfig#keyDataSecretRef
   */
  readonly keyDataSecretRef?: ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef;

  /**
   * ServerName is passed to the server for SNI and is used in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfig#serverName
   */
  readonly serverName?: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigTlsClientConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigTlsClientConfig(obj: ClusterSpecForProviderConfigTlsClientConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caData': obj.caData,
    'caDataSecretRef': toJson_ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef(obj.caDataSecretRef),
    'certDataSecretRef': toJson_ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef(obj.certDataSecretRef),
    'insecure': obj.insecure,
    'keyDataSecretRef': toJson_ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef(obj.keyDataSecretRef),
    'serverName': obj.serverName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolution
 */
export enum ClusterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderConfigRefPolicyResolve
 */
export enum ClusterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecProviderRefPolicyResolution
 */
export enum ClusterSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecProviderRefPolicyResolve
 */
export enum ClusterSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ClusterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ClusterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecPublishConnectionDetailsToConfigRefPolicy(obj: ClusterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CADataSecretRef references a secret holding PEM-encoded bytes (typically read from a root certificates bundle).
 *
 * @schema ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef
 */
export interface ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef {
  /**
   * Key whose value will be used.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef(obj: ClusterSpecForProviderConfigTlsClientConfigCaDataSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertDataSecretRef references a secret holding PEM-encoded bytes (typically read from a client certificate file).
 *
 * @schema ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef
 */
export interface ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef {
  /**
   * Key whose value will be used.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef(obj: ClusterSpecForProviderConfigTlsClientConfigCertDataSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyDataSecretRef references a secret holding PEM-encoded bytes (typically read from a client certificate key file).
 *
 * @schema ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef
 */
export interface ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef {
  /**
   * Key whose value will be used.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef(obj: ClusterSpecForProviderConfigTlsClientConfigKeyDataSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ClusterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

