// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * PlatformApplication is the Schema for the PlatformApplications API. Provides an SNS platform application resource.
 *
 * @schema PlatformApplication
 */
export class PlatformApplication extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PlatformApplication"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sns.aws.upbound.io/v1beta1',
    kind: 'PlatformApplication',
  }

  /**
   * Renders a Kubernetes manifest for "PlatformApplication".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PlatformApplicationProps): any {
    return {
      ...PlatformApplication.GVK,
      ...toJson_PlatformApplicationProps(props),
    };
  }

  /**
   * Defines a "PlatformApplication" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PlatformApplicationProps) {
    super(scope, id, {
      ...PlatformApplication.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PlatformApplication.GVK,
      ...toJson_PlatformApplicationProps(resolved),
    };
  }
}

/**
 * PlatformApplication is the Schema for the PlatformApplications API. Provides an SNS platform application resource.
 *
 * @schema PlatformApplication
 */
export interface PlatformApplicationProps {
  /**
   * @schema PlatformApplication#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PlatformApplicationSpec defines the desired state of PlatformApplication
   *
   * @schema PlatformApplication#spec
   */
  readonly spec: PlatformApplicationSpec;

}

/**
 * Converts an object of type 'PlatformApplicationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationProps(obj: PlatformApplicationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PlatformApplicationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PlatformApplicationSpec defines the desired state of PlatformApplication
 *
 * @schema PlatformApplicationSpec
 */
export interface PlatformApplicationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PlatformApplicationSpec#deletionPolicy
   */
  readonly deletionPolicy?: PlatformApplicationSpecDeletionPolicy;

  /**
   * @schema PlatformApplicationSpec#forProvider
   */
  readonly forProvider: PlatformApplicationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema PlatformApplicationSpec#initProvider
   */
  readonly initProvider?: PlatformApplicationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PlatformApplicationSpec#managementPolicies
   */
  readonly managementPolicies?: PlatformApplicationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema PlatformApplicationSpec#providerConfigRef
   */
  readonly providerConfigRef?: PlatformApplicationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema PlatformApplicationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PlatformApplicationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema PlatformApplicationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PlatformApplicationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PlatformApplicationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpec(obj: PlatformApplicationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PlatformApplicationSpecForProvider(obj.forProvider),
    'initProvider': toJson_PlatformApplicationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PlatformApplicationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PlatformApplicationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PlatformApplicationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PlatformApplicationSpecDeletionPolicy
 */
export enum PlatformApplicationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PlatformApplicationSpecForProvider
 */
export interface PlatformApplicationSpecForProvider {
  /**
   * The bundle identifier that's assigned to your iOS app. May only include alphanumeric characters, hyphens (-), and periods (.).
   *
   * @schema PlatformApplicationSpecForProvider#applePlatformBundleId
   */
  readonly applePlatformBundleId?: string;

  /**
   * The identifier that's assigned to your Apple developer account team. Must be 10 alphanumeric characters.
   *
   * @schema PlatformApplicationSpecForProvider#applePlatformTeamId
   */
  readonly applePlatformTeamId?: string;

  /**
   * The ARN of the SNS Topic triggered when a delivery to any of the platform endpoints associated with your platform application encounters a permanent failure.
   *
   * @schema PlatformApplicationSpecForProvider#eventDeliveryFailureTopicArn
   */
  readonly eventDeliveryFailureTopicArn?: string;

  /**
   * The ARN of the SNS Topic triggered when a new platform endpoint is added to your platform application.
   *
   * @schema PlatformApplicationSpecForProvider#eventEndpointCreatedTopicArn
   */
  readonly eventEndpointCreatedTopicArn?: string;

  /**
   * The ARN of the SNS Topic triggered when an existing platform endpoint is deleted from your platform application.
   *
   * @schema PlatformApplicationSpecForProvider#eventEndpointDeletedTopicArn
   */
  readonly eventEndpointDeletedTopicArn?: string;

  /**
   * The ARN of the SNS Topic triggered when an existing platform endpoint is changed from your platform application.
   *
   * @schema PlatformApplicationSpecForProvider#eventEndpointUpdatedTopicArn
   */
  readonly eventEndpointUpdatedTopicArn?: string;

  /**
   * The IAM role ARN permitted to receive failure feedback for this application and give SNS write access to use CloudWatch logs on your behalf.
   *
   * @schema PlatformApplicationSpecForProvider#failureFeedbackRoleArn
   */
  readonly failureFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate failureFeedbackRoleArn.
   *
   * @schema PlatformApplicationSpecForProvider#failureFeedbackRoleArnRef
   */
  readonly failureFeedbackRoleArnRef?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate failureFeedbackRoleArn.
   *
   * @schema PlatformApplicationSpecForProvider#failureFeedbackRoleArnSelector
   */
  readonly failureFeedbackRoleArnSelector?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector;

  /**
   * The platform that the app is registered with. See Platform for supported platforms.
   *
   * @schema PlatformApplicationSpecForProvider#platform
   */
  readonly platform?: string;

  /**
   * Application Platform credential. See Credential for type of credential required for platform.
   *
   * @schema PlatformApplicationSpecForProvider#platformCredentialSecretRef
   */
  readonly platformCredentialSecretRef?: PlatformApplicationSpecForProviderPlatformCredentialSecretRef;

  /**
   * Application Platform principal. See Principal for type of principal required for platform.
   *
   * @schema PlatformApplicationSpecForProvider#platformPrincipalSecretRef
   */
  readonly platformPrincipalSecretRef?: PlatformApplicationSpecForProviderPlatformPrincipalSecretRef;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PlatformApplicationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The IAM role ARN permitted to receive success feedback for this application and give SNS write access to use CloudWatch logs on your behalf.
   *
   * @schema PlatformApplicationSpecForProvider#successFeedbackRoleArn
   */
  readonly successFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate successFeedbackRoleArn.
   *
   * @schema PlatformApplicationSpecForProvider#successFeedbackRoleArnRef
   */
  readonly successFeedbackRoleArnRef?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate successFeedbackRoleArn.
   *
   * @schema PlatformApplicationSpecForProvider#successFeedbackRoleArnSelector
   */
  readonly successFeedbackRoleArnSelector?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector;

  /**
   * The sample rate percentage (0-100) of successfully delivered messages.
   *
   * @schema PlatformApplicationSpecForProvider#successFeedbackSampleRate
   */
  readonly successFeedbackSampleRate?: string;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProvider(obj: PlatformApplicationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applePlatformBundleId': obj.applePlatformBundleId,
    'applePlatformTeamId': obj.applePlatformTeamId,
    'eventDeliveryFailureTopicArn': obj.eventDeliveryFailureTopicArn,
    'eventEndpointCreatedTopicArn': obj.eventEndpointCreatedTopicArn,
    'eventEndpointDeletedTopicArn': obj.eventEndpointDeletedTopicArn,
    'eventEndpointUpdatedTopicArn': obj.eventEndpointUpdatedTopicArn,
    'failureFeedbackRoleArn': obj.failureFeedbackRoleArn,
    'failureFeedbackRoleArnRef': toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef(obj.failureFeedbackRoleArnRef),
    'failureFeedbackRoleArnSelector': toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector(obj.failureFeedbackRoleArnSelector),
    'platform': obj.platform,
    'platformCredentialSecretRef': toJson_PlatformApplicationSpecForProviderPlatformCredentialSecretRef(obj.platformCredentialSecretRef),
    'platformPrincipalSecretRef': toJson_PlatformApplicationSpecForProviderPlatformPrincipalSecretRef(obj.platformPrincipalSecretRef),
    'region': obj.region,
    'successFeedbackRoleArn': obj.successFeedbackRoleArn,
    'successFeedbackRoleArnRef': toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef(obj.successFeedbackRoleArnRef),
    'successFeedbackRoleArnSelector': toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector(obj.successFeedbackRoleArnSelector),
    'successFeedbackSampleRate': obj.successFeedbackSampleRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema PlatformApplicationSpecInitProvider
 */
export interface PlatformApplicationSpecInitProvider {
  /**
   * The bundle identifier that's assigned to your iOS app. May only include alphanumeric characters, hyphens (-), and periods (.).
   *
   * @schema PlatformApplicationSpecInitProvider#applePlatformBundleId
   */
  readonly applePlatformBundleId?: string;

  /**
   * The identifier that's assigned to your Apple developer account team. Must be 10 alphanumeric characters.
   *
   * @schema PlatformApplicationSpecInitProvider#applePlatformTeamId
   */
  readonly applePlatformTeamId?: string;

  /**
   * The ARN of the SNS Topic triggered when a delivery to any of the platform endpoints associated with your platform application encounters a permanent failure.
   *
   * @schema PlatformApplicationSpecInitProvider#eventDeliveryFailureTopicArn
   */
  readonly eventDeliveryFailureTopicArn?: string;

  /**
   * The ARN of the SNS Topic triggered when a new platform endpoint is added to your platform application.
   *
   * @schema PlatformApplicationSpecInitProvider#eventEndpointCreatedTopicArn
   */
  readonly eventEndpointCreatedTopicArn?: string;

  /**
   * The ARN of the SNS Topic triggered when an existing platform endpoint is deleted from your platform application.
   *
   * @schema PlatformApplicationSpecInitProvider#eventEndpointDeletedTopicArn
   */
  readonly eventEndpointDeletedTopicArn?: string;

  /**
   * The ARN of the SNS Topic triggered when an existing platform endpoint is changed from your platform application.
   *
   * @schema PlatformApplicationSpecInitProvider#eventEndpointUpdatedTopicArn
   */
  readonly eventEndpointUpdatedTopicArn?: string;

  /**
   * The platform that the app is registered with. See Platform for supported platforms.
   *
   * @schema PlatformApplicationSpecInitProvider#platform
   */
  readonly platform?: string;

  /**
   * The sample rate percentage (0-100) of successfully delivered messages.
   *
   * @schema PlatformApplicationSpecInitProvider#successFeedbackSampleRate
   */
  readonly successFeedbackSampleRate?: string;

}

/**
 * Converts an object of type 'PlatformApplicationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecInitProvider(obj: PlatformApplicationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applePlatformBundleId': obj.applePlatformBundleId,
    'applePlatformTeamId': obj.applePlatformTeamId,
    'eventDeliveryFailureTopicArn': obj.eventDeliveryFailureTopicArn,
    'eventEndpointCreatedTopicArn': obj.eventEndpointCreatedTopicArn,
    'eventEndpointDeletedTopicArn': obj.eventEndpointDeletedTopicArn,
    'eventEndpointUpdatedTopicArn': obj.eventEndpointUpdatedTopicArn,
    'platform': obj.platform,
    'successFeedbackSampleRate': obj.successFeedbackSampleRate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema PlatformApplicationSpecManagementPolicies
 */
export enum PlatformApplicationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema PlatformApplicationSpecProviderConfigRef
 */
export interface PlatformApplicationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlatformApplicationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlatformApplicationSpecProviderConfigRef#policy
   */
  readonly policy?: PlatformApplicationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PlatformApplicationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecProviderConfigRef(obj: PlatformApplicationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlatformApplicationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema PlatformApplicationSpecPublishConnectionDetailsTo
 */
export interface PlatformApplicationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PlatformApplicationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PlatformApplicationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PlatformApplicationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecPublishConnectionDetailsTo(obj: PlatformApplicationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PlatformApplicationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PlatformApplicationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema PlatformApplicationSpecWriteConnectionSecretToRef
 */
export interface PlatformApplicationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PlatformApplicationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PlatformApplicationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PlatformApplicationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecWriteConnectionSecretToRef(obj: PlatformApplicationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate failureFeedbackRoleArn.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef
 */
export interface PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef#policy
   */
  readonly policy?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef(obj: PlatformApplicationSpecForProviderFailureFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate failureFeedbackRoleArn.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector
 */
export interface PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector#policy
   */
  readonly policy?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector(obj: PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Application Platform credential. See Credential for type of credential required for platform.
 *
 * @schema PlatformApplicationSpecForProviderPlatformCredentialSecretRef
 */
export interface PlatformApplicationSpecForProviderPlatformCredentialSecretRef {
  /**
   * The key to select.
   *
   * @schema PlatformApplicationSpecForProviderPlatformCredentialSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema PlatformApplicationSpecForProviderPlatformCredentialSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PlatformApplicationSpecForProviderPlatformCredentialSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderPlatformCredentialSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderPlatformCredentialSecretRef(obj: PlatformApplicationSpecForProviderPlatformCredentialSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Application Platform principal. See Principal for type of principal required for platform.
 *
 * @schema PlatformApplicationSpecForProviderPlatformPrincipalSecretRef
 */
export interface PlatformApplicationSpecForProviderPlatformPrincipalSecretRef {
  /**
   * The key to select.
   *
   * @schema PlatformApplicationSpecForProviderPlatformPrincipalSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema PlatformApplicationSpecForProviderPlatformPrincipalSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PlatformApplicationSpecForProviderPlatformPrincipalSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderPlatformPrincipalSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderPlatformPrincipalSecretRef(obj: PlatformApplicationSpecForProviderPlatformPrincipalSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate successFeedbackRoleArn.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef
 */
export interface PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef#policy
   */
  readonly policy?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef(obj: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate successFeedbackRoleArn.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector
 */
export interface PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector#policy
   */
  readonly policy?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector(obj: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlatformApplicationSpecProviderConfigRefPolicy
 */
export interface PlatformApplicationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlatformApplicationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PlatformApplicationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlatformApplicationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PlatformApplicationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlatformApplicationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecProviderConfigRefPolicy(obj: PlatformApplicationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRef
 */
export interface PlatformApplicationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PlatformApplicationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecPublishConnectionDetailsToConfigRef(obj: PlatformApplicationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PlatformApplicationSpecPublishConnectionDetailsToMetadata
 */
export interface PlatformApplicationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PlatformApplicationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecPublishConnectionDetailsToMetadata(obj: PlatformApplicationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy
 */
export interface PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy(obj: PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy
 */
export interface PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy(obj: PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy
 */
export interface PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy(obj: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy
 */
export interface PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy(obj: PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlatformApplicationSpecProviderConfigRefPolicyResolution
 */
export enum PlatformApplicationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlatformApplicationSpecProviderConfigRefPolicyResolve
 */
export enum PlatformApplicationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy(obj: PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicyResolution
 */
export enum PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicyResolve
 */
export enum PlatformApplicationSpecForProviderFailureFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicyResolution
 */
export enum PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicyResolve
 */
export enum PlatformApplicationSpecForProviderFailureFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicyResolution
 */
export enum PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicyResolve
 */
export enum PlatformApplicationSpecForProviderSuccessFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicyResolution
 */
export enum PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicyResolve
 */
export enum PlatformApplicationSpecForProviderSuccessFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PlatformApplicationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * SMSPreferences is the Schema for the SMSPreferencess API. Provides a way to set SNS SMS preferences.
 *
 * @schema SMSPreferences
 */
export class SmsPreferences extends ApiObject {
  /**
   * Returns the apiVersion and kind for "SMSPreferences"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sns.aws.upbound.io/v1beta1',
    kind: 'SMSPreferences',
  }

  /**
   * Renders a Kubernetes manifest for "SMSPreferences".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SmsPreferencesProps): any {
    return {
      ...SmsPreferences.GVK,
      ...toJson_SmsPreferencesProps(props),
    };
  }

  /**
   * Defines a "SMSPreferences" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SmsPreferencesProps) {
    super(scope, id, {
      ...SmsPreferences.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...SmsPreferences.GVK,
      ...toJson_SmsPreferencesProps(resolved),
    };
  }
}

/**
 * SMSPreferences is the Schema for the SMSPreferencess API. Provides a way to set SNS SMS preferences.
 *
 * @schema SMSPreferences
 */
export interface SmsPreferencesProps {
  /**
   * @schema SMSPreferences#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SMSPreferencesSpec defines the desired state of SMSPreferences
   *
   * @schema SMSPreferences#spec
   */
  readonly spec: SmsPreferencesSpec;

}

/**
 * Converts an object of type 'SmsPreferencesProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesProps(obj: SmsPreferencesProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SmsPreferencesSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SMSPreferencesSpec defines the desired state of SMSPreferences
 *
 * @schema SmsPreferencesSpec
 */
export interface SmsPreferencesSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SmsPreferencesSpec#deletionPolicy
   */
  readonly deletionPolicy?: SmsPreferencesSpecDeletionPolicy;

  /**
   * @schema SmsPreferencesSpec#forProvider
   */
  readonly forProvider: SmsPreferencesSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SmsPreferencesSpec#initProvider
   */
  readonly initProvider?: SmsPreferencesSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SmsPreferencesSpec#managementPolicies
   */
  readonly managementPolicies?: SmsPreferencesSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SmsPreferencesSpec#providerConfigRef
   */
  readonly providerConfigRef?: SmsPreferencesSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SmsPreferencesSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SmsPreferencesSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SmsPreferencesSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SmsPreferencesSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SmsPreferencesSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpec(obj: SmsPreferencesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SmsPreferencesSpecForProvider(obj.forProvider),
    'initProvider': toJson_SmsPreferencesSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SmsPreferencesSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SmsPreferencesSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SmsPreferencesSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SmsPreferencesSpecDeletionPolicy
 */
export enum SmsPreferencesSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SmsPreferencesSpecForProvider
 */
export interface SmsPreferencesSpecForProvider {
  /**
   * A string, such as your business brand, that is displayed as the sender on the receiving device.
   *
   * @schema SmsPreferencesSpecForProvider#defaultSenderId
   */
  readonly defaultSenderId?: string;

  /**
   * The type of SMS message that you will send by default. Possible values are: Promotional, Transactional
   *
   * @schema SmsPreferencesSpecForProvider#defaultSmsType
   */
  readonly defaultSmsType?: string;

  /**
   * The ARN of the IAM role that allows Amazon SNS to write logs about SMS deliveries in CloudWatch Logs.
   *
   * @schema SmsPreferencesSpecForProvider#deliveryStatusIamRoleArn
   */
  readonly deliveryStatusIamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate deliveryStatusIamRoleArn.
   *
   * @schema SmsPreferencesSpecForProvider#deliveryStatusIamRoleArnRef
   */
  readonly deliveryStatusIamRoleArnRef?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate deliveryStatusIamRoleArn.
   *
   * @schema SmsPreferencesSpecForProvider#deliveryStatusIamRoleArnSelector
   */
  readonly deliveryStatusIamRoleArnSelector?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector;

  /**
   * The percentage of successful SMS deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value must be between 0 and 100.
   *
   * @schema SmsPreferencesSpecForProvider#deliveryStatusSuccessSamplingRate
   */
  readonly deliveryStatusSuccessSamplingRate?: string;

  /**
   * The maximum amount in USD that you are willing to spend each month to send SMS messages.
   *
   * @schema SmsPreferencesSpecForProvider#monthlySpendLimit
   */
  readonly monthlySpendLimit?: number;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SmsPreferencesSpecForProvider#region
   */
  readonly region: string;

  /**
   * The name of the Amazon S3 bucket to receive daily SMS usage reports from Amazon SNS.
   *
   * @schema SmsPreferencesSpecForProvider#usageReportS3Bucket
   */
  readonly usageReportS3Bucket?: string;

}

/**
 * Converts an object of type 'SmsPreferencesSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecForProvider(obj: SmsPreferencesSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultSenderId': obj.defaultSenderId,
    'defaultSmsType': obj.defaultSmsType,
    'deliveryStatusIamRoleArn': obj.deliveryStatusIamRoleArn,
    'deliveryStatusIamRoleArnRef': toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef(obj.deliveryStatusIamRoleArnRef),
    'deliveryStatusIamRoleArnSelector': toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector(obj.deliveryStatusIamRoleArnSelector),
    'deliveryStatusSuccessSamplingRate': obj.deliveryStatusSuccessSamplingRate,
    'monthlySpendLimit': obj.monthlySpendLimit,
    'region': obj.region,
    'usageReportS3Bucket': obj.usageReportS3Bucket,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SmsPreferencesSpecInitProvider
 */
export interface SmsPreferencesSpecInitProvider {
  /**
   * A string, such as your business brand, that is displayed as the sender on the receiving device.
   *
   * @schema SmsPreferencesSpecInitProvider#defaultSenderId
   */
  readonly defaultSenderId?: string;

  /**
   * The type of SMS message that you will send by default. Possible values are: Promotional, Transactional
   *
   * @schema SmsPreferencesSpecInitProvider#defaultSmsType
   */
  readonly defaultSmsType?: string;

  /**
   * The percentage of successful SMS deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value must be between 0 and 100.
   *
   * @schema SmsPreferencesSpecInitProvider#deliveryStatusSuccessSamplingRate
   */
  readonly deliveryStatusSuccessSamplingRate?: string;

  /**
   * The maximum amount in USD that you are willing to spend each month to send SMS messages.
   *
   * @schema SmsPreferencesSpecInitProvider#monthlySpendLimit
   */
  readonly monthlySpendLimit?: number;

  /**
   * The name of the Amazon S3 bucket to receive daily SMS usage reports from Amazon SNS.
   *
   * @schema SmsPreferencesSpecInitProvider#usageReportS3Bucket
   */
  readonly usageReportS3Bucket?: string;

}

/**
 * Converts an object of type 'SmsPreferencesSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecInitProvider(obj: SmsPreferencesSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultSenderId': obj.defaultSenderId,
    'defaultSmsType': obj.defaultSmsType,
    'deliveryStatusSuccessSamplingRate': obj.deliveryStatusSuccessSamplingRate,
    'monthlySpendLimit': obj.monthlySpendLimit,
    'usageReportS3Bucket': obj.usageReportS3Bucket,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SmsPreferencesSpecManagementPolicies
 */
export enum SmsPreferencesSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SmsPreferencesSpecProviderConfigRef
 */
export interface SmsPreferencesSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsPreferencesSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsPreferencesSpecProviderConfigRef#policy
   */
  readonly policy?: SmsPreferencesSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SmsPreferencesSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecProviderConfigRef(obj: SmsPreferencesSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsPreferencesSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SmsPreferencesSpecPublishConnectionDetailsTo
 */
export interface SmsPreferencesSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SmsPreferencesSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SmsPreferencesSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SmsPreferencesSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecPublishConnectionDetailsTo(obj: SmsPreferencesSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SmsPreferencesSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SmsPreferencesSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SmsPreferencesSpecWriteConnectionSecretToRef
 */
export interface SmsPreferencesSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SmsPreferencesSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SmsPreferencesSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SmsPreferencesSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecWriteConnectionSecretToRef(obj: SmsPreferencesSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate deliveryStatusIamRoleArn.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef
 */
export interface SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef#policy
   */
  readonly policy?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef(obj: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate deliveryStatusIamRoleArn.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector
 */
export interface SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector#policy
   */
  readonly policy?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector(obj: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SmsPreferencesSpecProviderConfigRefPolicy
 */
export interface SmsPreferencesSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsPreferencesSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SmsPreferencesSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsPreferencesSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SmsPreferencesSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsPreferencesSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecProviderConfigRefPolicy(obj: SmsPreferencesSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRef
 */
export interface SmsPreferencesSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SmsPreferencesSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecPublishConnectionDetailsToConfigRef(obj: SmsPreferencesSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SmsPreferencesSpecPublishConnectionDetailsToMetadata
 */
export interface SmsPreferencesSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SmsPreferencesSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecPublishConnectionDetailsToMetadata(obj: SmsPreferencesSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy
 */
export interface SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy(obj: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy
 */
export interface SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy(obj: SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsPreferencesSpecProviderConfigRefPolicyResolution
 */
export enum SmsPreferencesSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsPreferencesSpecProviderConfigRefPolicyResolve
 */
export enum SmsPreferencesSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy(obj: SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicyResolution
 */
export enum SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicyResolve
 */
export enum SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicyResolution
 */
export enum SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicyResolve
 */
export enum SmsPreferencesSpecForProviderDeliveryStatusIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SmsPreferencesSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Topic is the Schema for the Topics API. Provides an SNS topic resource.
 *
 * @schema Topic
 */
export class Topic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Topic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sns.aws.upbound.io/v1beta1',
    kind: 'Topic',
  }

  /**
   * Renders a Kubernetes manifest for "Topic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TopicProps): any {
    return {
      ...Topic.GVK,
      ...toJson_TopicProps(props),
    };
  }

  /**
   * Defines a "Topic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TopicProps) {
    super(scope, id, {
      ...Topic.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Topic.GVK,
      ...toJson_TopicProps(resolved),
    };
  }
}

/**
 * Topic is the Schema for the Topics API. Provides an SNS topic resource.
 *
 * @schema Topic
 */
export interface TopicProps {
  /**
   * @schema Topic#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TopicSpec defines the desired state of Topic
   *
   * @schema Topic#spec
   */
  readonly spec: TopicSpec;

}

/**
 * Converts an object of type 'TopicProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicProps(obj: TopicProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TopicSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicSpec defines the desired state of Topic
 *
 * @schema TopicSpec
 */
export interface TopicSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TopicSpec#deletionPolicy
   */
  readonly deletionPolicy?: TopicSpecDeletionPolicy;

  /**
   * @schema TopicSpec#forProvider
   */
  readonly forProvider: TopicSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TopicSpec#initProvider
   */
  readonly initProvider?: TopicSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TopicSpec#managementPolicies
   */
  readonly managementPolicies?: TopicSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TopicSpec#providerConfigRef
   */
  readonly providerConfigRef?: TopicSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TopicSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TopicSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TopicSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TopicSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TopicSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpec(obj: TopicSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TopicSpecForProvider(obj.forProvider),
    'initProvider': toJson_TopicSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TopicSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TopicSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TopicSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TopicSpecDeletionPolicy
 */
export enum TopicSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TopicSpecForProvider
 */
export interface TopicSpecForProvider {
  /**
   * IAM role for failure feedback
   *
   * @schema TopicSpecForProvider#applicationFailureFeedbackRoleArn
   */
  readonly applicationFailureFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate applicationFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#applicationFailureFeedbackRoleArnRef
   */
  readonly applicationFailureFeedbackRoleArnRef?: TopicSpecForProviderApplicationFailureFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate applicationFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#applicationFailureFeedbackRoleArnSelector
   */
  readonly applicationFailureFeedbackRoleArnSelector?: TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector;

  /**
   * The IAM role permitted to receive success feedback for this topic
   *
   * @schema TopicSpecForProvider#applicationSuccessFeedbackRoleArn
   */
  readonly applicationSuccessFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate applicationSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#applicationSuccessFeedbackRoleArnRef
   */
  readonly applicationSuccessFeedbackRoleArnRef?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate applicationSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#applicationSuccessFeedbackRoleArnSelector
   */
  readonly applicationSuccessFeedbackRoleArnSelector?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecForProvider#applicationSuccessFeedbackSampleRate
   */
  readonly applicationSuccessFeedbackSampleRate?: number;

  /**
   * Enables content-based deduplication for FIFO topics. For more information, see the related documentation
   *
   * @schema TopicSpecForProvider#contentBasedDeduplication
   */
  readonly contentBasedDeduplication?: boolean;

  /**
   * The SNS delivery policy. More on AWS documentation
   *
   * @schema TopicSpecForProvider#deliveryPolicy
   */
  readonly deliveryPolicy?: string;

  /**
   * The display name for the topic
   *
   * @schema TopicSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Boolean indicating whether or not to create a FIFO (first-in-first-out) topic (default is false).
   *
   * @schema TopicSpecForProvider#fifoTopic
   */
  readonly fifoTopic?: boolean;

  /**
   * IAM role for failure feedback
   *
   * @schema TopicSpecForProvider#firehoseFailureFeedbackRoleArn
   */
  readonly firehoseFailureFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate firehoseFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#firehoseFailureFeedbackRoleArnRef
   */
  readonly firehoseFailureFeedbackRoleArnRef?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate firehoseFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#firehoseFailureFeedbackRoleArnSelector
   */
  readonly firehoseFailureFeedbackRoleArnSelector?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector;

  /**
   * The IAM role permitted to receive success feedback for this topic
   *
   * @schema TopicSpecForProvider#firehoseSuccessFeedbackRoleArn
   */
  readonly firehoseSuccessFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate firehoseSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#firehoseSuccessFeedbackRoleArnRef
   */
  readonly firehoseSuccessFeedbackRoleArnRef?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate firehoseSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#firehoseSuccessFeedbackRoleArnSelector
   */
  readonly firehoseSuccessFeedbackRoleArnSelector?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecForProvider#firehoseSuccessFeedbackSampleRate
   */
  readonly firehoseSuccessFeedbackSampleRate?: number;

  /**
   * IAM role for failure feedback
   *
   * @schema TopicSpecForProvider#httpFailureFeedbackRoleArn
   */
  readonly httpFailureFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate httpFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#httpFailureFeedbackRoleArnRef
   */
  readonly httpFailureFeedbackRoleArnRef?: TopicSpecForProviderHttpFailureFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate httpFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#httpFailureFeedbackRoleArnSelector
   */
  readonly httpFailureFeedbackRoleArnSelector?: TopicSpecForProviderHttpFailureFeedbackRoleArnSelector;

  /**
   * The IAM role permitted to receive success feedback for this topic
   *
   * @schema TopicSpecForProvider#httpSuccessFeedbackRoleArn
   */
  readonly httpSuccessFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate httpSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#httpSuccessFeedbackRoleArnRef
   */
  readonly httpSuccessFeedbackRoleArnRef?: TopicSpecForProviderHttpSuccessFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate httpSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#httpSuccessFeedbackRoleArnSelector
   */
  readonly httpSuccessFeedbackRoleArnSelector?: TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecForProvider#httpSuccessFeedbackSampleRate
   */
  readonly httpSuccessFeedbackSampleRate?: number;

  /**
   * The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see Key Terms
   *
   * @schema TopicSpecForProvider#kmsMasterKeyId
   */
  readonly kmsMasterKeyId?: string;

  /**
   * IAM role for failure feedback
   *
   * @schema TopicSpecForProvider#lambdaFailureFeedbackRoleArn
   */
  readonly lambdaFailureFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate lambdaFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#lambdaFailureFeedbackRoleArnRef
   */
  readonly lambdaFailureFeedbackRoleArnRef?: TopicSpecForProviderLambdaFailureFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate lambdaFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#lambdaFailureFeedbackRoleArnSelector
   */
  readonly lambdaFailureFeedbackRoleArnSelector?: TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector;

  /**
   * The IAM role permitted to receive success feedback for this topic
   *
   * @schema TopicSpecForProvider#lambdaSuccessFeedbackRoleArn
   */
  readonly lambdaSuccessFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate lambdaSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#lambdaSuccessFeedbackRoleArnRef
   */
  readonly lambdaSuccessFeedbackRoleArnRef?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate lambdaSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#lambdaSuccessFeedbackRoleArnSelector
   */
  readonly lambdaSuccessFeedbackRoleArnSelector?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecForProvider#lambdaSuccessFeedbackSampleRate
   */
  readonly lambdaSuccessFeedbackSampleRate?: number;

  /**
   * The fully-formed AWS policy as JSON.
   *
   * @schema TopicSpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TopicSpecForProvider#region
   */
  readonly region: string;

  /**
   * If SignatureVersion should be 1 (SHA1) or 2 (SHA256). The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
   *
   * @schema TopicSpecForProvider#signatureVersion
   */
  readonly signatureVersion?: number;

  /**
   * IAM role for failure feedback
   *
   * @schema TopicSpecForProvider#sqsFailureFeedbackRoleArn
   */
  readonly sqsFailureFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate sqsFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#sqsFailureFeedbackRoleArnRef
   */
  readonly sqsFailureFeedbackRoleArnRef?: TopicSpecForProviderSqsFailureFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate sqsFailureFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#sqsFailureFeedbackRoleArnSelector
   */
  readonly sqsFailureFeedbackRoleArnSelector?: TopicSpecForProviderSqsFailureFeedbackRoleArnSelector;

  /**
   * The IAM role permitted to receive success feedback for this topic
   *
   * @schema TopicSpecForProvider#sqsSuccessFeedbackRoleArn
   */
  readonly sqsSuccessFeedbackRoleArn?: string;

  /**
   * Reference to a Role in iam to populate sqsSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#sqsSuccessFeedbackRoleArnRef
   */
  readonly sqsSuccessFeedbackRoleArnRef?: TopicSpecForProviderSqsSuccessFeedbackRoleArnRef;

  /**
   * Selector for a Role in iam to populate sqsSuccessFeedbackRoleArn.
   *
   * @schema TopicSpecForProvider#sqsSuccessFeedbackRoleArnSelector
   */
  readonly sqsSuccessFeedbackRoleArnSelector?: TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecForProvider#sqsSuccessFeedbackSampleRate
   */
  readonly sqsSuccessFeedbackSampleRate?: number;

  /**
   * Key-value map of resource tags.
   *
   * @schema TopicSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Tracing mode of an Amazon SNS topic. Valid values: "PassThrough", "Active".
   *
   * @schema TopicSpecForProvider#tracingConfig
   */
  readonly tracingConfig?: string;

}

/**
 * Converts an object of type 'TopicSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProvider(obj: TopicSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationFailureFeedbackRoleArn': obj.applicationFailureFeedbackRoleArn,
    'applicationFailureFeedbackRoleArnRef': toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnRef(obj.applicationFailureFeedbackRoleArnRef),
    'applicationFailureFeedbackRoleArnSelector': toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector(obj.applicationFailureFeedbackRoleArnSelector),
    'applicationSuccessFeedbackRoleArn': obj.applicationSuccessFeedbackRoleArn,
    'applicationSuccessFeedbackRoleArnRef': toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef(obj.applicationSuccessFeedbackRoleArnRef),
    'applicationSuccessFeedbackRoleArnSelector': toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector(obj.applicationSuccessFeedbackRoleArnSelector),
    'applicationSuccessFeedbackSampleRate': obj.applicationSuccessFeedbackSampleRate,
    'contentBasedDeduplication': obj.contentBasedDeduplication,
    'deliveryPolicy': obj.deliveryPolicy,
    'displayName': obj.displayName,
    'fifoTopic': obj.fifoTopic,
    'firehoseFailureFeedbackRoleArn': obj.firehoseFailureFeedbackRoleArn,
    'firehoseFailureFeedbackRoleArnRef': toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef(obj.firehoseFailureFeedbackRoleArnRef),
    'firehoseFailureFeedbackRoleArnSelector': toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector(obj.firehoseFailureFeedbackRoleArnSelector),
    'firehoseSuccessFeedbackRoleArn': obj.firehoseSuccessFeedbackRoleArn,
    'firehoseSuccessFeedbackRoleArnRef': toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef(obj.firehoseSuccessFeedbackRoleArnRef),
    'firehoseSuccessFeedbackRoleArnSelector': toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector(obj.firehoseSuccessFeedbackRoleArnSelector),
    'firehoseSuccessFeedbackSampleRate': obj.firehoseSuccessFeedbackSampleRate,
    'httpFailureFeedbackRoleArn': obj.httpFailureFeedbackRoleArn,
    'httpFailureFeedbackRoleArnRef': toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnRef(obj.httpFailureFeedbackRoleArnRef),
    'httpFailureFeedbackRoleArnSelector': toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnSelector(obj.httpFailureFeedbackRoleArnSelector),
    'httpSuccessFeedbackRoleArn': obj.httpSuccessFeedbackRoleArn,
    'httpSuccessFeedbackRoleArnRef': toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnRef(obj.httpSuccessFeedbackRoleArnRef),
    'httpSuccessFeedbackRoleArnSelector': toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector(obj.httpSuccessFeedbackRoleArnSelector),
    'httpSuccessFeedbackSampleRate': obj.httpSuccessFeedbackSampleRate,
    'kmsMasterKeyId': obj.kmsMasterKeyId,
    'lambdaFailureFeedbackRoleArn': obj.lambdaFailureFeedbackRoleArn,
    'lambdaFailureFeedbackRoleArnRef': toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnRef(obj.lambdaFailureFeedbackRoleArnRef),
    'lambdaFailureFeedbackRoleArnSelector': toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector(obj.lambdaFailureFeedbackRoleArnSelector),
    'lambdaSuccessFeedbackRoleArn': obj.lambdaSuccessFeedbackRoleArn,
    'lambdaSuccessFeedbackRoleArnRef': toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef(obj.lambdaSuccessFeedbackRoleArnRef),
    'lambdaSuccessFeedbackRoleArnSelector': toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector(obj.lambdaSuccessFeedbackRoleArnSelector),
    'lambdaSuccessFeedbackSampleRate': obj.lambdaSuccessFeedbackSampleRate,
    'policy': obj.policy,
    'region': obj.region,
    'signatureVersion': obj.signatureVersion,
    'sqsFailureFeedbackRoleArn': obj.sqsFailureFeedbackRoleArn,
    'sqsFailureFeedbackRoleArnRef': toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnRef(obj.sqsFailureFeedbackRoleArnRef),
    'sqsFailureFeedbackRoleArnSelector': toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnSelector(obj.sqsFailureFeedbackRoleArnSelector),
    'sqsSuccessFeedbackRoleArn': obj.sqsSuccessFeedbackRoleArn,
    'sqsSuccessFeedbackRoleArnRef': toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnRef(obj.sqsSuccessFeedbackRoleArnRef),
    'sqsSuccessFeedbackRoleArnSelector': toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector(obj.sqsSuccessFeedbackRoleArnSelector),
    'sqsSuccessFeedbackSampleRate': obj.sqsSuccessFeedbackSampleRate,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tracingConfig': obj.tracingConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TopicSpecInitProvider
 */
export interface TopicSpecInitProvider {
  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecInitProvider#applicationSuccessFeedbackSampleRate
   */
  readonly applicationSuccessFeedbackSampleRate?: number;

  /**
   * Enables content-based deduplication for FIFO topics. For more information, see the related documentation
   *
   * @schema TopicSpecInitProvider#contentBasedDeduplication
   */
  readonly contentBasedDeduplication?: boolean;

  /**
   * The SNS delivery policy. More on AWS documentation
   *
   * @schema TopicSpecInitProvider#deliveryPolicy
   */
  readonly deliveryPolicy?: string;

  /**
   * The display name for the topic
   *
   * @schema TopicSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Boolean indicating whether or not to create a FIFO (first-in-first-out) topic (default is false).
   *
   * @schema TopicSpecInitProvider#fifoTopic
   */
  readonly fifoTopic?: boolean;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecInitProvider#firehoseSuccessFeedbackSampleRate
   */
  readonly firehoseSuccessFeedbackSampleRate?: number;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecInitProvider#httpSuccessFeedbackSampleRate
   */
  readonly httpSuccessFeedbackSampleRate?: number;

  /**
   * The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see Key Terms
   *
   * @schema TopicSpecInitProvider#kmsMasterKeyId
   */
  readonly kmsMasterKeyId?: string;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecInitProvider#lambdaSuccessFeedbackSampleRate
   */
  readonly lambdaSuccessFeedbackSampleRate?: number;

  /**
   * The fully-formed AWS policy as JSON.
   *
   * @schema TopicSpecInitProvider#policy
   */
  readonly policy?: string;

  /**
   * If SignatureVersion should be 1 (SHA1) or 2 (SHA256). The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
   *
   * @schema TopicSpecInitProvider#signatureVersion
   */
  readonly signatureVersion?: number;

  /**
   * Percentage of success to sample
   *
   * @schema TopicSpecInitProvider#sqsSuccessFeedbackSampleRate
   */
  readonly sqsSuccessFeedbackSampleRate?: number;

  /**
   * Key-value map of resource tags.
   *
   * @schema TopicSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Tracing mode of an Amazon SNS topic. Valid values: "PassThrough", "Active".
   *
   * @schema TopicSpecInitProvider#tracingConfig
   */
  readonly tracingConfig?: string;

}

/**
 * Converts an object of type 'TopicSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecInitProvider(obj: TopicSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationSuccessFeedbackSampleRate': obj.applicationSuccessFeedbackSampleRate,
    'contentBasedDeduplication': obj.contentBasedDeduplication,
    'deliveryPolicy': obj.deliveryPolicy,
    'displayName': obj.displayName,
    'fifoTopic': obj.fifoTopic,
    'firehoseSuccessFeedbackSampleRate': obj.firehoseSuccessFeedbackSampleRate,
    'httpSuccessFeedbackSampleRate': obj.httpSuccessFeedbackSampleRate,
    'kmsMasterKeyId': obj.kmsMasterKeyId,
    'lambdaSuccessFeedbackSampleRate': obj.lambdaSuccessFeedbackSampleRate,
    'policy': obj.policy,
    'signatureVersion': obj.signatureVersion,
    'sqsSuccessFeedbackSampleRate': obj.sqsSuccessFeedbackSampleRate,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tracingConfig': obj.tracingConfig,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TopicSpecManagementPolicies
 */
export enum TopicSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TopicSpecProviderConfigRef
 */
export interface TopicSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecProviderConfigRef#policy
   */
  readonly policy?: TopicSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderConfigRef(obj: TopicSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TopicSpecPublishConnectionDetailsTo
 */
export interface TopicSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TopicSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TopicSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TopicSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsTo(obj: TopicSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TopicSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TopicSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TopicSpecWriteConnectionSecretToRef
 */
export interface TopicSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TopicSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TopicSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TopicSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecWriteConnectionSecretToRef(obj: TopicSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate applicationFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRef
 */
export interface TopicSpecForProviderApplicationFailureFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationFailureFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnRef(obj: TopicSpecForProviderApplicationFailureFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate applicationFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector(obj: TopicSpecForProviderApplicationFailureFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate applicationSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef
 */
export interface TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef(obj: TopicSpecForProviderApplicationSuccessFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate applicationSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector(obj: TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate firehoseFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef
 */
export interface TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef(obj: TopicSpecForProviderFirehoseFailureFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate firehoseFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector(obj: TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate firehoseSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef
 */
export interface TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef(obj: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate firehoseSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector(obj: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate httpFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRef
 */
export interface TopicSpecForProviderHttpFailureFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpFailureFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnRef(obj: TopicSpecForProviderHttpFailureFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate httpFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderHttpFailureFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpFailureFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnSelector(obj: TopicSpecForProviderHttpFailureFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate httpSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRef
 */
export interface TopicSpecForProviderHttpSuccessFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpSuccessFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnRef(obj: TopicSpecForProviderHttpSuccessFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate httpSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector(obj: TopicSpecForProviderHttpSuccessFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate lambdaFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRef
 */
export interface TopicSpecForProviderLambdaFailureFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaFailureFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnRef(obj: TopicSpecForProviderLambdaFailureFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate lambdaFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector(obj: TopicSpecForProviderLambdaFailureFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate lambdaSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef
 */
export interface TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef(obj: TopicSpecForProviderLambdaSuccessFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate lambdaSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector(obj: TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate sqsFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRef
 */
export interface TopicSpecForProviderSqsFailureFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsFailureFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnRef(obj: TopicSpecForProviderSqsFailureFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate sqsFailureFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderSqsFailureFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsFailureFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnSelector(obj: TopicSpecForProviderSqsFailureFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate sqsSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRef
 */
export interface TopicSpecForProviderSqsSuccessFeedbackRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRef#policy
   */
  readonly policy?: TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsSuccessFeedbackRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnRef(obj: TopicSpecForProviderSqsSuccessFeedbackRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate sqsSuccessFeedbackRoleArn.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector
 */
export interface TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector#policy
   */
  readonly policy?: TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector(obj: TopicSpecForProviderSqsSuccessFeedbackRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecProviderConfigRefPolicy
 */
export interface TopicSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecProviderConfigRefPolicy(obj: TopicSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRef
 */
export interface TopicSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TopicSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToConfigRef(obj: TopicSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TopicSpecPublishConnectionDetailsToMetadata
 */
export interface TopicSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TopicSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToMetadata(obj: TopicSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy
 */
export interface TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy(obj: TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy
 */
export interface TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy(obj: TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecProviderConfigRefPolicyResolution
 */
export enum TopicSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecProviderConfigRefPolicyResolve
 */
export enum TopicSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TopicSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSpecPublishConnectionDetailsToConfigRefPolicy(obj: TopicSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderApplicationFailureFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderApplicationFailureFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderApplicationSuccessFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderApplicationSuccessFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderFirehoseFailureFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderFirehoseFailureFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderFirehoseSuccessFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderFirehoseSuccessFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderHttpFailureFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderHttpFailureFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderHttpSuccessFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderHttpSuccessFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderLambdaFailureFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderLambdaFailureFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderLambdaSuccessFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderLambdaSuccessFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderSqsFailureFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderSqsFailureFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicyResolution
 */
export enum TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicyResolve
 */
export enum TopicSpecForProviderSqsSuccessFeedbackRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolution
 */
export enum TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolve
 */
export enum TopicSpecForProviderSqsSuccessFeedbackRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TopicSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TopicSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TopicPolicy is the Schema for the TopicPolicys API. Provides an SNS topic policy resource.
 *
 * @schema TopicPolicy
 */
export class TopicPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TopicPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sns.aws.upbound.io/v1beta1',
    kind: 'TopicPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "TopicPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TopicPolicyProps): any {
    return {
      ...TopicPolicy.GVK,
      ...toJson_TopicPolicyProps(props),
    };
  }

  /**
   * Defines a "TopicPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TopicPolicyProps) {
    super(scope, id, {
      ...TopicPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TopicPolicy.GVK,
      ...toJson_TopicPolicyProps(resolved),
    };
  }
}

/**
 * TopicPolicy is the Schema for the TopicPolicys API. Provides an SNS topic policy resource.
 *
 * @schema TopicPolicy
 */
export interface TopicPolicyProps {
  /**
   * @schema TopicPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TopicPolicySpec defines the desired state of TopicPolicy
   *
   * @schema TopicPolicy#spec
   */
  readonly spec: TopicPolicySpec;

}

/**
 * Converts an object of type 'TopicPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicyProps(obj: TopicPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TopicPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicPolicySpec defines the desired state of TopicPolicy
 *
 * @schema TopicPolicySpec
 */
export interface TopicPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TopicPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: TopicPolicySpecDeletionPolicy;

  /**
   * @schema TopicPolicySpec#forProvider
   */
  readonly forProvider: TopicPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TopicPolicySpec#initProvider
   */
  readonly initProvider?: TopicPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TopicPolicySpec#managementPolicies
   */
  readonly managementPolicies?: TopicPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TopicPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: TopicPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TopicPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TopicPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TopicPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TopicPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TopicPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpec(obj: TopicPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TopicPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_TopicPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TopicPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TopicPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TopicPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TopicPolicySpecDeletionPolicy
 */
export enum TopicPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TopicPolicySpecForProvider
 */
export interface TopicPolicySpecForProvider {
  /**
   * The ARN of the SNS topic
   *
   * @schema TopicPolicySpecForProvider#arn
   */
  readonly arn?: string;

  /**
   * Reference to a Topic in sns to populate arn.
   *
   * @schema TopicPolicySpecForProvider#arnRef
   */
  readonly arnRef?: TopicPolicySpecForProviderArnRef;

  /**
   * Selector for a Topic in sns to populate arn.
   *
   * @schema TopicPolicySpecForProvider#arnSelector
   */
  readonly arnSelector?: TopicPolicySpecForProviderArnSelector;

  /**
   * The fully-formed AWS policy as JSON.
   *
   * @schema TopicPolicySpecForProvider#policy
   */
  readonly policy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TopicPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'TopicPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecForProvider(obj: TopicPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'arn': obj.arn,
    'arnRef': toJson_TopicPolicySpecForProviderArnRef(obj.arnRef),
    'arnSelector': toJson_TopicPolicySpecForProviderArnSelector(obj.arnSelector),
    'policy': obj.policy,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TopicPolicySpecInitProvider
 */
export interface TopicPolicySpecInitProvider {
  /**
   * The fully-formed AWS policy as JSON.
   *
   * @schema TopicPolicySpecInitProvider#policy
   */
  readonly policy?: string;

}

/**
 * Converts an object of type 'TopicPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecInitProvider(obj: TopicPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'policy': obj.policy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TopicPolicySpecManagementPolicies
 */
export enum TopicPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TopicPolicySpecProviderConfigRef
 */
export interface TopicPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicPolicySpecProviderConfigRef#policy
   */
  readonly policy?: TopicPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecProviderConfigRef(obj: TopicPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TopicPolicySpecPublishConnectionDetailsTo
 */
export interface TopicPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TopicPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TopicPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TopicPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecPublishConnectionDetailsTo(obj: TopicPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TopicPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TopicPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TopicPolicySpecWriteConnectionSecretToRef
 */
export interface TopicPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TopicPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TopicPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TopicPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecWriteConnectionSecretToRef(obj: TopicPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic in sns to populate arn.
 *
 * @schema TopicPolicySpecForProviderArnRef
 */
export interface TopicPolicySpecForProviderArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicPolicySpecForProviderArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicPolicySpecForProviderArnRef#policy
   */
  readonly policy?: TopicPolicySpecForProviderArnRefPolicy;

}

/**
 * Converts an object of type 'TopicPolicySpecForProviderArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecForProviderArnRef(obj: TopicPolicySpecForProviderArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicPolicySpecForProviderArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic in sns to populate arn.
 *
 * @schema TopicPolicySpecForProviderArnSelector
 */
export interface TopicPolicySpecForProviderArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicPolicySpecForProviderArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicPolicySpecForProviderArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicPolicySpecForProviderArnSelector#policy
   */
  readonly policy?: TopicPolicySpecForProviderArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicPolicySpecForProviderArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecForProviderArnSelector(obj: TopicPolicySpecForProviderArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicPolicySpecForProviderArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicPolicySpecProviderConfigRefPolicy
 */
export interface TopicPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TopicPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TopicPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecProviderConfigRefPolicy(obj: TopicPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TopicPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface TopicPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecPublishConnectionDetailsToConfigRef(obj: TopicPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TopicPolicySpecPublishConnectionDetailsToMetadata
 */
export interface TopicPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecPublishConnectionDetailsToMetadata(obj: TopicPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicPolicySpecForProviderArnRefPolicy
 */
export interface TopicPolicySpecForProviderArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicPolicySpecForProviderArnRefPolicy#resolution
   */
  readonly resolution?: TopicPolicySpecForProviderArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicPolicySpecForProviderArnRefPolicy#resolve
   */
  readonly resolve?: TopicPolicySpecForProviderArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicPolicySpecForProviderArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecForProviderArnRefPolicy(obj: TopicPolicySpecForProviderArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicPolicySpecForProviderArnSelectorPolicy
 */
export interface TopicPolicySpecForProviderArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicPolicySpecForProviderArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicPolicySpecForProviderArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicPolicySpecForProviderArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicPolicySpecForProviderArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicPolicySpecForProviderArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecForProviderArnSelectorPolicy(obj: TopicPolicySpecForProviderArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicPolicySpecProviderConfigRefPolicyResolution
 */
export enum TopicPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicPolicySpecProviderConfigRefPolicyResolve
 */
export enum TopicPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TopicPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TopicPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: TopicPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicPolicySpecForProviderArnRefPolicyResolution
 */
export enum TopicPolicySpecForProviderArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicPolicySpecForProviderArnRefPolicyResolve
 */
export enum TopicPolicySpecForProviderArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicPolicySpecForProviderArnSelectorPolicyResolution
 */
export enum TopicPolicySpecForProviderArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicPolicySpecForProviderArnSelectorPolicyResolve
 */
export enum TopicPolicySpecForProviderArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TopicPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TopicPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TopicSubscription is the Schema for the TopicSubscriptions API. Provides a resource for subscribing to SNS topics.
 *
 * @schema TopicSubscription
 */
export class TopicSubscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TopicSubscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'sns.aws.upbound.io/v1beta1',
    kind: 'TopicSubscription',
  }

  /**
   * Renders a Kubernetes manifest for "TopicSubscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TopicSubscriptionProps): any {
    return {
      ...TopicSubscription.GVK,
      ...toJson_TopicSubscriptionProps(props),
    };
  }

  /**
   * Defines a "TopicSubscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TopicSubscriptionProps) {
    super(scope, id, {
      ...TopicSubscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TopicSubscription.GVK,
      ...toJson_TopicSubscriptionProps(resolved),
    };
  }
}

/**
 * TopicSubscription is the Schema for the TopicSubscriptions API. Provides a resource for subscribing to SNS topics.
 *
 * @schema TopicSubscription
 */
export interface TopicSubscriptionProps {
  /**
   * @schema TopicSubscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TopicSubscriptionSpec defines the desired state of TopicSubscription
   *
   * @schema TopicSubscription#spec
   */
  readonly spec: TopicSubscriptionSpec;

}

/**
 * Converts an object of type 'TopicSubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionProps(obj: TopicSubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TopicSubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TopicSubscriptionSpec defines the desired state of TopicSubscription
 *
 * @schema TopicSubscriptionSpec
 */
export interface TopicSubscriptionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TopicSubscriptionSpec#deletionPolicy
   */
  readonly deletionPolicy?: TopicSubscriptionSpecDeletionPolicy;

  /**
   * @schema TopicSubscriptionSpec#forProvider
   */
  readonly forProvider: TopicSubscriptionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TopicSubscriptionSpec#initProvider
   */
  readonly initProvider?: TopicSubscriptionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TopicSubscriptionSpec#managementPolicies
   */
  readonly managementPolicies?: TopicSubscriptionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TopicSubscriptionSpec#providerConfigRef
   */
  readonly providerConfigRef?: TopicSubscriptionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TopicSubscriptionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TopicSubscriptionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TopicSubscriptionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TopicSubscriptionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TopicSubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpec(obj: TopicSubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TopicSubscriptionSpecForProvider(obj.forProvider),
    'initProvider': toJson_TopicSubscriptionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TopicSubscriptionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TopicSubscriptionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TopicSubscriptionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TopicSubscriptionSpecDeletionPolicy
 */
export enum TopicSubscriptionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TopicSubscriptionSpecForProvider
 */
export interface TopicSubscriptionSpecForProvider {
  /**
   * Integer indicating number of minutes to wait in retrying mode for fetching subscription arn before marking it as failure. Only applicable for http and https protocols. Default is 1.
   *
   * @default 1.
   * @schema TopicSubscriptionSpecForProvider#confirmationTimeoutInMinutes
   */
  readonly confirmationTimeoutInMinutes?: number;

  /**
   * JSON String with the delivery policy (retries, backoff, etc.) that will be used in the subscription - this only applies to HTTP/S subscriptions. Refer to the SNS docs for more details.
   *
   * @schema TopicSubscriptionSpecForProvider#deliveryPolicy
   */
  readonly deliveryPolicy?: string;

  /**
   * Endpoint to send data to. The contents vary with the protocol. See details below.
   *
   * @schema TopicSubscriptionSpecForProvider#endpoint
   */
  readonly endpoint?: string;

  /**
   * Whether the endpoint is capable of auto confirming subscription (e.g., PagerDuty). Default is false.
   *
   * @default false.
   * @schema TopicSubscriptionSpecForProvider#endpointAutoConfirms
   */
  readonly endpointAutoConfirms?: boolean;

  /**
   * Reference to a Queue in sqs to populate endpoint.
   *
   * @schema TopicSubscriptionSpecForProvider#endpointRef
   */
  readonly endpointRef?: TopicSubscriptionSpecForProviderEndpointRef;

  /**
   * Selector for a Queue in sqs to populate endpoint.
   *
   * @schema TopicSubscriptionSpecForProvider#endpointSelector
   */
  readonly endpointSelector?: TopicSubscriptionSpecForProviderEndpointSelector;

  /**
   * JSON String with the filter policy that will be used in the subscription to filter messages seen by the target resource. Refer to the SNS docs for more details.
   *
   * @schema TopicSubscriptionSpecForProvider#filterPolicy
   */
  readonly filterPolicy?: string;

  /**
   * Whether the filter_policy applies to MessageAttributes (default) or MessageBody.
   *
   * @schema TopicSubscriptionSpecForProvider#filterPolicyScope
   */
  readonly filterPolicyScope?: string;

  /**
   * Protocol to use. Valid values are: sqs, sms, lambda, firehose, and application. Protocols email, email-json, http and https are also valid but partially supported. See details below.
   *
   * @schema TopicSubscriptionSpecForProvider#protocol
   */
  readonly protocol?: string;

  /**
   * Whether to enable raw message delivery (the original message is directly passed, not wrapped in JSON with the original message in the message property). Default is false.
   *
   * @default false.
   * @schema TopicSubscriptionSpecForProvider#rawMessageDelivery
   */
  readonly rawMessageDelivery?: boolean;

  /**
   * JSON String with the redrive policy that will be used in the subscription. Refer to the SNS docs for more details.
   *
   * @schema TopicSubscriptionSpecForProvider#redrivePolicy
   */
  readonly redrivePolicy?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TopicSubscriptionSpecForProvider#region
   */
  readonly region: string;

  /**
   * ARN of the IAM role to publish to Kinesis Data Firehose delivery stream. Refer to SNS docs.
   *
   * @schema TopicSubscriptionSpecForProvider#subscriptionRoleArn
   */
  readonly subscriptionRoleArn?: string;

  /**
   * Reference to a Role in iam to populate subscriptionRoleArn.
   *
   * @schema TopicSubscriptionSpecForProvider#subscriptionRoleArnRef
   */
  readonly subscriptionRoleArnRef?: TopicSubscriptionSpecForProviderSubscriptionRoleArnRef;

  /**
   * Selector for a Role in iam to populate subscriptionRoleArn.
   *
   * @schema TopicSubscriptionSpecForProvider#subscriptionRoleArnSelector
   */
  readonly subscriptionRoleArnSelector?: TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector;

  /**
   * ARN of the SNS topic to subscribe to.
   *
   * @schema TopicSubscriptionSpecForProvider#topicArn
   */
  readonly topicArn?: string;

  /**
   * Reference to a Topic to populate topicArn.
   *
   * @schema TopicSubscriptionSpecForProvider#topicArnRef
   */
  readonly topicArnRef?: TopicSubscriptionSpecForProviderTopicArnRef;

  /**
   * Selector for a Topic to populate topicArn.
   *
   * @schema TopicSubscriptionSpecForProvider#topicArnSelector
   */
  readonly topicArnSelector?: TopicSubscriptionSpecForProviderTopicArnSelector;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProvider(obj: TopicSubscriptionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirmationTimeoutInMinutes': obj.confirmationTimeoutInMinutes,
    'deliveryPolicy': obj.deliveryPolicy,
    'endpoint': obj.endpoint,
    'endpointAutoConfirms': obj.endpointAutoConfirms,
    'endpointRef': toJson_TopicSubscriptionSpecForProviderEndpointRef(obj.endpointRef),
    'endpointSelector': toJson_TopicSubscriptionSpecForProviderEndpointSelector(obj.endpointSelector),
    'filterPolicy': obj.filterPolicy,
    'filterPolicyScope': obj.filterPolicyScope,
    'protocol': obj.protocol,
    'rawMessageDelivery': obj.rawMessageDelivery,
    'redrivePolicy': obj.redrivePolicy,
    'region': obj.region,
    'subscriptionRoleArn': obj.subscriptionRoleArn,
    'subscriptionRoleArnRef': toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnRef(obj.subscriptionRoleArnRef),
    'subscriptionRoleArnSelector': toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector(obj.subscriptionRoleArnSelector),
    'topicArn': obj.topicArn,
    'topicArnRef': toJson_TopicSubscriptionSpecForProviderTopicArnRef(obj.topicArnRef),
    'topicArnSelector': toJson_TopicSubscriptionSpecForProviderTopicArnSelector(obj.topicArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TopicSubscriptionSpecInitProvider
 */
export interface TopicSubscriptionSpecInitProvider {
  /**
   * Integer indicating number of minutes to wait in retrying mode for fetching subscription arn before marking it as failure. Only applicable for http and https protocols. Default is 1.
   *
   * @default 1.
   * @schema TopicSubscriptionSpecInitProvider#confirmationTimeoutInMinutes
   */
  readonly confirmationTimeoutInMinutes?: number;

  /**
   * JSON String with the delivery policy (retries, backoff, etc.) that will be used in the subscription - this only applies to HTTP/S subscriptions. Refer to the SNS docs for more details.
   *
   * @schema TopicSubscriptionSpecInitProvider#deliveryPolicy
   */
  readonly deliveryPolicy?: string;

  /**
   * Whether the endpoint is capable of auto confirming subscription (e.g., PagerDuty). Default is false.
   *
   * @default false.
   * @schema TopicSubscriptionSpecInitProvider#endpointAutoConfirms
   */
  readonly endpointAutoConfirms?: boolean;

  /**
   * JSON String with the filter policy that will be used in the subscription to filter messages seen by the target resource. Refer to the SNS docs for more details.
   *
   * @schema TopicSubscriptionSpecInitProvider#filterPolicy
   */
  readonly filterPolicy?: string;

  /**
   * Whether the filter_policy applies to MessageAttributes (default) or MessageBody.
   *
   * @schema TopicSubscriptionSpecInitProvider#filterPolicyScope
   */
  readonly filterPolicyScope?: string;

  /**
   * Protocol to use. Valid values are: sqs, sms, lambda, firehose, and application. Protocols email, email-json, http and https are also valid but partially supported. See details below.
   *
   * @schema TopicSubscriptionSpecInitProvider#protocol
   */
  readonly protocol?: string;

  /**
   * Whether to enable raw message delivery (the original message is directly passed, not wrapped in JSON with the original message in the message property). Default is false.
   *
   * @default false.
   * @schema TopicSubscriptionSpecInitProvider#rawMessageDelivery
   */
  readonly rawMessageDelivery?: boolean;

  /**
   * JSON String with the redrive policy that will be used in the subscription. Refer to the SNS docs for more details.
   *
   * @schema TopicSubscriptionSpecInitProvider#redrivePolicy
   */
  readonly redrivePolicy?: string;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecInitProvider(obj: TopicSubscriptionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'confirmationTimeoutInMinutes': obj.confirmationTimeoutInMinutes,
    'deliveryPolicy': obj.deliveryPolicy,
    'endpointAutoConfirms': obj.endpointAutoConfirms,
    'filterPolicy': obj.filterPolicy,
    'filterPolicyScope': obj.filterPolicyScope,
    'protocol': obj.protocol,
    'rawMessageDelivery': obj.rawMessageDelivery,
    'redrivePolicy': obj.redrivePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TopicSubscriptionSpecManagementPolicies
 */
export enum TopicSubscriptionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TopicSubscriptionSpecProviderConfigRef
 */
export interface TopicSubscriptionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSubscriptionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSubscriptionSpecProviderConfigRef#policy
   */
  readonly policy?: TopicSubscriptionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecProviderConfigRef(obj: TopicSubscriptionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSubscriptionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TopicSubscriptionSpecPublishConnectionDetailsTo
 */
export interface TopicSubscriptionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TopicSubscriptionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TopicSubscriptionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecPublishConnectionDetailsTo(obj: TopicSubscriptionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TopicSubscriptionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TopicSubscriptionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TopicSubscriptionSpecWriteConnectionSecretToRef
 */
export interface TopicSubscriptionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TopicSubscriptionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TopicSubscriptionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecWriteConnectionSecretToRef(obj: TopicSubscriptionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Queue in sqs to populate endpoint.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointRef
 */
export interface TopicSubscriptionSpecForProviderEndpointRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointRef#policy
   */
  readonly policy?: TopicSubscriptionSpecForProviderEndpointRefPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderEndpointRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderEndpointRef(obj: TopicSubscriptionSpecForProviderEndpointRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSubscriptionSpecForProviderEndpointRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Queue in sqs to populate endpoint.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointSelector
 */
export interface TopicSubscriptionSpecForProviderEndpointSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointSelector#policy
   */
  readonly policy?: TopicSubscriptionSpecForProviderEndpointSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderEndpointSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderEndpointSelector(obj: TopicSubscriptionSpecForProviderEndpointSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSubscriptionSpecForProviderEndpointSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate subscriptionRoleArn.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRef
 */
export interface TopicSubscriptionSpecForProviderSubscriptionRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRef#policy
   */
  readonly policy?: TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderSubscriptionRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnRef(obj: TopicSubscriptionSpecForProviderSubscriptionRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate subscriptionRoleArn.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector
 */
export interface TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector#policy
   */
  readonly policy?: TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector(obj: TopicSubscriptionSpecForProviderSubscriptionRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Topic to populate topicArn.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnRef
 */
export interface TopicSubscriptionSpecForProviderTopicArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnRef#policy
   */
  readonly policy?: TopicSubscriptionSpecForProviderTopicArnRefPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderTopicArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderTopicArnRef(obj: TopicSubscriptionSpecForProviderTopicArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSubscriptionSpecForProviderTopicArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Topic to populate topicArn.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnSelector
 */
export interface TopicSubscriptionSpecForProviderTopicArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnSelector#policy
   */
  readonly policy?: TopicSubscriptionSpecForProviderTopicArnSelectorPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderTopicArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderTopicArnSelector(obj: TopicSubscriptionSpecForProviderTopicArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TopicSubscriptionSpecForProviderTopicArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSubscriptionSpecProviderConfigRefPolicy
 */
export interface TopicSubscriptionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecProviderConfigRefPolicy(obj: TopicSubscriptionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRef
 */
export interface TopicSubscriptionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecPublishConnectionDetailsToConfigRef(obj: TopicSubscriptionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TopicSubscriptionSpecPublishConnectionDetailsToMetadata
 */
export interface TopicSubscriptionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecPublishConnectionDetailsToMetadata(obj: TopicSubscriptionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointRefPolicy
 */
export interface TopicSubscriptionSpecForProviderEndpointRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointRefPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecForProviderEndpointRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointRefPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecForProviderEndpointRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderEndpointRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderEndpointRefPolicy(obj: TopicSubscriptionSpecForProviderEndpointRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointSelectorPolicy
 */
export interface TopicSubscriptionSpecForProviderEndpointSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointSelectorPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecForProviderEndpointSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecForProviderEndpointSelectorPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecForProviderEndpointSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderEndpointSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderEndpointSelectorPolicy(obj: TopicSubscriptionSpecForProviderEndpointSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy
 */
export interface TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy(obj: TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy
 */
export interface TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy(obj: TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnRefPolicy
 */
export interface TopicSubscriptionSpecForProviderTopicArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnRefPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecForProviderTopicArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnRefPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecForProviderTopicArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderTopicArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderTopicArnRefPolicy(obj: TopicSubscriptionSpecForProviderTopicArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnSelectorPolicy
 */
export interface TopicSubscriptionSpecForProviderTopicArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnSelectorPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecForProviderTopicArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecForProviderTopicArnSelectorPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecForProviderTopicArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecForProviderTopicArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecForProviderTopicArnSelectorPolicy(obj: TopicSubscriptionSpecForProviderTopicArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecProviderConfigRefPolicyResolution
 */
export enum TopicSubscriptionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecProviderConfigRefPolicyResolve
 */
export enum TopicSubscriptionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy(obj: TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointRefPolicyResolution
 */
export enum TopicSubscriptionSpecForProviderEndpointRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointRefPolicyResolve
 */
export enum TopicSubscriptionSpecForProviderEndpointRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointSelectorPolicyResolution
 */
export enum TopicSubscriptionSpecForProviderEndpointSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecForProviderEndpointSelectorPolicyResolve
 */
export enum TopicSubscriptionSpecForProviderEndpointSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicyResolution
 */
export enum TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicyResolve
 */
export enum TopicSubscriptionSpecForProviderSubscriptionRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicyResolution
 */
export enum TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicyResolve
 */
export enum TopicSubscriptionSpecForProviderSubscriptionRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnRefPolicyResolution
 */
export enum TopicSubscriptionSpecForProviderTopicArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnRefPolicyResolve
 */
export enum TopicSubscriptionSpecForProviderTopicArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnSelectorPolicyResolution
 */
export enum TopicSubscriptionSpecForProviderTopicArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecForProviderTopicArnSelectorPolicyResolve
 */
export enum TopicSubscriptionSpecForProviderTopicArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TopicSubscriptionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

