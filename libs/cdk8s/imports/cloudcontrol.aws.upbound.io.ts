// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Resource is the Schema for the Resources API. Manages a Cloud Control API Resource.
 *
 * @schema Resource
 */
export class Resource extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Resource"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudcontrol.aws.upbound.io/v1beta1',
    kind: 'Resource',
  }

  /**
   * Renders a Kubernetes manifest for "Resource".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ResourceProps): any {
    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(props),
    };
  }

  /**
   * Defines a "Resource" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ResourceProps) {
    super(scope, id, {
      ...Resource.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Resource.GVK,
      ...toJson_ResourceProps(resolved),
    };
  }
}

/**
 * Resource is the Schema for the Resources API. Manages a Cloud Control API Resource.
 *
 * @schema Resource
 */
export interface ResourceProps {
  /**
   * @schema Resource#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResourceSpec defines the desired state of Resource
   *
   * @schema Resource#spec
   */
  readonly spec: ResourceSpec;

}

/**
 * Converts an object of type 'ResourceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceProps(obj: ResourceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResourceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceSpec defines the desired state of Resource
 *
 * @schema ResourceSpec
 */
export interface ResourceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
   *
   * @schema ResourceSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResourceSpecDeletionPolicy;

  /**
   * @schema ResourceSpec#forProvider
   */
  readonly forProvider: ResourceSpecForProvider;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ResourceSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResourceSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema ResourceSpec#providerRef
   */
  readonly providerRef?: ResourceSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ResourceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResourceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ResourceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResourceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResourceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpec(obj: ResourceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResourceSpecForProvider(obj.forProvider),
    'providerConfigRef': toJson_ResourceSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_ResourceSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_ResourceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResourceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource.
 *
 * @schema ResourceSpecDeletionPolicy
 */
export enum ResourceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResourceSpecForProvider
 */
export interface ResourceSpecForProvider {
  /**
   * JSON string matching the CloudFormation resource type schema with desired configuration.
   *
   * @schema ResourceSpecForProvider#desiredState
   */
  readonly desiredState: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResourceSpecForProvider#region
   */
  readonly region: string;

  /**
   * Amazon Resource Name (ARN) of the IAM Role to assume for operations.
   *
   * @schema ResourceSpecForProvider#roleArn
   */
  readonly roleArn?: string;

  /**
   * Reference to a Role in iam to populate roleArn.
   *
   * @schema ResourceSpecForProvider#roleArnRef
   */
  readonly roleArnRef?: ResourceSpecForProviderRoleArnRef;

  /**
   * Selector for a Role in iam to populate roleArn.
   *
   * @schema ResourceSpecForProvider#roleArnSelector
   */
  readonly roleArnSelector?: ResourceSpecForProviderRoleArnSelector;

  /**
   * JSON string of the CloudFormation resource type schema which is used for plan time validation where possible. Automatically fetched if not provided. In large scale environments with multiple resources using the same type_name, it is recommended to fetch the schema once via the aws_cloudformation_type data source and use this argument to reduce DescribeType API operation throttling. This value is marked sensitive only to prevent large plan differences from showing.
   *
   * @schema ResourceSpecForProvider#schemaSecretRef
   */
  readonly schemaSecretRef?: ResourceSpecForProviderSchemaSecretRef;

  /**
   * CloudFormation resource type name. For example, AWS::EC2::VPC.
   *
   * @schema ResourceSpecForProvider#typeName
   */
  readonly typeName: string;

  /**
   * Identifier of the CloudFormation resource type version.
   *
   * @schema ResourceSpecForProvider#typeVersionId
   */
  readonly typeVersionId?: string;

}

/**
 * Converts an object of type 'ResourceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProvider(obj: ResourceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'desiredState': obj.desiredState,
    'region': obj.region,
    'roleArn': obj.roleArn,
    'roleArnRef': toJson_ResourceSpecForProviderRoleArnRef(obj.roleArnRef),
    'roleArnSelector': toJson_ResourceSpecForProviderRoleArnSelector(obj.roleArnSelector),
    'schemaSecretRef': toJson_ResourceSpecForProviderSchemaSecretRef(obj.schemaSecretRef),
    'typeName': obj.typeName,
    'typeVersionId': obj.typeVersionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ResourceSpecProviderConfigRef
 */
export interface ResourceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecProviderConfigRef#policy
   */
  readonly policy?: ResourceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRef(obj: ResourceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema ResourceSpecProviderRef
 */
export interface ResourceSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecProviderRef#policy
   */
  readonly policy?: ResourceSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderRef(obj: ResourceSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ResourceSpecPublishConnectionDetailsTo
 */
export interface ResourceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResourceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResourceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResourceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsTo(obj: ResourceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ResourceSpecWriteConnectionSecretToRef
 */
export interface ResourceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecWriteConnectionSecretToRef(obj: ResourceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate roleArn.
 *
 * @schema ResourceSpecForProviderRoleArnRef
 */
export interface ResourceSpecForProviderRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecForProviderRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecForProviderRoleArnRef#policy
   */
  readonly policy?: ResourceSpecForProviderRoleArnRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnRef(obj: ResourceSpecForProviderRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecForProviderRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate roleArn.
 *
 * @schema ResourceSpecForProviderRoleArnSelector
 */
export interface ResourceSpecForProviderRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ResourceSpecForProviderRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResourceSpecForProviderRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResourceSpecForProviderRoleArnSelector#policy
   */
  readonly policy?: ResourceSpecForProviderRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnSelector(obj: ResourceSpecForProviderRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResourceSpecForProviderRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JSON string of the CloudFormation resource type schema which is used for plan time validation where possible. Automatically fetched if not provided. In large scale environments with multiple resources using the same type_name, it is recommended to fetch the schema once via the aws_cloudformation_type data source and use this argument to reduce DescribeType API operation throttling. This value is marked sensitive only to prevent large plan differences from showing.
 *
 * @schema ResourceSpecForProviderSchemaSecretRef
 */
export interface ResourceSpecForProviderSchemaSecretRef {
  /**
   * The key to select.
   *
   * @schema ResourceSpecForProviderSchemaSecretRef#key
   */
  readonly key: string;

  /**
   * Name of the secret.
   *
   * @schema ResourceSpecForProviderSchemaSecretRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResourceSpecForProviderSchemaSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResourceSpecForProviderSchemaSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderSchemaSecretRef(obj: ResourceSpecForProviderSchemaSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecProviderConfigRefPolicy
 */
export interface ResourceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderConfigRefPolicy(obj: ResourceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecProviderRefPolicy
 */
export interface ResourceSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecProviderRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecProviderRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecProviderRefPolicy(obj: ResourceSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRef
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResourceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRef(obj: ResourceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResourceSpecPublishConnectionDetailsToMetadata
 */
export interface ResourceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResourceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToMetadata(obj: ResourceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecForProviderRoleArnRefPolicy
 */
export interface ResourceSpecForProviderRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRoleArnRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRoleArnRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnRefPolicy(obj: ResourceSpecForProviderRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResourceSpecForProviderRoleArnSelectorPolicy
 */
export interface ResourceSpecForProviderRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecForProviderRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: ResourceSpecForProviderRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecForProviderRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: ResourceSpecForProviderRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecForProviderRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecForProviderRoleArnSelectorPolicy(obj: ResourceSpecForProviderRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolution
 */
export enum ResourceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecProviderConfigRefPolicyResolve
 */
export enum ResourceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecProviderRefPolicyResolution
 */
export enum ResourceSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecProviderRefPolicyResolve
 */
export enum ResourceSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResourceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResourceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResourceSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResourceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRoleArnRefPolicyResolution
 */
export enum ResourceSpecForProviderRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRoleArnRefPolicyResolve
 */
export enum ResourceSpecForProviderRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecForProviderRoleArnSelectorPolicyResolution
 */
export enum ResourceSpecForProviderRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecForProviderRoleArnSelectorPolicyResolve
 */
export enum ResourceSpecForProviderRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResourceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

