// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Entry is the Schema for the Entrys API. Entry Metadata.
 *
 * @schema Entry
 */
export class Entry extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Entry"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datacatalog.gcp.upbound.io/v1beta1',
    kind: 'Entry',
  }

  /**
   * Renders a Kubernetes manifest for "Entry".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EntryProps): any {
    return {
      ...Entry.GVK,
      ...toJson_EntryProps(props),
    };
  }

  /**
   * Defines a "Entry" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EntryProps) {
    super(scope, id, {
      ...Entry.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Entry.GVK,
      ...toJson_EntryProps(resolved),
    };
  }
}

/**
 * Entry is the Schema for the Entrys API. Entry Metadata.
 *
 * @schema Entry
 */
export interface EntryProps {
  /**
   * @schema Entry#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EntrySpec defines the desired state of Entry
   *
   * @schema Entry#spec
   */
  readonly spec: EntrySpec;

}

/**
 * Converts an object of type 'EntryProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryProps(obj: EntryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EntrySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EntrySpec defines the desired state of Entry
 *
 * @schema EntrySpec
 */
export interface EntrySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EntrySpec#deletionPolicy
   */
  readonly deletionPolicy?: EntrySpecDeletionPolicy;

  /**
   * @schema EntrySpec#forProvider
   */
  readonly forProvider: EntrySpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EntrySpec#managementPolicy
   */
  readonly managementPolicy?: EntrySpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EntrySpec#providerConfigRef
   */
  readonly providerConfigRef?: EntrySpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EntrySpec#providerRef
   */
  readonly providerRef?: EntrySpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EntrySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EntrySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EntrySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EntrySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EntrySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpec(obj: EntrySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EntrySpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EntrySpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EntrySpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EntrySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EntrySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EntrySpecDeletionPolicy
 */
export enum EntrySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EntrySpecForProvider
 */
export interface EntrySpecForProvider {
  /**
   * Entry description, which can consist of several sentences or paragraphs that describe entry contents.
   *
   * @schema EntrySpecForProvider#description
   */
  readonly description?: string;

  /**
   * Display information such as title and description. A short name to identify the entry, for example, "Analytics Data - Jan 2011".
   *
   * @schema EntrySpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The name of the entry group this entry is in.
   *
   * @schema EntrySpecForProvider#entryGroup
   */
  readonly entryGroup?: string;

  /**
   * Reference to a EntryGroup in datacatalog to populate entryGroup.
   *
   * @schema EntrySpecForProvider#entryGroupRef
   */
  readonly entryGroupRef?: EntrySpecForProviderEntryGroupRef;

  /**
   * Selector for a EntryGroup in datacatalog to populate entryGroup.
   *
   * @schema EntrySpecForProvider#entryGroupSelector
   */
  readonly entryGroupSelector?: EntrySpecForProviderEntryGroupSelector;

  /**
   * The id of the entry to create.
   *
   * @schema EntrySpecForProvider#entryId
   */
  readonly entryId?: string;

  /**
   * Specification that applies to a Cloud Storage fileset. This is only valid on entries of type FILESET. Structure is documented below.
   *
   * @schema EntrySpecForProvider#gcsFilesetSpec
   */
  readonly gcsFilesetSpec?: EntrySpecForProviderGcsFilesetSpec[];

  /**
   * The resource this metadata entry refers to. For Google Cloud Platform resources, linkedResource is the full name of the resource. For example, the linkedResource for a table resource from BigQuery is: //bigquery.googleapis.com/projects/projectId/datasets/datasetId/tables/tableId Output only when Entry is of type in the EntryType enum. For entries with userSpecifiedType, this field is optional and defaults to an empty string.
   *
   * @schema EntrySpecForProvider#linkedResource
   */
  readonly linkedResource?: string;

  /**
   * Schema of the entry (e.g. BigQuery, GoogleSQL, Avro schema), as a json string. An entry might not have any schema attached to it. See https://cloud.google.com/data-catalog/docs/reference/rest/v1/projects.locations.entryGroups.entries#schema for what fields this schema can contain.
   *
   * @schema EntrySpecForProvider#schema
   */
  readonly schema?: string;

  /**
   * The type of the entry. Only used for Entries with types in the EntryType enum. Currently, only FILESET enum value is allowed. All other entries created through Data Catalog must use userSpecifiedType. Possible values are: FILESET.
   *
   * @schema EntrySpecForProvider#type
   */
  readonly type?: string;

  /**
   * This field indicates the entry's source system that Data Catalog does not integrate with. userSpecifiedSystem strings must begin with a letter or underscore and can only contain letters, numbers, and underscores; are case insensitive; must be at least 1 character and at most 64 characters long.
   *
   * @schema EntrySpecForProvider#userSpecifiedSystem
   */
  readonly userSpecifiedSystem?: string;

  /**
   * Entry type if it does not fit any of the input-allowed values listed in EntryType enum above. When creating an entry, users should check the enum values first, if nothing matches the entry to be created, then provide a custom value, for example "my_special_type". userSpecifiedType strings must begin with a letter or underscore and can only contain letters, numbers, and underscores; are case insensitive; must be at least 1 character and at most 64 characters long.
   *
   * @schema EntrySpecForProvider#userSpecifiedType
   */
  readonly userSpecifiedType?: string;

}

/**
 * Converts an object of type 'EntrySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecForProvider(obj: EntrySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'entryGroup': obj.entryGroup,
    'entryGroupRef': toJson_EntrySpecForProviderEntryGroupRef(obj.entryGroupRef),
    'entryGroupSelector': toJson_EntrySpecForProviderEntryGroupSelector(obj.entryGroupSelector),
    'entryId': obj.entryId,
    'gcsFilesetSpec': obj.gcsFilesetSpec?.map(y => toJson_EntrySpecForProviderGcsFilesetSpec(y)),
    'linkedResource': obj.linkedResource,
    'schema': obj.schema,
    'type': obj.type,
    'userSpecifiedSystem': obj.userSpecifiedSystem,
    'userSpecifiedType': obj.userSpecifiedType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EntrySpecManagementPolicy
 */
export enum EntrySpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EntrySpecProviderConfigRef
 */
export interface EntrySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntrySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntrySpecProviderConfigRef#policy
   */
  readonly policy?: EntrySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EntrySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecProviderConfigRef(obj: EntrySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntrySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EntrySpecProviderRef
 */
export interface EntrySpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntrySpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntrySpecProviderRef#policy
   */
  readonly policy?: EntrySpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EntrySpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecProviderRef(obj: EntrySpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntrySpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EntrySpecPublishConnectionDetailsTo
 */
export interface EntrySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EntrySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EntrySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EntrySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EntrySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EntrySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EntrySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecPublishConnectionDetailsTo(obj: EntrySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EntrySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EntrySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EntrySpecWriteConnectionSecretToRef
 */
export interface EntrySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EntrySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EntrySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EntrySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecWriteConnectionSecretToRef(obj: EntrySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a EntryGroup in datacatalog to populate entryGroup.
 *
 * @schema EntrySpecForProviderEntryGroupRef
 */
export interface EntrySpecForProviderEntryGroupRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntrySpecForProviderEntryGroupRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntrySpecForProviderEntryGroupRef#policy
   */
  readonly policy?: EntrySpecForProviderEntryGroupRefPolicy;

}

/**
 * Converts an object of type 'EntrySpecForProviderEntryGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecForProviderEntryGroupRef(obj: EntrySpecForProviderEntryGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntrySpecForProviderEntryGroupRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a EntryGroup in datacatalog to populate entryGroup.
 *
 * @schema EntrySpecForProviderEntryGroupSelector
 */
export interface EntrySpecForProviderEntryGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema EntrySpecForProviderEntryGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema EntrySpecForProviderEntryGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema EntrySpecForProviderEntryGroupSelector#policy
   */
  readonly policy?: EntrySpecForProviderEntryGroupSelectorPolicy;

}

/**
 * Converts an object of type 'EntrySpecForProviderEntryGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecForProviderEntryGroupSelector(obj: EntrySpecForProviderEntryGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_EntrySpecForProviderEntryGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EntrySpecForProviderGcsFilesetSpec
 */
export interface EntrySpecForProviderGcsFilesetSpec {
  /**
   * Patterns to identify a set of files in Google Cloud Storage. See Cloud Storage documentation for more information. Note that bucket wildcards are currently not supported. Examples of valid filePatterns:
   *
   * @schema EntrySpecForProviderGcsFilesetSpec#filePatterns
   */
  readonly filePatterns: string[];

}

/**
 * Converts an object of type 'EntrySpecForProviderGcsFilesetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecForProviderGcsFilesetSpec(obj: EntrySpecForProviderGcsFilesetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filePatterns': obj.filePatterns?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntrySpecProviderConfigRefPolicy
 */
export interface EntrySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntrySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EntrySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntrySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EntrySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EntrySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecProviderConfigRefPolicy(obj: EntrySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntrySpecProviderRefPolicy
 */
export interface EntrySpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntrySpecProviderRefPolicy#resolution
   */
  readonly resolution?: EntrySpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntrySpecProviderRefPolicy#resolve
   */
  readonly resolve?: EntrySpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EntrySpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecProviderRefPolicy(obj: EntrySpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EntrySpecPublishConnectionDetailsToConfigRef
 */
export interface EntrySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntrySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntrySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EntrySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EntrySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecPublishConnectionDetailsToConfigRef(obj: EntrySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntrySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EntrySpecPublishConnectionDetailsToMetadata
 */
export interface EntrySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EntrySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EntrySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EntrySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EntrySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecPublishConnectionDetailsToMetadata(obj: EntrySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntrySpecForProviderEntryGroupRefPolicy
 */
export interface EntrySpecForProviderEntryGroupRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntrySpecForProviderEntryGroupRefPolicy#resolution
   */
  readonly resolution?: EntrySpecForProviderEntryGroupRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntrySpecForProviderEntryGroupRefPolicy#resolve
   */
  readonly resolve?: EntrySpecForProviderEntryGroupRefPolicyResolve;

}

/**
 * Converts an object of type 'EntrySpecForProviderEntryGroupRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecForProviderEntryGroupRefPolicy(obj: EntrySpecForProviderEntryGroupRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema EntrySpecForProviderEntryGroupSelectorPolicy
 */
export interface EntrySpecForProviderEntryGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntrySpecForProviderEntryGroupSelectorPolicy#resolution
   */
  readonly resolution?: EntrySpecForProviderEntryGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntrySpecForProviderEntryGroupSelectorPolicy#resolve
   */
  readonly resolve?: EntrySpecForProviderEntryGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'EntrySpecForProviderEntryGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecForProviderEntryGroupSelectorPolicy(obj: EntrySpecForProviderEntryGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntrySpecProviderConfigRefPolicyResolution
 */
export enum EntrySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntrySpecProviderConfigRefPolicyResolve
 */
export enum EntrySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntrySpecProviderRefPolicyResolution
 */
export enum EntrySpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntrySpecProviderRefPolicyResolve
 */
export enum EntrySpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EntrySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EntrySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntrySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EntrySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntrySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EntrySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EntrySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntrySpecPublishConnectionDetailsToConfigRefPolicy(obj: EntrySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntrySpecForProviderEntryGroupRefPolicyResolution
 */
export enum EntrySpecForProviderEntryGroupRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntrySpecForProviderEntryGroupRefPolicyResolve
 */
export enum EntrySpecForProviderEntryGroupRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntrySpecForProviderEntryGroupSelectorPolicyResolution
 */
export enum EntrySpecForProviderEntryGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntrySpecForProviderEntryGroupSelectorPolicyResolve
 */
export enum EntrySpecForProviderEntryGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntrySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EntrySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntrySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EntrySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * EntryGroup is the Schema for the EntryGroups API. An EntryGroup resource represents a logical grouping of zero or more Data Catalog Entry resources.
 *
 * @schema EntryGroup
 */
export class EntryGroup extends ApiObject {
  /**
   * Returns the apiVersion and kind for "EntryGroup"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datacatalog.gcp.upbound.io/v1beta1',
    kind: 'EntryGroup',
  }

  /**
   * Renders a Kubernetes manifest for "EntryGroup".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EntryGroupProps): any {
    return {
      ...EntryGroup.GVK,
      ...toJson_EntryGroupProps(props),
    };
  }

  /**
   * Defines a "EntryGroup" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EntryGroupProps) {
    super(scope, id, {
      ...EntryGroup.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EntryGroup.GVK,
      ...toJson_EntryGroupProps(resolved),
    };
  }
}

/**
 * EntryGroup is the Schema for the EntryGroups API. An EntryGroup resource represents a logical grouping of zero or more Data Catalog Entry resources.
 *
 * @schema EntryGroup
 */
export interface EntryGroupProps {
  /**
   * @schema EntryGroup#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * EntryGroupSpec defines the desired state of EntryGroup
   *
   * @schema EntryGroup#spec
   */
  readonly spec: EntryGroupSpec;

}

/**
 * Converts an object of type 'EntryGroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupProps(obj: EntryGroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EntryGroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EntryGroupSpec defines the desired state of EntryGroup
 *
 * @schema EntryGroupSpec
 */
export interface EntryGroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EntryGroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: EntryGroupSpecDeletionPolicy;

  /**
   * @schema EntryGroupSpec#forProvider
   */
  readonly forProvider: EntryGroupSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema EntryGroupSpec#managementPolicy
   */
  readonly managementPolicy?: EntryGroupSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema EntryGroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: EntryGroupSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema EntryGroupSpec#providerRef
   */
  readonly providerRef?: EntryGroupSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema EntryGroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: EntryGroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema EntryGroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: EntryGroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'EntryGroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpec(obj: EntryGroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_EntryGroupSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_EntryGroupSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_EntryGroupSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_EntryGroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_EntryGroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EntryGroupSpecDeletionPolicy
 */
export enum EntryGroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema EntryGroupSpecForProvider
 */
export interface EntryGroupSpecForProvider {
  /**
   * Entry group description, which can consist of several sentences or paragraphs that describe entry group contents.
   *
   * @schema EntryGroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A short name to identify the entry group, for example, "analytics data - jan 2011".
   *
   * @schema EntryGroupSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * The id of the entry group to create. The id must begin with a letter or underscore, contain only English letters, numbers and underscores, and be at most 64 characters.
   *
   * @schema EntryGroupSpecForProvider#entryGroupId
   */
  readonly entryGroupId?: string;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema EntryGroupSpecForProvider#project
   */
  readonly project?: string;

  /**
   * EntryGroup location region.
   *
   * @schema EntryGroupSpecForProvider#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'EntryGroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecForProvider(obj: EntryGroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'entryGroupId': obj.entryGroupId,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema EntryGroupSpecManagementPolicy
 */
export enum EntryGroupSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema EntryGroupSpecProviderConfigRef
 */
export interface EntryGroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntryGroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntryGroupSpecProviderConfigRef#policy
   */
  readonly policy?: EntryGroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'EntryGroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecProviderConfigRef(obj: EntryGroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntryGroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema EntryGroupSpecProviderRef
 */
export interface EntryGroupSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntryGroupSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntryGroupSpecProviderRef#policy
   */
  readonly policy?: EntryGroupSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'EntryGroupSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecProviderRef(obj: EntryGroupSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntryGroupSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema EntryGroupSpecPublishConnectionDetailsTo
 */
export interface EntryGroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: EntryGroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: EntryGroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'EntryGroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecPublishConnectionDetailsTo(obj: EntryGroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_EntryGroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_EntryGroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema EntryGroupSpecWriteConnectionSecretToRef
 */
export interface EntryGroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema EntryGroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema EntryGroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'EntryGroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecWriteConnectionSecretToRef(obj: EntryGroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntryGroupSpecProviderConfigRefPolicy
 */
export interface EntryGroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntryGroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: EntryGroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntryGroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: EntryGroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EntryGroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecProviderConfigRefPolicy(obj: EntryGroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema EntryGroupSpecProviderRefPolicy
 */
export interface EntryGroupSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntryGroupSpecProviderRefPolicy#resolution
   */
  readonly resolution?: EntryGroupSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntryGroupSpecProviderRefPolicy#resolve
   */
  readonly resolve?: EntryGroupSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'EntryGroupSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecProviderRefPolicy(obj: EntryGroupSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema EntryGroupSpecPublishConnectionDetailsToConfigRef
 */
export interface EntryGroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'EntryGroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecPublishConnectionDetailsToConfigRef(obj: EntryGroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema EntryGroupSpecPublishConnectionDetailsToMetadata
 */
export interface EntryGroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'EntryGroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecPublishConnectionDetailsToMetadata(obj: EntryGroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntryGroupSpecProviderConfigRefPolicyResolution
 */
export enum EntryGroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntryGroupSpecProviderConfigRefPolicyResolve
 */
export enum EntryGroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntryGroupSpecProviderRefPolicyResolution
 */
export enum EntryGroupSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntryGroupSpecProviderRefPolicyResolve
 */
export enum EntryGroupSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: EntryGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: EntryGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: EntryGroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema EntryGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum EntryGroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema EntryGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum EntryGroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Tag is the Schema for the Tags API. Tags are used to attach custom metadata to Data Catalog resources.
 *
 * @schema Tag
 */
export class Tag extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Tag"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datacatalog.gcp.upbound.io/v1beta1',
    kind: 'Tag',
  }

  /**
   * Renders a Kubernetes manifest for "Tag".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TagProps): any {
    return {
      ...Tag.GVK,
      ...toJson_TagProps(props),
    };
  }

  /**
   * Defines a "Tag" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TagProps) {
    super(scope, id, {
      ...Tag.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Tag.GVK,
      ...toJson_TagProps(resolved),
    };
  }
}

/**
 * Tag is the Schema for the Tags API. Tags are used to attach custom metadata to Data Catalog resources.
 *
 * @schema Tag
 */
export interface TagProps {
  /**
   * @schema Tag#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TagSpec defines the desired state of Tag
   *
   * @schema Tag#spec
   */
  readonly spec: TagSpec;

}

/**
 * Converts an object of type 'TagProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagProps(obj: TagProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TagSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TagSpec defines the desired state of Tag
 *
 * @schema TagSpec
 */
export interface TagSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagSpec#deletionPolicy
   */
  readonly deletionPolicy?: TagSpecDeletionPolicy;

  /**
   * @schema TagSpec#forProvider
   */
  readonly forProvider: TagSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagSpec#managementPolicy
   */
  readonly managementPolicy?: TagSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TagSpec#providerConfigRef
   */
  readonly providerConfigRef?: TagSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TagSpec#providerRef
   */
  readonly providerRef?: TagSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TagSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TagSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TagSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TagSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TagSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpec(obj: TagSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TagSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TagSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TagSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TagSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TagSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagSpecDeletionPolicy
 */
export enum TagSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TagSpecForProvider
 */
export interface TagSpecForProvider {
  /**
   * Resources like Entry can have schemas associated with them. This scope allows users to attach tags to an individual column based on that schema. For attaching a tag to a nested column, use . to separate the column names. Example: outer_column.inner_column
   *
   * @schema TagSpecForProvider#column
   */
  readonly column?: string;

  /**
   * This maps the ID of a tag field to the value of and additional information about that field. Valid field IDs are defined by the tag's template. A tag must have at least 1 field and at most 500 fields. Structure is documented below.
   *
   * @schema TagSpecForProvider#fields
   */
  readonly fields?: TagSpecForProviderFields[];

  /**
   * The name of the parent this tag is attached to. This can be the name of an entry or an entry group. If an entry group, the tag will be attached to all entries in that group.
   *
   * @schema TagSpecForProvider#parent
   */
  readonly parent?: string;

  /**
   * Reference to a Entry in datacatalog to populate parent.
   *
   * @schema TagSpecForProvider#parentRef
   */
  readonly parentRef?: TagSpecForProviderParentRef;

  /**
   * Selector for a Entry in datacatalog to populate parent.
   *
   * @schema TagSpecForProvider#parentSelector
   */
  readonly parentSelector?: TagSpecForProviderParentSelector;

  /**
   * The resource name of the tag template that this tag uses. Example: projects/{project_id}/locations/{location}/tagTemplates/{tagTemplateId} This field cannot be modified after creation.
   *
   * @schema TagSpecForProvider#template
   */
  readonly template?: string;

  /**
   * Reference to a TagTemplate in datacatalog to populate template.
   *
   * @schema TagSpecForProvider#templateRef
   */
  readonly templateRef?: TagSpecForProviderTemplateRef;

  /**
   * Selector for a TagTemplate in datacatalog to populate template.
   *
   * @schema TagSpecForProvider#templateSelector
   */
  readonly templateSelector?: TagSpecForProviderTemplateSelector;

}

/**
 * Converts an object of type 'TagSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProvider(obj: TagSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'column': obj.column,
    'fields': obj.fields?.map(y => toJson_TagSpecForProviderFields(y)),
    'parent': obj.parent,
    'parentRef': toJson_TagSpecForProviderParentRef(obj.parentRef),
    'parentSelector': toJson_TagSpecForProviderParentSelector(obj.parentSelector),
    'template': obj.template,
    'templateRef': toJson_TagSpecForProviderTemplateRef(obj.templateRef),
    'templateSelector': toJson_TagSpecForProviderTemplateSelector(obj.templateSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagSpecManagementPolicy
 */
export enum TagSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TagSpecProviderConfigRef
 */
export interface TagSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecProviderConfigRef#policy
   */
  readonly policy?: TagSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TagSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderConfigRef(obj: TagSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TagSpecProviderRef
 */
export interface TagSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecProviderRef#policy
   */
  readonly policy?: TagSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TagSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderRef(obj: TagSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TagSpecPublishConnectionDetailsTo
 */
export interface TagSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TagSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TagSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TagSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsTo(obj: TagSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TagSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TagSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TagSpecWriteConnectionSecretToRef
 */
export interface TagSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TagSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TagSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TagSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecWriteConnectionSecretToRef(obj: TagSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TagSpecForProviderFields
 */
export interface TagSpecForProviderFields {
  /**
   * Holds the value for a tag field with boolean type.
   *
   * @schema TagSpecForProviderFields#boolValue
   */
  readonly boolValue?: boolean;

  /**
   * Holds the value for a tag field with double type.
   *
   * @schema TagSpecForProviderFields#doubleValue
   */
  readonly doubleValue?: number;

  /**
   * Holds the value for a tag field with enum type. This value must be one of the allowed values in the definition of this enum.
   *
   * @schema TagSpecForProviderFields#enumValue
   */
  readonly enumValue?: string;

  /**
   * The identifier for this object. Format specified above.
   *
   * @schema TagSpecForProviderFields#fieldName
   */
  readonly fieldName: string;

  /**
   * Holds the value for a tag field with string type.
   *
   * @schema TagSpecForProviderFields#stringValue
   */
  readonly stringValue?: string;

  /**
   * Holds the value for a tag field with timestamp type.
   *
   * @schema TagSpecForProviderFields#timestampValue
   */
  readonly timestampValue?: string;

}

/**
 * Converts an object of type 'TagSpecForProviderFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderFields(obj: TagSpecForProviderFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'boolValue': obj.boolValue,
    'doubleValue': obj.doubleValue,
    'enumValue': obj.enumValue,
    'fieldName': obj.fieldName,
    'stringValue': obj.stringValue,
    'timestampValue': obj.timestampValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Entry in datacatalog to populate parent.
 *
 * @schema TagSpecForProviderParentRef
 */
export interface TagSpecForProviderParentRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecForProviderParentRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecForProviderParentRef#policy
   */
  readonly policy?: TagSpecForProviderParentRefPolicy;

}

/**
 * Converts an object of type 'TagSpecForProviderParentRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderParentRef(obj: TagSpecForProviderParentRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecForProviderParentRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Entry in datacatalog to populate parent.
 *
 * @schema TagSpecForProviderParentSelector
 */
export interface TagSpecForProviderParentSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TagSpecForProviderParentSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TagSpecForProviderParentSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TagSpecForProviderParentSelector#policy
   */
  readonly policy?: TagSpecForProviderParentSelectorPolicy;

}

/**
 * Converts an object of type 'TagSpecForProviderParentSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderParentSelector(obj: TagSpecForProviderParentSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TagSpecForProviderParentSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TagTemplate in datacatalog to populate template.
 *
 * @schema TagSpecForProviderTemplateRef
 */
export interface TagSpecForProviderTemplateRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecForProviderTemplateRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecForProviderTemplateRef#policy
   */
  readonly policy?: TagSpecForProviderTemplateRefPolicy;

}

/**
 * Converts an object of type 'TagSpecForProviderTemplateRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderTemplateRef(obj: TagSpecForProviderTemplateRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecForProviderTemplateRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TagTemplate in datacatalog to populate template.
 *
 * @schema TagSpecForProviderTemplateSelector
 */
export interface TagSpecForProviderTemplateSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TagSpecForProviderTemplateSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TagSpecForProviderTemplateSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TagSpecForProviderTemplateSelector#policy
   */
  readonly policy?: TagSpecForProviderTemplateSelectorPolicy;

}

/**
 * Converts an object of type 'TagSpecForProviderTemplateSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderTemplateSelector(obj: TagSpecForProviderTemplateSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TagSpecForProviderTemplateSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecProviderConfigRefPolicy
 */
export interface TagSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TagSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TagSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderConfigRefPolicy(obj: TagSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecProviderRefPolicy
 */
export interface TagSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TagSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TagSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecProviderRefPolicy(obj: TagSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRef
 */
export interface TagSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TagSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToConfigRef(obj: TagSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TagSpecPublishConnectionDetailsToMetadata
 */
export interface TagSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TagSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToMetadata(obj: TagSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecForProviderParentRefPolicy
 */
export interface TagSpecForProviderParentRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecForProviderParentRefPolicy#resolution
   */
  readonly resolution?: TagSpecForProviderParentRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecForProviderParentRefPolicy#resolve
   */
  readonly resolve?: TagSpecForProviderParentRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecForProviderParentRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderParentRefPolicy(obj: TagSpecForProviderParentRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TagSpecForProviderParentSelectorPolicy
 */
export interface TagSpecForProviderParentSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecForProviderParentSelectorPolicy#resolution
   */
  readonly resolution?: TagSpecForProviderParentSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecForProviderParentSelectorPolicy#resolve
   */
  readonly resolve?: TagSpecForProviderParentSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecForProviderParentSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderParentSelectorPolicy(obj: TagSpecForProviderParentSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagSpecForProviderTemplateRefPolicy
 */
export interface TagSpecForProviderTemplateRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecForProviderTemplateRefPolicy#resolution
   */
  readonly resolution?: TagSpecForProviderTemplateRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecForProviderTemplateRefPolicy#resolve
   */
  readonly resolve?: TagSpecForProviderTemplateRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecForProviderTemplateRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderTemplateRefPolicy(obj: TagSpecForProviderTemplateRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TagSpecForProviderTemplateSelectorPolicy
 */
export interface TagSpecForProviderTemplateSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecForProviderTemplateSelectorPolicy#resolution
   */
  readonly resolution?: TagSpecForProviderTemplateSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecForProviderTemplateSelectorPolicy#resolve
   */
  readonly resolve?: TagSpecForProviderTemplateSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecForProviderTemplateSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecForProviderTemplateSelectorPolicy(obj: TagSpecForProviderTemplateSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecProviderConfigRefPolicyResolution
 */
export enum TagSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecProviderConfigRefPolicyResolve
 */
export enum TagSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecProviderRefPolicyResolution
 */
export enum TagSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecProviderRefPolicyResolve
 */
export enum TagSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TagSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TagSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TagSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagSpecPublishConnectionDetailsToConfigRefPolicy(obj: TagSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecForProviderParentRefPolicyResolution
 */
export enum TagSpecForProviderParentRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecForProviderParentRefPolicyResolve
 */
export enum TagSpecForProviderParentRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecForProviderParentSelectorPolicyResolution
 */
export enum TagSpecForProviderParentSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecForProviderParentSelectorPolicyResolve
 */
export enum TagSpecForProviderParentSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecForProviderTemplateRefPolicyResolution
 */
export enum TagSpecForProviderTemplateRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecForProviderTemplateRefPolicyResolve
 */
export enum TagSpecForProviderTemplateRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecForProviderTemplateSelectorPolicyResolution
 */
export enum TagSpecForProviderTemplateSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecForProviderTemplateSelectorPolicyResolve
 */
export enum TagSpecForProviderTemplateSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TagSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TagSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TagTemplate is the Schema for the TagTemplates API. A tag template defines a tag, which can have one or more typed fields.
 *
 * @schema TagTemplate
 */
export class TagTemplate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TagTemplate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'datacatalog.gcp.upbound.io/v1beta1',
    kind: 'TagTemplate',
  }

  /**
   * Renders a Kubernetes manifest for "TagTemplate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TagTemplateProps): any {
    return {
      ...TagTemplate.GVK,
      ...toJson_TagTemplateProps(props),
    };
  }

  /**
   * Defines a "TagTemplate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TagTemplateProps) {
    super(scope, id, {
      ...TagTemplate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TagTemplate.GVK,
      ...toJson_TagTemplateProps(resolved),
    };
  }
}

/**
 * TagTemplate is the Schema for the TagTemplates API. A tag template defines a tag, which can have one or more typed fields.
 *
 * @schema TagTemplate
 */
export interface TagTemplateProps {
  /**
   * @schema TagTemplate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TagTemplateSpec defines the desired state of TagTemplate
   *
   * @schema TagTemplate#spec
   */
  readonly spec: TagTemplateSpec;

}

/**
 * Converts an object of type 'TagTemplateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateProps(obj: TagTemplateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TagTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TagTemplateSpec defines the desired state of TagTemplate
 *
 * @schema TagTemplateSpec
 */
export interface TagTemplateSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagTemplateSpec#deletionPolicy
   */
  readonly deletionPolicy?: TagTemplateSpecDeletionPolicy;

  /**
   * @schema TagTemplateSpec#forProvider
   */
  readonly forProvider: TagTemplateSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TagTemplateSpec#managementPolicy
   */
  readonly managementPolicy?: TagTemplateSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TagTemplateSpec#providerConfigRef
   */
  readonly providerConfigRef?: TagTemplateSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema TagTemplateSpec#providerRef
   */
  readonly providerRef?: TagTemplateSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TagTemplateSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TagTemplateSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TagTemplateSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TagTemplateSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TagTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpec(obj: TagTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TagTemplateSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_TagTemplateSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_TagTemplateSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_TagTemplateSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TagTemplateSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagTemplateSpecDeletionPolicy
 */
export enum TagTemplateSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TagTemplateSpecForProvider
 */
export interface TagTemplateSpecForProvider {
  /**
   * The display name for this field.
   *
   * @schema TagTemplateSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Set of tag template field IDs and the settings for the field. This set is an exhaustive list of the allowed fields. This set must contain at least one field and at most 500 fields. The change of field_id will be resulting in re-creating of field. The change of primitive_type will be resulting in re-creating of field, however if the field is a required, you cannot update it. Structure is documented below.
   *
   * @schema TagTemplateSpecForProvider#fields
   */
  readonly fields?: TagTemplateSpecForProviderFields[];

  /**
   * This confirms the deletion of any possible tags using this template. Must be set to true in order to delete the tag template.
   *
   * @schema TagTemplateSpecForProvider#forceDelete
   */
  readonly forceDelete?: boolean;

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema TagTemplateSpecForProvider#project
   */
  readonly project?: string;

  /**
   * Template location region.
   *
   * @schema TagTemplateSpecForProvider#region
   */
  readonly region?: string;

}

/**
 * Converts an object of type 'TagTemplateSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecForProvider(obj: TagTemplateSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
    'fields': obj.fields?.map(y => toJson_TagTemplateSpecForProviderFields(y)),
    'forceDelete': obj.forceDelete,
    'project': obj.project,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TagTemplateSpecManagementPolicy
 */
export enum TagTemplateSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TagTemplateSpecProviderConfigRef
 */
export interface TagTemplateSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagTemplateSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagTemplateSpecProviderConfigRef#policy
   */
  readonly policy?: TagTemplateSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TagTemplateSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecProviderConfigRef(obj: TagTemplateSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagTemplateSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema TagTemplateSpecProviderRef
 */
export interface TagTemplateSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagTemplateSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagTemplateSpecProviderRef#policy
   */
  readonly policy?: TagTemplateSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'TagTemplateSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecProviderRef(obj: TagTemplateSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagTemplateSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TagTemplateSpecPublishConnectionDetailsTo
 */
export interface TagTemplateSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TagTemplateSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TagTemplateSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TagTemplateSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecPublishConnectionDetailsTo(obj: TagTemplateSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TagTemplateSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TagTemplateSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TagTemplateSpecWriteConnectionSecretToRef
 */
export interface TagTemplateSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TagTemplateSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TagTemplateSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TagTemplateSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecWriteConnectionSecretToRef(obj: TagTemplateSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TagTemplateSpecForProviderFields
 */
export interface TagTemplateSpecForProviderFields {
  /**
   * A description for this field.
   *
   * @schema TagTemplateSpecForProviderFields#description
   */
  readonly description?: string;

  /**
   * The display name for this field.
   *
   * @schema TagTemplateSpecForProviderFields#displayName
   */
  readonly displayName?: string;

  /**
   * The identifier for this object. Format specified above.
   *
   * @schema TagTemplateSpecForProviderFields#fieldId
   */
  readonly fieldId: string;

  /**
   * Whether this is a required field. Defaults to false.
   *
   * @default false.
   * @schema TagTemplateSpecForProviderFields#isRequired
   */
  readonly isRequired?: boolean;

  /**
   * The order of this field with respect to other fields in this tag template. A higher value indicates a more important field. The value can be negative. Multiple fields can have the same order, and field orders within a tag do not have to be sequential.
   *
   * @schema TagTemplateSpecForProviderFields#order
   */
  readonly order?: number;

  /**
   * The type of value this tag field can contain. Structure is documented below.
   *
   * @schema TagTemplateSpecForProviderFields#type
   */
  readonly type: TagTemplateSpecForProviderFieldsType[];

}

/**
 * Converts an object of type 'TagTemplateSpecForProviderFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecForProviderFields(obj: TagTemplateSpecForProviderFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'fieldId': obj.fieldId,
    'isRequired': obj.isRequired,
    'order': obj.order,
    'type': obj.type?.map(y => toJson_TagTemplateSpecForProviderFieldsType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagTemplateSpecProviderConfigRefPolicy
 */
export interface TagTemplateSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagTemplateSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TagTemplateSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagTemplateSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TagTemplateSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagTemplateSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecProviderConfigRefPolicy(obj: TagTemplateSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TagTemplateSpecProviderRefPolicy
 */
export interface TagTemplateSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagTemplateSpecProviderRefPolicy#resolution
   */
  readonly resolution?: TagTemplateSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagTemplateSpecProviderRefPolicy#resolve
   */
  readonly resolve?: TagTemplateSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'TagTemplateSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecProviderRefPolicy(obj: TagTemplateSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TagTemplateSpecPublishConnectionDetailsToConfigRef
 */
export interface TagTemplateSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TagTemplateSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecPublishConnectionDetailsToConfigRef(obj: TagTemplateSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TagTemplateSpecPublishConnectionDetailsToMetadata
 */
export interface TagTemplateSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TagTemplateSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecPublishConnectionDetailsToMetadata(obj: TagTemplateSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TagTemplateSpecForProviderFieldsType
 */
export interface TagTemplateSpecForProviderFieldsType {
  /**
   * Represents an enum type. Exactly one of primitive_type or enum_type must be set Structure is documented below.
   *
   * @schema TagTemplateSpecForProviderFieldsType#enumType
   */
  readonly enumType?: TagTemplateSpecForProviderFieldsTypeEnumType[];

  /**
   * Represents primitive types - string, bool etc. Exactly one of primitive_type or enum_type must be set Possible values are: DOUBLE, STRING, BOOL, TIMESTAMP.
   *
   * @schema TagTemplateSpecForProviderFieldsType#primitiveType
   */
  readonly primitiveType?: string;

}

/**
 * Converts an object of type 'TagTemplateSpecForProviderFieldsType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecForProviderFieldsType(obj: TagTemplateSpecForProviderFieldsType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enumType': obj.enumType?.map(y => toJson_TagTemplateSpecForProviderFieldsTypeEnumType(y)),
    'primitiveType': obj.primitiveType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagTemplateSpecProviderConfigRefPolicyResolution
 */
export enum TagTemplateSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagTemplateSpecProviderConfigRefPolicyResolve
 */
export enum TagTemplateSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagTemplateSpecProviderRefPolicyResolution
 */
export enum TagTemplateSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagTemplateSpecProviderRefPolicyResolve
 */
export enum TagTemplateSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TagTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TagTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy(obj: TagTemplateSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TagTemplateSpecForProviderFieldsTypeEnumType
 */
export interface TagTemplateSpecForProviderFieldsTypeEnumType {
  /**
   * The set of allowed values for this enum. The display names of the values must be case-insensitively unique within this set. Currently, enum values can only be added to the list of allowed values. Deletion and renaming of enum values are not supported. Can have up to 500 allowed values. Structure is documented below.
   *
   * @schema TagTemplateSpecForProviderFieldsTypeEnumType#allowedValues
   */
  readonly allowedValues: TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues[];

}

/**
 * Converts an object of type 'TagTemplateSpecForProviderFieldsTypeEnumType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecForProviderFieldsTypeEnumType(obj: TagTemplateSpecForProviderFieldsTypeEnumType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedValues': obj.allowedValues?.map(y => toJson_TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TagTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TagTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TagTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TagTemplateSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * @schema TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues
 */
export interface TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues {
  /**
   * The display name for this field.
   *
   * @schema TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues#displayName
   */
  readonly displayName: string;

}

/**
 * Converts an object of type 'TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues(obj: TagTemplateSpecForProviderFieldsTypeEnumTypeAllowedValues | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'displayName': obj.displayName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

