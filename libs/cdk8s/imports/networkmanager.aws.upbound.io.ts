// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AttachmentAccepter is the Schema for the AttachmentAccepters API.
 *
 * @schema AttachmentAccepter
 */
export class AttachmentAccepter extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AttachmentAccepter"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'AttachmentAccepter',
  }

  /**
   * Renders a Kubernetes manifest for "AttachmentAccepter".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AttachmentAccepterProps): any {
    return {
      ...AttachmentAccepter.GVK,
      ...toJson_AttachmentAccepterProps(props),
    };
  }

  /**
   * Defines a "AttachmentAccepter" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AttachmentAccepterProps) {
    super(scope, id, {
      ...AttachmentAccepter.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AttachmentAccepter.GVK,
      ...toJson_AttachmentAccepterProps(resolved),
    };
  }
}

/**
 * AttachmentAccepter is the Schema for the AttachmentAccepters API.
 *
 * @schema AttachmentAccepter
 */
export interface AttachmentAccepterProps {
  /**
   * @schema AttachmentAccepter#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AttachmentAccepterSpec defines the desired state of AttachmentAccepter
   *
   * @schema AttachmentAccepter#spec
   */
  readonly spec: AttachmentAccepterSpec;

}

/**
 * Converts an object of type 'AttachmentAccepterProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterProps(obj: AttachmentAccepterProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AttachmentAccepterSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AttachmentAccepterSpec defines the desired state of AttachmentAccepter
 *
 * @schema AttachmentAccepterSpec
 */
export interface AttachmentAccepterSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AttachmentAccepterSpec#deletionPolicy
   */
  readonly deletionPolicy?: AttachmentAccepterSpecDeletionPolicy;

  /**
   * @schema AttachmentAccepterSpec#forProvider
   */
  readonly forProvider: AttachmentAccepterSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema AttachmentAccepterSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AttachmentAccepterSpec#managementPolicies
   */
  readonly managementPolicies?: AttachmentAccepterSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema AttachmentAccepterSpec#providerConfigRef
   */
  readonly providerConfigRef?: AttachmentAccepterSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema AttachmentAccepterSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AttachmentAccepterSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema AttachmentAccepterSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AttachmentAccepterSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AttachmentAccepterSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpec(obj: AttachmentAccepterSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AttachmentAccepterSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AttachmentAccepterSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AttachmentAccepterSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AttachmentAccepterSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AttachmentAccepterSpecDeletionPolicy
 */
export enum AttachmentAccepterSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AttachmentAccepterSpecForProvider
 */
export interface AttachmentAccepterSpecForProvider {
  /**
   * The ID of the attachment.
   *
   * @schema AttachmentAccepterSpecForProvider#attachmentId
   */
  readonly attachmentId?: string;

  /**
   * Reference to a VPCAttachment in networkmanager to populate attachmentId.
   *
   * @schema AttachmentAccepterSpecForProvider#attachmentIdRef
   */
  readonly attachmentIdRef?: AttachmentAccepterSpecForProviderAttachmentIdRef;

  /**
   * Selector for a VPCAttachment in networkmanager to populate attachmentId.
   *
   * @schema AttachmentAccepterSpecForProvider#attachmentIdSelector
   */
  readonly attachmentIdSelector?: AttachmentAccepterSpecForProviderAttachmentIdSelector;

  /**
   * The type of attachment. Valid values can be found in the AWS Documentation
   *
   * @schema AttachmentAccepterSpecForProvider#attachmentType
   */
  readonly attachmentType?: string;

  /**
   * Reference to a VPCAttachment in networkmanager to populate attachmentType.
   *
   * @schema AttachmentAccepterSpecForProvider#attachmentTypeRef
   */
  readonly attachmentTypeRef?: AttachmentAccepterSpecForProviderAttachmentTypeRef;

  /**
   * Selector for a VPCAttachment in networkmanager to populate attachmentType.
   *
   * @schema AttachmentAccepterSpecForProvider#attachmentTypeSelector
   */
  readonly attachmentTypeSelector?: AttachmentAccepterSpecForProviderAttachmentTypeSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AttachmentAccepterSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProvider(obj: AttachmentAccepterSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attachmentId': obj.attachmentId,
    'attachmentIdRef': toJson_AttachmentAccepterSpecForProviderAttachmentIdRef(obj.attachmentIdRef),
    'attachmentIdSelector': toJson_AttachmentAccepterSpecForProviderAttachmentIdSelector(obj.attachmentIdSelector),
    'attachmentType': obj.attachmentType,
    'attachmentTypeRef': toJson_AttachmentAccepterSpecForProviderAttachmentTypeRef(obj.attachmentTypeRef),
    'attachmentTypeSelector': toJson_AttachmentAccepterSpecForProviderAttachmentTypeSelector(obj.attachmentTypeSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema AttachmentAccepterSpecManagementPolicies
 */
export enum AttachmentAccepterSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema AttachmentAccepterSpecProviderConfigRef
 */
export interface AttachmentAccepterSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentAccepterSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentAccepterSpecProviderConfigRef#policy
   */
  readonly policy?: AttachmentAccepterSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecProviderConfigRef(obj: AttachmentAccepterSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentAccepterSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema AttachmentAccepterSpecPublishConnectionDetailsTo
 */
export interface AttachmentAccepterSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AttachmentAccepterSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AttachmentAccepterSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecPublishConnectionDetailsTo(obj: AttachmentAccepterSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AttachmentAccepterSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AttachmentAccepterSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema AttachmentAccepterSpecWriteConnectionSecretToRef
 */
export interface AttachmentAccepterSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AttachmentAccepterSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AttachmentAccepterSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecWriteConnectionSecretToRef(obj: AttachmentAccepterSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPCAttachment in networkmanager to populate attachmentId.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdRef
 */
export interface AttachmentAccepterSpecForProviderAttachmentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdRef#policy
   */
  readonly policy?: AttachmentAccepterSpecForProviderAttachmentIdRefPolicy;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentIdRef(obj: AttachmentAccepterSpecForProviderAttachmentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentAccepterSpecForProviderAttachmentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPCAttachment in networkmanager to populate attachmentId.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdSelector
 */
export interface AttachmentAccepterSpecForProviderAttachmentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdSelector#policy
   */
  readonly policy?: AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentIdSelector(obj: AttachmentAccepterSpecForProviderAttachmentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPCAttachment in networkmanager to populate attachmentType.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeRef
 */
export interface AttachmentAccepterSpecForProviderAttachmentTypeRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeRef#policy
   */
  readonly policy?: AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentTypeRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentTypeRef(obj: AttachmentAccepterSpecForProviderAttachmentTypeRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPCAttachment in networkmanager to populate attachmentType.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelector
 */
export interface AttachmentAccepterSpecForProviderAttachmentTypeSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelector#policy
   */
  readonly policy?: AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentTypeSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentTypeSelector(obj: AttachmentAccepterSpecForProviderAttachmentTypeSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentAccepterSpecProviderConfigRefPolicy
 */
export interface AttachmentAccepterSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentAccepterSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AttachmentAccepterSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentAccepterSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AttachmentAccepterSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecProviderConfigRefPolicy(obj: AttachmentAccepterSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRef
 */
export interface AttachmentAccepterSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecPublishConnectionDetailsToConfigRef(obj: AttachmentAccepterSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AttachmentAccepterSpecPublishConnectionDetailsToMetadata
 */
export interface AttachmentAccepterSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecPublishConnectionDetailsToMetadata(obj: AttachmentAccepterSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdRefPolicy
 */
export interface AttachmentAccepterSpecForProviderAttachmentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdRefPolicy#resolution
   */
  readonly resolution?: AttachmentAccepterSpecForProviderAttachmentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdRefPolicy#resolve
   */
  readonly resolve?: AttachmentAccepterSpecForProviderAttachmentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentIdRefPolicy(obj: AttachmentAccepterSpecForProviderAttachmentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy
 */
export interface AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy(obj: AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy
 */
export interface AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy#resolution
   */
  readonly resolution?: AttachmentAccepterSpecForProviderAttachmentTypeRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy#resolve
   */
  readonly resolve?: AttachmentAccepterSpecForProviderAttachmentTypeRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy(obj: AttachmentAccepterSpecForProviderAttachmentTypeRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy
 */
export interface AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy#resolution
   */
  readonly resolution?: AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy#resolve
   */
  readonly resolve?: AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy(obj: AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentAccepterSpecProviderConfigRefPolicyResolution
 */
export enum AttachmentAccepterSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentAccepterSpecProviderConfigRefPolicyResolve
 */
export enum AttachmentAccepterSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy(obj: AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdRefPolicyResolution
 */
export enum AttachmentAccepterSpecForProviderAttachmentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdRefPolicyResolve
 */
export enum AttachmentAccepterSpecForProviderAttachmentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicyResolution
 */
export enum AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicyResolve
 */
export enum AttachmentAccepterSpecForProviderAttachmentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeRefPolicyResolution
 */
export enum AttachmentAccepterSpecForProviderAttachmentTypeRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeRefPolicyResolve
 */
export enum AttachmentAccepterSpecForProviderAttachmentTypeRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicyResolution
 */
export enum AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicyResolve
 */
export enum AttachmentAccepterSpecForProviderAttachmentTypeSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AttachmentAccepterSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ConnectAttachment is the Schema for the ConnectAttachments API.
 *
 * @schema ConnectAttachment
 */
export class ConnectAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ConnectAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'ConnectAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "ConnectAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectAttachmentProps): any {
    return {
      ...ConnectAttachment.GVK,
      ...toJson_ConnectAttachmentProps(props),
    };
  }

  /**
   * Defines a "ConnectAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectAttachmentProps) {
    super(scope, id, {
      ...ConnectAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ConnectAttachment.GVK,
      ...toJson_ConnectAttachmentProps(resolved),
    };
  }
}

/**
 * ConnectAttachment is the Schema for the ConnectAttachments API.
 *
 * @schema ConnectAttachment
 */
export interface ConnectAttachmentProps {
  /**
   * @schema ConnectAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectAttachmentSpec defines the desired state of ConnectAttachment
   *
   * @schema ConnectAttachment#spec
   */
  readonly spec: ConnectAttachmentSpec;

}

/**
 * Converts an object of type 'ConnectAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentProps(obj: ConnectAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectAttachmentSpec defines the desired state of ConnectAttachment
 *
 * @schema ConnectAttachmentSpec
 */
export interface ConnectAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectAttachmentSpecDeletionPolicy;

  /**
   * @schema ConnectAttachmentSpec#forProvider
   */
  readonly forProvider: ConnectAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConnectAttachmentSpec#initProvider
   */
  readonly initProvider?: ConnectAttachmentSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConnectAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: ConnectAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpec(obj: ConnectAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectAttachmentSpecForProvider(obj.forProvider),
    'initProvider': toJson_ConnectAttachmentSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConnectAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConnectAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectAttachmentSpecDeletionPolicy
 */
export enum ConnectAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectAttachmentSpecForProvider
 */
export interface ConnectAttachmentSpecForProvider {
  /**
   * The ID of a core network where you want to create the attachment.
   *
   * @schema ConnectAttachmentSpecForProvider#coreNetworkId
   */
  readonly coreNetworkId?: string;

  /**
   * Reference to a CoreNetwork to populate coreNetworkId.
   *
   * @schema ConnectAttachmentSpecForProvider#coreNetworkIdRef
   */
  readonly coreNetworkIdRef?: ConnectAttachmentSpecForProviderCoreNetworkIdRef;

  /**
   * Selector for a CoreNetwork to populate coreNetworkId.
   *
   * @schema ConnectAttachmentSpecForProvider#coreNetworkIdSelector
   */
  readonly coreNetworkIdSelector?: ConnectAttachmentSpecForProviderCoreNetworkIdSelector;

  /**
   * The Region where the edge is located.
   *
   * @schema ConnectAttachmentSpecForProvider#edgeLocation
   */
  readonly edgeLocation?: string;

  /**
   * Reference to a VPCAttachment in networkmanager to populate edgeLocation.
   *
   * @schema ConnectAttachmentSpecForProvider#edgeLocationRef
   */
  readonly edgeLocationRef?: ConnectAttachmentSpecForProviderEdgeLocationRef;

  /**
   * Selector for a VPCAttachment in networkmanager to populate edgeLocation.
   *
   * @schema ConnectAttachmentSpecForProvider#edgeLocationSelector
   */
  readonly edgeLocationSelector?: ConnectAttachmentSpecForProviderEdgeLocationSelector;

  /**
   * Options for creating an attachment.
   *
   * @schema ConnectAttachmentSpecForProvider#options
   */
  readonly options?: ConnectAttachmentSpecForProviderOptions[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConnectAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectAttachmentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ID of the attachment between the two connections.
   *
   * @schema ConnectAttachmentSpecForProvider#transportAttachmentId
   */
  readonly transportAttachmentId?: string;

  /**
   * Reference to a VPCAttachment in networkmanager to populate transportAttachmentId.
   *
   * @schema ConnectAttachmentSpecForProvider#transportAttachmentIdRef
   */
  readonly transportAttachmentIdRef?: ConnectAttachmentSpecForProviderTransportAttachmentIdRef;

  /**
   * Selector for a VPCAttachment in networkmanager to populate transportAttachmentId.
   *
   * @schema ConnectAttachmentSpecForProvider#transportAttachmentIdSelector
   */
  readonly transportAttachmentIdSelector?: ConnectAttachmentSpecForProviderTransportAttachmentIdSelector;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProvider(obj: ConnectAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coreNetworkId': obj.coreNetworkId,
    'coreNetworkIdRef': toJson_ConnectAttachmentSpecForProviderCoreNetworkIdRef(obj.coreNetworkIdRef),
    'coreNetworkIdSelector': toJson_ConnectAttachmentSpecForProviderCoreNetworkIdSelector(obj.coreNetworkIdSelector),
    'edgeLocation': obj.edgeLocation,
    'edgeLocationRef': toJson_ConnectAttachmentSpecForProviderEdgeLocationRef(obj.edgeLocationRef),
    'edgeLocationSelector': toJson_ConnectAttachmentSpecForProviderEdgeLocationSelector(obj.edgeLocationSelector),
    'options': obj.options?.map(y => toJson_ConnectAttachmentSpecForProviderOptions(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'transportAttachmentId': obj.transportAttachmentId,
    'transportAttachmentIdRef': toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdRef(obj.transportAttachmentIdRef),
    'transportAttachmentIdSelector': toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdSelector(obj.transportAttachmentIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ConnectAttachmentSpecInitProvider
 */
export interface ConnectAttachmentSpecInitProvider {
  /**
   * Options for creating an attachment.
   *
   * @schema ConnectAttachmentSpecInitProvider#options
   */
  readonly options?: ConnectAttachmentSpecInitProviderOptions[];

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectAttachmentSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectAttachmentSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecInitProvider(obj: ConnectAttachmentSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'options': obj.options?.map(y => toJson_ConnectAttachmentSpecInitProviderOptions(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConnectAttachmentSpecManagementPolicies
 */
export enum ConnectAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectAttachmentSpecProviderConfigRef
 */
export interface ConnectAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecProviderConfigRef(obj: ConnectAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectAttachmentSpecPublishConnectionDetailsTo
 */
export interface ConnectAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecPublishConnectionDetailsTo(obj: ConnectAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectAttachmentSpecWriteConnectionSecretToRef
 */
export interface ConnectAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecWriteConnectionSecretToRef(obj: ConnectAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CoreNetwork to populate coreNetworkId.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRef
 */
export interface ConnectAttachmentSpecForProviderCoreNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRef#policy
   */
  readonly policy?: ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderCoreNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderCoreNetworkIdRef(obj: ConnectAttachmentSpecForProviderCoreNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CoreNetwork to populate coreNetworkId.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelector
 */
export interface ConnectAttachmentSpecForProviderCoreNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelector#policy
   */
  readonly policy?: ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderCoreNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderCoreNetworkIdSelector(obj: ConnectAttachmentSpecForProviderCoreNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPCAttachment in networkmanager to populate edgeLocation.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationRef
 */
export interface ConnectAttachmentSpecForProviderEdgeLocationRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationRef#policy
   */
  readonly policy?: ConnectAttachmentSpecForProviderEdgeLocationRefPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderEdgeLocationRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderEdgeLocationRef(obj: ConnectAttachmentSpecForProviderEdgeLocationRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectAttachmentSpecForProviderEdgeLocationRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPCAttachment in networkmanager to populate edgeLocation.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationSelector
 */
export interface ConnectAttachmentSpecForProviderEdgeLocationSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationSelector#policy
   */
  readonly policy?: ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderEdgeLocationSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderEdgeLocationSelector(obj: ConnectAttachmentSpecForProviderEdgeLocationSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectAttachmentSpecForProviderOptions
 */
export interface ConnectAttachmentSpecForProviderOptions {
  /**
   * @schema ConnectAttachmentSpecForProviderOptions#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderOptions(obj: ConnectAttachmentSpecForProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPCAttachment in networkmanager to populate transportAttachmentId.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRef
 */
export interface ConnectAttachmentSpecForProviderTransportAttachmentIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRef#policy
   */
  readonly policy?: ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderTransportAttachmentIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdRef(obj: ConnectAttachmentSpecForProviderTransportAttachmentIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPCAttachment in networkmanager to populate transportAttachmentId.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelector
 */
export interface ConnectAttachmentSpecForProviderTransportAttachmentIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelector#policy
   */
  readonly policy?: ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderTransportAttachmentIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdSelector(obj: ConnectAttachmentSpecForProviderTransportAttachmentIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ConnectAttachmentSpecInitProviderOptions
 */
export interface ConnectAttachmentSpecInitProviderOptions {
  /**
   * @schema ConnectAttachmentSpecInitProviderOptions#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecInitProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecInitProviderOptions(obj: ConnectAttachmentSpecInitProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectAttachmentSpecProviderConfigRefPolicy
 */
export interface ConnectAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecProviderConfigRefPolicy(obj: ConnectAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecPublishConnectionDetailsToConfigRef(obj: ConnectAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecPublishConnectionDetailsToMetadata(obj: ConnectAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy
 */
export interface ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy(obj: ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy
 */
export interface ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy(obj: ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationRefPolicy
 */
export interface ConnectAttachmentSpecForProviderEdgeLocationRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationRefPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecForProviderEdgeLocationRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationRefPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecForProviderEdgeLocationRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderEdgeLocationRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderEdgeLocationRefPolicy(obj: ConnectAttachmentSpecForProviderEdgeLocationRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy
 */
export interface ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy(obj: ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy
 */
export interface ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy(obj: ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy
 */
export interface ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy(obj: ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum ConnectAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum ConnectAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicyResolution
 */
export enum ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicyResolve
 */
export enum ConnectAttachmentSpecForProviderCoreNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolution
 */
export enum ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolve
 */
export enum ConnectAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationRefPolicyResolution
 */
export enum ConnectAttachmentSpecForProviderEdgeLocationRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationRefPolicyResolve
 */
export enum ConnectAttachmentSpecForProviderEdgeLocationRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicyResolution
 */
export enum ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicyResolve
 */
export enum ConnectAttachmentSpecForProviderEdgeLocationSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicyResolution
 */
export enum ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicyResolve
 */
export enum ConnectAttachmentSpecForProviderTransportAttachmentIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicyResolution
 */
export enum ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicyResolve
 */
export enum ConnectAttachmentSpecForProviderTransportAttachmentIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Connection is the Schema for the Connections API. Creates a connection between two devices.
 *
 * @schema Connection
 */
export class Connection extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Connection"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'Connection',
  }

  /**
   * Renders a Kubernetes manifest for "Connection".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConnectionProps): any {
    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(props),
    };
  }

  /**
   * Defines a "Connection" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConnectionProps) {
    super(scope, id, {
      ...Connection.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Connection.GVK,
      ...toJson_ConnectionProps(resolved),
    };
  }
}

/**
 * Connection is the Schema for the Connections API. Creates a connection between two devices.
 *
 * @schema Connection
 */
export interface ConnectionProps {
  /**
   * @schema Connection#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConnectionSpec defines the desired state of Connection
   *
   * @schema Connection#spec
   */
  readonly spec: ConnectionSpec;

}

/**
 * Converts an object of type 'ConnectionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionProps(obj: ConnectionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConnectionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConnectionSpec defines the desired state of Connection
 *
 * @schema ConnectionSpec
 */
export interface ConnectionSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ConnectionSpec#deletionPolicy
   */
  readonly deletionPolicy?: ConnectionSpecDeletionPolicy;

  /**
   * @schema ConnectionSpec#forProvider
   */
  readonly forProvider: ConnectionSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema ConnectionSpec#initProvider
   */
  readonly initProvider?: ConnectionSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ConnectionSpec#managementPolicies
   */
  readonly managementPolicies?: ConnectionSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema ConnectionSpec#providerConfigRef
   */
  readonly providerConfigRef?: ConnectionSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema ConnectionSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ConnectionSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema ConnectionSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ConnectionSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ConnectionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpec(obj: ConnectionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ConnectionSpecForProvider(obj.forProvider),
    'initProvider': toJson_ConnectionSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ConnectionSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ConnectionSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ConnectionSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ConnectionSpecDeletionPolicy
 */
export enum ConnectionSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ConnectionSpecForProvider
 */
export interface ConnectionSpecForProvider {
  /**
   * The ID of the second device in the connection.
   *
   * @schema ConnectionSpecForProvider#connectedDeviceId
   */
  readonly connectedDeviceId?: string;

  /**
   * Reference to a Device in networkmanager to populate connectedDeviceId.
   *
   * @schema ConnectionSpecForProvider#connectedDeviceIdRef
   */
  readonly connectedDeviceIdRef?: ConnectionSpecForProviderConnectedDeviceIdRef;

  /**
   * Selector for a Device in networkmanager to populate connectedDeviceId.
   *
   * @schema ConnectionSpecForProvider#connectedDeviceIdSelector
   */
  readonly connectedDeviceIdSelector?: ConnectionSpecForProviderConnectedDeviceIdSelector;

  /**
   * The ID of the link for the second device.
   *
   * @schema ConnectionSpecForProvider#connectedLinkId
   */
  readonly connectedLinkId?: string;

  /**
   * A description of the connection.
   *
   * @schema ConnectionSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the first device in the connection.
   *
   * @schema ConnectionSpecForProvider#deviceId
   */
  readonly deviceId?: string;

  /**
   * Reference to a Device in networkmanager to populate deviceId.
   *
   * @schema ConnectionSpecForProvider#deviceIdRef
   */
  readonly deviceIdRef?: ConnectionSpecForProviderDeviceIdRef;

  /**
   * Selector for a Device in networkmanager to populate deviceId.
   *
   * @schema ConnectionSpecForProvider#deviceIdSelector
   */
  readonly deviceIdSelector?: ConnectionSpecForProviderDeviceIdSelector;

  /**
   * The ID of the global network.
   *
   * @schema ConnectionSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema ConnectionSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: ConnectionSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema ConnectionSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: ConnectionSpecForProviderGlobalNetworkIdSelector;

  /**
   * The ID of the link for the first device.
   *
   * @schema ConnectionSpecForProvider#linkId
   */
  readonly linkId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ConnectionSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectionSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProvider(obj: ConnectionSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectedDeviceId': obj.connectedDeviceId,
    'connectedDeviceIdRef': toJson_ConnectionSpecForProviderConnectedDeviceIdRef(obj.connectedDeviceIdRef),
    'connectedDeviceIdSelector': toJson_ConnectionSpecForProviderConnectedDeviceIdSelector(obj.connectedDeviceIdSelector),
    'connectedLinkId': obj.connectedLinkId,
    'description': obj.description,
    'deviceId': obj.deviceId,
    'deviceIdRef': toJson_ConnectionSpecForProviderDeviceIdRef(obj.deviceIdRef),
    'deviceIdSelector': toJson_ConnectionSpecForProviderDeviceIdSelector(obj.deviceIdSelector),
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_ConnectionSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_ConnectionSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'linkId': obj.linkId,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema ConnectionSpecInitProvider
 */
export interface ConnectionSpecInitProvider {
  /**
   * The ID of the link for the second device.
   *
   * @schema ConnectionSpecInitProvider#connectedLinkId
   */
  readonly connectedLinkId?: string;

  /**
   * A description of the connection.
   *
   * @schema ConnectionSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the link for the first device.
   *
   * @schema ConnectionSpecInitProvider#linkId
   */
  readonly linkId?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ConnectionSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ConnectionSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecInitProvider(obj: ConnectionSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectedLinkId': obj.connectedLinkId,
    'description': obj.description,
    'linkId': obj.linkId,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema ConnectionSpecManagementPolicies
 */
export enum ConnectionSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema ConnectionSpecProviderConfigRef
 */
export interface ConnectionSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecProviderConfigRef#policy
   */
  readonly policy?: ConnectionSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRef(obj: ConnectionSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema ConnectionSpecPublishConnectionDetailsTo
 */
export interface ConnectionSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ConnectionSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ConnectionSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ConnectionSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsTo(obj: ConnectionSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema ConnectionSpecWriteConnectionSecretToRef
 */
export interface ConnectionSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ConnectionSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ConnectionSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecWriteConnectionSecretToRef(obj: ConnectionSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Device in networkmanager to populate connectedDeviceId.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdRef
 */
export interface ConnectionSpecForProviderConnectedDeviceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdRef#policy
   */
  readonly policy?: ConnectionSpecForProviderConnectedDeviceIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectedDeviceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectedDeviceIdRef(obj: ConnectionSpecForProviderConnectedDeviceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderConnectedDeviceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Device in networkmanager to populate connectedDeviceId.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdSelector
 */
export interface ConnectionSpecForProviderConnectedDeviceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectedDeviceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectedDeviceIdSelector(obj: ConnectionSpecForProviderConnectedDeviceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Device in networkmanager to populate deviceId.
 *
 * @schema ConnectionSpecForProviderDeviceIdRef
 */
export interface ConnectionSpecForProviderDeviceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderDeviceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderDeviceIdRef#policy
   */
  readonly policy?: ConnectionSpecForProviderDeviceIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderDeviceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderDeviceIdRef(obj: ConnectionSpecForProviderDeviceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderDeviceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Device in networkmanager to populate deviceId.
 *
 * @schema ConnectionSpecForProviderDeviceIdSelector
 */
export interface ConnectionSpecForProviderDeviceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderDeviceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderDeviceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderDeviceIdSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderDeviceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderDeviceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderDeviceIdSelector(obj: ConnectionSpecForProviderDeviceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderDeviceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdRef
 */
export interface ConnectionSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: ConnectionSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderGlobalNetworkIdRef(obj: ConnectionSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdSelector
 */
export interface ConnectionSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderGlobalNetworkIdSelector(obj: ConnectionSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecProviderConfigRefPolicy
 */
export interface ConnectionSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecProviderConfigRefPolicy(obj: ConnectionSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRef
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRef(obj: ConnectionSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToMetadata
 */
export interface ConnectionSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToMetadata(obj: ConnectionSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdRefPolicy
 */
export interface ConnectionSpecForProviderConnectedDeviceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderConnectedDeviceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderConnectedDeviceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectedDeviceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectedDeviceIdRefPolicy(obj: ConnectionSpecForProviderConnectedDeviceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy
 */
export interface ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderConnectedDeviceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderConnectedDeviceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy(obj: ConnectionSpecForProviderConnectedDeviceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderDeviceIdRefPolicy
 */
export interface ConnectionSpecForProviderDeviceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderDeviceIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderDeviceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderDeviceIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderDeviceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderDeviceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderDeviceIdRefPolicy(obj: ConnectionSpecForProviderDeviceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderDeviceIdSelectorPolicy
 */
export interface ConnectionSpecForProviderDeviceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderDeviceIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderDeviceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderDeviceIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderDeviceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderDeviceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderDeviceIdSelectorPolicy(obj: ConnectionSpecForProviderDeviceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface ConnectionSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderGlobalNetworkIdRefPolicy(obj: ConnectionSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: ConnectionSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: ConnectionSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy(obj: ConnectionSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolution
 */
export enum ConnectionSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecProviderConfigRefPolicyResolve
 */
export enum ConnectionSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ConnectionSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ConnectionSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConnectionSpecPublishConnectionDetailsToConfigRefPolicy(obj: ConnectionSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdRefPolicyResolution
 */
export enum ConnectionSpecForProviderConnectedDeviceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdRefPolicyResolve
 */
export enum ConnectionSpecForProviderConnectedDeviceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderConnectedDeviceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderConnectedDeviceIdSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderConnectedDeviceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderDeviceIdRefPolicyResolution
 */
export enum ConnectionSpecForProviderDeviceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderDeviceIdRefPolicyResolve
 */
export enum ConnectionSpecForProviderDeviceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderDeviceIdSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderDeviceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderDeviceIdSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderDeviceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum ConnectionSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum ConnectionSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum ConnectionSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum ConnectionSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ConnectionSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CoreNetwork is the Schema for the CoreNetworks API. Provides a core network resource.
 *
 * @schema CoreNetwork
 */
export class CoreNetwork extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CoreNetwork"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'CoreNetwork',
  }

  /**
   * Renders a Kubernetes manifest for "CoreNetwork".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CoreNetworkProps): any {
    return {
      ...CoreNetwork.GVK,
      ...toJson_CoreNetworkProps(props),
    };
  }

  /**
   * Defines a "CoreNetwork" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CoreNetworkProps) {
    super(scope, id, {
      ...CoreNetwork.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CoreNetwork.GVK,
      ...toJson_CoreNetworkProps(resolved),
    };
  }
}

/**
 * CoreNetwork is the Schema for the CoreNetworks API. Provides a core network resource.
 *
 * @schema CoreNetwork
 */
export interface CoreNetworkProps {
  /**
   * @schema CoreNetwork#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CoreNetworkSpec defines the desired state of CoreNetwork
   *
   * @schema CoreNetwork#spec
   */
  readonly spec: CoreNetworkSpec;

}

/**
 * Converts an object of type 'CoreNetworkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkProps(obj: CoreNetworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CoreNetworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CoreNetworkSpec defines the desired state of CoreNetwork
 *
 * @schema CoreNetworkSpec
 */
export interface CoreNetworkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CoreNetworkSpec#deletionPolicy
   */
  readonly deletionPolicy?: CoreNetworkSpecDeletionPolicy;

  /**
   * @schema CoreNetworkSpec#forProvider
   */
  readonly forProvider: CoreNetworkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CoreNetworkSpec#initProvider
   */
  readonly initProvider?: CoreNetworkSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CoreNetworkSpec#managementPolicies
   */
  readonly managementPolicies?: CoreNetworkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CoreNetworkSpec#providerConfigRef
   */
  readonly providerConfigRef?: CoreNetworkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CoreNetworkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CoreNetworkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CoreNetworkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CoreNetworkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CoreNetworkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpec(obj: CoreNetworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CoreNetworkSpecForProvider(obj.forProvider),
    'initProvider': toJson_CoreNetworkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CoreNetworkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CoreNetworkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CoreNetworkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CoreNetworkSpecDeletionPolicy
 */
export enum CoreNetworkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CoreNetworkSpecForProvider
 */
export interface CoreNetworkSpecForProvider {
  /**
   * The base policy created by setting the create_base_policy argument to true requires a region to be set in the edge-locations, location key. If base_policy_region is not specified, the region used in the base policy defaults to the region specified in the provider block.
   *
   * @schema CoreNetworkSpecForProvider#basePolicyRegion
   */
  readonly basePolicyRegion?: string;

  /**
   * A list of regions to add to the base policy. The base policy created by setting the create_base_policy argument to true requires one or more regions to be set in the edge-locations, location key. If base_policy_regions is not specified, the region used in the base policy defaults to the region specified in the provider block.
   *
   * @schema CoreNetworkSpecForProvider#basePolicyRegions
   */
  readonly basePolicyRegions?: string[];

  /**
   * Specifies whether to create a base policy when a core network is created or updated. A base policy is created and set to LIVE to allow attachments to the core network (e.g. VPC Attachments) before applying a policy document provided using the aws_networkmanager_core_network_policy_attachment resource. This base policy is needed if your core network does not have any LIVE policies (e.g. a core network resource created without the policy_document argument) and your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Valid values are true or false. Conflicts with policy_document. An example base policy is shown below. This base policy is overridden with the policy that you specify in the aws_networkmanager_core_network_policy_attachment resource.
   *
   * @schema CoreNetworkSpecForProvider#createBasePolicy
   */
  readonly createBasePolicy?: boolean;

  /**
   * Description of the Core Network.
   *
   * @schema CoreNetworkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the global network that a core network will be a part of.
   *
   * @schema CoreNetworkSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema CoreNetworkSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: CoreNetworkSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema CoreNetworkSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: CoreNetworkSpecForProviderGlobalNetworkIdSelector;

  /**
   * Policy document for creating a core network. Note that updating this argument will result in the new policy document version being set as the LATEST and LIVE policy document. Refer to the Core network policies documentation for more information. Conflicts with create_base_policy.
   *
   * @schema CoreNetworkSpecForProvider#policyDocument
   */
  readonly policyDocument?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CoreNetworkSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CoreNetworkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CoreNetworkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecForProvider(obj: CoreNetworkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basePolicyRegion': obj.basePolicyRegion,
    'basePolicyRegions': obj.basePolicyRegions?.map(y => y),
    'createBasePolicy': obj.createBasePolicy,
    'description': obj.description,
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_CoreNetworkSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_CoreNetworkSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'policyDocument': obj.policyDocument,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CoreNetworkSpecInitProvider
 */
export interface CoreNetworkSpecInitProvider {
  /**
   * The base policy created by setting the create_base_policy argument to true requires a region to be set in the edge-locations, location key. If base_policy_region is not specified, the region used in the base policy defaults to the region specified in the provider block.
   *
   * @schema CoreNetworkSpecInitProvider#basePolicyRegion
   */
  readonly basePolicyRegion?: string;

  /**
   * A list of regions to add to the base policy. The base policy created by setting the create_base_policy argument to true requires one or more regions to be set in the edge-locations, location key. If base_policy_regions is not specified, the region used in the base policy defaults to the region specified in the provider block.
   *
   * @schema CoreNetworkSpecInitProvider#basePolicyRegions
   */
  readonly basePolicyRegions?: string[];

  /**
   * Specifies whether to create a base policy when a core network is created or updated. A base policy is created and set to LIVE to allow attachments to the core network (e.g. VPC Attachments) before applying a policy document provided using the aws_networkmanager_core_network_policy_attachment resource. This base policy is needed if your core network does not have any LIVE policies (e.g. a core network resource created without the policy_document argument) and your policy document has static routes pointing to VPC attachments and you want to attach your VPCs to the core network before applying the desired policy document. Valid values are true or false. Conflicts with policy_document. An example base policy is shown below. This base policy is overridden with the policy that you specify in the aws_networkmanager_core_network_policy_attachment resource.
   *
   * @schema CoreNetworkSpecInitProvider#createBasePolicy
   */
  readonly createBasePolicy?: boolean;

  /**
   * Description of the Core Network.
   *
   * @schema CoreNetworkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Policy document for creating a core network. Note that updating this argument will result in the new policy document version being set as the LATEST and LIVE policy document. Refer to the Core network policies documentation for more information. Conflicts with create_base_policy.
   *
   * @schema CoreNetworkSpecInitProvider#policyDocument
   */
  readonly policyDocument?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema CoreNetworkSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'CoreNetworkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecInitProvider(obj: CoreNetworkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basePolicyRegion': obj.basePolicyRegion,
    'basePolicyRegions': obj.basePolicyRegions?.map(y => y),
    'createBasePolicy': obj.createBasePolicy,
    'description': obj.description,
    'policyDocument': obj.policyDocument,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CoreNetworkSpecManagementPolicies
 */
export enum CoreNetworkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CoreNetworkSpecProviderConfigRef
 */
export interface CoreNetworkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CoreNetworkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CoreNetworkSpecProviderConfigRef#policy
   */
  readonly policy?: CoreNetworkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CoreNetworkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecProviderConfigRef(obj: CoreNetworkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CoreNetworkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CoreNetworkSpecPublishConnectionDetailsTo
 */
export interface CoreNetworkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CoreNetworkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CoreNetworkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CoreNetworkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecPublishConnectionDetailsTo(obj: CoreNetworkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CoreNetworkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CoreNetworkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CoreNetworkSpecWriteConnectionSecretToRef
 */
export interface CoreNetworkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CoreNetworkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CoreNetworkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CoreNetworkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecWriteConnectionSecretToRef(obj: CoreNetworkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdRef
 */
export interface CoreNetworkSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'CoreNetworkSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecForProviderGlobalNetworkIdRef(obj: CoreNetworkSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelector
 */
export interface CoreNetworkSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'CoreNetworkSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecForProviderGlobalNetworkIdSelector(obj: CoreNetworkSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CoreNetworkSpecProviderConfigRefPolicy
 */
export interface CoreNetworkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CoreNetworkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CoreNetworkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CoreNetworkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CoreNetworkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CoreNetworkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecProviderConfigRefPolicy(obj: CoreNetworkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRef
 */
export interface CoreNetworkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CoreNetworkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecPublishConnectionDetailsToConfigRef(obj: CoreNetworkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CoreNetworkSpecPublishConnectionDetailsToMetadata
 */
export interface CoreNetworkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CoreNetworkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecPublishConnectionDetailsToMetadata(obj: CoreNetworkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: CoreNetworkSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: CoreNetworkSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy(obj: CoreNetworkSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy(obj: CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CoreNetworkSpecProviderConfigRefPolicyResolution
 */
export enum CoreNetworkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CoreNetworkSpecProviderConfigRefPolicyResolve
 */
export enum CoreNetworkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy(obj: CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum CoreNetworkSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum CoreNetworkSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum CoreNetworkSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CoreNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CustomerGatewayAssociation is the Schema for the CustomerGatewayAssociations API. Associates a customer gateway with a device and optionally, with a link.
 *
 * @schema CustomerGatewayAssociation
 */
export class CustomerGatewayAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomerGatewayAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'CustomerGatewayAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "CustomerGatewayAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomerGatewayAssociationProps): any {
    return {
      ...CustomerGatewayAssociation.GVK,
      ...toJson_CustomerGatewayAssociationProps(props),
    };
  }

  /**
   * Defines a "CustomerGatewayAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomerGatewayAssociationProps) {
    super(scope, id, {
      ...CustomerGatewayAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomerGatewayAssociation.GVK,
      ...toJson_CustomerGatewayAssociationProps(resolved),
    };
  }
}

/**
 * CustomerGatewayAssociation is the Schema for the CustomerGatewayAssociations API. Associates a customer gateway with a device and optionally, with a link.
 *
 * @schema CustomerGatewayAssociation
 */
export interface CustomerGatewayAssociationProps {
  /**
   * @schema CustomerGatewayAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomerGatewayAssociationSpec defines the desired state of CustomerGatewayAssociation
   *
   * @schema CustomerGatewayAssociation#spec
   */
  readonly spec: CustomerGatewayAssociationSpec;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationProps(obj: CustomerGatewayAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomerGatewayAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomerGatewayAssociationSpec defines the desired state of CustomerGatewayAssociation
 *
 * @schema CustomerGatewayAssociationSpec
 */
export interface CustomerGatewayAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomerGatewayAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: CustomerGatewayAssociationSpecDeletionPolicy;

  /**
   * @schema CustomerGatewayAssociationSpec#forProvider
   */
  readonly forProvider: CustomerGatewayAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema CustomerGatewayAssociationSpec#initProvider
   */
  readonly initProvider?: CustomerGatewayAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CustomerGatewayAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: CustomerGatewayAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema CustomerGatewayAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: CustomerGatewayAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema CustomerGatewayAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomerGatewayAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema CustomerGatewayAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomerGatewayAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpec(obj: CustomerGatewayAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomerGatewayAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_CustomerGatewayAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CustomerGatewayAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomerGatewayAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomerGatewayAssociationSpecDeletionPolicy
 */
export enum CustomerGatewayAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomerGatewayAssociationSpecForProvider
 */
export interface CustomerGatewayAssociationSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the customer gateway.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#customerGatewayArn
   */
  readonly customerGatewayArn?: string;

  /**
   * Reference to a CustomerGateway in ec2 to populate customerGatewayArn.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#customerGatewayArnRef
   */
  readonly customerGatewayArnRef?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef;

  /**
   * Selector for a CustomerGateway in ec2 to populate customerGatewayArn.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#customerGatewayArnSelector
   */
  readonly customerGatewayArnSelector?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector;

  /**
   * The ID of the device.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#deviceId
   */
  readonly deviceId?: string;

  /**
   * Reference to a Device in networkmanager to populate deviceId.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#deviceIdRef
   */
  readonly deviceIdRef?: CustomerGatewayAssociationSpecForProviderDeviceIdRef;

  /**
   * Selector for a Device in networkmanager to populate deviceId.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#deviceIdSelector
   */
  readonly deviceIdSelector?: CustomerGatewayAssociationSpecForProviderDeviceIdSelector;

  /**
   * The ID of the global network.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector;

  /**
   * The ID of the link.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#linkId
   */
  readonly linkId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CustomerGatewayAssociationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProvider(obj: CustomerGatewayAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerGatewayArn': obj.customerGatewayArn,
    'customerGatewayArnRef': toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef(obj.customerGatewayArnRef),
    'customerGatewayArnSelector': toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector(obj.customerGatewayArnSelector),
    'deviceId': obj.deviceId,
    'deviceIdRef': toJson_CustomerGatewayAssociationSpecForProviderDeviceIdRef(obj.deviceIdRef),
    'deviceIdSelector': toJson_CustomerGatewayAssociationSpecForProviderDeviceIdSelector(obj.deviceIdSelector),
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'linkId': obj.linkId,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema CustomerGatewayAssociationSpecInitProvider
 */
export interface CustomerGatewayAssociationSpecInitProvider {
  /**
   * The ID of the link.
   *
   * @schema CustomerGatewayAssociationSpecInitProvider#linkId
   */
  readonly linkId?: string;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecInitProvider(obj: CustomerGatewayAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linkId': obj.linkId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema CustomerGatewayAssociationSpecManagementPolicies
 */
export enum CustomerGatewayAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema CustomerGatewayAssociationSpecProviderConfigRef
 */
export interface CustomerGatewayAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerGatewayAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerGatewayAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecProviderConfigRef(obj: CustomerGatewayAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerGatewayAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsTo
 */
export interface CustomerGatewayAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsTo(obj: CustomerGatewayAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema CustomerGatewayAssociationSpecWriteConnectionSecretToRef
 */
export interface CustomerGatewayAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomerGatewayAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomerGatewayAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecWriteConnectionSecretToRef(obj: CustomerGatewayAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CustomerGateway in ec2 to populate customerGatewayArn.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef
 */
export interface CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef(obj: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CustomerGateway in ec2 to populate customerGatewayArn.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector
 */
export interface CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector(obj: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Device in networkmanager to populate deviceId.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRef
 */
export interface CustomerGatewayAssociationSpecForProviderDeviceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRef#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderDeviceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderDeviceIdRef(obj: CustomerGatewayAssociationSpecForProviderDeviceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Device in networkmanager to populate deviceId.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelector
 */
export interface CustomerGatewayAssociationSpecForProviderDeviceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelector#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderDeviceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderDeviceIdSelector(obj: CustomerGatewayAssociationSpecForProviderDeviceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef
 */
export interface CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef(obj: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector
 */
export interface CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector(obj: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerGatewayAssociationSpecProviderConfigRefPolicy
 */
export interface CustomerGatewayAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecProviderConfigRefPolicy(obj: CustomerGatewayAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef(obj: CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata(obj: CustomerGatewayAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy
 */
export interface CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy(obj: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy
 */
export interface CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy(obj: CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy
 */
export interface CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy(obj: CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy
 */
export interface CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy(obj: CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy(obj: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy(obj: CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecProviderConfigRefPolicyResolution
 */
export enum CustomerGatewayAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecProviderConfigRefPolicyResolve
 */
export enum CustomerGatewayAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicyResolution
 */
export enum CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicyResolve
 */
export enum CustomerGatewayAssociationSpecForProviderCustomerGatewayArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicyResolution
 */
export enum CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicyResolve
 */
export enum CustomerGatewayAssociationSpecForProviderCustomerGatewayArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicyResolution
 */
export enum CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicyResolve
 */
export enum CustomerGatewayAssociationSpecForProviderDeviceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicyResolution
 */
export enum CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicyResolve
 */
export enum CustomerGatewayAssociationSpecForProviderDeviceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum CustomerGatewayAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum CustomerGatewayAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomerGatewayAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Device is the Schema for the Devices API. Creates a device in a global network.
 *
 * @schema Device
 */
export class Device extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Device"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'Device',
  }

  /**
   * Renders a Kubernetes manifest for "Device".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: DeviceProps): any {
    return {
      ...Device.GVK,
      ...toJson_DeviceProps(props),
    };
  }

  /**
   * Defines a "Device" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: DeviceProps) {
    super(scope, id, {
      ...Device.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Device.GVK,
      ...toJson_DeviceProps(resolved),
    };
  }
}

/**
 * Device is the Schema for the Devices API. Creates a device in a global network.
 *
 * @schema Device
 */
export interface DeviceProps {
  /**
   * @schema Device#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DeviceSpec defines the desired state of Device
   *
   * @schema Device#spec
   */
  readonly spec: DeviceSpec;

}

/**
 * Converts an object of type 'DeviceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceProps(obj: DeviceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DeviceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeviceSpec defines the desired state of Device
 *
 * @schema DeviceSpec
 */
export interface DeviceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DeviceSpec#deletionPolicy
   */
  readonly deletionPolicy?: DeviceSpecDeletionPolicy;

  /**
   * @schema DeviceSpec#forProvider
   */
  readonly forProvider: DeviceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema DeviceSpec#initProvider
   */
  readonly initProvider?: DeviceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DeviceSpec#managementPolicies
   */
  readonly managementPolicies?: DeviceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema DeviceSpec#providerConfigRef
   */
  readonly providerConfigRef?: DeviceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema DeviceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DeviceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema DeviceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DeviceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DeviceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpec(obj: DeviceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DeviceSpecForProvider(obj.forProvider),
    'initProvider': toJson_DeviceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DeviceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DeviceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DeviceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DeviceSpecDeletionPolicy
 */
export enum DeviceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DeviceSpecForProvider
 */
export interface DeviceSpecForProvider {
  /**
   * The AWS location of the device. Documented below.
   *
   * @schema DeviceSpecForProvider#awsLocation
   */
  readonly awsLocation?: DeviceSpecForProviderAwsLocation[];

  /**
   * A description of the device.
   *
   * @schema DeviceSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the global network.
   *
   * @schema DeviceSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema DeviceSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: DeviceSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema DeviceSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: DeviceSpecForProviderGlobalNetworkIdSelector;

  /**
   * The location of the device. Documented below.
   *
   * @schema DeviceSpecForProvider#location
   */
  readonly location?: DeviceSpecForProviderLocation[];

  /**
   * The model of device.
   *
   * @schema DeviceSpecForProvider#model
   */
  readonly model?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DeviceSpecForProvider#region
   */
  readonly region: string;

  /**
   * The serial number of the device.
   *
   * @schema DeviceSpecForProvider#serialNumber
   */
  readonly serialNumber?: string;

  /**
   * The ID of the site.
   *
   * @schema DeviceSpecForProvider#siteId
   */
  readonly siteId?: string;

  /**
   * Reference to a Site in networkmanager to populate siteId.
   *
   * @schema DeviceSpecForProvider#siteIdRef
   */
  readonly siteIdRef?: DeviceSpecForProviderSiteIdRef;

  /**
   * Selector for a Site in networkmanager to populate siteId.
   *
   * @schema DeviceSpecForProvider#siteIdSelector
   */
  readonly siteIdSelector?: DeviceSpecForProviderSiteIdSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema DeviceSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of device.
   *
   * @schema DeviceSpecForProvider#type
   */
  readonly type?: string;

  /**
   * The vendor of the device.
   *
   * @schema DeviceSpecForProvider#vendor
   */
  readonly vendor?: string;

}

/**
 * Converts an object of type 'DeviceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProvider(obj: DeviceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsLocation': obj.awsLocation?.map(y => toJson_DeviceSpecForProviderAwsLocation(y)),
    'description': obj.description,
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_DeviceSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_DeviceSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'location': obj.location?.map(y => toJson_DeviceSpecForProviderLocation(y)),
    'model': obj.model,
    'region': obj.region,
    'serialNumber': obj.serialNumber,
    'siteId': obj.siteId,
    'siteIdRef': toJson_DeviceSpecForProviderSiteIdRef(obj.siteIdRef),
    'siteIdSelector': toJson_DeviceSpecForProviderSiteIdSelector(obj.siteIdSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'vendor': obj.vendor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema DeviceSpecInitProvider
 */
export interface DeviceSpecInitProvider {
  /**
   * The AWS location of the device. Documented below.
   *
   * @schema DeviceSpecInitProvider#awsLocation
   */
  readonly awsLocation?: DeviceSpecInitProviderAwsLocation[];

  /**
   * A description of the device.
   *
   * @schema DeviceSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The location of the device. Documented below.
   *
   * @schema DeviceSpecInitProvider#location
   */
  readonly location?: DeviceSpecInitProviderLocation[];

  /**
   * The model of device.
   *
   * @schema DeviceSpecInitProvider#model
   */
  readonly model?: string;

  /**
   * The serial number of the device.
   *
   * @schema DeviceSpecInitProvider#serialNumber
   */
  readonly serialNumber?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema DeviceSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of device.
   *
   * @schema DeviceSpecInitProvider#type
   */
  readonly type?: string;

  /**
   * The vendor of the device.
   *
   * @schema DeviceSpecInitProvider#vendor
   */
  readonly vendor?: string;

}

/**
 * Converts an object of type 'DeviceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecInitProvider(obj: DeviceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsLocation': obj.awsLocation?.map(y => toJson_DeviceSpecInitProviderAwsLocation(y)),
    'description': obj.description,
    'location': obj.location?.map(y => toJson_DeviceSpecInitProviderLocation(y)),
    'model': obj.model,
    'serialNumber': obj.serialNumber,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
    'vendor': obj.vendor,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema DeviceSpecManagementPolicies
 */
export enum DeviceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema DeviceSpecProviderConfigRef
 */
export interface DeviceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecProviderConfigRef#policy
   */
  readonly policy?: DeviceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderConfigRef(obj: DeviceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema DeviceSpecPublishConnectionDetailsTo
 */
export interface DeviceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DeviceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DeviceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DeviceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsTo(obj: DeviceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DeviceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DeviceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema DeviceSpecWriteConnectionSecretToRef
 */
export interface DeviceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DeviceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DeviceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DeviceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecWriteConnectionSecretToRef(obj: DeviceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecForProviderAwsLocation
 */
export interface DeviceSpecForProviderAwsLocation {
  /**
   * The Amazon Resource Name (ARN) of the subnet that the device is located in.
   *
   * @schema DeviceSpecForProviderAwsLocation#subnetArn
   */
  readonly subnetArn?: string;

  /**
   * The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
   *
   * @schema DeviceSpecForProviderAwsLocation#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'DeviceSpecForProviderAwsLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderAwsLocation(obj: DeviceSpecForProviderAwsLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subnetArn': obj.subnetArn,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdRef
 */
export interface DeviceSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: DeviceSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderGlobalNetworkIdRef(obj: DeviceSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdSelector
 */
export interface DeviceSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: DeviceSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderGlobalNetworkIdSelector(obj: DeviceSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeviceSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecForProviderLocation
 */
export interface DeviceSpecForProviderLocation {
  /**
   * The physical address.
   *
   * @schema DeviceSpecForProviderLocation#address
   */
  readonly address?: string;

  /**
   * The latitude.
   *
   * @schema DeviceSpecForProviderLocation#latitude
   */
  readonly latitude?: string;

  /**
   * The longitude.
   *
   * @schema DeviceSpecForProviderLocation#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'DeviceSpecForProviderLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderLocation(obj: DeviceSpecForProviderLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Site in networkmanager to populate siteId.
 *
 * @schema DeviceSpecForProviderSiteIdRef
 */
export interface DeviceSpecForProviderSiteIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecForProviderSiteIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecForProviderSiteIdRef#policy
   */
  readonly policy?: DeviceSpecForProviderSiteIdRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderSiteIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderSiteIdRef(obj: DeviceSpecForProviderSiteIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecForProviderSiteIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Site in networkmanager to populate siteId.
 *
 * @schema DeviceSpecForProviderSiteIdSelector
 */
export interface DeviceSpecForProviderSiteIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema DeviceSpecForProviderSiteIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema DeviceSpecForProviderSiteIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema DeviceSpecForProviderSiteIdSelector#policy
   */
  readonly policy?: DeviceSpecForProviderSiteIdSelectorPolicy;

}

/**
 * Converts an object of type 'DeviceSpecForProviderSiteIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderSiteIdSelector(obj: DeviceSpecForProviderSiteIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_DeviceSpecForProviderSiteIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecInitProviderAwsLocation
 */
export interface DeviceSpecInitProviderAwsLocation {
  /**
   * The Amazon Resource Name (ARN) of the subnet that the device is located in.
   *
   * @schema DeviceSpecInitProviderAwsLocation#subnetArn
   */
  readonly subnetArn?: string;

  /**
   * The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
   *
   * @schema DeviceSpecInitProviderAwsLocation#zone
   */
  readonly zone?: string;

}

/**
 * Converts an object of type 'DeviceSpecInitProviderAwsLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecInitProviderAwsLocation(obj: DeviceSpecInitProviderAwsLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'subnetArn': obj.subnetArn,
    'zone': obj.zone,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema DeviceSpecInitProviderLocation
 */
export interface DeviceSpecInitProviderLocation {
  /**
   * The physical address.
   *
   * @schema DeviceSpecInitProviderLocation#address
   */
  readonly address?: string;

  /**
   * The latitude.
   *
   * @schema DeviceSpecInitProviderLocation#latitude
   */
  readonly latitude?: string;

  /**
   * The longitude.
   *
   * @schema DeviceSpecInitProviderLocation#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'DeviceSpecInitProviderLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecInitProviderLocation(obj: DeviceSpecInitProviderLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecProviderConfigRefPolicy
 */
export interface DeviceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecProviderConfigRefPolicy(obj: DeviceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRef
 */
export interface DeviceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DeviceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToConfigRef(obj: DeviceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DeviceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DeviceSpecPublishConnectionDetailsToMetadata
 */
export interface DeviceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema DeviceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToMetadata(obj: DeviceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface DeviceSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderGlobalNetworkIdRefPolicy(obj: DeviceSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface DeviceSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderGlobalNetworkIdSelectorPolicy(obj: DeviceSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecForProviderSiteIdRefPolicy
 */
export interface DeviceSpecForProviderSiteIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderSiteIdRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderSiteIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderSiteIdRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderSiteIdRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderSiteIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderSiteIdRefPolicy(obj: DeviceSpecForProviderSiteIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema DeviceSpecForProviderSiteIdSelectorPolicy
 */
export interface DeviceSpecForProviderSiteIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecForProviderSiteIdSelectorPolicy#resolution
   */
  readonly resolution?: DeviceSpecForProviderSiteIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecForProviderSiteIdSelectorPolicy#resolve
   */
  readonly resolve?: DeviceSpecForProviderSiteIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecForProviderSiteIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecForProviderSiteIdSelectorPolicy(obj: DeviceSpecForProviderSiteIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecProviderConfigRefPolicyResolution
 */
export enum DeviceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecProviderConfigRefPolicyResolve
 */
export enum DeviceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DeviceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DeviceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DeviceSpecPublishConnectionDetailsToConfigRefPolicy(obj: DeviceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum DeviceSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum DeviceSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum DeviceSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum DeviceSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderSiteIdRefPolicyResolution
 */
export enum DeviceSpecForProviderSiteIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderSiteIdRefPolicyResolve
 */
export enum DeviceSpecForProviderSiteIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecForProviderSiteIdSelectorPolicyResolution
 */
export enum DeviceSpecForProviderSiteIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecForProviderSiteIdSelectorPolicyResolve
 */
export enum DeviceSpecForProviderSiteIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DeviceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GlobalNetwork is the Schema for the GlobalNetworks API. Provides a global network resource.
 *
 * @schema GlobalNetwork
 */
export class GlobalNetwork extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GlobalNetwork"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'GlobalNetwork',
  }

  /**
   * Renders a Kubernetes manifest for "GlobalNetwork".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GlobalNetworkProps): any {
    return {
      ...GlobalNetwork.GVK,
      ...toJson_GlobalNetworkProps(props),
    };
  }

  /**
   * Defines a "GlobalNetwork" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GlobalNetworkProps) {
    super(scope, id, {
      ...GlobalNetwork.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GlobalNetwork.GVK,
      ...toJson_GlobalNetworkProps(resolved),
    };
  }
}

/**
 * GlobalNetwork is the Schema for the GlobalNetworks API. Provides a global network resource.
 *
 * @schema GlobalNetwork
 */
export interface GlobalNetworkProps {
  /**
   * @schema GlobalNetwork#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GlobalNetworkSpec defines the desired state of GlobalNetwork
   *
   * @schema GlobalNetwork#spec
   */
  readonly spec: GlobalNetworkSpec;

}

/**
 * Converts an object of type 'GlobalNetworkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkProps(obj: GlobalNetworkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GlobalNetworkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GlobalNetworkSpec defines the desired state of GlobalNetwork
 *
 * @schema GlobalNetworkSpec
 */
export interface GlobalNetworkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GlobalNetworkSpec#deletionPolicy
   */
  readonly deletionPolicy?: GlobalNetworkSpecDeletionPolicy;

  /**
   * @schema GlobalNetworkSpec#forProvider
   */
  readonly forProvider: GlobalNetworkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema GlobalNetworkSpec#initProvider
   */
  readonly initProvider?: GlobalNetworkSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GlobalNetworkSpec#managementPolicies
   */
  readonly managementPolicies?: GlobalNetworkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema GlobalNetworkSpec#providerConfigRef
   */
  readonly providerConfigRef?: GlobalNetworkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema GlobalNetworkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GlobalNetworkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema GlobalNetworkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GlobalNetworkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GlobalNetworkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpec(obj: GlobalNetworkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GlobalNetworkSpecForProvider(obj.forProvider),
    'initProvider': toJson_GlobalNetworkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GlobalNetworkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GlobalNetworkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GlobalNetworkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GlobalNetworkSpecDeletionPolicy
 */
export enum GlobalNetworkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GlobalNetworkSpecForProvider
 */
export interface GlobalNetworkSpecForProvider {
  /**
   * Description of the Global Network.
   *
   * @schema GlobalNetworkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GlobalNetworkSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GlobalNetworkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'GlobalNetworkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecForProvider(obj: GlobalNetworkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema GlobalNetworkSpecInitProvider
 */
export interface GlobalNetworkSpecInitProvider {
  /**
   * Description of the Global Network.
   *
   * @schema GlobalNetworkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema GlobalNetworkSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'GlobalNetworkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecInitProvider(obj: GlobalNetworkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema GlobalNetworkSpecManagementPolicies
 */
export enum GlobalNetworkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema GlobalNetworkSpecProviderConfigRef
 */
export interface GlobalNetworkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalNetworkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalNetworkSpecProviderConfigRef#policy
   */
  readonly policy?: GlobalNetworkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalNetworkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecProviderConfigRef(obj: GlobalNetworkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalNetworkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema GlobalNetworkSpecPublishConnectionDetailsTo
 */
export interface GlobalNetworkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GlobalNetworkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GlobalNetworkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GlobalNetworkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecPublishConnectionDetailsTo(obj: GlobalNetworkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GlobalNetworkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GlobalNetworkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema GlobalNetworkSpecWriteConnectionSecretToRef
 */
export interface GlobalNetworkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GlobalNetworkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GlobalNetworkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GlobalNetworkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecWriteConnectionSecretToRef(obj: GlobalNetworkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GlobalNetworkSpecProviderConfigRefPolicy
 */
export interface GlobalNetworkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalNetworkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalNetworkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalNetworkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalNetworkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalNetworkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecProviderConfigRefPolicy(obj: GlobalNetworkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRef
 */
export interface GlobalNetworkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GlobalNetworkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecPublishConnectionDetailsToConfigRef(obj: GlobalNetworkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GlobalNetworkSpecPublishConnectionDetailsToMetadata
 */
export interface GlobalNetworkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GlobalNetworkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecPublishConnectionDetailsToMetadata(obj: GlobalNetworkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalNetworkSpecProviderConfigRefPolicyResolution
 */
export enum GlobalNetworkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalNetworkSpecProviderConfigRefPolicyResolve
 */
export enum GlobalNetworkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy(obj: GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GlobalNetworkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Link is the Schema for the Links API. Creates a link for a site.
 *
 * @schema Link
 */
export class Link extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Link"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'Link',
  }

  /**
   * Renders a Kubernetes manifest for "Link".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LinkProps): any {
    return {
      ...Link.GVK,
      ...toJson_LinkProps(props),
    };
  }

  /**
   * Defines a "Link" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LinkProps) {
    super(scope, id, {
      ...Link.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Link.GVK,
      ...toJson_LinkProps(resolved),
    };
  }
}

/**
 * Link is the Schema for the Links API. Creates a link for a site.
 *
 * @schema Link
 */
export interface LinkProps {
  /**
   * @schema Link#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LinkSpec defines the desired state of Link
   *
   * @schema Link#spec
   */
  readonly spec: LinkSpec;

}

/**
 * Converts an object of type 'LinkProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkProps(obj: LinkProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LinkSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LinkSpec defines the desired state of Link
 *
 * @schema LinkSpec
 */
export interface LinkSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LinkSpec#deletionPolicy
   */
  readonly deletionPolicy?: LinkSpecDeletionPolicy;

  /**
   * @schema LinkSpec#forProvider
   */
  readonly forProvider: LinkSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LinkSpec#initProvider
   */
  readonly initProvider?: LinkSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LinkSpec#managementPolicies
   */
  readonly managementPolicies?: LinkSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LinkSpec#providerConfigRef
   */
  readonly providerConfigRef?: LinkSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LinkSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LinkSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LinkSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LinkSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LinkSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpec(obj: LinkSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LinkSpecForProvider(obj.forProvider),
    'initProvider': toJson_LinkSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LinkSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LinkSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LinkSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LinkSpecDeletionPolicy
 */
export enum LinkSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LinkSpecForProvider
 */
export interface LinkSpecForProvider {
  /**
   * The upload speed and download speed in Mbps. Documented below.
   *
   * @schema LinkSpecForProvider#bandwidth
   */
  readonly bandwidth?: LinkSpecForProviderBandwidth[];

  /**
   * A description of the link.
   *
   * @schema LinkSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the global network.
   *
   * @schema LinkSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema LinkSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: LinkSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema LinkSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: LinkSpecForProviderGlobalNetworkIdSelector;

  /**
   * The provider of the link.
   *
   * @schema LinkSpecForProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LinkSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the site.
   *
   * @schema LinkSpecForProvider#siteId
   */
  readonly siteId?: string;

  /**
   * Reference to a Site to populate siteId.
   *
   * @schema LinkSpecForProvider#siteIdRef
   */
  readonly siteIdRef?: LinkSpecForProviderSiteIdRef;

  /**
   * Selector for a Site to populate siteId.
   *
   * @schema LinkSpecForProvider#siteIdSelector
   */
  readonly siteIdSelector?: LinkSpecForProviderSiteIdSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema LinkSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of the link.
   *
   * @schema LinkSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LinkSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProvider(obj: LinkSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bandwidth': obj.bandwidth?.map(y => toJson_LinkSpecForProviderBandwidth(y)),
    'description': obj.description,
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_LinkSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_LinkSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'providerName': obj.providerName,
    'region': obj.region,
    'siteId': obj.siteId,
    'siteIdRef': toJson_LinkSpecForProviderSiteIdRef(obj.siteIdRef),
    'siteIdSelector': toJson_LinkSpecForProviderSiteIdSelector(obj.siteIdSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema LinkSpecInitProvider
 */
export interface LinkSpecInitProvider {
  /**
   * The upload speed and download speed in Mbps. Documented below.
   *
   * @schema LinkSpecInitProvider#bandwidth
   */
  readonly bandwidth?: LinkSpecInitProviderBandwidth[];

  /**
   * A description of the link.
   *
   * @schema LinkSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The provider of the link.
   *
   * @schema LinkSpecInitProvider#providerName
   */
  readonly providerName?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema LinkSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The type of the link.
   *
   * @schema LinkSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LinkSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecInitProvider(obj: LinkSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bandwidth': obj.bandwidth?.map(y => toJson_LinkSpecInitProviderBandwidth(y)),
    'description': obj.description,
    'providerName': obj.providerName,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LinkSpecManagementPolicies
 */
export enum LinkSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LinkSpecProviderConfigRef
 */
export interface LinkSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkSpecProviderConfigRef#policy
   */
  readonly policy?: LinkSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LinkSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecProviderConfigRef(obj: LinkSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LinkSpecPublishConnectionDetailsTo
 */
export interface LinkSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LinkSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LinkSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LinkSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LinkSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LinkSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LinkSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecPublishConnectionDetailsTo(obj: LinkSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LinkSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LinkSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LinkSpecWriteConnectionSecretToRef
 */
export interface LinkSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LinkSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LinkSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LinkSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecWriteConnectionSecretToRef(obj: LinkSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinkSpecForProviderBandwidth
 */
export interface LinkSpecForProviderBandwidth {
  /**
   * Download speed in Mbps.
   *
   * @schema LinkSpecForProviderBandwidth#downloadSpeed
   */
  readonly downloadSpeed?: number;

  /**
   * Upload speed in Mbps.
   *
   * @schema LinkSpecForProviderBandwidth#uploadSpeed
   */
  readonly uploadSpeed?: number;

}

/**
 * Converts an object of type 'LinkSpecForProviderBandwidth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderBandwidth(obj: LinkSpecForProviderBandwidth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downloadSpeed': obj.downloadSpeed,
    'uploadSpeed': obj.uploadSpeed,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdRef
 */
export interface LinkSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: LinkSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'LinkSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderGlobalNetworkIdRef(obj: LinkSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdSelector
 */
export interface LinkSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: LinkSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'LinkSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderGlobalNetworkIdSelector(obj: LinkSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LinkSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Site to populate siteId.
 *
 * @schema LinkSpecForProviderSiteIdRef
 */
export interface LinkSpecForProviderSiteIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkSpecForProviderSiteIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkSpecForProviderSiteIdRef#policy
   */
  readonly policy?: LinkSpecForProviderSiteIdRefPolicy;

}

/**
 * Converts an object of type 'LinkSpecForProviderSiteIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderSiteIdRef(obj: LinkSpecForProviderSiteIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkSpecForProviderSiteIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Site to populate siteId.
 *
 * @schema LinkSpecForProviderSiteIdSelector
 */
export interface LinkSpecForProviderSiteIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LinkSpecForProviderSiteIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LinkSpecForProviderSiteIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LinkSpecForProviderSiteIdSelector#policy
   */
  readonly policy?: LinkSpecForProviderSiteIdSelectorPolicy;

}

/**
 * Converts an object of type 'LinkSpecForProviderSiteIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderSiteIdSelector(obj: LinkSpecForProviderSiteIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LinkSpecForProviderSiteIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema LinkSpecInitProviderBandwidth
 */
export interface LinkSpecInitProviderBandwidth {
  /**
   * Download speed in Mbps.
   *
   * @schema LinkSpecInitProviderBandwidth#downloadSpeed
   */
  readonly downloadSpeed?: number;

  /**
   * Upload speed in Mbps.
   *
   * @schema LinkSpecInitProviderBandwidth#uploadSpeed
   */
  readonly uploadSpeed?: number;

}

/**
 * Converts an object of type 'LinkSpecInitProviderBandwidth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecInitProviderBandwidth(obj: LinkSpecInitProviderBandwidth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'downloadSpeed': obj.downloadSpeed,
    'uploadSpeed': obj.uploadSpeed,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LinkSpecProviderConfigRefPolicy
 */
export interface LinkSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LinkSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LinkSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecProviderConfigRefPolicy(obj: LinkSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LinkSpecPublishConnectionDetailsToConfigRef
 */
export interface LinkSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LinkSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LinkSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecPublishConnectionDetailsToConfigRef(obj: LinkSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LinkSpecPublishConnectionDetailsToMetadata
 */
export interface LinkSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LinkSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LinkSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LinkSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LinkSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecPublishConnectionDetailsToMetadata(obj: LinkSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface LinkSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: LinkSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: LinkSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderGlobalNetworkIdRefPolicy(obj: LinkSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface LinkSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: LinkSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: LinkSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LinkSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderGlobalNetworkIdSelectorPolicy(obj: LinkSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LinkSpecForProviderSiteIdRefPolicy
 */
export interface LinkSpecForProviderSiteIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkSpecForProviderSiteIdRefPolicy#resolution
   */
  readonly resolution?: LinkSpecForProviderSiteIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkSpecForProviderSiteIdRefPolicy#resolve
   */
  readonly resolve?: LinkSpecForProviderSiteIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkSpecForProviderSiteIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderSiteIdRefPolicy(obj: LinkSpecForProviderSiteIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LinkSpecForProviderSiteIdSelectorPolicy
 */
export interface LinkSpecForProviderSiteIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkSpecForProviderSiteIdSelectorPolicy#resolution
   */
  readonly resolution?: LinkSpecForProviderSiteIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkSpecForProviderSiteIdSelectorPolicy#resolve
   */
  readonly resolve?: LinkSpecForProviderSiteIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LinkSpecForProviderSiteIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecForProviderSiteIdSelectorPolicy(obj: LinkSpecForProviderSiteIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkSpecProviderConfigRefPolicyResolution
 */
export enum LinkSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkSpecProviderConfigRefPolicyResolve
 */
export enum LinkSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LinkSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LinkSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LinkSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LinkSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkSpecPublishConnectionDetailsToConfigRefPolicy(obj: LinkSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum LinkSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum LinkSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum LinkSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum LinkSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkSpecForProviderSiteIdRefPolicyResolution
 */
export enum LinkSpecForProviderSiteIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkSpecForProviderSiteIdRefPolicyResolve
 */
export enum LinkSpecForProviderSiteIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkSpecForProviderSiteIdSelectorPolicyResolution
 */
export enum LinkSpecForProviderSiteIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkSpecForProviderSiteIdSelectorPolicyResolve
 */
export enum LinkSpecForProviderSiteIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LinkSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LinkSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * LinkAssociation is the Schema for the LinkAssociations API. Associates a link to a device.
 *
 * @schema LinkAssociation
 */
export class LinkAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "LinkAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'LinkAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "LinkAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LinkAssociationProps): any {
    return {
      ...LinkAssociation.GVK,
      ...toJson_LinkAssociationProps(props),
    };
  }

  /**
   * Defines a "LinkAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LinkAssociationProps) {
    super(scope, id, {
      ...LinkAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...LinkAssociation.GVK,
      ...toJson_LinkAssociationProps(resolved),
    };
  }
}

/**
 * LinkAssociation is the Schema for the LinkAssociations API. Associates a link to a device.
 *
 * @schema LinkAssociation
 */
export interface LinkAssociationProps {
  /**
   * @schema LinkAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * LinkAssociationSpec defines the desired state of LinkAssociation
   *
   * @schema LinkAssociation#spec
   */
  readonly spec: LinkAssociationSpec;

}

/**
 * Converts an object of type 'LinkAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationProps(obj: LinkAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LinkAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * LinkAssociationSpec defines the desired state of LinkAssociation
 *
 * @schema LinkAssociationSpec
 */
export interface LinkAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema LinkAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: LinkAssociationSpecDeletionPolicy;

  /**
   * @schema LinkAssociationSpec#forProvider
   */
  readonly forProvider: LinkAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema LinkAssociationSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema LinkAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: LinkAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema LinkAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: LinkAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema LinkAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: LinkAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema LinkAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: LinkAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'LinkAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpec(obj: LinkAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_LinkAssociationSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_LinkAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_LinkAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_LinkAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema LinkAssociationSpecDeletionPolicy
 */
export enum LinkAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema LinkAssociationSpecForProvider
 */
export interface LinkAssociationSpecForProvider {
  /**
   * The ID of the device.
   *
   * @schema LinkAssociationSpecForProvider#deviceId
   */
  readonly deviceId?: string;

  /**
   * Reference to a Device to populate deviceId.
   *
   * @schema LinkAssociationSpecForProvider#deviceIdRef
   */
  readonly deviceIdRef?: LinkAssociationSpecForProviderDeviceIdRef;

  /**
   * Selector for a Device to populate deviceId.
   *
   * @schema LinkAssociationSpecForProvider#deviceIdSelector
   */
  readonly deviceIdSelector?: LinkAssociationSpecForProviderDeviceIdSelector;

  /**
   * The ID of the global network.
   *
   * @schema LinkAssociationSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema LinkAssociationSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: LinkAssociationSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema LinkAssociationSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: LinkAssociationSpecForProviderGlobalNetworkIdSelector;

  /**
   * The ID of the link.
   *
   * @schema LinkAssociationSpecForProvider#linkId
   */
  readonly linkId?: string;

  /**
   * Reference to a Link in networkmanager to populate linkId.
   *
   * @schema LinkAssociationSpecForProvider#linkIdRef
   */
  readonly linkIdRef?: LinkAssociationSpecForProviderLinkIdRef;

  /**
   * Selector for a Link in networkmanager to populate linkId.
   *
   * @schema LinkAssociationSpecForProvider#linkIdSelector
   */
  readonly linkIdSelector?: LinkAssociationSpecForProviderLinkIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema LinkAssociationSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProvider(obj: LinkAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceId': obj.deviceId,
    'deviceIdRef': toJson_LinkAssociationSpecForProviderDeviceIdRef(obj.deviceIdRef),
    'deviceIdSelector': toJson_LinkAssociationSpecForProviderDeviceIdSelector(obj.deviceIdSelector),
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_LinkAssociationSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_LinkAssociationSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'linkId': obj.linkId,
    'linkIdRef': toJson_LinkAssociationSpecForProviderLinkIdRef(obj.linkIdRef),
    'linkIdSelector': toJson_LinkAssociationSpecForProviderLinkIdSelector(obj.linkIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema LinkAssociationSpecManagementPolicies
 */
export enum LinkAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema LinkAssociationSpecProviderConfigRef
 */
export interface LinkAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: LinkAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecProviderConfigRef(obj: LinkAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema LinkAssociationSpecPublishConnectionDetailsTo
 */
export interface LinkAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: LinkAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: LinkAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LinkAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecPublishConnectionDetailsTo(obj: LinkAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_LinkAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_LinkAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema LinkAssociationSpecWriteConnectionSecretToRef
 */
export interface LinkAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema LinkAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema LinkAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'LinkAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecWriteConnectionSecretToRef(obj: LinkAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Device to populate deviceId.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdRef
 */
export interface LinkAssociationSpecForProviderDeviceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdRef#policy
   */
  readonly policy?: LinkAssociationSpecForProviderDeviceIdRefPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderDeviceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderDeviceIdRef(obj: LinkAssociationSpecForProviderDeviceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkAssociationSpecForProviderDeviceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Device to populate deviceId.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdSelector
 */
export interface LinkAssociationSpecForProviderDeviceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdSelector#policy
   */
  readonly policy?: LinkAssociationSpecForProviderDeviceIdSelectorPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderDeviceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderDeviceIdSelector(obj: LinkAssociationSpecForProviderDeviceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LinkAssociationSpecForProviderDeviceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdRef
 */
export interface LinkAssociationSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderGlobalNetworkIdRef(obj: LinkAssociationSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelector
 */
export interface LinkAssociationSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderGlobalNetworkIdSelector(obj: LinkAssociationSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Link in networkmanager to populate linkId.
 *
 * @schema LinkAssociationSpecForProviderLinkIdRef
 */
export interface LinkAssociationSpecForProviderLinkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkAssociationSpecForProviderLinkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkAssociationSpecForProviderLinkIdRef#policy
   */
  readonly policy?: LinkAssociationSpecForProviderLinkIdRefPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderLinkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderLinkIdRef(obj: LinkAssociationSpecForProviderLinkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkAssociationSpecForProviderLinkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Link in networkmanager to populate linkId.
 *
 * @schema LinkAssociationSpecForProviderLinkIdSelector
 */
export interface LinkAssociationSpecForProviderLinkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema LinkAssociationSpecForProviderLinkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema LinkAssociationSpecForProviderLinkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema LinkAssociationSpecForProviderLinkIdSelector#policy
   */
  readonly policy?: LinkAssociationSpecForProviderLinkIdSelectorPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderLinkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderLinkIdSelector(obj: LinkAssociationSpecForProviderLinkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_LinkAssociationSpecForProviderLinkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LinkAssociationSpecProviderConfigRefPolicy
 */
export interface LinkAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecProviderConfigRefPolicy(obj: LinkAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface LinkAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'LinkAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecPublishConnectionDetailsToConfigRef(obj: LinkAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema LinkAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface LinkAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'LinkAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecPublishConnectionDetailsToMetadata(obj: LinkAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdRefPolicy
 */
export interface LinkAssociationSpecForProviderDeviceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdRefPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecForProviderDeviceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdRefPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecForProviderDeviceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderDeviceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderDeviceIdRefPolicy(obj: LinkAssociationSpecForProviderDeviceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdSelectorPolicy
 */
export interface LinkAssociationSpecForProviderDeviceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdSelectorPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecForProviderDeviceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecForProviderDeviceIdSelectorPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecForProviderDeviceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderDeviceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderDeviceIdSelectorPolicy(obj: LinkAssociationSpecForProviderDeviceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy(obj: LinkAssociationSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy(obj: LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema LinkAssociationSpecForProviderLinkIdRefPolicy
 */
export interface LinkAssociationSpecForProviderLinkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecForProviderLinkIdRefPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecForProviderLinkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecForProviderLinkIdRefPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecForProviderLinkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderLinkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderLinkIdRefPolicy(obj: LinkAssociationSpecForProviderLinkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema LinkAssociationSpecForProviderLinkIdSelectorPolicy
 */
export interface LinkAssociationSpecForProviderLinkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecForProviderLinkIdSelectorPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecForProviderLinkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecForProviderLinkIdSelectorPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecForProviderLinkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecForProviderLinkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecForProviderLinkIdSelectorPolicy(obj: LinkAssociationSpecForProviderLinkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecProviderConfigRefPolicyResolution
 */
export enum LinkAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecProviderConfigRefPolicyResolve
 */
export enum LinkAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdRefPolicyResolution
 */
export enum LinkAssociationSpecForProviderDeviceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdRefPolicyResolve
 */
export enum LinkAssociationSpecForProviderDeviceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdSelectorPolicyResolution
 */
export enum LinkAssociationSpecForProviderDeviceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecForProviderDeviceIdSelectorPolicyResolve
 */
export enum LinkAssociationSpecForProviderDeviceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum LinkAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum LinkAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum LinkAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecForProviderLinkIdRefPolicyResolution
 */
export enum LinkAssociationSpecForProviderLinkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecForProviderLinkIdRefPolicyResolve
 */
export enum LinkAssociationSpecForProviderLinkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecForProviderLinkIdSelectorPolicyResolution
 */
export enum LinkAssociationSpecForProviderLinkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecForProviderLinkIdSelectorPolicyResolve
 */
export enum LinkAssociationSpecForProviderLinkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum LinkAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Site is the Schema for the Sites API. Creates a site in a global network.
 *
 * @schema Site
 */
export class Site extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Site"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'Site',
  }

  /**
   * Renders a Kubernetes manifest for "Site".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SiteProps): any {
    return {
      ...Site.GVK,
      ...toJson_SiteProps(props),
    };
  }

  /**
   * Defines a "Site" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SiteProps) {
    super(scope, id, {
      ...Site.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Site.GVK,
      ...toJson_SiteProps(resolved),
    };
  }
}

/**
 * Site is the Schema for the Sites API. Creates a site in a global network.
 *
 * @schema Site
 */
export interface SiteProps {
  /**
   * @schema Site#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SiteSpec defines the desired state of Site
   *
   * @schema Site#spec
   */
  readonly spec: SiteSpec;

}

/**
 * Converts an object of type 'SiteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteProps(obj: SiteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_SiteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SiteSpec defines the desired state of Site
 *
 * @schema SiteSpec
 */
export interface SiteSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema SiteSpec#deletionPolicy
   */
  readonly deletionPolicy?: SiteSpecDeletionPolicy;

  /**
   * @schema SiteSpec#forProvider
   */
  readonly forProvider: SiteSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema SiteSpec#initProvider
   */
  readonly initProvider?: SiteSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema SiteSpec#managementPolicies
   */
  readonly managementPolicies?: SiteSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema SiteSpec#providerConfigRef
   */
  readonly providerConfigRef?: SiteSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema SiteSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: SiteSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema SiteSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: SiteSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'SiteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpec(obj: SiteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_SiteSpecForProvider(obj.forProvider),
    'initProvider': toJson_SiteSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_SiteSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_SiteSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_SiteSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema SiteSpecDeletionPolicy
 */
export enum SiteSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema SiteSpecForProvider
 */
export interface SiteSpecForProvider {
  /**
   * Description of the Site.
   *
   * @schema SiteSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The ID of the Global Network to create the site in.
   *
   * @schema SiteSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema SiteSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: SiteSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema SiteSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: SiteSpecForProviderGlobalNetworkIdSelector;

  /**
   * The site location as documented below.
   *
   * @schema SiteSpecForProvider#location
   */
  readonly location?: SiteSpecForProviderLocation[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema SiteSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema SiteSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SiteSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecForProvider(obj: SiteSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_SiteSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_SiteSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'location': obj.location?.map(y => toJson_SiteSpecForProviderLocation(y)),
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema SiteSpecInitProvider
 */
export interface SiteSpecInitProvider {
  /**
   * Description of the Site.
   *
   * @schema SiteSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The site location as documented below.
   *
   * @schema SiteSpecInitProvider#location
   */
  readonly location?: SiteSpecInitProviderLocation[];

  /**
   * Key-value map of resource tags.
   *
   * @schema SiteSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'SiteSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecInitProvider(obj: SiteSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'location': obj.location?.map(y => toJson_SiteSpecInitProviderLocation(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema SiteSpecManagementPolicies
 */
export enum SiteSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema SiteSpecProviderConfigRef
 */
export interface SiteSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SiteSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SiteSpecProviderConfigRef#policy
   */
  readonly policy?: SiteSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'SiteSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecProviderConfigRef(obj: SiteSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SiteSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema SiteSpecPublishConnectionDetailsTo
 */
export interface SiteSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema SiteSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: SiteSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema SiteSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: SiteSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema SiteSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'SiteSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecPublishConnectionDetailsTo(obj: SiteSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_SiteSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_SiteSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema SiteSpecWriteConnectionSecretToRef
 */
export interface SiteSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema SiteSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema SiteSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'SiteSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecWriteConnectionSecretToRef(obj: SiteSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdRef
 */
export interface SiteSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: SiteSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'SiteSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecForProviderGlobalNetworkIdRef(obj: SiteSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SiteSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdSelector
 */
export interface SiteSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: SiteSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'SiteSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecForProviderGlobalNetworkIdSelector(obj: SiteSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_SiteSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SiteSpecForProviderLocation
 */
export interface SiteSpecForProviderLocation {
  /**
   * Address of the location.
   *
   * @schema SiteSpecForProviderLocation#address
   */
  readonly address?: string;

  /**
   * Latitude of the location.
   *
   * @schema SiteSpecForProviderLocation#latitude
   */
  readonly latitude?: string;

  /**
   * Longitude of the location.
   *
   * @schema SiteSpecForProviderLocation#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'SiteSpecForProviderLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecForProviderLocation(obj: SiteSpecForProviderLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema SiteSpecInitProviderLocation
 */
export interface SiteSpecInitProviderLocation {
  /**
   * Address of the location.
   *
   * @schema SiteSpecInitProviderLocation#address
   */
  readonly address?: string;

  /**
   * Latitude of the location.
   *
   * @schema SiteSpecInitProviderLocation#latitude
   */
  readonly latitude?: string;

  /**
   * Longitude of the location.
   *
   * @schema SiteSpecInitProviderLocation#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'SiteSpecInitProviderLocation' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecInitProviderLocation(obj: SiteSpecInitProviderLocation | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'address': obj.address,
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SiteSpecProviderConfigRefPolicy
 */
export interface SiteSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SiteSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: SiteSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SiteSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: SiteSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SiteSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecProviderConfigRefPolicy(obj: SiteSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema SiteSpecPublishConnectionDetailsToConfigRef
 */
export interface SiteSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema SiteSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema SiteSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: SiteSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'SiteSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecPublishConnectionDetailsToConfigRef(obj: SiteSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_SiteSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema SiteSpecPublishConnectionDetailsToMetadata
 */
export interface SiteSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema SiteSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema SiteSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema SiteSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'SiteSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecPublishConnectionDetailsToMetadata(obj: SiteSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface SiteSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: SiteSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: SiteSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'SiteSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecForProviderGlobalNetworkIdRefPolicy(obj: SiteSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface SiteSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: SiteSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SiteSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: SiteSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'SiteSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecForProviderGlobalNetworkIdSelectorPolicy(obj: SiteSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SiteSpecProviderConfigRefPolicyResolution
 */
export enum SiteSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SiteSpecProviderConfigRefPolicyResolve
 */
export enum SiteSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema SiteSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface SiteSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema SiteSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: SiteSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema SiteSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: SiteSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'SiteSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SiteSpecPublishConnectionDetailsToConfigRefPolicy(obj: SiteSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum SiteSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum SiteSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum SiteSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SiteSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum SiteSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema SiteSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum SiteSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema SiteSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum SiteSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TransitGatewayConnectPeerAssociation is the Schema for the TransitGatewayConnectPeerAssociations API. Associates a transit gateway Connect peer with a device, and optionally, with a link.
 *
 * @schema TransitGatewayConnectPeerAssociation
 */
export class TransitGatewayConnectPeerAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransitGatewayConnectPeerAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'TransitGatewayConnectPeerAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "TransitGatewayConnectPeerAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransitGatewayConnectPeerAssociationProps): any {
    return {
      ...TransitGatewayConnectPeerAssociation.GVK,
      ...toJson_TransitGatewayConnectPeerAssociationProps(props),
    };
  }

  /**
   * Defines a "TransitGatewayConnectPeerAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransitGatewayConnectPeerAssociationProps) {
    super(scope, id, {
      ...TransitGatewayConnectPeerAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransitGatewayConnectPeerAssociation.GVK,
      ...toJson_TransitGatewayConnectPeerAssociationProps(resolved),
    };
  }
}

/**
 * TransitGatewayConnectPeerAssociation is the Schema for the TransitGatewayConnectPeerAssociations API. Associates a transit gateway Connect peer with a device, and optionally, with a link.
 *
 * @schema TransitGatewayConnectPeerAssociation
 */
export interface TransitGatewayConnectPeerAssociationProps {
  /**
   * @schema TransitGatewayConnectPeerAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransitGatewayConnectPeerAssociationSpec defines the desired state of TransitGatewayConnectPeerAssociation
   *
   * @schema TransitGatewayConnectPeerAssociation#spec
   */
  readonly spec: TransitGatewayConnectPeerAssociationSpec;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationProps(obj: TransitGatewayConnectPeerAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransitGatewayConnectPeerAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayConnectPeerAssociationSpec defines the desired state of TransitGatewayConnectPeerAssociation
 *
 * @schema TransitGatewayConnectPeerAssociationSpec
 */
export interface TransitGatewayConnectPeerAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TransitGatewayConnectPeerAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: TransitGatewayConnectPeerAssociationSpecDeletionPolicy;

  /**
   * @schema TransitGatewayConnectPeerAssociationSpec#forProvider
   */
  readonly forProvider: TransitGatewayConnectPeerAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TransitGatewayConnectPeerAssociationSpec#initProvider
   */
  readonly initProvider?: TransitGatewayConnectPeerAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TransitGatewayConnectPeerAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: TransitGatewayConnectPeerAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TransitGatewayConnectPeerAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: TransitGatewayConnectPeerAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TransitGatewayConnectPeerAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TransitGatewayConnectPeerAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpec(obj: TransitGatewayConnectPeerAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TransitGatewayConnectPeerAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_TransitGatewayConnectPeerAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TransitGatewayConnectPeerAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TransitGatewayConnectPeerAssociationSpecDeletionPolicy
 */
export enum TransitGatewayConnectPeerAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TransitGatewayConnectPeerAssociationSpecForProvider
 */
export interface TransitGatewayConnectPeerAssociationSpecForProvider {
  /**
   * The ID of the device.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#deviceId
   */
  readonly deviceId?: string;

  /**
   * Reference to a Device in networkmanager to populate deviceId.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#deviceIdRef
   */
  readonly deviceIdRef?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef;

  /**
   * Selector for a Device in networkmanager to populate deviceId.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#deviceIdSelector
   */
  readonly deviceIdSelector?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector;

  /**
   * The ID of the global network.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector;

  /**
   * The ID of the link.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#linkId
   */
  readonly linkId?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The Amazon Resource Name (ARN) of the Connect peer.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#transitGatewayConnectPeerArn
   */
  readonly transitGatewayConnectPeerArn?: string;

  /**
   * Reference to a TransitGatewayConnectPeer in ec2 to populate transitGatewayConnectPeerArn.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#transitGatewayConnectPeerArnRef
   */
  readonly transitGatewayConnectPeerArnRef?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef;

  /**
   * Selector for a TransitGatewayConnectPeer in ec2 to populate transitGatewayConnectPeerArn.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProvider#transitGatewayConnectPeerArnSelector
   */
  readonly transitGatewayConnectPeerArnSelector?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProvider(obj: TransitGatewayConnectPeerAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deviceId': obj.deviceId,
    'deviceIdRef': toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef(obj.deviceIdRef),
    'deviceIdSelector': toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector(obj.deviceIdSelector),
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'linkId': obj.linkId,
    'region': obj.region,
    'transitGatewayConnectPeerArn': obj.transitGatewayConnectPeerArn,
    'transitGatewayConnectPeerArnRef': toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef(obj.transitGatewayConnectPeerArnRef),
    'transitGatewayConnectPeerArnSelector': toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector(obj.transitGatewayConnectPeerArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecInitProvider
 */
export interface TransitGatewayConnectPeerAssociationSpecInitProvider {
  /**
   * The ID of the link.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecInitProvider#linkId
   */
  readonly linkId?: string;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecInitProvider(obj: TransitGatewayConnectPeerAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'linkId': obj.linkId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecManagementPolicies
 */
export enum TransitGatewayConnectPeerAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRef
 */
export interface TransitGatewayConnectPeerAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecProviderConfigRef(obj: TransitGatewayConnectPeerAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo
 */
export interface TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo(obj: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef
 */
export interface TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef(obj: TransitGatewayConnectPeerAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Device in networkmanager to populate deviceId.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef(obj: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Device in networkmanager to populate deviceId.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector(obj: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef(obj: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector(obj: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TransitGatewayConnectPeer in ec2 to populate transitGatewayConnectPeerArn.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef(obj: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TransitGatewayConnectPeer in ec2 to populate transitGatewayConnectPeerArn.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector(obj: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy(obj: TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef(obj: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata(obj: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy(obj: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy(obj: TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy(obj: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy(obj: TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy(obj: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy(obj: TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderDeviceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecForProviderTransitGatewayConnectPeerArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TransitGatewayConnectPeerAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TransitGatewayRegistration is the Schema for the TransitGatewayRegistrations API. Registers a transit gateway to a global network.
 *
 * @schema TransitGatewayRegistration
 */
export class TransitGatewayRegistration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransitGatewayRegistration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'TransitGatewayRegistration',
  }

  /**
   * Renders a Kubernetes manifest for "TransitGatewayRegistration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransitGatewayRegistrationProps): any {
    return {
      ...TransitGatewayRegistration.GVK,
      ...toJson_TransitGatewayRegistrationProps(props),
    };
  }

  /**
   * Defines a "TransitGatewayRegistration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransitGatewayRegistrationProps) {
    super(scope, id, {
      ...TransitGatewayRegistration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransitGatewayRegistration.GVK,
      ...toJson_TransitGatewayRegistrationProps(resolved),
    };
  }
}

/**
 * TransitGatewayRegistration is the Schema for the TransitGatewayRegistrations API. Registers a transit gateway to a global network.
 *
 * @schema TransitGatewayRegistration
 */
export interface TransitGatewayRegistrationProps {
  /**
   * @schema TransitGatewayRegistration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransitGatewayRegistrationSpec defines the desired state of TransitGatewayRegistration
   *
   * @schema TransitGatewayRegistration#spec
   */
  readonly spec: TransitGatewayRegistrationSpec;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationProps(obj: TransitGatewayRegistrationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransitGatewayRegistrationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransitGatewayRegistrationSpec defines the desired state of TransitGatewayRegistration
 *
 * @schema TransitGatewayRegistrationSpec
 */
export interface TransitGatewayRegistrationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TransitGatewayRegistrationSpec#deletionPolicy
   */
  readonly deletionPolicy?: TransitGatewayRegistrationSpecDeletionPolicy;

  /**
   * @schema TransitGatewayRegistrationSpec#forProvider
   */
  readonly forProvider: TransitGatewayRegistrationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema TransitGatewayRegistrationSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TransitGatewayRegistrationSpec#managementPolicies
   */
  readonly managementPolicies?: TransitGatewayRegistrationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema TransitGatewayRegistrationSpec#providerConfigRef
   */
  readonly providerConfigRef?: TransitGatewayRegistrationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema TransitGatewayRegistrationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TransitGatewayRegistrationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema TransitGatewayRegistrationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TransitGatewayRegistrationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpec(obj: TransitGatewayRegistrationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TransitGatewayRegistrationSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TransitGatewayRegistrationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TransitGatewayRegistrationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TransitGatewayRegistrationSpecDeletionPolicy
 */
export enum TransitGatewayRegistrationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TransitGatewayRegistrationSpecForProvider
 */
export interface TransitGatewayRegistrationSpecForProvider {
  /**
   * The ID of the Global Network to register to.
   *
   * @schema TransitGatewayRegistrationSpecForProvider#globalNetworkId
   */
  readonly globalNetworkId?: string;

  /**
   * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema TransitGatewayRegistrationSpecForProvider#globalNetworkIdRef
   */
  readonly globalNetworkIdRef?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef;

  /**
   * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
   *
   * @schema TransitGatewayRegistrationSpecForProvider#globalNetworkIdSelector
   */
  readonly globalNetworkIdSelector?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TransitGatewayRegistrationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ARN of the Transit Gateway to register.
   *
   * @schema TransitGatewayRegistrationSpecForProvider#transitGatewayArn
   */
  readonly transitGatewayArn?: string;

  /**
   * Reference to a TransitGateway in ec2 to populate transitGatewayArn.
   *
   * @schema TransitGatewayRegistrationSpecForProvider#transitGatewayArnRef
   */
  readonly transitGatewayArnRef?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef;

  /**
   * Selector for a TransitGateway in ec2 to populate transitGatewayArn.
   *
   * @schema TransitGatewayRegistrationSpecForProvider#transitGatewayArnSelector
   */
  readonly transitGatewayArnSelector?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProvider(obj: TransitGatewayRegistrationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'globalNetworkId': obj.globalNetworkId,
    'globalNetworkIdRef': toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef(obj.globalNetworkIdRef),
    'globalNetworkIdSelector': toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector(obj.globalNetworkIdSelector),
    'region': obj.region,
    'transitGatewayArn': obj.transitGatewayArn,
    'transitGatewayArnRef': toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef(obj.transitGatewayArnRef),
    'transitGatewayArnSelector': toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector(obj.transitGatewayArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema TransitGatewayRegistrationSpecManagementPolicies
 */
export enum TransitGatewayRegistrationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema TransitGatewayRegistrationSpecProviderConfigRef
 */
export interface TransitGatewayRegistrationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRegistrationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRegistrationSpecProviderConfigRef#policy
   */
  readonly policy?: TransitGatewayRegistrationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecProviderConfigRef(obj: TransitGatewayRegistrationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRegistrationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsTo
 */
export interface TransitGatewayRegistrationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsTo(obj: TransitGatewayRegistrationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema TransitGatewayRegistrationSpecWriteConnectionSecretToRef
 */
export interface TransitGatewayRegistrationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TransitGatewayRegistrationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TransitGatewayRegistrationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecWriteConnectionSecretToRef(obj: TransitGatewayRegistrationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef
 */
export interface TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef#policy
   */
  readonly policy?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef(obj: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a GlobalNetwork in networkmanager to populate globalNetworkId.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector
 */
export interface TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector#policy
   */
  readonly policy?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector(obj: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TransitGateway in ec2 to populate transitGatewayArn.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef
 */
export interface TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef#policy
   */
  readonly policy?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef(obj: TransitGatewayRegistrationSpecForProviderTransitGatewayArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TransitGateway in ec2 to populate transitGatewayArn.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector
 */
export interface TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector#policy
   */
  readonly policy?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector(obj: TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRegistrationSpecProviderConfigRefPolicy
 */
export interface TransitGatewayRegistrationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRegistrationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRegistrationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRegistrationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRegistrationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecProviderConfigRefPolicy(obj: TransitGatewayRegistrationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef
 */
export interface TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef(obj: TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata
 */
export interface TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata(obj: TransitGatewayRegistrationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy
 */
export interface TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy(obj: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy
 */
export interface TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy(obj: TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy
 */
export interface TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy(obj: TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy
 */
export interface TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy#resolution
   */
  readonly resolution?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy#resolve
   */
  readonly resolve?: TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy(obj: TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRegistrationSpecProviderConfigRefPolicyResolution
 */
export enum TransitGatewayRegistrationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRegistrationSpecProviderConfigRefPolicyResolve
 */
export enum TransitGatewayRegistrationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy(obj: TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicyResolution
 */
export enum TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicyResolve
 */
export enum TransitGatewayRegistrationSpecForProviderGlobalNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicyResolution
 */
export enum TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicyResolve
 */
export enum TransitGatewayRegistrationSpecForProviderGlobalNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicyResolution
 */
export enum TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicyResolve
 */
export enum TransitGatewayRegistrationSpecForProviderTransitGatewayArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicyResolution
 */
export enum TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicyResolve
 */
export enum TransitGatewayRegistrationSpecForProviderTransitGatewayArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TransitGatewayRegistrationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCAttachment is the Schema for the VPCAttachments API.
 *
 * @schema VPCAttachment
 */
export class VpcAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'networkmanager.aws.upbound.io/v1beta1',
    kind: 'VPCAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "VPCAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VpcAttachmentProps): any {
    return {
      ...VpcAttachment.GVK,
      ...toJson_VpcAttachmentProps(props),
    };
  }

  /**
   * Defines a "VPCAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VpcAttachmentProps) {
    super(scope, id, {
      ...VpcAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VpcAttachment.GVK,
      ...toJson_VpcAttachmentProps(resolved),
    };
  }
}

/**
 * VPCAttachment is the Schema for the VPCAttachments API.
 *
 * @schema VPCAttachment
 */
export interface VpcAttachmentProps {
  /**
   * @schema VPCAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCAttachmentSpec defines the desired state of VPCAttachment
   *
   * @schema VPCAttachment#spec
   */
  readonly spec: VpcAttachmentSpec;

}

/**
 * Converts an object of type 'VpcAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentProps(obj: VpcAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCAttachmentSpec defines the desired state of VPCAttachment
 *
 * @schema VpcAttachmentSpec
 */
export interface VpcAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcAttachmentSpecDeletionPolicy;

  /**
   * @schema VpcAttachmentSpec#forProvider
   */
  readonly forProvider: VpcAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
   *
   * @schema VpcAttachmentSpec#initProvider
   */
  readonly initProvider?: VpcAttachmentSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out through a Crossplane feature flag. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: VpcAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema VpcAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema VpcAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema VpcAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpec(obj: VpcAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcAttachmentSpecForProvider(obj.forProvider),
    'initProvider': toJson_VpcAttachmentSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcAttachmentSpecDeletionPolicy
 */
export enum VpcAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VpcAttachmentSpecForProvider
 */
export interface VpcAttachmentSpecForProvider {
  /**
   * The ID of a core network for the VPC attachment.
   *
   * @schema VpcAttachmentSpecForProvider#coreNetworkId
   */
  readonly coreNetworkId?: string;

  /**
   * Reference to a CoreNetwork to populate coreNetworkId.
   *
   * @schema VpcAttachmentSpecForProvider#coreNetworkIdRef
   */
  readonly coreNetworkIdRef?: VpcAttachmentSpecForProviderCoreNetworkIdRef;

  /**
   * Selector for a CoreNetwork to populate coreNetworkId.
   *
   * @schema VpcAttachmentSpecForProvider#coreNetworkIdSelector
   */
  readonly coreNetworkIdSelector?: VpcAttachmentSpecForProviderCoreNetworkIdSelector;

  /**
   * Options for the VPC attachment.
   *
   * @schema VpcAttachmentSpecForProvider#options
   */
  readonly options?: VpcAttachmentSpecForProviderOptions[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VpcAttachmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * The subnet ARN of the VPC attachment.
   *
   * @schema VpcAttachmentSpecForProvider#subnetArns
   */
  readonly subnetArns?: string[];

  /**
   * References to Subnet in ec2 to populate subnetArns.
   *
   * @schema VpcAttachmentSpecForProvider#subnetArnsRefs
   */
  readonly subnetArnsRefs?: VpcAttachmentSpecForProviderSubnetArnsRefs[];

  /**
   * Selector for a list of Subnet in ec2 to populate subnetArns.
   *
   * @schema VpcAttachmentSpecForProvider#subnetArnsSelector
   */
  readonly subnetArnsSelector?: VpcAttachmentSpecForProviderSubnetArnsSelector;

  /**
   * Key-value map of resource tags.
   *
   * @schema VpcAttachmentSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The ARN of the VPC.
   *
   * @schema VpcAttachmentSpecForProvider#vpcArn
   */
  readonly vpcArn?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcArn.
   *
   * @schema VpcAttachmentSpecForProvider#vpcArnRef
   */
  readonly vpcArnRef?: VpcAttachmentSpecForProviderVpcArnRef;

  /**
   * Selector for a VPC in ec2 to populate vpcArn.
   *
   * @schema VpcAttachmentSpecForProvider#vpcArnSelector
   */
  readonly vpcArnSelector?: VpcAttachmentSpecForProviderVpcArnSelector;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProvider(obj: VpcAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'coreNetworkId': obj.coreNetworkId,
    'coreNetworkIdRef': toJson_VpcAttachmentSpecForProviderCoreNetworkIdRef(obj.coreNetworkIdRef),
    'coreNetworkIdSelector': toJson_VpcAttachmentSpecForProviderCoreNetworkIdSelector(obj.coreNetworkIdSelector),
    'options': obj.options?.map(y => toJson_VpcAttachmentSpecForProviderOptions(y)),
    'region': obj.region,
    'subnetArns': obj.subnetArns?.map(y => y),
    'subnetArnsRefs': obj.subnetArnsRefs?.map(y => toJson_VpcAttachmentSpecForProviderSubnetArnsRefs(y)),
    'subnetArnsSelector': toJson_VpcAttachmentSpecForProviderSubnetArnsSelector(obj.subnetArnsSelector),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpcArn': obj.vpcArn,
    'vpcArnRef': toJson_VpcAttachmentSpecForProviderVpcArnRef(obj.vpcArnRef),
    'vpcArnSelector': toJson_VpcAttachmentSpecForProviderVpcArnSelector(obj.vpcArnSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored unless the Management Policies feature flag is disabled. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.
 *
 * @schema VpcAttachmentSpecInitProvider
 */
export interface VpcAttachmentSpecInitProvider {
  /**
   * Options for the VPC attachment.
   *
   * @schema VpcAttachmentSpecInitProvider#options
   */
  readonly options?: VpcAttachmentSpecInitProviderOptions[];

  /**
   * Key-value map of resource tags.
   *
   * @schema VpcAttachmentSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'VpcAttachmentSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecInitProvider(obj: VpcAttachmentSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'options': obj.options?.map(y => toJson_VpcAttachmentSpecInitProviderOptions(y)),
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers can take on an external resource.
 *
 * @schema VpcAttachmentSpecManagementPolicies
 */
export enum VpcAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema VpcAttachmentSpecProviderConfigRef
 */
export interface VpcAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: VpcAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecProviderConfigRef(obj: VpcAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema VpcAttachmentSpecPublishConnectionDetailsTo
 */
export interface VpcAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecPublishConnectionDetailsTo(obj: VpcAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema VpcAttachmentSpecWriteConnectionSecretToRef
 */
export interface VpcAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecWriteConnectionSecretToRef(obj: VpcAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a CoreNetwork to populate coreNetworkId.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdRef
 */
export interface VpcAttachmentSpecForProviderCoreNetworkIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdRef#policy
   */
  readonly policy?: VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderCoreNetworkIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderCoreNetworkIdRef(obj: VpcAttachmentSpecForProviderCoreNetworkIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a CoreNetwork to populate coreNetworkId.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelector
 */
export interface VpcAttachmentSpecForProviderCoreNetworkIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelector#policy
   */
  readonly policy?: VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderCoreNetworkIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderCoreNetworkIdSelector(obj: VpcAttachmentSpecForProviderCoreNetworkIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcAttachmentSpecForProviderOptions
 */
export interface VpcAttachmentSpecForProviderOptions {
  /**
   * Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow.
   *
   * @schema VpcAttachmentSpecForProviderOptions#applianceModeSupport
   */
  readonly applianceModeSupport?: boolean;

  /**
   * Indicates whether IPv6 is supported.
   *
   * @schema VpcAttachmentSpecForProviderOptions#ipv6Support
   */
  readonly ipv6Support?: boolean;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderOptions(obj: VpcAttachmentSpecForProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applianceModeSupport': obj.applianceModeSupport,
    'ipv6Support': obj.ipv6Support,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A Reference to a named object.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsRefs
 */
export interface VpcAttachmentSpecForProviderSubnetArnsRefs {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsRefs#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsRefs#policy
   */
  readonly policy?: VpcAttachmentSpecForProviderSubnetArnsRefsPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderSubnetArnsRefs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderSubnetArnsRefs(obj: VpcAttachmentSpecForProviderSubnetArnsRefs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAttachmentSpecForProviderSubnetArnsRefsPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a list of Subnet in ec2 to populate subnetArns.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsSelector
 */
export interface VpcAttachmentSpecForProviderSubnetArnsSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsSelector#policy
   */
  readonly policy?: VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderSubnetArnsSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderSubnetArnsSelector(obj: VpcAttachmentSpecForProviderSubnetArnsSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcArn.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnRef
 */
export interface VpcAttachmentSpecForProviderVpcArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnRef#policy
   */
  readonly policy?: VpcAttachmentSpecForProviderVpcArnRefPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderVpcArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderVpcArnRef(obj: VpcAttachmentSpecForProviderVpcArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAttachmentSpecForProviderVpcArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcArn.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnSelector
 */
export interface VpcAttachmentSpecForProviderVpcArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnSelector#policy
   */
  readonly policy?: VpcAttachmentSpecForProviderVpcArnSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderVpcArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderVpcArnSelector(obj: VpcAttachmentSpecForProviderVpcArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAttachmentSpecForProviderVpcArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema VpcAttachmentSpecInitProviderOptions
 */
export interface VpcAttachmentSpecInitProviderOptions {
  /**
   * Indicates whether appliance mode is supported. If enabled, traffic flow between a source and destination use the same Availability Zone for the VPC attachment for the lifetime of that flow.
   *
   * @schema VpcAttachmentSpecInitProviderOptions#applianceModeSupport
   */
  readonly applianceModeSupport?: boolean;

  /**
   * Indicates whether IPv6 is supported.
   *
   * @schema VpcAttachmentSpecInitProviderOptions#ipv6Support
   */
  readonly ipv6Support?: boolean;

}

/**
 * Converts an object of type 'VpcAttachmentSpecInitProviderOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecInitProviderOptions(obj: VpcAttachmentSpecInitProviderOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applianceModeSupport': obj.applianceModeSupport,
    'ipv6Support': obj.ipv6Support,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAttachmentSpecProviderConfigRefPolicy
 */
export interface VpcAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecProviderConfigRefPolicy(obj: VpcAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecPublishConnectionDetailsToConfigRef(obj: VpcAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface VpcAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecPublishConnectionDetailsToMetadata(obj: VpcAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy
 */
export interface VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecForProviderCoreNetworkIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecForProviderCoreNetworkIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy(obj: VpcAttachmentSpecForProviderCoreNetworkIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy
 */
export interface VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy(obj: VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsRefsPolicy
 */
export interface VpcAttachmentSpecForProviderSubnetArnsRefsPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsRefsPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecForProviderSubnetArnsRefsPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsRefsPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecForProviderSubnetArnsRefsPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderSubnetArnsRefsPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderSubnetArnsRefsPolicy(obj: VpcAttachmentSpecForProviderSubnetArnsRefsPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy
 */
export interface VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecForProviderSubnetArnsSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecForProviderSubnetArnsSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy(obj: VpcAttachmentSpecForProviderSubnetArnsSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnRefPolicy
 */
export interface VpcAttachmentSpecForProviderVpcArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnRefPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecForProviderVpcArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnRefPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecForProviderVpcArnRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderVpcArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderVpcArnRefPolicy(obj: VpcAttachmentSpecForProviderVpcArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnSelectorPolicy
 */
export interface VpcAttachmentSpecForProviderVpcArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnSelectorPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecForProviderVpcArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecForProviderVpcArnSelectorPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecForProviderVpcArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecForProviderVpcArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecForProviderVpcArnSelectorPolicy(obj: VpcAttachmentSpecForProviderVpcArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum VpcAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum VpcAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdRefPolicyResolution
 */
export enum VpcAttachmentSpecForProviderCoreNetworkIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdRefPolicyResolve
 */
export enum VpcAttachmentSpecForProviderCoreNetworkIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolution
 */
export enum VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolve
 */
export enum VpcAttachmentSpecForProviderCoreNetworkIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsRefsPolicyResolution
 */
export enum VpcAttachmentSpecForProviderSubnetArnsRefsPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsRefsPolicyResolve
 */
export enum VpcAttachmentSpecForProviderSubnetArnsRefsPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsSelectorPolicyResolution
 */
export enum VpcAttachmentSpecForProviderSubnetArnsSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecForProviderSubnetArnsSelectorPolicyResolve
 */
export enum VpcAttachmentSpecForProviderSubnetArnsSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnRefPolicyResolution
 */
export enum VpcAttachmentSpecForProviderVpcArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnRefPolicyResolve
 */
export enum VpcAttachmentSpecForProviderVpcArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnSelectorPolicyResolution
 */
export enum VpcAttachmentSpecForProviderVpcArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecForProviderVpcArnSelectorPolicyResolve
 */
export enum VpcAttachmentSpecForProviderVpcArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

