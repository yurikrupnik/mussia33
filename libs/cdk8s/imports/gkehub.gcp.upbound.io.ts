// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Membership is the Schema for the Memberships API. Membership contains information about a member cluster.
 *
 * @schema Membership
 */
export class Membership extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Membership"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gkehub.gcp.upbound.io/v1beta1',
    kind: 'Membership',
  }

  /**
   * Renders a Kubernetes manifest for "Membership".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MembershipProps): any {
    return {
      ...Membership.GVK,
      ...toJson_MembershipProps(props),
    };
  }

  /**
   * Defines a "Membership" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MembershipProps) {
    super(scope, id, {
      ...Membership.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Membership.GVK,
      ...toJson_MembershipProps(resolved),
    };
  }
}

/**
 * Membership is the Schema for the Memberships API. Membership contains information about a member cluster.
 *
 * @schema Membership
 */
export interface MembershipProps {
  /**
   * @schema Membership#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MembershipSpec defines the desired state of Membership
   *
   * @schema Membership#spec
   */
  readonly spec: MembershipSpec;

}

/**
 * Converts an object of type 'MembershipProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipProps(obj: MembershipProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MembershipSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MembershipSpec defines the desired state of Membership
 *
 * @schema MembershipSpec
 */
export interface MembershipSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MembershipSpec#deletionPolicy
   */
  readonly deletionPolicy?: MembershipSpecDeletionPolicy;

  /**
   * @schema MembershipSpec#forProvider
   */
  readonly forProvider: MembershipSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MembershipSpec#managementPolicy
   */
  readonly managementPolicy?: MembershipSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MembershipSpec#providerConfigRef
   */
  readonly providerConfigRef?: MembershipSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MembershipSpec#providerRef
   */
  readonly providerRef?: MembershipSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MembershipSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MembershipSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MembershipSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MembershipSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MembershipSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpec(obj: MembershipSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MembershipSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MembershipSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MembershipSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MembershipSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MembershipSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MembershipSpecDeletionPolicy
 */
export enum MembershipSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MembershipSpecForProvider
 */
export interface MembershipSpecForProvider {
  /**
   * Authority encodes how Google will recognize identities from this Membership. See the workload identity documentation for more details: https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity Structure is documented below.
   *
   * @schema MembershipSpecForProvider#authority
   */
  readonly authority?: MembershipSpecForProviderAuthority[];

  /**
   * If this Membership is a Kubernetes API server hosted on GKE, this is a self link to its GCP resource. Structure is documented below.
   *
   * @schema MembershipSpecForProvider#endpoint
   */
  readonly endpoint?: MembershipSpecForProviderEndpoint[];

  /**
   * Labels to apply to this membership.
   *
   * @schema MembershipSpecForProvider#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * The ID of the project in which the resource belongs. If it is not provided, the provider project is used.
   *
   * @schema MembershipSpecForProvider#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'MembershipSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProvider(obj: MembershipSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authority': obj.authority?.map(y => toJson_MembershipSpecForProviderAuthority(y)),
    'endpoint': obj.endpoint?.map(y => toJson_MembershipSpecForProviderEndpoint(y)),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MembershipSpecManagementPolicy
 */
export enum MembershipSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MembershipSpecProviderConfigRef
 */
export interface MembershipSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipSpecProviderConfigRef#policy
   */
  readonly policy?: MembershipSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MembershipSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecProviderConfigRef(obj: MembershipSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MembershipSpecProviderRef
 */
export interface MembershipSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipSpecProviderRef#policy
   */
  readonly policy?: MembershipSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MembershipSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecProviderRef(obj: MembershipSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MembershipSpecPublishConnectionDetailsTo
 */
export interface MembershipSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MembershipSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MembershipSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MembershipSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MembershipSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MembershipSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MembershipSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecPublishConnectionDetailsTo(obj: MembershipSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MembershipSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MembershipSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MembershipSpecWriteConnectionSecretToRef
 */
export interface MembershipSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MembershipSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MembershipSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MembershipSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecWriteConnectionSecretToRef(obj: MembershipSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MembershipSpecForProviderAuthority
 */
export interface MembershipSpecForProviderAuthority {
  /**
   * A JSON Web Token (JWT) issuer URI. issuer must start with https:// and // be a valid with length <2000 characters. For example: https://container.googleapis.com/v1/projects/my-project/locations/us-west1/clusters/my-cluster (must be locations rather than zones).googleapis.com/v1/${google_container_cluster.my-cluster.id}".
   *
   * @schema MembershipSpecForProviderAuthority#issuer
   */
  readonly issuer: string;

}

/**
 * Converts an object of type 'MembershipSpecForProviderAuthority' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProviderAuthority(obj: MembershipSpecForProviderAuthority | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'issuer': obj.issuer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MembershipSpecForProviderEndpoint
 */
export interface MembershipSpecForProviderEndpoint {
  /**
   * If this Membership is a Kubernetes API server hosted on GKE, this is a self link to its GCP resource. Structure is documented below.
   *
   * @schema MembershipSpecForProviderEndpoint#gkeCluster
   */
  readonly gkeCluster?: MembershipSpecForProviderEndpointGkeCluster[];

}

/**
 * Converts an object of type 'MembershipSpecForProviderEndpoint' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProviderEndpoint(obj: MembershipSpecForProviderEndpoint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gkeCluster': obj.gkeCluster?.map(y => toJson_MembershipSpecForProviderEndpointGkeCluster(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MembershipSpecProviderConfigRefPolicy
 */
export interface MembershipSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MembershipSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MembershipSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecProviderConfigRefPolicy(obj: MembershipSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MembershipSpecProviderRefPolicy
 */
export interface MembershipSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MembershipSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MembershipSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecProviderRefPolicy(obj: MembershipSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MembershipSpecPublishConnectionDetailsToConfigRef
 */
export interface MembershipSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MembershipSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MembershipSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecPublishConnectionDetailsToConfigRef(obj: MembershipSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MembershipSpecPublishConnectionDetailsToMetadata
 */
export interface MembershipSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MembershipSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MembershipSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MembershipSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MembershipSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecPublishConnectionDetailsToMetadata(obj: MembershipSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MembershipSpecForProviderEndpointGkeCluster
 */
export interface MembershipSpecForProviderEndpointGkeCluster {
  /**
   * Self-link of the GCP resource for the GKE cluster. For example: //container.googleapis.com/projects/my-project/zones/us-west1-a/clusters/my-cluster. It can be at the most 1000 characters in length.googleapis.com/${google_container_cluster.my-cluster.id}" or google_container_cluster.my-cluster.id.
   *
   * @schema MembershipSpecForProviderEndpointGkeCluster#resourceLink
   */
  readonly resourceLink?: string;

  /**
   * Reference to a Cluster in container to populate resourceLink.
   *
   * @schema MembershipSpecForProviderEndpointGkeCluster#resourceLinkRef
   */
  readonly resourceLinkRef?: MembershipSpecForProviderEndpointGkeClusterResourceLinkRef;

  /**
   * Selector for a Cluster in container to populate resourceLink.
   *
   * @schema MembershipSpecForProviderEndpointGkeCluster#resourceLinkSelector
   */
  readonly resourceLinkSelector?: MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector;

}

/**
 * Converts an object of type 'MembershipSpecForProviderEndpointGkeCluster' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProviderEndpointGkeCluster(obj: MembershipSpecForProviderEndpointGkeCluster | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resourceLink': obj.resourceLink,
    'resourceLinkRef': toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkRef(obj.resourceLinkRef),
    'resourceLinkSelector': toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector(obj.resourceLinkSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipSpecProviderConfigRefPolicyResolution
 */
export enum MembershipSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipSpecProviderConfigRefPolicyResolve
 */
export enum MembershipSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipSpecProviderRefPolicyResolution
 */
export enum MembershipSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipSpecProviderRefPolicyResolve
 */
export enum MembershipSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MembershipSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MembershipSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj: MembershipSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Cluster in container to populate resourceLink.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRef
 */
export interface MembershipSpecForProviderEndpointGkeClusterResourceLinkRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRef#policy
   */
  readonly policy?: MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy;

}

/**
 * Converts an object of type 'MembershipSpecForProviderEndpointGkeClusterResourceLinkRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkRef(obj: MembershipSpecForProviderEndpointGkeClusterResourceLinkRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Cluster in container to populate resourceLink.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector
 */
export interface MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector#policy
   */
  readonly policy?: MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy;

}

/**
 * Converts an object of type 'MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector(obj: MembershipSpecForProviderEndpointGkeClusterResourceLinkSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy
 */
export interface MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy#resolution
   */
  readonly resolution?: MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy#resolve
   */
  readonly resolve?: MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy(obj: MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy
 */
export interface MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy#resolution
   */
  readonly resolution?: MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy#resolve
   */
  readonly resolve?: MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy(obj: MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicyResolution
 */
export enum MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicyResolve
 */
export enum MembershipSpecForProviderEndpointGkeClusterResourceLinkRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicyResolution
 */
export enum MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicyResolve
 */
export enum MembershipSpecForProviderEndpointGkeClusterResourceLinkSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * MembershipIAMMember is the Schema for the MembershipIAMMembers API. <no value>
 *
 * @schema MembershipIAMMember
 */
export class MembershipIamMember extends ApiObject {
  /**
   * Returns the apiVersion and kind for "MembershipIAMMember"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'gkehub.gcp.upbound.io/v1beta1',
    kind: 'MembershipIAMMember',
  }

  /**
   * Renders a Kubernetes manifest for "MembershipIAMMember".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MembershipIamMemberProps): any {
    return {
      ...MembershipIamMember.GVK,
      ...toJson_MembershipIamMemberProps(props),
    };
  }

  /**
   * Defines a "MembershipIAMMember" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MembershipIamMemberProps) {
    super(scope, id, {
      ...MembershipIamMember.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...MembershipIamMember.GVK,
      ...toJson_MembershipIamMemberProps(resolved),
    };
  }
}

/**
 * MembershipIAMMember is the Schema for the MembershipIAMMembers API. <no value>
 *
 * @schema MembershipIAMMember
 */
export interface MembershipIamMemberProps {
  /**
   * @schema MembershipIAMMember#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MembershipIAMMemberSpec defines the desired state of MembershipIAMMember
   *
   * @schema MembershipIAMMember#spec
   */
  readonly spec: MembershipIamMemberSpec;

}

/**
 * Converts an object of type 'MembershipIamMemberProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberProps(obj: MembershipIamMemberProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MembershipIamMemberSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MembershipIAMMemberSpec defines the desired state of MembershipIAMMember
 *
 * @schema MembershipIamMemberSpec
 */
export interface MembershipIamMemberSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MembershipIamMemberSpec#deletionPolicy
   */
  readonly deletionPolicy?: MembershipIamMemberSpecDeletionPolicy;

  /**
   * @schema MembershipIamMemberSpec#forProvider
   */
  readonly forProvider: MembershipIamMemberSpecForProvider;

  /**
   * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema MembershipIamMemberSpec#managementPolicy
   */
  readonly managementPolicy?: MembershipIamMemberSpecManagementPolicy;

  /**
   * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
   *
   * @schema MembershipIamMemberSpec#providerConfigRef
   */
  readonly providerConfigRef?: MembershipIamMemberSpecProviderConfigRef;

  /**
   * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
   *
   * @schema MembershipIamMemberSpec#providerRef
   */
  readonly providerRef?: MembershipIamMemberSpecProviderRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
   *
   * @schema MembershipIamMemberSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: MembershipIamMemberSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
   *
   * @schema MembershipIamMemberSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: MembershipIamMemberSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'MembershipIamMemberSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpec(obj: MembershipIamMemberSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_MembershipIamMemberSpecForProvider(obj.forProvider),
    'managementPolicy': obj.managementPolicy,
    'providerConfigRef': toJson_MembershipIamMemberSpecProviderConfigRef(obj.providerConfigRef),
    'providerRef': toJson_MembershipIamMemberSpecProviderRef(obj.providerRef),
    'publishConnectionDetailsTo': toJson_MembershipIamMemberSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_MembershipIamMemberSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either "Delete" or "Orphan" the external resource. This field is planned to be deprecated in favor of the ManagementPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MembershipIamMemberSpecDeletionPolicy
 */
export enum MembershipIamMemberSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema MembershipIamMemberSpecForProvider
 */
export interface MembershipIamMemberSpecForProvider {
  /**
   * @schema MembershipIamMemberSpecForProvider#condition
   */
  readonly condition?: MembershipIamMemberSpecForProviderCondition[];

  /**
   * @schema MembershipIamMemberSpecForProvider#member
   */
  readonly member?: string;

  /**
   * @schema MembershipIamMemberSpecForProvider#membershipId
   */
  readonly membershipId?: string;

  /**
   * Reference to a Membership in gkehub to populate membershipId.
   *
   * @schema MembershipIamMemberSpecForProvider#membershipIdRef
   */
  readonly membershipIdRef?: MembershipIamMemberSpecForProviderMembershipIdRef;

  /**
   * Selector for a Membership in gkehub to populate membershipId.
   *
   * @schema MembershipIamMemberSpecForProvider#membershipIdSelector
   */
  readonly membershipIdSelector?: MembershipIamMemberSpecForProviderMembershipIdSelector;

  /**
   * @schema MembershipIamMemberSpecForProvider#project
   */
  readonly project?: string;

  /**
   * @schema MembershipIamMemberSpecForProvider#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecForProvider(obj: MembershipIamMemberSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'condition': obj.condition?.map(y => toJson_MembershipIamMemberSpecForProviderCondition(y)),
    'member': obj.member,
    'membershipId': obj.membershipId,
    'membershipIdRef': toJson_MembershipIamMemberSpecForProviderMembershipIdRef(obj.membershipIdRef),
    'membershipIdSelector': toJson_MembershipIamMemberSpecForProviderMembershipIdSelector(obj.membershipIdSelector),
    'project': obj.project,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicy specifies the level of control Crossplane has over the managed external resource. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema MembershipIamMemberSpecManagementPolicy
 */
export enum MembershipIamMemberSpecManagementPolicy {
  /** FullControl */
  FULL_CONTROL = "FullControl",
  /** ObserveOnly */
  OBSERVE_ONLY = "ObserveOnly",
  /** OrphanOnDelete */
  ORPHAN_ON_DELETE = "OrphanOnDelete",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.
 *
 * @schema MembershipIamMemberSpecProviderConfigRef
 */
export interface MembershipIamMemberSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipIamMemberSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipIamMemberSpecProviderConfigRef#policy
   */
  readonly policy?: MembershipIamMemberSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecProviderConfigRef(obj: MembershipIamMemberSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipIamMemberSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`
 *
 * @schema MembershipIamMemberSpecProviderRef
 */
export interface MembershipIamMemberSpecProviderRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipIamMemberSpecProviderRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipIamMemberSpecProviderRef#policy
   */
  readonly policy?: MembershipIamMemberSpecProviderRefPolicy;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecProviderRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecProviderRef(obj: MembershipIamMemberSpecProviderRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipIamMemberSpecProviderRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.
 *
 * @schema MembershipIamMemberSpecPublishConnectionDetailsTo
 */
export interface MembershipIamMemberSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: MembershipIamMemberSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: MembershipIamMemberSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecPublishConnectionDetailsTo(obj: MembershipIamMemberSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_MembershipIamMemberSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_MembershipIamMemberSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.
 *
 * @schema MembershipIamMemberSpecWriteConnectionSecretToRef
 */
export interface MembershipIamMemberSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema MembershipIamMemberSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema MembershipIamMemberSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecWriteConnectionSecretToRef(obj: MembershipIamMemberSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MembershipIamMemberSpecForProviderCondition
 */
export interface MembershipIamMemberSpecForProviderCondition {
  /**
   * @schema MembershipIamMemberSpecForProviderCondition#description
   */
  readonly description?: string;

  /**
   * @schema MembershipIamMemberSpecForProviderCondition#expression
   */
  readonly expression: string;

  /**
   * @schema MembershipIamMemberSpecForProviderCondition#title
   */
  readonly title: string;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecForProviderCondition' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecForProviderCondition(obj: MembershipIamMemberSpecForProviderCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'expression': obj.expression,
    'title': obj.title,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Membership in gkehub to populate membershipId.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdRef
 */
export interface MembershipIamMemberSpecForProviderMembershipIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdRef#policy
   */
  readonly policy?: MembershipIamMemberSpecForProviderMembershipIdRefPolicy;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecForProviderMembershipIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecForProviderMembershipIdRef(obj: MembershipIamMemberSpecForProviderMembershipIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipIamMemberSpecForProviderMembershipIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Membership in gkehub to populate membershipId.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdSelector
 */
export interface MembershipIamMemberSpecForProviderMembershipIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdSelector#policy
   */
  readonly policy?: MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecForProviderMembershipIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecForProviderMembershipIdSelector(obj: MembershipIamMemberSpecForProviderMembershipIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MembershipIamMemberSpecProviderConfigRefPolicy
 */
export interface MembershipIamMemberSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipIamMemberSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: MembershipIamMemberSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipIamMemberSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: MembershipIamMemberSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecProviderConfigRefPolicy(obj: MembershipIamMemberSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MembershipIamMemberSpecProviderRefPolicy
 */
export interface MembershipIamMemberSpecProviderRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipIamMemberSpecProviderRefPolicy#resolution
   */
  readonly resolution?: MembershipIamMemberSpecProviderRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipIamMemberSpecProviderRefPolicy#resolve
   */
  readonly resolve?: MembershipIamMemberSpecProviderRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecProviderRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecProviderRefPolicy(obj: MembershipIamMemberSpecProviderRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.
 *
 * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRef
 */
export interface MembershipIamMemberSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecPublishConnectionDetailsToConfigRef(obj: MembershipIamMemberSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema MembershipIamMemberSpecPublishConnectionDetailsToMetadata
 */
export interface MembershipIamMemberSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.annotations". - It is up to Secret Store implementation for others store types.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as "metadata.labels". - It is up to Secret Store implementation for others store types.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecPublishConnectionDetailsToMetadata(obj: MembershipIamMemberSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdRefPolicy
 */
export interface MembershipIamMemberSpecForProviderMembershipIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdRefPolicy#resolution
   */
  readonly resolution?: MembershipIamMemberSpecForProviderMembershipIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdRefPolicy#resolve
   */
  readonly resolve?: MembershipIamMemberSpecForProviderMembershipIdRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecForProviderMembershipIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecForProviderMembershipIdRefPolicy(obj: MembershipIamMemberSpecForProviderMembershipIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy
 */
export interface MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy#resolution
   */
  readonly resolution?: MembershipIamMemberSpecForProviderMembershipIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy#resolve
   */
  readonly resolve?: MembershipIamMemberSpecForProviderMembershipIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy(obj: MembershipIamMemberSpecForProviderMembershipIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipIamMemberSpecProviderConfigRefPolicyResolution
 */
export enum MembershipIamMemberSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipIamMemberSpecProviderConfigRefPolicyResolve
 */
export enum MembershipIamMemberSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipIamMemberSpecProviderRefPolicyResolution
 */
export enum MembershipIamMemberSpecProviderRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipIamMemberSpecProviderRefPolicyResolve
 */
export enum MembershipIamMemberSpecProviderRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
   *
   * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy(obj: MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdRefPolicyResolution
 */
export enum MembershipIamMemberSpecForProviderMembershipIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdRefPolicyResolve
 */
export enum MembershipIamMemberSpecForProviderMembershipIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdSelectorPolicyResolution
 */
export enum MembershipIamMemberSpecForProviderMembershipIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipIamMemberSpecForProviderMembershipIdSelectorPolicyResolve
 */
export enum MembershipIamMemberSpecForProviderMembershipIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.
 *
 * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.
 *
 * @schema MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum MembershipIamMemberSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

